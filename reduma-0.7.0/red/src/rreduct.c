/* $Log: rreduct.c,v $
 * Revision 1.35  1996/02/23  14:16:28  rs
 * tasm_time inserted...
 *
 * Revision 1.34  1996/02/21  17:19:21  rs
 * more options for tasm + distribute+ D_MESS
 *
 * Revision 1.33  1996/02/20  15:53:49  rs
 * more work on tasm + distribute + measure
 *
 * Revision 1.32  1996/02/19  19:19:11  rs
 * more command line options for distributed tasm (and measurements)
 *
 * Revision 1.31  1996/02/16  16:16:04  rs
 * some changes concerning the integration of measurements
 * in tasm
 *
 * Revision 1.30  1996/02/16  09:07:55  sf
 * Execname will be used for generation of executable (again)
 *
 * Revision 1.29  1996/02/15  17:59:31  cr
 * removed dangerous spaces in in call-string for tasm
 *
 * Revision 1.28  1996/02/15  16:24:05  rs
 * minor changes
 *
 * Revision 1.26  1996/02/14  17:03:57  rs
 * changes in the tasm startup for the distributed version
 *
 * Revision 1.25  1996/02/13  16:34:58  rs
 * changes for nCUBE (D_SLAVE ;-) + TASM
 *
 * Revision 1.24  1996/02/05  13:19:11  sf
 * in call to tasm : Redumalib, nCubelib, Tasmlib
 *
 * Revision 1.23  1996/01/23  17:31:04  sf
 * *** empty log message ***
 *
 * Revision 1.22  1996/01/16  16:00:52  rs
 * some output added for ADV_SCHED
 *
 * Revision 1.21  1995/12/05  13:45:35  rs
 * no distributed measurement file-merging in (all) pvm version(s)
 *
 * Revision 1.20  1995/11/06  17:07:42  stt
 * filepointers are set to NULL after closing
 *
 * Revision 1.19  1995/09/11  14:21:00  rs
 * some changes for the pvm measure version
 *
 * Revision 1.18  1995/09/07  15:56:15  sf
 * START_MODUL added
 *
 * Revision 1.16  1995/05/18  10:03:51  sf
 * gcc call removed, tasm makes it now itself
 *
 * Revision 1.15  1995/05/03  11:10:01  sf
 * new red.setup keyword: CodeDup : int
 * if not set -> no code duplication while using tasm
 * if 0 -> unlimited code duplication
 * if > 0 -> max number of duplication
 *
 * Revision 1.14  1995/04/05  15:03:14  sf
 * minor change in gcc call
 *
 * Revision 1.13  1995/03/31  08:23:37  sf
 * minor bug fix
 *
 * Revision 1.12  1995/03/24  09:28:46  sf
 * *** empty log message ***
 *
 * Revision 1.11  1995/03/24  08:23:46  sf
 * tasm will be searched in path
 *
 * Revision 1.10  1995/03/22  13:04:31  sf
 * pm bug fixed
 *
 * Revision 1.9  1995/03/07  14:49:16  sf
 * if UseTasm is set, reduct() accepts input from a file generated by tasm
 *
 * Revision 1.8  1995/02/09  16:14:55  rs
 * changed "correct" output of UH's PM statistics
 *
 * Revision 1.7  1994/11/01  15:54:30  car
 * generate codefile in non-DEBUG-version
 *
 * Revision 1.6  1994/06/20  18:23:06  mah
 * reduce to normal form available for WITHTILDE
 *
 * Revision 1.5  1994/06/20  06:03:01  car
 * first extension for optimizer
 *
 * Revision 1.4  1994/05/18  10:51:34  mah
 * no reduce to normal form in WITHTILDE version
 *
 * Revision 1.3  1993/09/01  12:37:17  base
 * ANSI-version mit mess und verteilungs-Routinen
 *
 * Revision 1.2  1992/12/16  12:50:46  rs
 * ANSI-Version
 *
 * Revision 1.1  1992/11/04  18:12:30  base
 * Initial revision
 * */



/*----------------------------------------------------------------------------
 * reduct -- steuert die drei Phasen der Reduktionsmaschine, und sorgt
 *           fuer ein evtl. verpointertes Wiederaufsetzen.
 *           Der zu reduzierende Ausdruck wird auf dem E-Stack erwartet.
 *           Der Ergebnisausdruck wird auf den E-Stack zurueckgeliefert.
 *           Es erfolgt fuer die einzelnen Phasen eine Zeitmessung, die an den
 *           Editor uebergeben wird.
 * globals --
 *----------------------------------------------------------------------------
 */

/*-----------------------------------------------------------------------------
 * reduct:c external -- reduct
   reduct:c external -- get_tasm_output
 * reduct:c internal -- none
 *-----------------------------------------------------------------------------
 */

/* last update  by     why

   copied       by     to

*/
 
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include "rstdinc.h"
#include "rstackty.h"
#include "rheapty.h"
#include "rstelem.h"
#include "rextern.h"
#include "rmeasure.h"
#include "rinter.h"
#include "cparm.h"
#include "dbug.h"
#if D_DIST
#include "DBHexport.h"
#endif

/* #include "rnf.h" */
/* ak *//* rnf.h/rnf.c  :  Modul zur Berechnung einer Normalform */
        /* Importiert die Funktion reduce_to_nf ().              */
        /* Diese Funktion treibt die Reduktion rekursiv in den   */
        /* Rumpf von Abstraktionen.                              */

/* --- externe variablen und funktionen --- */

/* sf 23.02.95   */
extern int UseTasm;
extern int TasmOpt;
extern int CodeDup;
extern int UseTasmRedCount;
extern char CodeFile[80];
extern char Tasm2KiR[80];
extern char Redumalib[80];
extern char nCubelib[80];
extern char Tasmlib[80];
extern char Execname[80];
int get_tasm_output(void);
/*****************/

#if D_DIST
#include <sys/time.h>
#endif

#if D_MESS
#include "d_mess_io.h"
extern getkey();
extern char *_errmes;
#endif

#if DEBUG
extern char TraceFile[];	/* rreduce.c */
extern FILE *TraceFp;		/* rreduce.c */
extern int showdisplay;		/* rruntime.c */
#if UH_ZF_PM
extern FILE *ofp;
extern char pmanal_name[100];
#endif /* UH_ZF_PM */
#endif
extern PTR_DESCRIPTOR _old_expr_p; /* kopie des zuletzt bearbeiteten ausdrucks */
extern void           ptrav_a_e();           /* trav:c */
extern STACKELEM      st_expr();             /* storepro:c */
extern void           ret_expr();            /* retrieve:c */
extern void           ea_create();           /* ea-create:c*/
extern void           ear();                 /* ear:c      */
extern void           ea_retrieve();         /* ea_ret:c   */
extern void           load_expr();
extern void           inter();               /* rinter.c */ /* dg */
extern int            intact_inter();        /* rintact.c */ /* stt */
extern T_CODEDESCR    codedesc;              /* rinter.h */ /* dg */
extern void           reduce_to_nf();        /* rnf.c */ /* ak */
extern int            ia_binds_on_stack;     /* rintact.c */ /* stt */

#if D_DIST
extern void send_params();
extern void send_graph();
extern void receive_result();
extern flush_queue();
extern clearscreen();
extern m_super_merging();
extern char ticket_file[];

extern int cube_dim;
#if (D_MESS && ADV_SCHED)
extern int no_suspended;
#endif /* D_MESS && ADV_SCHED */
#endif

/* ach 05/11/92 */
extern int init_print_heap();                /* dumpheap.c */
extern void loleila();                       /* rdummies.c */
extern void print_heap();                    /* dumpheap.c */
extern void load_heap();                     /* dumpheap.c */
extern void stack_error();                   /* rstack.c */
/* end of ach */

/* RS 5.11.1992 */
extern void setdisplay();  /* rruntime.c */
extern void monitor_call();  /* rruntime.c */ 
extern void DescDump();      /* rdesc.c */
extern STACKELEM *ppopstack();    /* rstack,c */
extern void test_inc_refcnt();    /* rheap.c */
extern void test_dec_refcnt();    /* rheap.c */
extern void res_heap();           /* rheap.c */
extern void rel_heap();           /* rheap.c */
/* END of RS 5.11.1992 */

/* RS 6.11.1992 */ 
extern void disable_scav();                /* rscavenge.c */
extern void enable_scav();                 /* rscavenge.c */
extern void dynamic_gc();                  /* rscavenge.c */
/* END of RS 6.11.1992 */ 

#if SCAV_DEBUG
extern void scav_write_log ();
#endif

/* --- interne variablen und funktionen --- */

       void           evaluate();   /* forward */   /* dg */
       PTR_DESCRIPTOR code_desc;                    /* dg */

double tvorher;                     /* zeitmessung */
double tpre;                        /* zeitmessung */
double tpro;                        /* zeitmessung */
double tpos;                        /* zeitmessung */
double tges;                        /* zeitmessung */
double tasm_time;

#if  SINTRAN3
extern double tused();
#define TIMER() tused()
#else
extern long clock();
#define TIMER() (clock() / 1000000.0)
#endif

int call_system(char **s)
{
  int pid, status;
  DBUG_ENTER("call_system");
  switch(pid = fork())
  {
    case -1: post_mortem("call_system: unable to generate new process");
             status = 1;
             break;
    case  0: execvp(*s, s); 
             perror("");sleep(5);
             post_mortem("call_system: unable to execute new process");
             status = 1;
             break;
    default: while (wait(&status) != pid);
  }
  DBUG_RETURN(status);
}
    



/* dg */ /*------------------------------------------------------------------*/
/* dg */ /* reduct                                                           */
/* dg */ /*------------------------------------------------------------------*/
/* dg */
/* dg */ void reduct(PTR_UEBERGABE p_parms)
/* dg */ {
/* dg */   /*STACKELEM  x;                       ach 05/11/92 */
/* PTR_UEBERGABE p_parms   [sf 23.02.95]  */
int exec_success = 0;
#if D_DIST
  double zeit1 = 0.0, zeit2 = 0.0;
  struct timeval t0;
#endif

#if D_MESS
  double m_zeit1 = 0.0, m_zeit2 = 0.0;
#endif

/* dg */
/* dg */   START_MODUL("reduct");
/* dg */
#if DEBUG
/* dg */   showdisplay = TRUE;
/* dg */   setdisplay();         /* Stackbildaufbau */
/* dg */   monitor_call();       /* Benutzer kann interagieren */
           if ((TraceFp = fopen(TraceFile,"w")) == NULL)
             post_mortem("cannot open tracefile");
#if UH_ZF_PM
           if ((ofp=fopen(pmanal_name,"a"))==NULL) ofp=fopen("/dev/null","a");
#endif /* UH_ZF_PM */
#endif

#if D_MESS
#ifndef M_OLD_MERGING    /* for ASCII merging only */
#if D_PVM
             if (!m_merge_strat)
               post_mortem("PVM: please change MergingStrategy to 1 in red.setup.");
#endif /* D_PVM */
#endif
#endif D_MESS

/* dg */   /* initialisierungen fuer die zeitmessung */
/* dg */   tvorher = tpre = tpro = tpos = tges = 0.0;
/* dg */   tvorher = TIMER();           /* tvorher eingefuegt: ach 05/11/92 */
/* dg */   tvorher = TIMER();
/* dg */
/* dg */   if (T_KLAA(READSTACK(S_e))) {
/* dg */     /*-------------------------------*/
/* dg */     /* verpointertes Wiederaufsetzen */
/* dg */     /*-------------------------------*/
/* dg */     if (_old_expr_p == NULL)
/* dg */       post_mortem("reduct: there's no preprocessed expression.");
/* dg */     WRITESTACK(S_e,(STACKELEM)_old_expr_p); /* KLAA ueberschreiben */
/* dg */     tpre = TIMER();
/* dg */     evaluate();        /* auswertung anstossen */
/* dg */     tpro = TIMER();
/* dg */   }
/* dg */   else {
/* dg */     /*---------------*/
/* dg */     /* Preprocessing */
/* dg */     /*---------------*/
/* dg */     _old_expr_p = NULL; /* kein alter Ausdruck gespeichert    */
/* dg */     ea_create();        /* Steuermodul der Preprocessingphase */
/* dg */     /* der preprocesste ausdruck liegt als EXPR-descriptor auf e */
/* dg */     ear();                                   /* compilieren (abstr.) */
/* dg */     /* der compilierte ausdruck liegt als COMB-descriptor auf e */
/* dg */     code_desc = (T_PTD)READSTACK(S_e);       /* codedescriptor */
#if SCAVENGE
/* tg */     dynamic_gc ();
#endif
/* dg */     init_print_heap();                       /* dg 04.03.91 HeapDumpFile,HeapBase,HeapAlign */
/* dg */     loleila(R_COMB(*code_desc,ptc),SYMBTAB); /* loleila compiler */
/* dg */     /*------------*/
/* dg */     /* Processing */
/* dg */     /*------------*/
/* dg */     print_heap(NULL);                        /* dg 25.01.91 NULL: name aus red.setup */
/*  sf [03.03.95] anfang */
  if (0 != UseTasm)
  {
    static char p_str[15][80];
    static char *h_ptr[15];
    int i = 0,j;
    
    DBUG_PRINT ("RREDUCT", ("preparing the TASM call..."));

    strcpy(p_str[i], "tasm");
    h_ptr[i] = p_str[i++];
    
    if (-1 < CodeDup) 
    {
      sprintf(p_str[i], "-d%d", CodeDup);
      h_ptr[i] = p_str[i++];
    }
    if (0 < TasmOpt) 
    {
      strcpy(p_str[i], "-trO2");
      h_ptr[i] = p_str[i++];
    }
    else if (-1 == TasmOpt)
    {
      strcpy(p_str[i], "-D#t");
      h_ptr[i] = p_str[i++];
    }
    sprintf(p_str[i], "-L%s", Redumalib);
    h_ptr[i] = p_str[i++];
    sprintf(p_str[i], "-N%s", nCubelib);
    h_ptr[i] = p_str[i++];
    sprintf(p_str[i], "-l%s", Tasmlib);
    h_ptr[i] = p_str[i++];

#if D_DIST
    sprintf(p_str[i], "-n");
    h_ptr[i] = p_str[i++];
#if D_MESS
    sprintf(p_str[i], "-m");
    h_ptr[i] = p_str[i++];

#ifndef DBUG_OFF
    sprintf(p_str[i], "-D");
    h_ptr[i] = p_str[i++];
#endif

#endif
#endif 

    sprintf(p_str[i], "-Co%s", Execname);
    h_ptr[i] = p_str[i++];
    if (1 == UseTasmRedCount)
    {
      strcpy(p_str[i], "-R");
      h_ptr[i] = p_str[i++];
    }
    strcpy(p_str[i], CodeFile);
    h_ptr[i] = p_str[i++];
    h_ptr[i] = NULL;

    DBUG_PRINT("RREDUCT", ("calling:"));
    for (j=0; j<i; j++) DBUG_PRINT("RREDUCT", ("%d: %s", j, h_ptr[j]));

    exec_success = call_system(h_ptr);
    if (0 != exec_success)
      post_mortem("reduct: generation of C-file failed");
  }
/*  sf [03.03.95] ende */

/* dg */     tpre = TIMER();

#if D_DIST
 gettimeofday (&t0, NULL);
 zeit1 =  t0.tv_sec + t0.tv_usec/1000000.0;
#endif


          if (0 == UseTasm)
          {

#if D_DIST

DBUG_PRINT ("rreduct", ("Zeit vorher: %f", zeit1));

#if DEBUG
 DBUG_PRINT ("rreduct", ("Jetzt wuerde ich gern den screen loeschen !"));

#endif
             flush_queue();
             send_params();
             send_graph();

#if NCDEBUG
             DBHinit(1<<cube_dim);
             DBHrun();
#endif
             receive_result();

#else  /* D_DIST */

            int newcode = 0;  /* stt */
            
/* dg */    inter(R_COMB(*code_desc,ptc));           /* codeausfuehrung */
            
            ia_binds_on_stack = 0;

            while ((newcode = intact_inter()) != 0)  /* stt  14.09.95 */
              inter(newcode);

#endif /* D_DIST */

          }
          else if (0 == exec_success) 
          {
            static char p_str[30][80];
            static char *h_ptr[30];
            int i = 0,j;
            
            DBUG_PRINT ("RREDUCT", ("preparing the call of the compiled program..."));

#if D_DIST
#if D_MESS
            strcpy(p_str[i], "mhost");
#else
            strcpy(p_str[i], "host");
#endif /* D_MESS */
#else /* D_DIST */ 
            sprintf(p_str[i], "%s", Execname);
#endif /* D_DIST */
            h_ptr[i] = p_str[i++];

#if D_DIST
#if D_MESS
#ifndef DBUG_OFF
            sprintf(p_str[i], "-#d:t:o,/tmp/tracefile_");
            h_ptr[i] = p_str[i++];
#endif
#endif /* D_MESS */
            sprintf(p_str[i], "-n%d", cube_dim);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-t%s", ticket_file);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-f%s", Execname);
            h_ptr[i] = p_str[i++];
#if D_MESS
            DBUG_PRINT("RREDUCT", ("writing options for measurements"));
            sprintf(p_str[i], "-m%d", d_bib_mask);
            h_ptr[i] = p_str[i++]; 
            sprintf(p_str[i], "-q%d", m_merge_strat);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-x%d", m_ackno);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-y%s", m_mesfilehea);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-z%s", m_mesfilepath);
            h_ptr[i] = p_str[i++];
            if (_errmes[0]=='\0')
              strcpy(_errmes, "default");
            sprintf(p_str[i], "-E%s", _errmes);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-X%s", m_remote_host);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-M%d", m_del_files);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-Q%s", m_target_dir);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-Y%s", m_remote_dir);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-Z%s", m_remote_bin);
            h_ptr[i] = p_str[i++];
#endif /* D_MESS */
#endif /* D_DIST */

            sprintf(p_str[i], "-k%s", Tasm2KiR);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-h%d", p_parms->heapsize);
            h_ptr[i] = p_str[i++];
/*            sprintf(p_str[i], "-s%d", p_parms->qstacksize);
            h_ptr[i] = p_str[i++];
*/
            sprintf(p_str[i], "-d%d", p_parms->heapdes);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-R%d", p_parms->redcnt);
            h_ptr[i] = p_str[i++];
            if (-1 == TasmOpt)
            {
              sprintf(p_str[i], "-#t");
              h_ptr[i] = p_str[i++];
            }
            h_ptr[i] = NULL;

            DBUG_PRINT("RREDUCT", ("calling:"));
            DBUG_PRINT("RREDUCT", ("first: %s", h_ptr[1]));
            for (j=0; j<i; j++)
              DBUG_PRINT("RREDUCT", ("%d: %s", j, h_ptr[j])); 

            DBUG_PRINT("RREDUCT", ("really calling now..."));
            if (0 != call_system(h_ptr)) {
              sleep(10);
              post_mortem("reduct: execution of generated file failed"); }
          }

DBUG_PRINT ("rreduct", ("Hi, I'm back !"));

#if D_DIST
 gettimeofday (&t0, NULL);
 zeit2 =  t0.tv_sec + t0.tv_usec/1000000.0;

DBUG_PRINT ("rreduct", ("Zeit nachher: %f", zeit2));
DBUG_PRINT ("rreduct", ("Differenz: %4.2f", zeit2-zeit1));

#endif

#if D_MESS
             if (m_ackno)
               fflush (stdout);
             gettimeofday (&t0, NULL); 
             m_zeit1 = t0.tv_sec + t0.tv_usec/1000000.0; 
             if (m_ackno) {
               clearscreen();
               printf (" merging measurement files ...\n");
               fflush (stdout); 
               }
            
             if (!UseTasm) {

#ifdef M_OLD_MERGING    /* for ASCII merging only */
             get_em_merged();   /*  old merging */
#else
             if (m_merge_strat)
               m_super_merging();
             else
#if !D_PVM
               m_merging();
#endif
#endif
             if (!m_merge_strat)
               m_remote_copy();

             }

             gettimeofday (&t0, NULL); 
             m_zeit2 = t0.tv_sec + t0.tv_usec/1000000.0; 
             if (m_zeit1 == m_zeit2)
               DBUG_PRINT ("REDUCT", ("great time-measurement !"));
             else
               if (m_ackno)
                 printf ("\n merging time: %4.2f s\n", m_zeit2-m_zeit1);
             if (m_ackno) {
#if ADV_SCHED
               printf ("\n Number of suspended processes: %i\n\n", no_suspended);
#endif /* ADV_SCHED */
               printf (" press return ...\n");
               fflush(stdout);
               getkey(); 
               }
#endif

/* dg */     tpro = TIMER();
             if (UseTasm) {
               PUSHSTACK(S_a, get_tasm_output());
               }

#if SCAV_DEBUG
/* tg */     scav_write_log ();
#endif
/* dg */     PPOPSTACK(S_e);                          /* codedescriptor */
/* dg */     load_heap(NULL);                         /* dg 04.02.92 NULL: name aus red.setup */
/* dg */   }
/* dg */   _old_expr_p = (PTR_DESCRIPTOR)POPSTACK(S_a);
/* dg */   if (T_POINTER((int)_old_expr_p))
/* dg */     INC_REFCNT(_old_expr_p);
/* dg */   PUSHSTACK(S_e,_old_expr_p);
#if SCAVENGE
/* tg */   disable_scav();
#endif
/* dg */   /*----------------*/
/* dg */   /* Postprocessing */
/* dg */   /*----------------*/
#if RED_TO_NF
/* ak */    reduce_to_nf ();        /* Vorantreiben der Reduktion, Berechnung der Normalform  */
#endif
/* dg */   ea_retrieve();          /* Steuermodul der Postprocessing Phase */
/* dg */   tpos = TIMER();
/* dg */   tpos -= tpro;
/* dg */   tpro -= tpre;
/* dg */   tpre -= tvorher;

           if (UseTasm) {
             tpro = tasm_time;
             }

#if D_DIST
    tpro = zeit2-zeit1;
#endif

/* dg */   tges = tpre + tpro + tpos;
/* dg */ 
#if DEBUG
/* dg */   showdisplay = FALSE;    /* Stackbildmanipulation unterdruecken */
           if (TraceFp)
           {
             fclose(TraceFp);
             TraceFp = NULL;  /* stt */
           }
#if UH_ZF_PM          
           fclose(ofp);
#endif
#endif
/* dg */   END_MODUL("reduct");
/* dg */ }

/* file eval.c */

#include <setjmp.h>

/* --- externe variablen/funktionen --- */

extern BOOLEAN _interrupt;    /* rreduct.c */
extern jmp_buf _interruptbuf; /* rreduct.c */
extern void    freeheap();    /* rheap.c */
extern int     Rout_Eval[];   /* rinter.c */

#define CHECK_EXPR(ptd) \
           (R_DESC(*ptd,class) == C_LIST && R_DESC(*ptd,type) == TY_UNDEF) || \
           (R_DESC(*ptd,type) == TY_CLOS) || \
           (R_DESC(*ptd,type) == TY_COMB && R_COMB(*ptd,nargs) == 0) || \
           (R_DESC(*ptd,type) == TY_EXPR) || \
           (R_DESC(*ptd,type) == TY_NOMAT)

/* -------------------------------------------------- */
/* evaluate: evaluiert den ausdruck auf stack e und   */
/*           bewegt ihn auf stack a                   */
/* -------------------------------------------------- */

void evaluate()
{
  register STACKELEM  x,y;
  register int        dim;
  register VOLATILE T_PTD      ptdesc=(T_PTD)0; /* Initialisierung von TB, 6.11.1992, volatile: ach 10/11/92 */

  START_MODUL("evaluate");

  /* interruptbehandlung neu initialisieren */
  setjmp(_interruptbuf);
  if (_interrupt) {                              /* interrupt aufgetreten? */
    _interrupt = FALSE;                          /* zuruecksetzen */
    post_mortem("evaluate: interrupt received"); /* alles abbrechen */
  }

  PUSHSTACK(S_m,KLAA);             /* bottomsymbol */

main_e:

  x = READSTACK(S_e);
  if (T_POINTER(x)) {
    ptdesc = (T_PTD)x;
    if (R_DESC(*ptdesc,type) == TY_COMB && R_COMB(*ptdesc,nargs) == 0) {
      /* nullstellige funktion (constant applicative form) */
      PUSHSTACK(S_a,x);          /* COMB */
      PPOPSTACK(S_e);            /* COMB */
      INC_REFCNT(ptdesc);        /* um freigabe durch inter zu verhindern */

DBUG_PRINT ("RREDUCT", ("Yups, ich bin hier !"));

      inter(Rout_Eval);          /* evaluieren */

      DEC_REFCNT(ptdesc);        /* freigabe */
      goto main_m;
    } /* end TY_COMB */
    else
    if (R_DESC(*ptdesc,type) == TY_CLOS) {
      /* (un)gesaettigte closure  */
      if (R_CLOS(*ptdesc,args) == 0) {
        /* 0-stellige closure (indirektionsknoten) */
        y = R_CLOS(*ptdesc,pta)[0]; /* dereferenzieren */
        if (T_POINTER(y))
          INC_REFCNT((T_PTD)y);
        PUSHSTACK(S_a,y);          /* und auf a! ablegen */
        PPOPSTACK(S_e);            /* closure */
        DEC_REFCNT(ptdesc);        /* freigeben */
        goto main_m;
      }
      else {
        /* keine 0-stellige closure */
        int count = 0;
        PUSHSTACK(S_a,x);          /* closure */
        WRITESTACK(S_e,DOLLAR);    /* trennsymbol ueber closure */
        /* testen ob die closure nicht ausgewertete ausdruecke enthaelt */
        /* ACHTUNG: hiermit wird die reihenfolge der auswertung geaendert !!! */
        /* for (dim = R_CLOS(*ptdesc,args) ; dim >= 0 ; dim--) { */
        for (dim = 0; dim <= (int) R_CLOS(*ptdesc,args) ; dim++) {
                        /* int gecastet von RS 04/11/92 */ 
          y = R_CLOS(*ptdesc,pta)[dim];
          if (T_POINTER(y)) {
            register T_PTD ptd = (T_PTD)y;
            if (CHECK_EXPR(ptd)) {
              INC_REFCNT(ptd);
              PUSHSTACK(S_e,ptd);
              PUSHSTACK(S_m,SET_ARITY(AP,dim));
              count++;
            }
          }
        } /* end for */
        goto main_e;
      }
    } /* end TY_CLOS */
    else
    if (R_DESC(*ptdesc,class) == C_LIST && R_DESC(*ptdesc,type) == TY_UNDEF) {
      /* liste zu behandeln */
      int count = 0;
      PUSHSTACK(S_a,x);                   /* list */
      WRITESTACK(S_e,HASH);               /* trennsymbol */
      /* testen ob die liste nicht ausgewertete ausdruecke enthaelt */
      for (dim = R_LIST(*ptdesc,dim); --dim >= 0 ;) {
        y = R_LIST(*ptdesc,ptdv)[dim];
        if (T_POINTER(y)) {
          register T_PTD ptd = (T_PTD)y;
          if (CHECK_EXPR(ptd)) {
            INC_REFCNT(ptd);
            PUSHSTACK(S_e,ptd);
            PUSHSTACK(S_m,SET_ARITY(LIST,dim));
            count++;
          }
        }
      } /* end for */
      if (count == 0) {
        PPOPSTACK(S_e);      /* HASH weg */
        goto main_m;
      }
      goto main_e;
    } /* end C_LIST */
    else
    if (R_DESC(*ptdesc,type) == TY_EXPR) {
      /* (nicht ausfuehrbare) applikation */
      int count = 0;
      PUSHSTACK(S_a,x);                   /* expr */
      WRITESTACK(S_e,HASH);               /* trennsymbol */
      /* testen ob die applikation nicht ausgewertete ausdruecke enthaelt */
      for (dim = R_EXPR(*ptdesc,pte)[0]; dim > 0 ; dim--) {
        y = R_EXPR(*ptdesc,pte)[dim];
        if (T_POINTER(y)) {
          register T_PTD ptd = (T_PTD)y;
          if (CHECK_EXPR(ptd)) {
            INC_REFCNT(ptd);
            PUSHSTACK(S_e,ptd);
            PUSHSTACK(S_m,SET_ARITY(SNAP,dim));
            count++;
          }
        }
      } /* end for */
      if (count == 0) {
        PPOPSTACK(S_e);      /* HASH weg */
        goto main_m;
      }
      goto main_e;
    } /* end TY_EXPR */
    else {
      /* sonstige faelle */
      PUSHSTACK(S_a,x);
      PPOPSTACK(S_e);
      goto main_m;
    }
  } /* end T_POINTER(x) */
  else
  if (T_DOLLAR(x)) {
    /* ende der behandlung einer closure */
    register PTR_HEAPELEM pth = R_CLOS(*ptdesc,pta);
    ptdesc = (T_PTD)READSTACK(S_a); /* closure */
    INC_REFCNT(ptdesc);             /* um freigabe durch inter zu verhindern */
    PUSHSTACK(S_a,ptdesc);          /* closure verdoppeln */

DBUG_PRINT ("RREDUCT", ("Ich bin hier unten !"));

    inter(Rout_Eval);               /* evaluieren */

    /* argumente der closure freigeben */
    RES_HEAP;
    for (dim = R_CLOS(*ptdesc,args) ; dim >= 0 ; dim--) {
      if (T_POINTER(pth[dim])) {
        DEC_REFCNT((T_PTD)pth[dim]);
      }
    }
    freeheap(R_CLOS(*ptdesc,pta));
    REL_HEAP;
    /* indirektionsknoten anlegen (CLOS mit args == 0) */
    L_CLOS(*ptdesc,args) = 0;
    y = POPSTACK(S_a);             /* ergebnis von eval */
    if (T_POINTER(y))
      INC_REFCNT((T_PTD)y);
    R_CLOS(*ptdesc,pta)[0] = y;     /* resultat eintragen */
    WRITESTACK(S_a,y);              /* ergebnis von eval ueber closure */
    DEC_REFCNT(ptdesc);             /* closure freigeben */
    PPOPSTACK(S_e);                 /* DOLLAR */
    goto main_m;
  }
  else
  if (T_HASH(x)) {
    /* ende der behandlung einer liste oder applikation */
    PPOPSTACK(S_e);                 /* HASH */
    goto main_m;
  }
  else {
    /* alle sonstigen faelle */
    PUSHSTACK(S_a,x);
    PPOPSTACK(S_e);
    goto main_m;
  }

main_m:

  x = READSTACK(S_m);
  if (T_AP(x)) {
    /* argument einer closure wurde evaluiert */
    y = POPSTACK(S_a);                            /* result of evaluation */
    ptdesc = (T_PTD)READSTACK(S_a);               /* CLOS-descriptor */
    dim = ARITY(x);                               /* arity of AP(n) */
    DEC_REFCNT((T_PTD)R_CLOS(*ptdesc,pta)[dim]);  /* always a pointer !!! */
    R_CLOS(*ptdesc,pta)[dim] = y;                 /* replace by value */
    PPOPSTACK(S_m);
    goto main_e;
  } /* end T_AP */
  else
  if (T_LIST(x)) {
    /* element einer liste wurde evaluiert */
    y = POPSTACK(S_a);                            /* result of evaluation */
    ptdesc = (T_PTD)READSTACK(S_a);               /* LIST-descriptor */
    dim = ARITY(x);                               /*  arity of LIST(n) */
    DEC_REFCNT((T_PTD)R_LIST(*ptdesc,ptdv)[dim]); /* always a pointer !!! */
    R_LIST(*ptdesc,ptdv)[dim] = y;                /* replace by value */
    PPOPSTACK(S_m);
    goto main_e;
  } /* end T_LIST */
  else
  if (T_SNAP(x)) {
    /* element einer applikation wurde evaluiert */
    y = POPSTACK(S_a);                           /* result of evaluation */
    ptdesc = (T_PTD)READSTACK(S_a);              /* EXPR-descriptor */
    dim = ARITY(x);                              /* arity of SNAP(n) */
    DEC_REFCNT((T_PTD)R_EXPR(*ptdesc,pte)[dim]); /* always a pointer !!! */
    R_EXPR(*ptdesc,pte)[dim] = y;                /* replace by value */
    PPOPSTACK(S_m);
    goto main_e;
  } /* end T_SNAP */
  else
  if (T_KLAA(x)) {
    /* terminierung */
    PPOPSTACK(S_m);
    END_MODUL("evaluate");
    return;
  } /* end T_KLAA */
  else {
    post_mortem("evaluate: unexpected symbol on stack m");
  }
} /* end evaluate() */

/* end of       rreduct.c */
