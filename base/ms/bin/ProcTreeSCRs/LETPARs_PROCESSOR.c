/* This file is automatically generated (by scr2c.awk)
** DO NOT EDIT BELOW!
*/

#include <dbug.h>

#include <msMacros.h>
#include <scriptMacros.h>
#include <groups.h>
#include <externVars.h>

extern void SET_MODE();
extern void SET_X_LABEL();
extern void SET_Y_LABEL();
extern void SET_X_GRID();
extern void SET_Y_GRID();
extern void SET_X_MIN();
extern void SET_X_MAX();
extern void SET_Y_MIN();
extern void SET_Y_MAX();
extern void SET_LEGEND();
extern void SET_STYLE();
extern void SET_LINESTYLE();
extern void SET_MARKER();
extern void SET_SHADE();
extern void CREATE_BAR();
extern void INCREMENT();
extern void REMOVE_XY();
extern void ADD_XY();
extern void UPDATE_XY();
extern void CREATION_ARROW();
extern void FILL_SLOT();
extern void SHOW_HISTORY();
extern void SHOW_FUTURE();
extern void SET_METER();
extern void DRAW_METER();
extern void SET_DIMENSIONS();
extern void FILL_ALL();
extern void FILL_BLOCK();
extern int GET_HEAPBASE();
extern void DRAW_FRAGMENTATION();
extern void SET_CACHING();
extern void SET_STACKING();
extern void SET_SEPARATION();
extern void SET_FRAGMENTATION();
extern void ADD_NODE();
extern void REMOVE_NODE();
extern void SET_NODES();
extern void SET_LABELS();
extern void SET_DEPTH();
extern void ZOOM_IN();
extern void ZOOM_OUT();
extern void SHOW_TOP();
extern void NEXT_FRAME();
extern void NEXT_FRAME_BUT_CONTINUE();
extern void SET_DELAY();
extern void SET_RATE();
extern void SET_TITLE();
extern void SET_STYLE();
extern void SET_COLORS();
extern void GET_TIME();
extern void HEADER_FILE();
extern void HEADER_TIME();
extern void HEADER_NODISTNUM();
extern void HEADER_DIMENSION();
extern void HEADER_STEPS();
extern void HEADER_FACTOR();
extern void HEADER_BINARY();
extern void HEADER_HEAPSIZE();
extern void HEADER_HEAPDES();
extern void FLUSH();

extern void SAVE();
extern void PRINT();
extern void CLEAR();

#define STACK_SIZE 1000
#define MAX_TICKETS 8
static int pids[MAX_PROCESSORS][MAX_PROCESSES],
           numProcesses[MAX_PROCESSORS],
           tempProcess, tempProcess2, i, j, k;
static short father[MAX_PROCESSORS][MAX_PROCESSES][STACK_SIZE],
             topOfStack[MAX_PROCESSORS][MAX_PROCESSES],
             actualNode[MAX_PROCESSORS][MAX_PROCESSES], lastNode,
             newNode[MAX_PROCESSORS][MAX_PROCESSES][MAX_PROCESSORS]
                    [MAX_TICKETS],
             topOfNewNodeQueue[MAX_PROCESSORS][MAX_PROCESSES]
                              [MAX_PROCESSORS];
static char rememberFile[100], rememberTime[100], rememberSteps[100],
            temp[1000], label[10];
int pid(processor, realPid)
int processor, realPid;
{
	int i;
	for(i=0; i<numProcesses[processor]; ++i) {
		if(pids[processor][i] == realPid) {
			return(i);
		}
	}
	return(-1);
}
void push(processor, process, i)
short processor, process, i;
{
	short t;
	if((t = ++topOfStack[processor][process]) < STACK_SIZE) {
		father[processor][process][t-1] = i;
	} else {
		printf("Push on exceeded stack...\n");
	}
	return;
}
short pop(processor, process)
short processor, process;
{
	short t;
	if((t = --topOfStack[processor][process]) >= 0) {
		return(father[processor][process][t]);
	} else {
		printf("Pop on empty stack..\n");
		return((short)-1);
	}
}
short peek(processor, process)
short processor, process;
{
	short t;
	if((t = topOfStack[processor][process]) >= 1) {
		return(father[processor][process][t-1]);
	} else {
		printf("Peek on empty stack..\n");
		return((short)-1);
	}
}
int isEmpty(processor, process)
short processor, process;
{
	return(topOfStack[processor][process] == 0);
}


void eval()
{
  /*DBUG_ENTER("eval");*/

  switch(ID) {

  case MINDEX_BEGIN:
for(i=0; i<MAX_PROCESSORS; ++i) {
	for(j=0; j<MAX_PROCESSES; ++j) {
		topOfStack[i][j] = 0;
		for(k=0; k<MAX_PROCESSORS; ++k) {
			topOfNewNodeQueue[i][j][k] = 0;
		}
	}
}

/* Colors for "Disributed", "Own" and "Nodes" */
SET_COLORS(LIGHT_YELLOW, GREEN, BLACK, LIGHT_RED);
HEADER_FILE(rememberFile);
HEADER_TIME(rememberTime);
HEADER_STEPS(rememberSteps);
sprintf(temp, "%s (%s) -- %s reduction steps",
        rememberFile, rememberTime, rememberSteps);
SET_TITLE(temp);
actualNode[0][0] = lastNode = 0;
ADD_NODE(lastNode, NOCARE, NOCARE, "0");
NEXT_FRAME();
break;

  case MINDEX_COUNT_PUSHH:
tempProcess = pid(PROCESSOR, PROCESS);
push(PROCESSOR, tempProcess, actualNode[PROCESSOR][tempProcess]);
break;

  case MINDEX_PROC_NODIST:
tempProcess = pid(PROCESSOR, PROCESS);
/* No distribution... */
++lastNode;
sprintf(label, "%d", PROCESSOR);
ADD_NODE(lastNode, peek(PROCESSOR, tempProcess), NODIST, label);
actualNode[PROCESSOR][tempProcess] = lastNode;
NEXT_FRAME();
break;


  case MINDEX_PROC_DIST:
tempProcess = pid(PROCESSOR, PROCESS);
if(PD_NEXT_PROC == -1) {
	/* No distribution... */
	++lastNode;
	sprintf(label, "%d", PROCESSOR);
	ADD_NODE(lastNode, peek(PROCESSOR, tempProcess),
	         HOME, label);
	actualNode[PROCESSOR][tempProcess] = lastNode;
	NEXT_FRAME();
}
/* If PD_NEXT_PROC != -1 there will be a SEND_BEGIN for the
** distribution. See next case...
*/
break;

  case MINDEX_SEND_BEGIN:
if(!strcmp(S_TYPE, "MT_NEW_PROCESS")) {
	tempProcess = pid(PROCESSOR, PROCESS);
	/* Distribution... */
	++lastNode;
	sprintf(label, "%d", S_TARGET_PROC);
	ADD_NODE(lastNode, peek(PROCESSOR, tempProcess),
	         DISTRIBUTED, label);
	k = ++topOfNewNodeQueue[PROCESSOR][tempProcess][S_TARGET_PROC];
	newNode[PROCESSOR][tempProcess][S_TARGET_PROC][k-1] = lastNode;
	NEXT_FRAME();
}
break;

  case MINDEX_PROC_CREATE:
/* Is this pid in the table yet? */
if(pid(PROCESSOR, PC_PID) == -1) {
	pids[PROCESSOR][numProcesses[PROCESSOR]++] = PC_PID;
}
break;

  case MINDEX_RECEIVE_END:
if(!strcmp(R_TYPE, "MT_NEW_PROCESS")) {
	tempProcess = pid(PROCESSOR, R_FOR_PID);
	tempProcess2 = pid(R_FROM_PROC, R_FROM_PID);
	k = --topOfNewNodeQueue[R_FROM_PROC][tempProcess2][PROCESSOR];
	actualNode[PROCESSOR]
	          [tempProcess] = newNode[R_FROM_PROC][tempProcess2]
	                                 [PROCESSOR][0];
	if(k) {
		/* There's more than 1 element in the queue -> SHIFT */
		for(i=0; i<k; i++){
			newNode[R_FROM_PROC][tempProcess2]
			       [PROCESSOR][i] =	newNode[R_FROM_PROC]
			                               [tempProcess2]
			                               [PROCESSOR]
			                               [i+1];
		}
	}
}
break;

  case MINDEX_COUNT_WAIT:
pop(PROCESSOR, pid(PROCESSOR, PROCESS));
break;

  case MINDEX_END:
break;
  }

  /*DBUG_VOID_RETURN*/

  return;
}


void iNeed(needed)
char needed[IDS_LEN][MAX_IDS]; {
  int i = 0;

  strcpy(needed[i++], "COUNT_PUSHH");
  strcpy(needed[i++], "PROC_NODIST");
  strcpy(needed[i++], "PROC_DIST");
  strcpy(needed[i++], "SEND_BEGIN");
  strcpy(needed[i++], "PROC_CREATE");
  strcpy(needed[i++], "RECEIVE_END");
  strcpy(needed[i++], "COUNT_WAIT");
  strcpy(needed[i++], "");

  return;
}
