head	1.58;
access;
symbols;
locks; strict;
comment	@ * @;


1.58
date	96.04.11.13.27.29;	author cr;	state Exp;
branches;
next	1.57;

1.57
date	96.03.06.12.01.23;	author sf;	state Exp;
branches;
next	1.56;

1.56
date	96.03.06.11.36.51;	author sf;	state Exp;
branches;
next	1.55;

1.55
date	96.02.29.20.50.01;	author sf;	state Exp;
branches;
next	1.54;

1.54
date	96.02.29.12.16.12;	author sf;	state Exp;
branches;
next	1.53;

1.53
date	96.02.23.13.27.10;	author rs;	state Exp;
branches;
next	1.52;

1.52
date	96.02.22.16.19.01;	author stt;	state Exp;
branches;
next	1.51;

1.51
date	96.02.21.09.49.53;	author stt;	state Exp;
branches;
next	1.50;

1.50
date	96.02.16.18.45.31;	author stt;	state Exp;
branches;
next	1.49;

1.49
date	96.02.16.14.02.34;	author cr;	state Exp;
branches;
next	1.48;

1.48
date	96.02.16.09.19.57;	author sf;	state Exp;
branches;
next	1.47;

1.47
date	96.02.15.16.40.10;	author cr;	state Exp;
branches;
next	1.46;

1.46
date	96.02.13.18.46.05;	author stt;	state Exp;
branches;
next	1.45;

1.45
date	96.02.13.18.00.15;	author stt;	state Exp;
branches;
next	1.44;

1.44
date	96.02.13.17.49.21;	author sf;	state Exp;
branches;
next	1.43;

1.43
date	96.02.09.10.23.48;	author sf;	state Exp;
branches;
next	1.42;

1.42
date	96.02.07.17.50.08;	author rs;	state Exp;
branches;
next	1.41;

1.41
date	96.02.07.11.54.32;	author sf;	state Exp;
branches;
next	1.40;

1.40
date	96.02.06.18.33.00;	author rs;	state Exp;
branches;
next	1.39;

1.39
date	96.02.05.13.17.38;	author sf;	state Exp;
branches;
next	1.38;

1.38
date	96.01.31.12.36.54;	author sf;	state Exp;
branches;
next	1.37;

1.37
date	96.01.25.16.36.19;	author stt;	state Exp;
branches;
next	1.36;

1.36
date	96.01.23.17.46.52;	author sf;	state Exp;
branches;
next	1.35;

1.35
date	95.10.25.15.26.41;	author sf;	state Exp;
branches;
next	1.34;

1.34
date	95.07.10.13.59.46;	author car;	state Exp;
branches;
next	1.33;

1.33
date	95.07.04.11.44.28;	author sf;	state Exp;
branches;
next	1.32;

1.32
date	95.06.29.09.17.54;	author sf;	state Exp;
branches;
next	1.31;

1.31
date	95.06.28.12.17.33;	author sf;	state Exp;
branches;
next	1.30;

1.30
date	95.06.28.09.58.12;	author sf;	state Exp;
branches;
next	1.29;

1.29
date	95.06.15.09.44.00;	author sf;	state Exp;
branches;
next	1.28;

1.28
date	95.06.02.16.32.58;	author sf;	state Exp;
branches;
next	1.27;

1.27
date	95.06.01.15.30.27;	author sf;	state Exp;
branches;
next	1.26;

1.26
date	95.05.25.12.02.35;	author sf;	state Exp;
branches;
next	1.25;

1.25
date	95.05.19.11.19.11;	author sf;	state Exp;
branches;
next	1.24;

1.24
date	95.05.18.13.51.00;	author sf;	state Exp;
branches;
next	1.23;

1.23
date	95.05.17.15.12.31;	author sf;	state Exp;
branches;
next	1.22;

1.22
date	95.05.12.10.01.04;	author sf;	state Exp;
branches;
next	1.21;

1.21
date	95.05.02.14.17.40;	author sf;	state Exp;
branches;
next	1.20;

1.20
date	95.04.26.12.55.13;	author cr;	state Exp;
branches;
next	1.19;

1.19
date	95.04.05.14.18.41;	author sf;	state Exp;
branches;
next	1.18;

1.18
date	95.04.03.13.01.14;	author sf;	state Exp;
branches;
next	1.17;

1.17
date	95.03.31.12.03.43;	author sf;	state Exp;
branches;
next	1.16;

1.16
date	95.03.29.16.28.01;	author cr;	state Exp;
branches;
next	1.15;

1.15
date	95.03.29.14.12.51;	author sf;	state Exp;
branches;
next	1.14;

1.14
date	95.03.27.14.48.23;	author sf;	state Exp;
branches;
next	1.13;

1.13
date	95.03.24.13.42.45;	author cr;	state Exp;
branches;
next	1.12;

1.12
date	95.03.24.13.37.40;	author cr;	state Exp;
branches;
next	1.11;

1.11
date	95.03.24.13.32.35;	author sf;	state Exp;
branches;
next	1.10;

1.10
date	95.03.15.08.27.56;	author sf;	state Exp;
branches;
next	1.9;

1.9
date	95.03.08.13.24.45;	author sf;	state Exp;
branches;
next	1.8;

1.8
date	95.03.08.12.31.30;	author sf;	state Exp;
branches;
next	1.7;

1.7
date	95.03.07.16.17.26;	author sf;	state Exp;
branches;
next	1.6;

1.6
date	95.03.06.16.55.47;	author sf;	state Exp;
branches;
next	1.5;

1.5
date	95.03.06.15.46.20;	author sf;	state Exp;
branches;
next	1.4;

1.4
date	95.02.02.11.48.18;	author sf;	state Exp;
branches;
next	1.3;

1.3
date	95.01.25.10.13.14;	author sf;	state Exp;
branches;
next	1.2;

1.2
date	95.01.06.16.51.15;	author sf;	state Exp;
branches;
next	1.1;

1.1
date	95.01.04.13.16.29;	author sf;	state Exp;
branches;
next	;


desc
@Initial revision
@


1.58
log
@prepare for separate compilation (again:-(
step I: avoid use of program-specific global variables
in tasm-generated code inside initdata.c and rmkclos.c
(cf. compile.c c_output.c)
@
text
@#define WITHTILDE 1
#define PROLOG_EXTERN
#include "prolog.h"
#include <sys/time.h>

/******************************************************************************/
/*                                                                            */
/* Encoding of the Output sending back to reduma                              */
/*                                                                            */
/* output : tag data                                                          */
/*                                                                            */
/* with                                                                       */
/*                                                                            */
/* data   : length output* (in case of ri_list,ri_frame, ri_intact)           */
/*        : tagged_integer | tagged_boolean  (in case of ri_int or ri_bool)   */
/*        : value_of_real (in case of ri_real)                                */
/*        : arity arg graph_adr  (in case of ri_case, ri_comb or ri_cond)     */
/*        : act_nomat reason ptsdes guard_body[0] guard_body[1] guard_body[2] */
/*          guard_body[3]                                                     */
/*        : arity arg (in case of ri_sub)                                     */
/*        : tag arity arg nfv (in case of closure) ...                        */
/*        : name value (in case of ri_slot)                                   */
/*                                                                            */
/* act_nomat : integer                                                        */
/* reason    : integer                                                        */
/* arity     : integer                                                        */
/* arg       : integer                                                        */
/* graph_adr : integer                                                        */
/* guard_body[0] : integer                                                    */
/* guard_body[1] : output                                                     */
/* guard_body[2] : output                                                     */
/* guard_body[3] : output                                                     */
/* name          : output                                                     */
/* value         : output                                                     */
/*                                                                            */
/* tag    : ri_int | ri_real | ri_list | ri_func                              */
/*        | ri_mat | ri_vect | ri_tvect | ri_cons | ri_prim                   */
/*                                                                            */
/*                                                                            */
/******************************************************************************/

typedef enum {
                ri_bool = 0, ri_int = 1, ri_real = 2, ri_list = 3, ri_clos = 4, 
                ri_mat = 5, ri_vect = 6, ri_tvect = 7, ri_cons = 8, ri_prim = 9,
                ri_comb = 10, ri_cond = 11, ri_expr = 12, ri_case = 13,
                ri_CAVE = 14, ri_nomat = 15, ri_sub = 16, ri_dyncomb = 17,
                ri_char = 18, ri_string = 19, ri_var = 20, ri_const = 21,
                ri_name = 22, ri_constant = 23, ri_undef = 24, ri_frame = 25,
                ri_slot = 26, ri_intact
              } RED_INPUT;
/*******************************************************************************/

int newheap(), controlled_exit();
void lo(int), OutputOfTasm2KiR(int);

FILE *tasm2kir  = stdout;
extern int AsciiOutput, KiROutput, withtilde;
extern char ri_tasmoutfile[120];
extern INTACT_TAB intact_tab[];
extern double start_time;

static int st_number_of_descs, st_number_of_data;
static int *st_data_table,*st_ptc_table;
static PTR_DESCRIPTOR *st_funcdesctable;
#define DESC(x)  (* (PTR_DESCRIPTOR) x)


#ifdef __sparc__
#if (0==NO_STACK_REG)
  register int *st_h asm ("g5");
  register int *st_w asm ("g7");
  register int *st_a asm ("g6");
#else
  extern int *st_h;
  extern int *st_w;
  extern int *st_a;
#endif
#else
  extern int *st_h;
  extern int *st_w;
  extern int *st_a;
#endif

extern PTR_DESCRIPTOR _desc;

#define GET_PTC(x)    search_ptc(x)
#define LASTCHAR      0xFFFFFFDF 
#define IS_CHAR(x)    ((((x) & 0x0000000F) == 0x0000000c) && ((x) & 0x00000010))
#define IS_VAR_CHAR(x) ((((x) & 0x0000000F) == 0x0000000c) &&((x) & 0x00000020))
#define GET_THAT_CHAR(x)   ((x) >> 16)
#define UNTAGLAST(x)  ((x) | ~LASTCHAR)
#define TAGLASTCHAR(x)  ((x) & LASTCHAR)
#define MAKE_VAR_CHAR(x)  (((x) << 16) | 0x0000002c)


int initdata_list_initial (int dim, int *args)
{
  int i;
  PTR_HEAPELEM pth; /* pointer to heapelement */
  DBUG_ENTER("initdata_list_initial");
  
  if (0 == dim)
    _desc = _nil;
  else
  {
    MAKEDESC(_desc, 1, C_LIST, TY_UNDEF);
    DBUG_PRINT("INITDATA",("dim: %d",dim));
    L_LIST((*_desc), dim) = dim;
    L_LIST((*_desc), ptdd) = 0;
    GET_HEAP(dim, A_LIST((*_desc), ptdv));
    DBUG_PRINT("INITDATA",("Got heap"));
    RES_HEAP;
    DBUG_PRINT("INITDATA",("heap reserved"));
    pth = R_LIST(*_desc,ptdv);
    DBUG_PRINT("INITDATA",("pth initialized"));
    for (i = 0; i < dim; i++) 
    {
      DBUG_PRINT("INITDATA",("pth[%d] will be copied next",i));
      pth[i] = args[i];
      DBUG_PRINT("INITDATA",("pth[%d] copied",i));
    }
    L_LIST((*_desc), ptdd) = NULL;
    DBUG_PRINT("INITDATA",("ptdd initialized"));
    L_LIST((*_desc), special) = NULL;
    DBUG_PRINT("INITDATA",("special initialized"));
    REL_HEAP;
    DBUG_PRINT("INITDATA",("heap released"));
  }
  DBUG_RETURN((int)_desc);
}


int initdata_list (int dim)
{
  int i;
  PTR_HEAPELEM pth; /* pointer to heapelement */
  DBUG_ENTER("initdata_list");
  
  if (0 == dim)
    _desc = _nil;
  else
  {
    MAKEDESC(_desc, 1, C_LIST, TY_UNDEF);
    DBUG_PRINT("INITDATA",("dim: %d",dim));
    L_LIST((*_desc), dim) = dim;
    L_LIST((*_desc), ptdd) = 0;
    GET_HEAP(dim, A_LIST((*_desc), ptdv));
    DBUG_PRINT("INITDATA",("Got heap"));
    RES_HEAP;
    DBUG_PRINT("INITDATA",("heap reserved"));
    pth = R_LIST(*_desc,ptdv);
    DBUG_PRINT("INITDATA",("pth initialized"));
    for (i = 0; i < dim; i++) 
    {
      DBUG_PRINT("INITDATA",("pth[%d] will be copied next",i));
      pth[i] = peek(w, dim - i - 1);
      DBUG_PRINT("INITDATA",("pth[%d] copied",i));
    }
    L_LIST((*_desc), ptdd) = NULL;
    DBUG_PRINT("INITDATA",("ptdd initialized"));
    L_LIST((*_desc), special) = NULL;
    DBUG_PRINT("INITDATA",("special initialized"));
    REL_HEAP;
    DBUG_PRINT("INITDATA",("heap released"));
  }
  DBUG_RETURN((int)_desc);
}

int initdata_i_list (int dim)
{
  int i;
  PTR_HEAPELEM pth; /* pointer to heapelement */
  DBUG_ENTER("initdata_i_list");
  
  if (0 == dim)
    _desc = _nil;
  else
  {
    MAKEDESC(_desc, 1, C_LIST, TY_UNDEF);
    L_LIST((*_desc), dim) = dim;
    L_LIST((*_desc), ptdd) = 0;
    GET_HEAP(dim, A_LIST((*_desc), ptdv));
    RES_HEAP;
    pth = R_LIST(*_desc,ptdv);
    for (i = 0; i < dim; i++) 
      pth[i] = peek(w,i); 
    L_LIST((*_desc), ptdd) = NULL;
    L_LIST((*_desc), special) = NULL;
    REL_HEAP;
  }
  DBUG_RETURN((int)_desc);
}

int initdata_string(int dim, int *args)
{
  int i;
  PTR_HEAPELEM pth; /* pointer to heapelement */
  DBUG_ENTER("initdata_string");

  if (0 == dim)
    _desc = _nilstring;
  else
  {
    MAKEDESC(_desc, 1, C_LIST, TY_STRING);
    L_LIST((*_desc), dim) = dim;
    L_LIST((*_desc), ptdd) = 0;
    GET_HEAP(dim, A_LIST((*_desc), ptdv));
    RES_HEAP;
    pth = R_LIST(*_desc,ptdv);
    for (i = 0; i < dim; i++)
      pth[i] = args[i];
    L_LIST((*_desc), ptdd) = NULL;
    L_LIST((*_desc), special) = NULL;
    REL_HEAP;
  }
  DBUG_RETURN((int)_desc);
}

int initdata_free_var(int dim, char *args)
{
  int i;
  T_PTD ptdesc;
  
  PTR_HEAPELEM pth; /* pointer to heapelement */
  DBUG_ENTER("initdata_string");

  MAKEDESC(_desc, 1, C_EXPRESSION, TY_NAME);
  GET_HEAP(dim + 1, A_NAME((*_desc), ptn));
  RES_HEAP;
  pth = R_NAME(*_desc, ptn);
  pth[0]=dim;
  for (i = 1; i <= dim; i++)
  {
    pth[i] = args[i-1];
    pth[i] = MAKE_VAR_CHAR(pth[i]);
  }
  pth[dim] = TAGLASTCHAR(pth[dim]);
  REL_HEAP;
  MAKEDESC(ptdesc, 1, C_CONSTANT, TY_VAR);
  L_VAR(*ptdesc, nlabar) = 0;
  L_VAR(*ptdesc, ptnd) = _desc;
  DBUG_RETURN((int)ptdesc);
}

int initdata_matrix(int c, int t, int rows, int cols, int *mvt)
{
  int i;
  double *rmvt, *new_rmvt;
  T_PTD ptdesc;
  PTR_HEAPELEM pth; /* pointer to heapelement */
  DBUG_ENTER("initdata_matrix");
  
  if (0 == rows * cols)
  {
    if (C_MATRIX == c)
      _desc = _nilmat;
    else if (C_VECTOR == c)
      _desc = _nilvect;
    else if (C_TVECTOR == c)
      _desc = _niltvect;
  }
  else
  {
    MAKEDESC(_desc, 1, c, t);
    L_MVT(*_desc, ptdd, c) = NULL;
    L_MVT(*_desc, nrows, c) = rows;
    L_MVT(*_desc, ncols, c) = cols;
    if (TY_REAL == t)
    {
      GET_HEAP(rows * cols * sizeof(double) / sizeof(T_HEAPELEM), A_MVT(*_desc, ptdv, c));
      RES_HEAP;
      new_rmvt = (double *)R_MVT(*_desc, ptdv, c);
      rmvt = (double *)mvt;
      for(i = 0; i < rows * cols; i++)
        new_rmvt[i] = (double)rmvt[i];
      L_MVT(*_desc, ptdv, c) = (PTR_HEAPELEM)new_rmvt;
      REL_HEAP;
    }
    else
    {
      GET_HEAP(rows * cols, A_MVT((*_desc), ptdv, c));
      for(i = 0; i < rows * cols; i++)
        L_MVT(*_desc, ptdv, c)[i] = mvt[i];
    }
  }
  DBUG_RETURN((int)_desc);  
}

/* cr 15/03/95, kir(ff), START */
int initdata_inter (DESC_TYPE type,int dim, int *args)
{
  int i;
  PTR_HEAPELEM pth; /* pointer to heapelement */
  DBUG_ENTER("initdata_inter");
  
  MAKEDESC(_desc, 1, C_INTER, type);
  L_INTER((*_desc), dim) = dim;
  GET_HEAP(dim, A_INTER((*_desc), args));
  RES_HEAP;
  pth = R_INTER(*_desc,args) + dim  - 1;
  for (i = 0; i < dim; i++) 
    pth[-i] = args[i]; 
  REL_HEAP;
  DBUG_RETURN((int)_desc);
}

int initdata_frame (int dim, int *args)
{
  int i;
  PTR_HEAPELEM pth; /* pointer to heapelement */
  DBUG_ENTER("initdata_frame");
  
  MAKEDESC(_desc, 1, C_FRAME, TY_FRAME);
  L_FRAME((*_desc), dim) = dim;
  GET_HEAP(dim, A_FRAME((*_desc), slots));
  RES_HEAP;
  pth = R_FRAME(*_desc,slots);
  for (i = 0; i < dim; i++) 
    pth[i] = args[i]; 
  REL_HEAP;
  DBUG_RETURN((int)_desc);
}

int initdata_slot (int dim, int *args)
{
  PTR_HEAPELEM pth; /* pointer to heapelement */
  DBUG_ENTER("initdata_slot");
  
  MAKEDESC(_desc, 1, C_FRAME, TY_SLOT);
  L_SLOT((*_desc),name) = (PTR_DESCRIPTOR)(args[0]);
  L_SLOT((*_desc),value) = args[1];
  DBUG_RETURN((int)_desc);
}
/* cr 15/03/95, kir(ff), END */

/* stt, 13.02.96 */
int initdata_intact(int intact)
{
  int i;
  PTR_HEAPELEM pth;

  DBUG_ENTER("initdata_intact");
  MAKEDESC(_desc, 1, C_INTACT, TY_INTACT);
  L_INTACT(*_desc,dim)  = FUNC_ARITY(intact) + 1;
  GET_HEAP(FUNC_ARITY(intact) + 2, A_INTACT(*_desc,args));
  RES_HEAP;
  pth = R_INTACT(*_desc,args);
  *pth++ = intact;
  for (i=0; i<FUNC_ARITY(intact); i++)
    *pth++ = peek(w, i);
  REL_HEAP;
  DBUG_RETURN((int)_desc);
}


int initdata_scalar(double value)
{
  DBUG_ENTER("initdata_scalar");
  
  MAKEDESC(_desc,1,C_SCALAR, TY_REAL);
  L_SCALAR(*_desc, valr) = value;
  DBUG_RETURN((int)_desc);
}  

PTR_DESCRIPTOR initdata_new_scalar(double value, int h_desc)
{
  DBUG_ENTER("initdata_new_scalar");
  
  MAKEDESC((PTR_DESCRIPTOR)h_desc,1,C_SCALAR, TY_REAL);
  L_SCALAR(*(PTR_DESCRIPTOR)h_desc, valr) = value;
  DBUG_RETURN((PTR_DESCRIPTOR)h_desc);
}  


int search_ptc(int d)
{
  int i, class;
  DBUG_ENTER("search_ptc");
  switch(R_DESC(DESC(d), type))
  {
    case TY_COMB:
      for (i = 0; i < 2 * st_number_of_descs; i+=2)
      {
        if (st_ptc_table[i] == (int)R_COMB(DESC(d), ptd))
          break;
      }
      break;
    case TY_CASE:
      for (i = 0; i < 2 * st_number_of_descs; i+=2)
      {
        if (st_ptc_table[i] == (int)R_CASE(DESC(d), ptd))
          break;
      }
      break;
    case TY_CONDI:
      for (i = 0; i < 2 * st_number_of_descs; i+=2)
      {
        if (st_ptc_table[i] == (int)R_CONDI(DESC(d), ptd))
          break;
      }
      break;
  }
  DBUG_RETURN((int)st_ptc_table[i + 1]);
}

/*************************************************************/
/* gets a stack element and prints it out                    */
/* now only lists, reals, booleans and integers              */
/*************************************************************/
void lo(int lw)
{
int i, j;
char class[10];
double *rmvt;
int mvt_class;

  if (T_INT(lw))  
    printf("%d",VAL_INT(lw));       
  else if (T_BOOLEAN(lw))                           
  {                                              
    if (T_SA_FALSE(lw))                        
      printf("false");                  
    else if (T_SA_TRUE(lw))                    
      printf("true");                   
    else printf("Error in boolean result !\n");  
  }                                              
  else if ((IS_CHAR(lw)) || (IS_VAR_CHAR(lw)))
  {
    if (isprint((char)GET_THAT_CHAR(lw)))
      printf("%c", (char)GET_THAT_CHAR(lw));
    else
      printf("'\\%03o'", (char)GET_THAT_CHAR(lw));      /* stt 20.02.96 */
  }
  else if (T_POINTER(lw)) 
  {                        
    if ((R_DESC(DESC(lw),class)==C_SCALAR) && (R_DESC(DESC(lw),type)==TY_REAL))
      printf("%.16g", R_SCALAR(DESC(lw),valr)) ; 
    else if ((R_DESC(DESC(lw), class) == C_MATRIX) 
              || (R_DESC(DESC(lw), class) == C_VECTOR)
              || (R_DESC(DESC(lw), class) == C_TVECTOR))
    {
      if (R_DESC(DESC(lw), class) == C_MATRIX)
      {
        strcpy(class, "mat");
        mvt_class = C_MATRIX;
      }
      else if (R_DESC(DESC(lw), class) == C_VECTOR)
      {
        strcpy(class, "vect");
        mvt_class = C_VECTOR;
      }
      else if (R_DESC(DESC(lw), class) == C_TVECTOR)
      {
        strcpy(class, "tvect");
        mvt_class = C_TVECTOR;
      }
      switch (R_MVT(DESC(lw), type, mvt_class))
      {
        case TY_INTEGER:
          printf("%s\n", class);
          if (0 == R_MVT(DESC(lw), nrows, mvt_class) * R_MVT(DESC(lw), nrows, mvt_class))
            printf("<>\n");
          else
          {
            int rows, cols;
            if (R_DESC(DESC(lw), class) == C_TVECTOR)
            {
              cols = R_MVT(DESC(lw), nrows, mvt_class);
              rows = R_MVT(DESC(lw), ncols, mvt_class);
            }
            else
            {
              rows = R_MVT(DESC(lw), nrows, mvt_class);
              cols = R_MVT(DESC(lw), ncols, mvt_class);
            }
            for(i = 0; i < rows; i++)
            {
              printf("<");
              if (0 < R_MVT(DESC(lw), ncols, mvt_class))
                printf("%d", 
                  R_MVT(DESC(lw), ptdv, mvt_class)[i * R_MVT(DESC(lw), ncols, mvt_class)]);
              for(j = 1; j < cols; j++)
              {
                if (R_DESC(DESC(lw), class) == C_TVECTOR)
                  printf(",\n %d", 
                    R_MVT(DESC(lw), ptdv, mvt_class)[i*R_MVT(DESC(lw), ncols, mvt_class)+j]);
                else
                  printf(", %d", 
                    R_MVT(DESC(lw), ptdv, mvt_class)[i*R_MVT(DESC(lw), ncols, mvt_class)+j]);
              }
              printf(">\n");
            }
          }
          break;
        case TY_BOOL:
          printf("b%s\n", class);
          if (0 == R_MVT(DESC(lw), nrows, mvt_class) * R_MVT(DESC(lw), nrows, mvt_class))
            printf("<>\n");
          else
          {
            for(i = 0; i < R_MVT(DESC(lw), nrows, mvt_class); i++)
            {
              printf("<");
              if (0 < R_MVT(DESC(lw), ncols, mvt_class))
                printf("%s", 
                  R_MVT(DESC(lw), ptdv, mvt_class)[i*R_MVT(DESC(lw), ncols, mvt_class)] 
                  ? "true" : "false");
              for(j = 1; j < R_MVT(DESC(lw), ncols, mvt_class); j++)
              {
                if (R_DESC(DESC(lw), class) == C_TVECTOR)
                  printf(",\n\t%s", R_MVT(DESC(lw), ptdv, mvt_class)
                          [i*R_MVT(DESC(lw), ncols, mvt_class) + j] ? "true" : "false");
                else
                  printf(", %s",
                    R_MVT(DESC(lw), ptdv, mvt_class)[i*R_MVT(DESC(lw), ncols, mvt_class) + j]
                                  ? "true" : "false");
              }
              printf(">\n");
            }
          }
          break;
        case TY_REAL:
          rmvt = (double *)R_MVT(DESC(lw), ptdv, mvt_class);
          printf("%s\n", class);
          if (0 == R_MVT(DESC(lw), nrows, mvt_class) * R_MVT(DESC(lw), nrows, mvt_class))
            printf("<>\n");
          else
          {
            for(i = 0; i < R_MVT(DESC(lw), nrows, mvt_class); i++)
            {
              printf("<");
              if (0 < R_MVT(DESC(lw), ncols, mvt_class))
                printf("%.16g",
                  rmvt[i * R_MVT(DESC(lw), ncols, mvt_class)]);
              for(j = 1; j < R_MVT(DESC(lw), ncols, mvt_class); j++)
              {
                if (R_DESC(DESC(lw), class) == C_TVECTOR)
                  printf(",\n\t%.16g",
                    rmvt[i * R_MVT(DESC(lw), ncols, mvt_class) + j]);
                else
                  printf(", %.16g",
                    rmvt[i * R_MVT(DESC(lw), ncols, mvt_class) + j]);
              }
              printf(">\n");
            }
          }
          break;
        case TY_UNDEF:
          printf("nil%s", class);
        break;
        default:;
      }
    } 
    else if (R_DESC(DESC(lw),class) == C_LIST)  
    {
      if (R_DESC(DESC(lw), type) == TY_UNDEF)
      {
        if (0 != ((T_PTD)lw)->u.li.dim)
        {
          printf("< ");        
          for(i=0; i+1<((T_PTD)lw)->u.li.dim; i++)
          {
            lo(((T_PTD)lw)->u.li.ptdv[i]);
            printf(", ");
          }
          lo(((T_PTD)lw)->u.li.ptdv[i]);
          printf(" >");
        }
        else printf("<>");
      }
      else if(R_DESC(DESC(lw), type) == TY_STRING)
      {
        if (0 != ((T_PTD)lw)->u.li.dim)
        {
          printf("'");
          for(i=0; i < ((T_PTD)lw)->u.li.dim; i++)
            lo(((T_PTD)lw)->u.li.ptdv[i]);
          printf("`");
        }
        else printf("'`");
      }
      else
        printf("(lo) unknown C_LIST object %d\n",lw);
    }
    else if (R_DESC(DESC(lw), class) == C_CONSTANT)
    {
      if (R_DESC(DESC(lw),type) == TY_VAR)
      {
        lo((int)((T_PTD)lw)->u.va.ptnd);
      }
      else
        printf("(lo) unknown C_CONSTANT object %d\n",lw);
    }
    else if (R_DESC(DESC(lw), class) == C_EXPRESSION)
    {
      if (R_DESC(DESC(lw), type) == TY_NAME)
      {
        int dim;
        int *help;
        dim = (((T_PTD)lw)->u.na.ptn)[0];
        help = (int *)(((T_PTD)lw)->u.na.ptn);
        for (i = 1; i < dim; i++)
          printf("%c", (char)(GET_THAT_CHAR(help[i])));
        printf("%c", (char)(GET_THAT_CHAR(UNTAGLAST(help[dim]))));
      }
      else
        printf("(lo) unknown C_EXPRESSION object %d\n",lw);
    }
/* cr 09/03/95, kir(ff), START */
      else if (R_DESC(DESC(lw),class) == C_FRAME)
      {
        if (R_DESC(DESC(lw),type) == TY_FRAME)
        {
            if (0 != ((T_PTD)lw)->u.frame.dim)
            {
              printf("<: ");        
              for(i=0; i+1<((T_PTD)lw)->u.frame.dim; i++)
              {
                lo(((T_PTD)lw)->u.frame.slots[i]);
                printf(", ");
              }
              lo(((T_PTD)lw)->u.frame.slots[i]);
              printf(" :>");
            }
            else printf("<: :>");
        }
        else if (R_DESC(DESC(lw),type) == TY_SLOT)
        {
            lo((int)(((T_PTD)lw)->u.slot.name));
            printf(":: ");
            lo(((T_PTD)lw)->u.slot.value);
        }
        else
            printf("(lo) unknown C_FRAME object %d\n",lw);
      }
      else if (R_DESC(DESC(lw),class) == C_INTER)
        switch (R_DESC(DESC(lw),type))
        {
            case TY_PUT: printf("put{ ");
                         lo(((T_PTD)lw)->u.inter.args[0]);
                         printf(", ");
                         lo(((T_PTD)lw)->u.inter.args[1]);
                         printf(", ");
                         lo(((T_PTD)lw)->u.inter.args[2]);
                         printf("} ");
                         break;
            case TY_GET: printf("get{ ");
                         lo(((T_PTD)lw)->u.inter.args[0]);
                         printf(", ");
                         lo(((T_PTD)lw)->u.inter.args[1]);
                         printf("} ");
                         break;
            case TY_DONE: printf("done{ } ");
                         break;
            default:     printf("(lo) unknown C_INTER object %d\n",lw);
        }
/* cr 09/03/95, kir(ff), END */
         /* stt, 13.02.96 */
    else if ((R_DESC(DESC(lw),class) == C_INTACT) &&
             (R_DESC(DESC(lw),type) == TY_INTACT) )
    {
      PTR_HEAPELEM pth; /* pointer to heapelement */

      pth = (PTR_HEAPELEM) R_INTACT(DESC(lw),args);
      printf("%s( ", intact_tab[FUNC_INDEX(*pth++)].name);
      for(i = R_INTACT(DESC(lw),dim) - 1; i>0; i--)
      {
        lo(*pth++);
        if (i == 1)
          printf(" ) ");
        else
          printf(", ");
      }
    }
    else
      printf("(lo) unknown Pointer %d !\n",lw);
  }
  else if T_IAFUNC(lw)
    printf("%s ", intact_tab[FUNC_INDEX(lw)].name);
  else                                       
    printf("(lo) Something not a list, integer or real in result %d !\n",lw); 
}

/*************************************************************/

void t_output(int lw, int number_of_descs, PTR_DESCRIPTOR *funcdesctable, int number_of_data, int *data_table, int *ptc_table)
{
  struct timeval t0;
  double used_time;

  if (1 == AsciiOutput) lo(lw);
  if (1 == KiROutput)
  {
    tasm2kir = stdout;
    if (strcmp(ri_tasmoutfile, "__default"))
    if (NULL == (tasm2kir = fopen(ri_tasmoutfile, "w")))
    {
      fprintf(stderr, " Couldn't open %s !\n", ri_tasmoutfile);
      exit(1);
    }

    /* used time */
    gettimeofday (&t0, NULL);
    used_time = t0.tv_sec + t0.tv_usec/1000000.0 - start_time;
    fprintf(tasm2kir, "%f\n", used_time);
    /*************/

    st_number_of_descs = number_of_descs;  /* prepare for call to OutputOfTasm2KiR */
    st_number_of_data = number_of_data;    /* need to avoid global variables */
    st_data_table = data_table;            /* if we want to use modules */
    st_ptc_table = ptc_table;              /* but don't want to pass recursively */
    st_funcdesctable = funcdesctable;      /* thus we copy them to static */
                                           /* variables here */

    OutputOfTasm2KiR(lw);
    fclose(tasm2kir);
  }
}

int AreYouInfuncdesctable(const int me)
{
  int i;
  for (i = 0; i < st_number_of_descs; i++)
    if (me == (int)st_funcdesctable[i]) return(TRUE);
  return(FALSE);
}

int AreYouIndatatable(const int me)
{
  int i;
  for (i = 0; i < st_number_of_data; i++)
    if (me == (int)&st_data_table[i]) return(TRUE);
  return(FALSE);
}
/*******************************************************************************/
/* "unreadable" output to file tasm2kir to send result back to reduma          */
/*******************************************************************************/
void OutputOfTasm2KiR(int lw)
{
  int i, dim;
  int mvt_class;
  PTR_HEAPELEM pth;
  
  if (NULL == lw)
    controlled_exit("Unexpected ZERO on top of stack W");
  else if (T_INT(lw))
    fprintf(tasm2kir, " %d %d", ri_int, lw);
  else if (lw &0x2)
    fprintf(tasm2kir, " %d %d", ri_int, lw);
  else if (T_BOOLEAN(lw))
    fprintf(tasm2kir, " %d %d", ri_bool, lw);
  else if (T_CONSTANT(lw))
    fprintf(tasm2kir, " %d %d", ri_constant, lw);
  else if ((T_FUNC(lw) && (!AreYouInfuncdesctable(lw))) || T_IAFUNC(lw))
    fprintf(tasm2kir, " %d %d", ri_prim, lw);
  else if (T_STR_CHAR(lw))
    fprintf(tasm2kir, " %d %d", ri_char, lw);
  else if ((R_DESC(DESC(lw),class) == C_SCALAR) && (R_DESC(DESC(lw),type)==TY_REAL))
    fprintf(tasm2kir, " %d %.16g", ri_real, R_SCALAR(DESC(lw), valr));
  else if ((R_DESC(DESC(lw),class) == C_MATRIX) || (R_DESC(DESC(lw),class) == C_VECTOR) ||
                (R_DESC(DESC(lw),class) == C_TVECTOR))
  {
    mvt_class = R_DESC(DESC(lw), class);
    switch(mvt_class)
    {
      case C_MATRIX:
        fprintf(tasm2kir, " %d", ri_mat);
        break;
      case C_VECTOR:
        fprintf(tasm2kir, " %d", ri_vect);
        break;
      case C_TVECTOR:
        fprintf(tasm2kir, " %d", ri_tvect);
        break;
      default:;
    }
    switch(R_DESC(DESC(lw), type))
    {
      case TY_INTEGER:
        fprintf(tasm2kir, " %d", ri_int);
        break;
      case TY_BOOL:
        fprintf(tasm2kir, " %d", ri_bool);
        break;
      case TY_REAL:
        fprintf(tasm2kir, " %d", ri_real);
        break;
      case TY_UNDEF:
        fprintf(tasm2kir, " %d", ri_undef);
        break;
    }
    fprintf(tasm2kir, " %d", R_MVT(DESC(lw), nrows, mvt_class));
    fprintf(tasm2kir, " %d", R_MVT(DESC(lw), ncols, mvt_class));
    switch(R_DESC(DESC(lw), type))
    {
      case TY_UNDEF:
        break;
      case TY_INTEGER:
      case TY_BOOL:
        for(i = 0; 
          i < R_MVT(DESC(lw), nrows, mvt_class) * R_MVT(DESC(lw), ncols, mvt_class); i++)
          fprintf(tasm2kir, " %d", R_MVT(DESC(lw), ptdv, mvt_class)[i]);
        break;
      case TY_REAL:
      {
        double *rmvt;
        rmvt = (double *)R_MVT(DESC(lw), ptdv, mvt_class);
        for(i = 0; 
          i < R_MVT(DESC(lw), nrows, mvt_class) * R_MVT(DESC(lw), ncols, mvt_class); i++)
          fprintf(tasm2kir, " %.16g", rmvt[i]);
        break;
      }
    }
  }
  else if (C_CONSTANT == R_DESC(DESC(lw),class))
  {
    if (TY_VAR == R_DESC(DESC(lw), type))
    {
      fprintf(tasm2kir, " %d %d %d", ri_const, ri_var, R_VAR(DESC(lw), nlabar));
      OutputOfTasm2KiR((int)R_VAR(DESC(lw), ptnd));
    }
  }
  else if (C_LIST == R_DESC(DESC(lw),class))
  {
    if (TY_UNDEF == R_DESC(DESC(lw), type))
    {
      RED_INPUT hilfe;
      int isstr;
      dim = R_LIST(DESC(lw), dim);
      hilfe = ri_list;
#if 0
      if (0 < dim)
        if (T_POINTER(lw) || 
                       (T_FUNC(R_LIST(DESC(lw), ptdv)[0]) && (!AreYouIndatatable(lw))))
          isstr = R_LIST(DESC(lw), ptdv)[0];
          if (T_POINTER(isstr))
            if ((TY_STRING == R_DESC(DESC(isstr), type)) && R_LIST(DESC(isstr), dim))
              if (MAKE_CHAR('\137') == R_LIST(DESC(R_LIST(DESC(lw), ptdv)[0]), ptdv)[0])
                hilfe = ri_cons; /* it is a _ -> assuming a userdefined constructor */
#endif
      fprintf(tasm2kir, " %d %d", hilfe, dim);
      pth = R_LIST(DESC(lw), ptdv);
      for (i = 0; i < dim; i++) OutputOfTasm2KiR(pth[i]);
    }
    else if (TY_STRING == R_DESC(DESC(lw), type))
    {
      dim = R_LIST(DESC(lw), dim);
      fprintf(tasm2kir, " %d %d", ri_string, dim);
      pth = R_LIST(DESC(lw), ptdv);
      for (i = 0; i < dim; i++) 
        OutputOfTasm2KiR(pth[i]);
    }
  }
  else if (C_FRAME == R_DESC(DESC(lw),class)) /* cr 16.02.96 */
  {
    if (TY_FRAME == R_DESC(DESC(lw), type))
    {
      RED_INPUT hilfe;
      int isstr;
      dim = R_FRAME(DESC(lw), dim);
      hilfe = ri_frame;
      fprintf(tasm2kir, " %d %d", hilfe, dim);
      pth = R_FRAME(DESC(lw), slots);
      for (i = 0; i < dim; i++) OutputOfTasm2KiR(pth[i]);
    }
    else if (TY_SLOT == R_DESC(DESC(lw), type))
    {
      fprintf(tasm2kir, " %d", ri_slot);
      OutputOfTasm2KiR((T_HEAPELEM)R_SLOT(DESC(lw), name));
      OutputOfTasm2KiR(R_SLOT(DESC(lw), value));
    }
  }
  else if (C_EXPRESSION == R_DESC(DESC(lw), class))
  {
    if (TY_NAME == R_DESC(DESC(lw), type))
    {
      int j;
      fprintf(tasm2kir, " %d %d", ri_expr, ri_name);
      i = R_NAME(DESC(lw), ptn)[0];
      fprintf(tasm2kir, " %d", i);
      for (j = 1; j <= i; j++)
        fprintf(tasm2kir, " %d",R_NAME(DESC(lw), ptn)[j]);
    }
    else if (TY_EXPR == R_DESC(DESC(lw), type))
    {
      fprintf(tasm2kir, " %d %d %d %d", ri_expr, ri_expr, 
                                     R_EXPR(DESC(lw), pte)[0],
                                     R_EXPR(DESC(lw), pte)[1]);
      pth = (PTR_HEAPELEM)R_EXPR(DESC(lw), pte) + 2;
      for (i = 0; i < R_EXPR(DESC(lw), pte)[0] - 1; i++)
        OutputOfTasm2KiR(pth[i]);
    }
    if (TY_SUB == R_DESC(DESC(lw), type))
    {
      int arg1, arg2;

      pth = (PTR_HEAPELEM)R_EXPR(DESC(lw), pte);
      arg1 = (int)*pth++;
      arg2 = (int)*pth++;
      fprintf(tasm2kir," %d %d %d %d", ri_expr, ri_sub, arg1, arg2);
      for (i = 0; i < arg1 - 1; i++)
        OutputOfTasm2KiR(pth[i]);
    }

    else if (TY_NOMAT == R_DESC(DESC(lw), type))
    {
      fprintf(tasm2kir, " %d %d %d %d %d %d %d %d", ri_expr, ri_nomat,
                                        R_NOMAT(DESC(lw), act_nomat),
                                        R_NOMAT(DESC(lw), reason),
                                        (int)R_NOMAT(DESC(lw), ptsdes),
                                        R_NOMAT(DESC(lw), guard_body)[0], /* length */
                                        R_NOMAT(DESC(lw), guard_body)[1], /* guard */
                                        R_NOMAT(DESC(lw), guard_body)[2]); /* body */
      OutputOfTasm2KiR(R_NOMAT(DESC(lw), guard_body)[3]); /* arg from match */

    }
      
  }
  else if (C_FUNC == R_DESC(DESC(lw), class))
  {
    int arity; /* used args */
    int arg;   /* needed args */
    int nfv;   /* # free vars if withtilde */
    int graph_adr; /* where to find to @@-graph */
    if (TY_CASE == R_DESC(DESC(lw), type))
    {
      arity = R_COMB(DESC(lw), nargs);
      arg = R_COMB(DESC(lw), args);
      graph_adr = (int) R_COMB(DESC(lw), ptd);
      fprintf(tasm2kir, " %d %d %d %d %d", ri_case, arity, arg, graph_adr, GET_PTC(lw));
    }
    if (TY_COMB == R_DESC(DESC(lw), type))
    {
      arity = R_COMB(DESC(lw), nargs);
      arg = R_COMB(DESC(lw), args);
      graph_adr = (int) R_COMB(DESC(lw), ptd);
      if (AreYouInfuncdesctable(lw))
        fprintf(tasm2kir, " %d %d %d %d %d", ri_comb, arity, arg, graph_adr, GET_PTC(lw));
      else
      {  
        fprintf(tasm2kir, " %d %d %d", ri_dyncomb, arity, arg, graph_adr);
        OutputOfTasm2KiR(graph_adr);
      }
    }
    if (TY_CONDI == R_DESC(DESC(lw), type))
    {
      arity = R_CONDI(DESC(lw), nargs);
      arg = R_CONDI(DESC(lw), args);
      graph_adr = (int) R_CONDI(DESC(lw), ptd);
      fprintf(tasm2kir, " %d %d %d %d %d", ri_cond, arity, arg, graph_adr, GET_PTC(lw));
    }
    else if (TY_CLOS == R_DESC(DESC(lw), type))
    {
      if (TY_NOMATBODY == R_CLOS(DESC(lw), ftype))
      {
        int hilf;
        
        pth = R_CLOS(DESC(lw), pta);
        arity = R_CLOS(DESC(lw), args);
        arg = R_CLOS(DESC(lw), nargs);
        nfv = R_CLOS(DESC(lw), nfv);

        fprintf(tasm2kir, " %d %d %d %d %d", ri_clos, ri_nomat, arity, arg, nfv);
       
        hilf = nfv + arity;
        fprintf(tasm2kir, " %d %d", pth[0], pth[1]); /* ptr to SWITCH-expression, 
                                                        # of failed when */
        OutputOfTasm2KiR(pth[2]);   /* guard */
        OutputOfTasm2KiR(pth[3]);   /* match */
        pth += 4;
        while (hilf-- > 0)       /* first arity elems are bound vars, other nfvs */
          OutputOfTasm2KiR(*pth++);
      }
      else if ((TY_PRIM   == R_CLOS(DESC(lw), ftype)) ||
               (TY_INTACT == R_CLOS(DESC(lw), ftype)))
      {
        pth = R_CLOS(DESC(lw), pta);
        arity = R_CLOS(DESC(lw), args); 
        arg = R_CLOS(DESC(lw), nargs);
        fprintf(tasm2kir," %d %d %d %d %d", ri_clos,
                   ((TY_PRIM == R_CLOS(DESC(lw), ftype)) ? ri_prim : ri_intact),
                   *pth++, arity, arg);
        for (i = 0; i < arity; i++) OutputOfTasm2KiR(pth[i]);
      }
      else if (TY_COMB == R_CLOS(DESC(lw), ftype))
      {
        if (withtilde)
          nfv = R_CLOS(DESC(lw), nfv);
        else
          nfv = 0;
  
        arity = R_CLOS(DESC(lw), args);
        arg = R_CLOS(DESC(lw), nargs);
        fprintf(tasm2kir," %d %d %d %d %d", ri_clos, ri_comb, arity, arg, nfv);
        pth = R_CLOS(DESC(lw), pta);
        for (i = 0; i < arity + nfv + 1; i++) OutputOfTasm2KiR(pth[i]);
      }
      else if (TY_CASE == R_CLOS(DESC(lw), ftype))
      { 
        if (withtilde)
          nfv = R_CLOS(DESC(lw), nfv);
        else
          nfv = 0;

        arity = R_CLOS(DESC(lw), args);
        arg = R_CLOS(DESC(lw), nargs);
        fprintf(tasm2kir," %d %d %d %d %d", ri_clos, ri_case, arity, arg, nfv);
        pth = R_CLOS(DESC(lw), pta);
        for (i = 0; i < arity + nfv + 1; i++) OutputOfTasm2KiR(pth[i]);
      }

      else if (TY_CONDI == R_CLOS(DESC(lw), ftype))
      {
        if (withtilde)
          nfv = (R_CLOS(DESC(lw), nfv));
        else
          nfv = 0;
        arity = R_CLOS(DESC(lw), args);
        arg = R_CLOS(DESC(lw), nargs);
        fprintf(tasm2kir," %d %d %d %d %d", ri_clos, ri_cond, arity, arg, nfv);
        pth = R_CLOS(DESC(lw), pta);
        for (i = 0; i < arity + nfv + 1; i++) OutputOfTasm2KiR(pth[i]);
      }
    }
  } 
  else if ((C_INTACT == R_DESC(DESC(lw), class)) &&
           (TY_INTACT == R_DESC(DESC(lw), type)))
  {
    int dim;

    dim = R_INTACT(DESC(lw), dim);
    pth = R_INTACT(DESC(lw), args);
    fprintf(tasm2kir, " %d %d", ri_intact, dim);
    for (i = 0; i < dim; i++) OutputOfTasm2KiR(pth[i]);
  }
}


int controlled_exit(const char *s)
{
  FILE *error_out;
  int a, i;

  if (KiROutput)
  {
    error_out = fopen(ri_tasmoutfile, "w");
    fprintf(error_out, " %d %d", ri_string, strlen(s));
    for (i = 0; i < strlen(s); i++)
    {
      a = (int)s[i];
      fprintf(error_out, " %d %d", ri_char, MAKE_CHAR(a));
    }
    fclose(error_out);
  }
  else 
    fprintf(stderr, "%s\n", s);
  exit(0);
  return(1);
}

void trap_handler(void)
{
  controlled_exit("Division by zero");
}

static int matherr(struct exception *a)
{
#if (0==D_SLAVE)
  if (DOMAIN == a->type)
    return(controlled_exit("Error occured in function"));
  else
#endif /* D_SLAVE */
    return(controlled_exit("Unknown Error"));
#if (0==D_SLAVE)
  return(0);
#endif /* D_SLAVE */
}

void clearscreen(void)
{}
@


1.57
log
@bug fix
@
text
@d57 1
a57 1
extern int AsciiOutput, KiROutput, withtilde, number_of_descs, number_of_data;
a58 2
extern int data_table[];
extern int ptc_table[];
a59 1
extern PTR_DESCRIPTOR funcdesctable[];
d61 4
d382 1
a382 1
      for (i = 0; i < 2 * number_of_descs; i+=2)
d384 1
a384 1
        if (ptc_table[i] == (int)R_COMB(DESC(d), ptd))
d389 1
a389 1
      for (i = 0; i < 2 * number_of_descs; i+=2)
d391 1
a391 1
        if (ptc_table[i] == (int)R_CASE(DESC(d), ptd))
d396 1
a396 1
      for (i = 0; i < 2 * number_of_descs; i+=2)
d398 1
a398 1
        if (ptc_table[i] == (int)R_CONDI(DESC(d), ptd))
d403 1
a403 1
  DBUG_RETURN((int)ptc_table[i + 1]);
d686 1
a686 1
void t_output(int lw)
d708 7
d723 2
a724 2
  for (i = 0; i < number_of_descs; i++)
    if (me == (int)funcdesctable[i]) return(TRUE);
d731 2
a732 2
  for (i = 0; i < number_of_data; i++)
    if (me == (int)&data_table[i]) return(TRUE);
@


1.56
log
@function for new scalar if gcc is not used
@
text
@d185 1
a185 1
      pth[dim - i - 1] = peek(w,i); 
@


1.55
log
@bug fix
@
text
@d364 10
@


1.54
log
@bug fix
@
text
@d185 1
a185 1
      pth[dim - i] = peek(w,i); 
@


1.53
log
@some stt fix ;-)
first line of "tasm2kir": processing time (double)
@
text
@d185 1
a185 1
      pth[dim] = peek(w,i); 
@


1.52
log
@output of interaction closure
@
text
@d4 1
d63 1
d677 3
d690 7
d965 1
a965 1
        for (i = 0; i < arity - arg; i++) OutputOfTasm2KiR(pth[i]);
@


1.51
log
@Output of nonprintable characters.
@
text
@d944 2
a945 1
      else if (TY_PRIM == R_CLOS(DESC(lw), ftype))
d950 3
a952 1
        fprintf(tasm2kir," %d %d %d %d %d", ri_clos, ri_prim, *pth++, arity, arg);
@


1.50
log
@added ri_intact
@
text
@d414 7
a420 5
  else if (IS_CHAR(lw))
    printf("%c", (char)GET_THAT_CHAR(lw));
  else if (IS_VAR_CHAR(lw))
    printf("%c", (char)GET_THAT_CHAR(lw));
        
@


1.49
log
@added ri_frame,ri_slot
@
text
@d13 1
a13 1
/* data   : length output* (in case of ri_list,ri_frame)                      */
d48 1
a48 1
                ri_slot = 26
d722 1
a722 1
  else if (T_FUNC(lw) && (!AreYouInfuncdesctable(lw)))
d991 10
@


1.48
log
@bug fix in initdata_i_list
%f -> %.16g
@
text
@d13 1
a13 1
/* data   : length_of_list output* (in case of ri_list)                       */
d21 1
d32 2
d47 2
a48 1
                ri_name = 22, ri_constant = 23, ri_undef = 24
d820 19
@


1.47
log
@swapped parameters (name,value) in initdata_slot
@
text
@d179 1
a179 1
      pth[dim - i - 1] = peek(w,i); 
d418 1
a418 1
      printf("%f", R_SCALAR(DESC(lw),valr)) ; 
d514 1
a514 1
                printf("%f",
d519 1
a519 1
                  printf(",\n\t%f",
d522 1
a522 1
                  printf(", %f",
d723 1
a723 1
    fprintf(tasm2kir, " %d %f", ri_real, R_SCALAR(DESC(lw), valr));
d774 1
a774 1
          fprintf(tasm2kir, " %f", rmvt[i]);
@


1.46
log
@minor bugfix
@
text
@d323 2
a324 2
  L_SLOT((*_desc),name) = (PTR_DESCRIPTOR)(args[1]);
  L_SLOT((*_desc),value) = args[0];
@


1.45
log
@Interactions supported.
Bugfix CHAR-Macros, clearscreen-decl.
@
text
@a655 2
    else if T_IAFUNC(lw)
      printf("%s ", intact_tab[FUNC_INDEX(lw)].name);
d659 2
@


1.44
log
@ifdef -> if where necessary
@
text
@d56 1
d81 2
a82 2
#define IS_CHAR(x)    ((((x) & 0x0000000F) & 0x0000000c) && ((x) & 0x00000010))
#define IS_VAR_CHAR(x) ((((x) & 0x0000000F) & 0x0000000c) && ((x) & 0x00000020))
d329 20
d639 19
a1010 1
#if DBUG_OFF
a1012 1
#endif DBUG_OFF
@


1.43
log
@bug fix in handling of global free variables
@
text
@a0 1
#ifndef WITHTILDE
a1 1
#endif
d61 1
a61 1
#ifndef NO_STACK_REG
a84 1
#define ISLASTCHAR(x) ((x) & ~LASTCHAR)
d960 1
a960 1
#ifndef D_SLAVE
d966 1
a966 1
#ifndef D_SLAVE
d971 1
a971 1
#ifdef DBUG_OFF
@


1.42
log
@the output of free variables still needs some work...
@
text
@d97 3
a99 11
  MAKEDESC(_desc, 1, C_LIST, TY_UNDEF);
  DBUG_PRINT("INITDATA",("dim: %d",dim));
  L_LIST((*_desc), dim) = dim;
  L_LIST((*_desc), ptdd) = 0;
  GET_HEAP(dim, A_LIST((*_desc), ptdv));
  DBUG_PRINT("INITDATA",("Got heap"));
  RES_HEAP;
  DBUG_PRINT("INITDATA",("heap reserved"));
  pth = R_LIST(*_desc,ptdv);
  DBUG_PRINT("INITDATA",("pth initialized"));
  for (i = 0; i < dim; i++) 
d101 23
a123 10
    DBUG_PRINT("INITDATA",("pth[%d] will be copied next",i));
    pth[i] = args[i];
    DBUG_PRINT("INITDATA",("pth[%d] copied",i));
  }
  L_LIST((*_desc), ptdd) = NULL;
  DBUG_PRINT("INITDATA",("ptdd initialized"));
  L_LIST((*_desc), special) = NULL;
  DBUG_PRINT("INITDATA",("special initialized"));
  REL_HEAP;
  DBUG_PRINT("INITDATA",("heap released"));
d134 3
a136 11
  MAKEDESC(_desc, 1, C_LIST, TY_UNDEF);
  DBUG_PRINT("INITDATA",("dim: %d",dim));
  L_LIST((*_desc), dim) = dim;
  L_LIST((*_desc), ptdd) = 0;
  GET_HEAP(dim, A_LIST((*_desc), ptdv));
  DBUG_PRINT("INITDATA",("Got heap"));
  RES_HEAP;
  DBUG_PRINT("INITDATA",("heap reserved"));
  pth = R_LIST(*_desc,ptdv);
  DBUG_PRINT("INITDATA",("pth initialized"));
  for (i = 0; i < dim; i++) 
d138 23
a160 10
    DBUG_PRINT("INITDATA",("pth[%d] will be copied next",i));
    pth[i] = peek(w, dim - i - 1);
    DBUG_PRINT("INITDATA",("pth[%d] copied",i));
  }
  L_LIST((*_desc), ptdd) = NULL;
  DBUG_PRINT("INITDATA",("ptdd initialized"));
  L_LIST((*_desc), special) = NULL;
  DBUG_PRINT("INITDATA",("special initialized"));
  REL_HEAP;
  DBUG_PRINT("INITDATA",("heap released"));
d170 16
a185 11
  MAKEDESC(_desc, 1, C_LIST, TY_UNDEF);
  L_LIST((*_desc), dim) = dim;
  L_LIST((*_desc), ptdd) = 0;
  GET_HEAP(dim, A_LIST((*_desc), ptdv));
  RES_HEAP;
  pth = R_LIST(*_desc,ptdv);
  for (i = 0; i < dim; i++) 
    pth[dim - i - 1] = peek(w,i); 
  L_LIST((*_desc), ptdd) = NULL;
  L_LIST((*_desc), special) = NULL;
  REL_HEAP;
d195 16
a210 11
  MAKEDESC(_desc, 1, C_LIST, TY_STRING);
  L_LIST((*_desc), dim) = dim;
  L_LIST((*_desc), ptdd) = 0;
  GET_HEAP(dim, A_LIST((*_desc), ptdv));
  RES_HEAP;
  pth = R_LIST(*_desc,ptdv);
  for (i = 0; i < dim; i++)
    pth[i] = args[i];
  L_LIST((*_desc), ptdd) = NULL;
  L_LIST((*_desc), special) = NULL;
  REL_HEAP;
d229 1
a229 1
    pth[i] = args[i];
d248 1
a248 5
  MAKEDESC(_desc, 1, c, t);
  L_MVT(*_desc, ptdd, c) = NULL;
  L_MVT(*_desc, nrows, c) = rows;
  L_MVT(*_desc, ncols, c) = cols;
  if (TY_REAL == t)
d250 6
a255 8
    GET_HEAP(rows * cols * sizeof(double) / sizeof(T_HEAPELEM), A_MVT(*_desc, ptdv, c));
    RES_HEAP;
    new_rmvt = (double *)R_MVT(*_desc, ptdv, c);
    rmvt = (double *)mvt;
    for(i = 0; i < rows * cols; i++)
      new_rmvt[i] = (double)rmvt[i];
    L_MVT(*_desc, ptdv, c) = (PTR_HEAPELEM)new_rmvt;
    REL_HEAP;
d259 21
a279 3
    GET_HEAP(rows * cols, A_MVT((*_desc), ptdv, c));
    for(i = 0; i < rows * cols; i++)
      L_MVT(*_desc, ptdv, c)[i] = mvt[i];
d561 7
a567 4
        i = 1;
        while (ISLASTCHAR((((T_PTD)lw)->u.na.ptn)[i]))
          lo((((T_PTD)lw)->u.na.ptn)[i++]);
        lo(UNTAGLAST((((T_PTD)lw)->u.na.ptn)[i]));
d787 3
a789 4
      i = 0;
      while (ISLASTCHAR(R_NAME(DESC(lw), ptn)[i])) i++;
      fprintf(tasm2kir, " %d", i + 1);
      for (j = 0; j <= i; j++)
d973 5
@


1.41
log
@another initializing of lists due to distributing
@
text
@d203 1
a203 1
  GET_HEAP(dim, A_NAME((*_desc), ptn));
d206 2
a207 1
  for (i = 0; i < dim; i++)
d212 1
a212 1
  pth[dim - 1] = TAGLASTCHAR(pth[dim - 1]);
d529 1
a529 1
        i = 0;
@


1.40
log
@!D_SLAVE => no clearscreen
@
text
@d91 1
a91 1
int initdata_list (int dim, int *args)
d95 32
d130 1
d134 1
d136 1
d138 1
d140 5
a144 1
    pth[i] = args[i]; 
d146 1
d148 1
d150 1
d154 1
a154 1
int initdata_i_list (int dim, int *args)
d167 1
a167 1
    pth[dim - i - 1] = args[i]; 
a937 4
#if !D_SLAVE
void clearscreen(void)
{}
#endif
@


1.39
log
@*** empty log message ***
@
text
@d895 1
d898 1
@


1.38
log
@D_SLAVE inserted
@
text
@a894 1
#if DEBUG
a896 1
#endif
@


1.37
log
@*** empty log message ***
@
text
@d885 1
d889 1
d891 1
d893 1
d895 1
d898 1
@


1.36
log
@dummy function clearscreen to satisfy the linker
@
text
@d7 32
a38 32
/*******************************************************************************/
/*                                                                             */
/* Encoding of the Output sending back to reduma                               */
/*                                                                             */
/* output : tag data                                                           */
/*                                                                             */
/* with                                                                        */
/*                                                                             */
/* data   : length_of_list output* (in case of ri_list)                        */
/*        : tagged_integer | tagged_boolean  (in case of ri_int or ri_bool)    */
/*        : value_of_real (in case of ri_real)                                 */
/*        : arity arg graph_adr  (in case of ri_case, ri_comb or ri_cond)      */
/*        : act_nomat reason ptsdes guard_body[0] guard_body[1] guard_body[2]  */
/*          guard_body[3]                                                      */
/*        : arity arg (in case of ri_sub)                                      */
/*        : tag arity arg nfv (in case of closure) ...                         */
/*                                                                             */
/* act_nomat : integer                                                         */
/* reason    : integer                                                         */
/* arity     : integer                                                         */
/* arg       : integer                                                         */
/* graph_adr : integer                                                         */
/* guard_body[0] : integer                                                     */
/* guard_body[1] : output                                                      */
/* guard_body[2] : output                                                      */
/* guard_body[3] : output                                                      */
/*                                                                             */
/* tag    : ri_int | ri_real | ri_list | ri_func                               */
/*        | ri_mat | ri_vect | ri_tvect | ri_cons | ri_prim                    */
/*                                                                             */
/*                                                                             */
/*******************************************************************************/
@


1.35
log
@reduce2nf preparation
@
text
@d891 2
@


1.34
log
@db_prolog.h removed
@
text
@d57 1
d80 1
d264 30
d760 1
a760 1
      fprintf(tasm2kir, " %d %d %d %d", ri_case, arity, arg, graph_adr);
d768 1
a768 1
        fprintf(tasm2kir, " %d %d %d %d", ri_comb, arity, arg, graph_adr);
d780 1
a780 1
      fprintf(tasm2kir, " %d %d %d %d", ri_cond, arity, arg, graph_adr);
@


1.33
log
@access macros corrected
@
text
@a4 3
#ifdef DEBUG
#include "db_prolog.h"
#else
a5 1
#endif
@


1.32
log
@RES_HEAP <-> REL_HEAP corrected
@
text
@d276 1
d302 1
d304 2
d307 1
d309 2
d312 1
d314 3
a316 1
      switch (R_MVT(DESC(lw), type, C_MATRIX))
d320 1
a320 1
          if (0 == R_MVT(DESC(lw), nrows, C_MATRIX) * R_MVT(DESC(lw), nrows, C_MATRIX))
d327 2
a328 2
              cols = R_MVT(DESC(lw), nrows, C_MATRIX);
              rows = R_MVT(DESC(lw), ncols, C_MATRIX);
d332 2
a333 2
              rows = R_MVT(DESC(lw), nrows, C_MATRIX);
              cols = R_MVT(DESC(lw), ncols, C_MATRIX);
d338 1
a338 1
              if (0 < R_MVT(DESC(lw), ncols, C_MATRIX))
d340 1
a340 1
                  R_MVT(DESC(lw), ptdv, C_MATRIX)[i * R_MVT(DESC(lw), ncols, C_MATRIX)]);
d345 1
a345 1
                    R_MVT(DESC(lw), ptdv, C_MATRIX)[i*R_MVT(DESC(lw), ncols, C_MATRIX)+j]);
d348 1
a348 1
                    R_MVT(DESC(lw), ptdv, C_MATRIX)[i*R_MVT(DESC(lw), ncols, C_MATRIX)+j]);
d356 1
a356 1
          if (0 == R_MVT(DESC(lw), nrows, C_MATRIX) * R_MVT(DESC(lw), nrows, C_MATRIX))
d360 1
a360 1
            for(i = 0; i < R_MVT(DESC(lw), nrows, C_MATRIX); i++)
d363 1
a363 1
              if (0 < R_MVT(DESC(lw), ncols, C_MATRIX))
d365 1
a365 1
                  R_MVT(DESC(lw), ptdv, C_MATRIX)[i*R_MVT(DESC(lw), ncols, C_MATRIX)] 
d367 1
a367 1
              for(j = 1; j < R_MVT(DESC(lw), ncols, C_MATRIX); j++)
d370 2
a371 2
                  printf(",\n\t%s", R_MVT(DESC(lw), ptdv, C_MATRIX)
                          [i*R_MVT(DESC(lw), ncols, C_MATRIX) + j] ? "true" : "false");
d374 1
a374 1
                    R_MVT(DESC(lw), ptdv, C_MATRIX)[i*R_MVT(DESC(lw), ncols, C_MATRIX) + j]
d382 1
a382 1
          rmvt = (double *)R_MVT(DESC(lw), ptdv, C_MATRIX);
d384 1
a384 1
          if (0 == R_MVT(DESC(lw), nrows, C_MATRIX) * R_MVT(DESC(lw), nrows, C_MATRIX))
d388 1
a388 1
            for(i = 0; i < R_MVT(DESC(lw), nrows, C_MATRIX); i++)
d391 1
a391 1
              if (0 < R_MVT(DESC(lw), ncols, C_MATRIX))
d393 2
a394 2
                  rmvt[i * R_MVT(DESC(lw), ncols, C_MATRIX)]);
              for(j = 1; j < R_MVT(DESC(lw), ncols, C_MATRIX); j++)
d398 1
a398 1
                    rmvt[i * R_MVT(DESC(lw), ncols, C_MATRIX) + j]);
d401 1
a401 1
                    rmvt[i * R_MVT(DESC(lw), ncols, C_MATRIX) + j]);
d561 1
d583 2
a584 1
    switch(R_DESC(DESC(lw), class))
d612 2
a613 2
    fprintf(tasm2kir, " %d", R_MVT(DESC(lw), nrows, C_MATRIX));
    fprintf(tasm2kir, " %d", R_MVT(DESC(lw), ncols, C_MATRIX));
d621 2
a622 2
          i < R_MVT(DESC(lw), nrows, C_MATRIX) * R_MVT(DESC(lw), ncols, C_MATRIX); i++)
          fprintf(tasm2kir, " %d", R_MVT(DESC(lw), ptdv, C_MATRIX)[i]);
d627 1
a627 1
        rmvt = (double *)R_MVT(DESC(lw), ptdv, C_MATRIX);
d629 1
a629 1
          i < R_MVT(DESC(lw), nrows, C_MATRIX) * R_MVT(DESC(lw), ncols, C_MATRIX); i++)
@


1.31
log
@one more indirection in the descriptor table funcdesctable
which is now called stat_funcdesctable
funcdesctable is now an array of pointers to descriptors
@
text
@a189 1
  RES_HEAP;
d193 1
d199 1
a206 1
  REL_HEAP;
@


1.30
log
@includes now (db_)prolog.h
@
text
@d61 1
a61 1
extern T_DESCRIPTOR funcdesctable[];
d534 1
a534 1
    if (me == (int)&funcdesctable[i]) return(TRUE);
d821 1
a821 5
  fprintf(stderr, "controlled_exit reached with %s\n", s);
  sleep(3);
  error_out = fopen(ri_tasmoutfile, "w");
  fprintf(error_out, " %d %d", ri_string, strlen(s));
  for (i = 0; i < strlen(s); i++)
d823 8
a830 2
    a = (int)s[i];
    fprintf(error_out, " %d %d", ri_char, MAKE_CHAR(a));
d832 2
a833 1
  fclose(error_out);
@


1.29
log
@tvect output beautified
@
text
@d4 6
a9 9
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "dbug.h"
#include "rstdinc.h"
#include "rstelem.h"
#include "rheapty.h"
#include "rstackty.h"
#define MAKE_CHAR(x)  (((x) << 16) | 0x0000001c)
d54 1
a54 1
int newdesc(), post_mortem(), newheap(), controlled_exit();
d86 1
a86 1
#define GET_CHAR(x)   ((x) >> 16)
d288 1
a288 1
    printf("%c", (char)GET_CHAR(lw));
d290 1
a290 1
    printf("%c", (char)GET_CHAR(lw));
@


1.28
log
@empty mat, vect, tvect
@
text
@d191 2
a192 10
  if (C_TVECTOR  == c)
  {
    L_MVT(*_desc, nrows, c) = cols;
    L_MVT(*_desc, ncols, c) = rows;
  }
  else
  {
    L_MVT(*_desc, nrows, c) = rows;
    L_MVT(*_desc, ncols, c) = cols;
  }
d317 12
a328 1
            for(i = 0; i < R_MVT(DESC(lw), nrows, C_MATRIX); i++)
d334 1
a334 1
              for(j = 1; j < R_MVT(DESC(lw), ncols, C_MATRIX); j++)
d337 1
a337 1
                  printf(",\n\t%d", 
@


1.27
log
@output of mat, vect, tvect
@
text
@d53 1
a53 1
                ri_name = 22, ri_constant = 23,
d321 3
a323 1
          for(i = 0; i < R_MVT(DESC(lw), nrows, C_MATRIX); i++)
d325 1
a325 5
            printf("<");
            if (0 < R_MVT(DESC(lw), ncols, C_MATRIX))
              printf("%d", 
                R_MVT(DESC(lw), ptdv, C_MATRIX)[i * R_MVT(DESC(lw), ncols, C_MATRIX)]);
            for(j = 1; j < R_MVT(DESC(lw), ncols, C_MATRIX); j++)
d327 14
a340 6
              if (R_DESC(DESC(lw), class) == C_TVECTOR)
                printf(",\n\t%d", 
                  R_MVT(DESC(lw), ptdv, C_MATRIX)[i*R_MVT(DESC(lw), ncols, C_MATRIX) + j]);
              else
                printf(", %d", 
                  R_MVT(DESC(lw), ptdv, C_MATRIX)[i*R_MVT(DESC(lw), ncols, C_MATRIX) + j]);
a341 1
            printf(">\n");
d346 3
a348 1
          for(i = 0; i < R_MVT(DESC(lw), nrows, C_MATRIX); i++)
d350 1
a350 6
            printf("<");
            if (0 < R_MVT(DESC(lw), ncols, C_MATRIX))
              printf("%s", 
                R_MVT(DESC(lw), ptdv, C_MATRIX)[i*R_MVT(DESC(lw), ncols, C_MATRIX)] 
                ? "true" : "false");
            for(j = 1; j < R_MVT(DESC(lw), ncols, C_MATRIX); j++)
d352 16
a367 7
              if (R_DESC(DESC(lw), class) == C_TVECTOR)
                printf(",\n\t%s", R_MVT(DESC(lw), ptdv, C_MATRIX)
                        [i*R_MVT(DESC(lw), ncols, C_MATRIX) + j] ? "true" : "false");
              else
                printf(", %s",
                  R_MVT(DESC(lw), ptdv, C_MATRIX)[i*R_MVT(DESC(lw), ncols, C_MATRIX) + j]
                                ? "true" : "false");
a368 1
            printf(">\n");
d374 3
a376 1
          for(i = 0; i < R_MVT(DESC(lw), nrows, C_MATRIX); i++)
d378 1
a378 5
            printf("<");
            if (0 < R_MVT(DESC(lw), ncols, C_MATRIX))
              printf("%f",
                rmvt[i * R_MVT(DESC(lw), ncols, C_MATRIX)]);
            for(j = 1; j < R_MVT(DESC(lw), ncols, C_MATRIX); j++)
d380 14
a393 6
              if (R_DESC(DESC(lw), class) == C_TVECTOR)
                printf(",\n\t%f",
                  rmvt[i * R_MVT(DESC(lw), ncols, C_MATRIX) + j]);
              else
                printf(", %f",
                  rmvt[i * R_MVT(DESC(lw), ncols, C_MATRIX) + j]);
a394 1
            printf(">\n");
d397 3
d596 3
d604 2
@


1.26
log
@pointer to direct descriptor initialized
@
text
@d181 39
a219 1

d284 3
a286 1
int i;
d307 78
d551 49
@


1.25
log
@bug fix in userdef'd cons handling
@
text
@d104 1
d124 1
d144 1
d449 1
d458 1
@


1.24
log
@bug fix
@
text
@d451 1
a451 1
            if (TY_STRING == R_DESC(DESC(isstr), type))
@


1.23
log
@MAKE_CHAR changed
@
text
@d93 1
a93 1
#define MAKE_VAR_CHAR(x)  (((x) << 16) | 0x00009e2c)
d575 1
a575 1
        for (i = 0; i < arity; i++) OutputOfTasm2KiR(pth[i]);
d626 2
@


1.22
log
@initdata_i_list (makes inverse list)
@
text
@d12 1
a12 1
#define MAKE_CHAR(x)  (((x) << 16) | 0x0000ab1c)
d443 1
d449 5
a453 3
          if (TY_STRING == R_DESC(DESC(R_LIST(DESC(lw), ptdv)[0]), type))
            if (MAKE_CHAR('\137') == R_LIST(DESC(R_LIST(DESC(lw), ptdv)[0]), ptdv)[0])
             hilfe = ri_cons; 
@


1.21
log
@first try to retranslate userdefined constructors
@
text
@d115 19
@


1.20
log
@lo: bug fixed, error messages added.
@
text
@d12 1
d57 2
a58 2
int newdesc(), post_mortem(), newheap();
void lo(int), OutputOfTasm2KiR(int), controlled_exit();
d61 1
a61 1
extern int AsciiOutput, KiROutput, withtilde, number_of_descs;
d63 1
d379 8
d423 1
d425 8
a432 1
      fprintf(tasm2kir, " %d %d", ri_list, dim);
a597 1
#define MAKE_CHAR(x)  (((x) << 16) | 0x0000ab1c)
d599 1
a599 1
void controlled_exit(const char *s)
d613 1
d624 1
a624 1
    controlled_exit("Error occured in function");
d626 1
a626 1
    controlled_exit("Unknown Error");
@


1.19
log
@redundant code removed
@
text
@d271 2
d280 2
d285 1
a285 1
      if (R_DESC(DESC(lw), type) = TY_NAME)
d292 2
d319 2
d341 1
a341 1
            default:     printf("unknown interaction %d\n",lw);
d345 1
a345 1
      printf("unknown Pointer %d !\n",lw);
d348 1
a348 1
    printf("Something not a list, integer or real in result %d !\n",lw); 
@


1.18
log
@*** empty log message ***
@
text
@d440 12
a569 25
  else if (C_EXPRESSION == R_DESC(DESC(lw), class))
  {
    if (TY_EXPR == R_DESC(DESC(lw), type))
    {
      int arg1, arg2;
      
      pth = (PTR_HEAPELEM)R_EXPR(DESC(lw), pte);
      arg1 = (int)*pth++;
      arg2 = (int)*pth++;
      fprintf(tasm2kir," %d %d %d %d", ri_expr, ri_expr, arg1, arg2);
      for (i = 0; i < arg1 - 1; i++)
        OutputOfTasm2KiR(pth[i]);
    }
    if (TY_SUB == R_DESC(DESC(lw), type))
    {
      int arg1, arg2;
      
      pth = (PTR_HEAPELEM)R_EXPR(DESC(lw), pte);
      arg1 = (int)*pth++;
      arg2 = (int)*pth++;
      fprintf(tasm2kir," %d %d %d %d", ri_expr, ri_sub, arg1, arg2);
      for (i = 0; i < arg1 - 1; i++)
        OutputOfTasm2KiR(pth[i]);
    }
  }
@


1.17
log
@bug fixed in PM
@
text
@d170 1
a170 1
  pth = R_INTER(*_desc,args);
d172 1
a172 1
    pth[i] = args[i]; 
d200 2
a201 2
  L_SLOT((*_desc),name) = (PTR_DESCRIPTOR)(args[0]);
  L_SLOT((*_desc),value) = args[1];
d336 2
@


1.16
log
@corrected? order of args for initdata_{inter,slot}
@
text
@d51 2
a52 2
                ri_char = 18, ri_string = 19, ri_var = 20, ri_constant = 21,
                ri_name = 22
d170 1
a170 1
  pth = R_INTER(*_desc,args)+dim-1;
d172 1
a172 1
    pth[-i] = args[i]; 
d200 2
a201 2
  L_SLOT((*_desc),name) = (PTR_DESCRIPTOR)(args[1]);
  L_SLOT((*_desc),value) = args[0];
a334 2
      else
        printf("unknown Pointer %d !\n",lw);
d383 2
d395 1
a395 1
      fprintf(tasm2kir, " %d %d %d", ri_constant, ri_var, R_VAR(DESC(lw), nlabar));
@


1.15
log
@trap handler for controlled progam in case of math error installed
@
text
@d170 1
a170 1
  pth = R_INTER(*_desc,args);
d172 1
a172 1
    pth[i] = args[i]; 
d200 2
a201 2
  L_SLOT((*_desc),name) = (PTR_DESCRIPTOR)(args[0]);
  L_SLOT((*_desc),value) = args[1];
d335 2
@


1.14
log
@output of strings
@
text
@d6 1
d51 2
a52 1
                ri_char = 18, ri_string = 19
d57 1
a57 1
void lo(int), OutputOfTasm2KiR(int);
d65 1
d84 1
d86 1
d88 5
d132 25
d236 2
d243 2
a244 1
    if (R_DESC(DESC(lw),class) == C_LIST)  
a270 18
  }
/* cr 09/03/95, kir(ff), START */
  else if (R_DESC(DESC(lw),class) == C_FRAME)
  {
    if (R_DESC(DESC(lw),type) == TY_FRAME)
    {
        if (0 != ((T_PTD)lw)->u.frame.dim)
        {
          printf("<: ");        
          for(i=0; i+1<((T_PTD)lw)->u.frame.dim; i++)
          {
            lo(((T_PTD)lw)->u.frame.slots[i]);
            printf(", ");
          }
          lo(((T_PTD)lw)->u.frame.slots[i]);
          printf(" :>");
        }
        else printf("<: :>");
d272 1
a272 1
    else if (R_DESC(DESC(lw),type) == TY_SLOT)
d274 4
a277 3
        lo((int)(((T_PTD)lw)->u.slot.name));
        printf(":: ");
        lo(((T_PTD)lw)->u.slot.value);
d279 1
a279 3
  }
  else if (R_DESC(DESC(lw),class) == C_INTER)
    switch (R_DESC(DESC(lw),type))
d281 7
a287 17
        case TY_PUT: printf("put{ ");
                     lo(((T_PTD)lw)->u.inter.args[0]);
                     printf(", ");
                     lo(((T_PTD)lw)->u.inter.args[1]);
                     printf(", ");
                     lo(((T_PTD)lw)->u.inter.args[2]);
                     printf("} ");
                     break;
        case TY_GET: printf("get{ ");
                     lo(((T_PTD)lw)->u.inter.args[0]);
                     printf(", ");
                     lo(((T_PTD)lw)->u.inter.args[1]);
                     printf("} ");
                     break;
        case TY_DONE: printf("done{ } ");
                     break;
        default:     printf("unknown interaction %d\n",lw);
d289 46
d336 1
d374 4
a377 2

  if (T_INT(lw))
d389 8
d417 11
a427 1
    if (TY_EXPR == R_DESC(DESC(lw), type))
d581 22
d604 8
@


1.13
log
@warnings removed
@
text
@d49 2
a50 1
                ri_CAVE = 14, ri_nomat = 15, ri_sub = 16, ri_dyncomb = 17
d81 2
d103 21
d199 3
d207 16
a222 5
  {
    if (0 != ((T_PTD)lw)->u.li.dim)
    {
      printf("< ");        
      for(i=0; i+1<((T_PTD)lw)->u.li.dim; i++)
d224 8
a231 2
        lo(((T_PTD)lw)->u.li.ptdv[i]);
        printf(", ");
a232 4
      lo(((T_PTD)lw)->u.li.ptdv[i]);
      printf(" >");
    }
    else printf("<>");
a280 3

  }
  
d327 2
d333 15
a347 4
    dim = R_LIST(DESC(lw), dim);
    fprintf(tasm2kir, " %d %d", ri_list, dim);
    pth = R_LIST(DESC(lw), ptdv);
    for (i = 0; i < dim; i++) OutputOfTasm2KiR(pth[i]);
@


1.12
log
@added: initdata_inter,initdata_frame,initdata_slot
added TY_FRAME,TY_SLOT,TY_PUT,TY_GET,TY_DONE to lo
@
text
@d141 1
a141 1
  L_SLOT((*_desc),name) = args[0];
d214 1
a214 1
        lo(((T_PTD)lw)->u.slot.name);
@


1.11
log
@some insufficient PM output
@
text
@d100 47
d194 48
@


1.10
log
@pm implemented
@
text
@d16 1
a16 1
/* output : signal data                                                        */
d20 8
a27 3
/* data   : length_of_list output*                                             */
/*        : tagged_integer | tagged_boolean                                    */
/*        : value_of_real                                                      */
d29 11
a39 1
/* signal : ri_int | ri_real | ri_list | ri_func                               */
d48 2
a49 1
                ri_comb = 10, ri_cond = 11, ri_expr = 12, ri_case = 13
d67 4
d204 25
a234 1
  
d247 7
a253 1
      fprintf(tasm2kir, " %d %d %d %d", ri_comb, arity, arg, graph_adr);
d264 8
d273 12
a284 1
      if (TY_PRIM == R_CLOS(DESC(lw), ftype))
d342 12
a353 1
      fprintf(tasm2kir," %d %d %d", ri_expr, arg1, arg2);
@


1.9
log
@minor change in error message
@
text
@d33 1
a33 1
                ri_comb = 10, ri_cond = 11, ri_expr = 12
d47 1
d51 1
d191 7
d236 14
@


1.8
log
@prepared for retranslating of unreducible expressions like 'ap 5 to [7]
@
text
@d138 1
d142 1
a142 1
      fprintf(stderr, " Couldn't open djskfh !\n");
@


1.7
log
@will always be compiled with WITHTILDE defined
@
text
@d33 1
a33 1
                ri_comb = 10, ri_cond = 11
d166 2
d240 14
@


1.6
log
@prepared for separated modules
@
text
@d1 3
@


1.5
log
@output for reduma and screen
@
text
@a7 1
#include "mytypes.h"
d43 1
a43 1
#ifdef h__sparc__
@


1.4
log
@stack pointer in register (if sparc)
@
text
@d9 26
d36 1
d38 4
d44 1
a44 1
#ifdef __sparc__
d92 1
a92 1
int i,j;
d94 3
a96 3
if (T_INT(lw))  
  printf("%d",VAL_INT(lw));       
else if (T_BOOLEAN(lw))                           
d104 5
a108 7
else if (T_POINTER(lw)) 
{                        
  if ((R_DESC(DESC(lw),class)==C_SCALAR) && (R_DESC(DESC(lw),type)==TY_REAL))
    printf("%f", R_SCALAR(DESC(lw),valr)) ; 
  if (R_DESC(DESC(lw),class) == C_LIST)  
{
  if (0 != ((T_PTD)lw)->u.li.dim)
d110 1
a110 2
    printf("< ");        
    for(i=0; i+1<((T_PTD)lw)->u.li.dim; i++)
d112 6
d119 1
a119 1
      printf(", ");
d121 2
a122 2
    lo(((T_PTD)lw)->u.li.ptdv[i]);
    printf(" >");
d124 3
a126 1
  else printf("<>");
d128 17
d147 6
a152 2
else                                       
  printf("Something not a list, integer or real in result %d !\n",lw); 
d154 7
d162 38
d201 36
a236 1

@


1.3
log
@minor changes
@
text
@d9 1
d13 1
a13 1
#ifdef BLUBBER_BLUBB  /*__sparc__*/
d39 2
d53 49
@


1.2
log
@initializes reals and lists
@
text
@a23 2
PTR_HEAPELEM pth; /* pointer to heapelement */
T_PTD ptdesc;     /* pointer to descriptor */
d28 1
@


1.1
log
@Initial revision
@
text
@d27 1
a27 1
int initdata_list (int dim)
d29 2
a30 1
  int i, arg1;
a33 1
  L_LIST((*_desc), special) = LIST;        /* Edit-Feld */
d36 3
a38 2
  for (i = dim; --i >= 0;) 
    L_LIST(*_desc, ptdv)[i] = TAG_INT(R_MVT(DESC(arg1), ptdv,class1)[i]);
d40 1
a40 1
  return((int)_desc);
d45 2
d49 1
a49 1
  return((int)_desc);
@
