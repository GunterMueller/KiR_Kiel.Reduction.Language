head	1.14;
access;
symbols;
locks; strict;
comment	@ * @;


1.14
date	96.02.13.17.56.28;	author sf;	state Exp;
branches;
next	1.13;

1.13
date	96.02.13.16.36.56;	author sf;	state Exp;
branches;
next	1.12;

1.12
date	95.07.26.14.35.58;	author sf;	state Exp;
branches;
next	1.11;

1.11
date	95.07.12.13.52.52;	author sf;	state Exp;
branches;
next	1.10;

1.10
date	95.07.12.11.20.12;	author sf;	state Exp;
branches;
next	1.9;

1.9
date	95.07.11.16.31.15;	author sf;	state Exp;
branches;
next	1.8;

1.8
date	95.07.10.15.43.58;	author sf;	state Exp;
branches;
next	1.7;

1.7
date	95.07.10.15.08.45;	author sf;	state Exp;
branches;
next	1.6;

1.6
date	95.07.07.14.46.51;	author sf;	state Exp;
branches;
next	1.5;

1.5
date	95.07.06.11.36.22;	author sf;	state Exp;
branches;
next	1.4;

1.4
date	95.07.06.06.59.37;	author sf;	state Exp;
branches;
next	1.3;

1.3
date	95.06.29.09.17.54;	author sf;	state Exp;
branches;
next	1.2;

1.2
date	95.06.14.13.44.53;	author sf;	state Exp;
branches;
next	1.1;

1.1
date	95.06.14.12.00.48;	author sf;	state Exp;
branches;
next	;


desc
@@


1.14
log
@empty structures as a result will be delivered as _nil*
@
text
@#define WITHTILDE 1
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "dbug.h"
#include "rstdinc.h"
#include "rstelem.h"
#include "rheapty.h"
#include "rstackty.h"
extern PTR_DESCRIPTOR _desc; 
extern PTR_DESCRIPTOR _nil; 
extern PTR_DESCRIPTOR _nilstring;
extern PTR_DESCRIPTOR _nilmat;
extern PTR_DESCRIPTOR _nilvect;
extern PTR_DESCRIPTOR _niltvect;

int newdesc(), post_mortem(), newheap(), controlled_exit();

PTR_DESCRIPTOR mvt_desc;
PTR_HEAPELEM pth;
extern int AsciiOutput, KiROutput, withtilde, number_of_descs;
#define DESC(x)  (* (PTR_DESCRIPTOR) x)
/********************************************************************/
/* EQUAL ON                                                         */     
/* int_mat x int                                                    */     
/* real_mat x int                                                   */     
/* int_mat x real                                                   */     
/* real_mat x real                                                  */     
/* int x int_mat                                                    */     
/* int x real_mat                                                   */     
/* real x int_mat                                                   */     
/* real x real_mat                                                  */     
/* RESULT is always a bool_mat                                      */     
/********************************************************************/
T_PTD t_scal_mvt_equal(T_PTD a, T_PTD b)
{
  int rows, cols, i, class;
  register double *rmvt;
  DBUG_ENTER("t_compare");

  if (T_INT((STACKELEM)(STACKELEM)a))
  {
    class = R_DESC(DESC(b), class);
    rows = R_MVT(*b, nrows, class);
    cols = R_MVT(*b, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*b, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if (R_MVT(*b, ptdv, class)[i] == VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;   
      case TY_REAL:
        rmvt = (double *)R_MVT(*b, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] == (double)VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;   
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if ((C_SCALAR == R_DESC(*a, class)) && (TY_REAL == R_DESC(*a, type)))
  {
    class = R_DESC(DESC(b), class);
    rows = R_MVT(*b, nrows, class);
    cols = R_MVT(*b, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*b, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if ((double)(R_MVT(*b, ptdv, class)[i] == R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*b, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] == R_SCALAR(*a, valr))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if (T_INT((STACKELEM)b))
  {
    class = R_DESC(DESC(a), class);
    rows = R_MVT(*a, nrows, class);
    cols = R_MVT(*a, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*a, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if (R_MVT(*a, ptdv, class)[i] == VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*a, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] == (double)VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if ((C_SCALAR == R_DESC(*b, class)) && (TY_REAL == R_DESC(*b, type)))
  {
    class = R_DESC(DESC(a), class);
    rows = R_MVT(*a, nrows, class);
    cols = R_MVT(*a, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*a, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if ((double)(R_MVT(*a, ptdv, class)[i] == R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*a, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] == R_SCALAR(*b, valr))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  DBUG_RETURN(mvt_desc);
}


/********************************************************************/
/* NOT EQUAL ON                                                     */     
/* int_mat x int                                                    */     
/* real_mat x int                                                   */     
/* int_mat x real                                                   */     
/* real_mat x real                                                  */     
/* int x int_mat                                                    */     
/* int x real_mat                                                   */     
/* real x int_mat                                                   */     
/* real x real_mat                                                  */     
/* RESULT is always a bool_mat                                      */     
/********************************************************************/
T_PTD t_scal_mvt_nequal(T_PTD a, T_PTD b)
{
  int class;
  int rows, cols, i;
  register double *rmvt;
  DBUG_ENTER("t_compare");

  if (T_INT((STACKELEM)a))
  {
    class = R_DESC(DESC(b), class);
    rows = R_MVT(*b, nrows, class);
    cols = R_MVT(*b, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*b, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if (R_MVT(*b, ptdv, class)[i] != VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;   
      case TY_REAL:
        rmvt = (double *)R_MVT(*b, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] != (double)VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;   
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if ((C_SCALAR == R_DESC(*a, class)) && (TY_REAL == R_DESC(*a, type)))
  {
    class = R_DESC(DESC(b), class);
    rows = R_MVT(*b, nrows, class);
    cols = R_MVT(*b, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*b, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if ((double)(R_MVT(*b, ptdv, class)[i] != R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*b, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] != R_SCALAR(*a, valr))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if (T_INT((STACKELEM)b))
  {
    class = R_DESC(DESC(a), class);
    rows = R_MVT(*a, nrows, class);
    cols = R_MVT(*a, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*a, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if (R_MVT(*a, ptdv, class)[i] != VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*a, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] != (double)VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if ((C_SCALAR == R_DESC(*b, class)) && (TY_REAL == R_DESC(*b, type)))
  {
    class = R_DESC(DESC(a), class);
    rows = R_MVT(*a, nrows, class);
    cols = R_MVT(*a, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*a, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if ((double)(R_MVT(*a, ptdv, class)[i] != R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*a, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] != R_SCALAR(*b, valr))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  DBUG_RETURN(mvt_desc);
}


/********************************************************************/
/* LESS EQUAL ON                                                    */     
/* int_mat x int                                                    */     
/* real_mat x int                                                   */     
/* int_mat x real                                                   */     
/* real_mat x real                                                  */     
/* int x int_mat                                                    */     
/* int x real_mat                                                   */     
/* real x int_mat                                                   */     
/* real x real_mat                                                  */     
/* RESULT is always a bool_mat                                      */     
/********************************************************************/
T_PTD t_scal_mvt_lequal(T_PTD a, T_PTD b)
{
  int class;
  int rows, cols, i;
  register double *rmvt;
  DBUG_ENTER("t_compare");

  if (T_INT((STACKELEM)a))
  {
    class = R_DESC(DESC(b), class);
    rows = R_MVT(*b, nrows, class);
    cols = R_MVT(*b, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*b, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if (R_MVT(*b, ptdv, class)[i] >= VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;   
      case TY_REAL:
        rmvt = (double *)R_MVT(*b, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] >= (double)VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;   
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if ((C_SCALAR == R_DESC(*a, class)) && (TY_REAL == R_DESC(*a, type)))
  {
    class = R_DESC(DESC(b), class);
    rows = R_MVT(*b, nrows, class);
    cols = R_MVT(*b, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*b, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if ((double)(R_MVT(*b, ptdv, class)[i] >= R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*b, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] >= R_SCALAR(*a, valr))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if (T_INT((STACKELEM)b))
  {
    class = R_DESC(DESC(a), class);
    rows = R_MVT(*a, nrows, class);
    cols = R_MVT(*a, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*a, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if (R_MVT(*a, ptdv, class)[i] <= VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*a, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] <= (double)VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if ((C_SCALAR == R_DESC(*b, class)) && (TY_REAL == R_DESC(*b, type)))
  {
    class = R_DESC(DESC(a), class);
    rows = R_MVT(*a, nrows, class);
    cols = R_MVT(*a, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*a, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if ((double)(R_MVT(*a, ptdv, class)[i] >= R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*a, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] <= R_SCALAR(*b, valr))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  DBUG_RETURN(mvt_desc);
}

/********************************************************************/
/* GREATER EQUAL ON                                                 */     
/* int_mat x int                                                    */     
/* real_mat x int                                                   */     
/* int_mat x real                                                   */     
/* real_mat x real                                                  */     
/* int x int_mat                                                    */     
/* int x real_mat                                                   */     
/* real x int_mat                                                   */     
/* real x real_mat                                                  */     
/* RESULT is always a bool_mat                                      */     
/********************************************************************/
T_PTD t_scal_mvt_gequal(T_PTD a, T_PTD b)
{
  int class;
  int rows, cols, i;
  register double *rmvt;
  DBUG_ENTER("t_compare");

  if (T_INT((STACKELEM)a))
  {
    class = R_DESC(DESC(b), class);
    rows = R_MVT(*b, nrows, class);
    cols = R_MVT(*b, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*b, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if (R_MVT(*b, ptdv, class)[i] <= VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;   
      case TY_REAL:
        rmvt = (double *)R_MVT(*b, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] <= (double)VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;   
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if ((C_SCALAR == R_DESC(*a, class)) && (TY_REAL == R_DESC(*a, type)))
  {
    class = R_DESC(DESC(b), class);
    rows = R_MVT(*b, nrows, class);
    cols = R_MVT(*b, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*b, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if ((double)(R_MVT(*b, ptdv, class)[i] <= R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*b, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] <= R_SCALAR(*a, valr))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if (T_INT((STACKELEM)b))
  {
    class = R_DESC(DESC(a), class);
    rows = R_MVT(*a, nrows, class);
    cols = R_MVT(*a, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*a, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if (R_MVT(*a, ptdv, class)[i] >= VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*a, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] >= (double)VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if ((C_SCALAR == R_DESC(*b, class)) && (TY_REAL == R_DESC(*b, type)))
  {
    class = R_DESC(DESC(a), class);
    rows = R_MVT(*a, nrows, class);
    cols = R_MVT(*a, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*a, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if ((double)(R_MVT(*a, ptdv, class)[i] <= R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*a, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] >= R_SCALAR(*b, valr))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  DBUG_RETURN(mvt_desc);
}


/********************************************************************/
/* GREATER ON                                                       */     
/* int_mat x int                                                    */     
/* real_mat x int                                                   */     
/* int_mat x real                                                   */     
/* real_mat x real                                                  */     
/* int x int_mat                                                    */     
/* int x real_mat                                                   */     
/* real x int_mat                                                   */     
/* real x real_mat                                                  */     
/* RESULT is always a bool_mat                                      */     
/********************************************************************/
T_PTD t_scal_mvt_greater(T_PTD a, T_PTD b)
{
  int class;
  int rows, cols, i;
  register double *rmvt;
  DBUG_ENTER("t_compare");

  if (T_INT((STACKELEM)a))
  {
    class = R_DESC(DESC(b), class);
    rows = R_MVT(*b, nrows, class);
    cols = R_MVT(*b, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*b, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if (R_MVT(*b, ptdv, class)[i] < VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;   
      case TY_REAL:
        rmvt = (double *)R_MVT(*b, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] < (double)VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;   
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if ((C_SCALAR == R_DESC(*a, class)) && (TY_REAL == R_DESC(*a, type)))
  {
    class = R_DESC(DESC(b), class);
    rows = R_MVT(*b, nrows, class);
    cols = R_MVT(*b, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*b, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if ((double)(R_MVT(*b, ptdv, class)[i] < R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*b, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] < R_SCALAR(*a, valr))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if (T_INT((STACKELEM)b))
  {
    class = R_DESC(DESC(a), class);
    rows = R_MVT(*a, nrows, class);
    cols = R_MVT(*a, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*a, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if (R_MVT(*a, ptdv, class)[i] > VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*a, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] > (double)VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if ((C_SCALAR == R_DESC(*b, class)) && (TY_REAL == R_DESC(*b, type)))
  {
    class = R_DESC(DESC(a), class);
    rows = R_MVT(*a, nrows, class);
    cols = R_MVT(*a, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*a, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if ((double)(R_MVT(*a, ptdv, class)[i] < R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*a, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] > R_SCALAR(*b, valr))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  DBUG_RETURN(mvt_desc);
}

/********************************************************************/
/* LESS ON                                                          */     
/* int_mat x int                                                    */     
/* real_mat x int                                                   */     
/* int_mat x real                                                   */     
/* real_mat x real                                                  */     
/* int x int_mat                                                    */     
/* int x real_mat                                                   */     
/* real x int_mat                                                   */     
/* real x real_mat                                                  */     
/* RESULT is always a bool_mat                                      */     
/********************************************************************/
T_PTD t_scal_mvt_less(T_PTD a, T_PTD b)
{
  int class;
  int rows, cols, i;
  register double *rmvt;
  DBUG_ENTER("t_compare");

  if (T_INT((STACKELEM)a))
  {
    class = R_DESC(DESC(b), class);
    rows = R_MVT(*b, nrows, class);
    cols = R_MVT(*b, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*b, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if (R_MVT(*b, ptdv, class)[i] > VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;   
      case TY_REAL:
        rmvt = (double *)R_MVT(*b, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] > (double)VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;   
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if ((C_SCALAR == R_DESC(*a, class)) && (TY_REAL == R_DESC(*a, type)))
  {
    class = R_DESC(DESC(b), class);
    rows = R_MVT(*b, nrows, class);
    cols = R_MVT(*b, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*b, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if ((double)(R_MVT(*b, ptdv, class)[i] > R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*b, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] > R_SCALAR(*a, valr))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if (T_INT((STACKELEM)b))
  {
    class = R_DESC(DESC(a), class);
    rows = R_MVT(*a, nrows, class);
    cols = R_MVT(*a, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*a, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if (R_MVT(*a, ptdv, class)[i] < VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*a, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] < (double)VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  else if ((C_SCALAR == R_DESC(*b, class)) && (TY_REAL == R_DESC(*b, type)))
  {
    class = R_DESC(DESC(a), class);
    rows = R_MVT(*a, nrows, class);
    cols = R_MVT(*a, nrows, class);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, class), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, class) = NULL;
    L_MVT(*mvt_desc, nrows, class) = rows;
    L_MVT(*mvt_desc, ncols, class) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, class));
    switch(R_MVT(*a, type, class))
    {
      case TY_INTEGER:
        for (i = 0; i < rows * cols; i++)
        {
          if ((double)(R_MVT(*a, ptdv, class)[i] > R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      case TY_REAL:
        rmvt = (double *)R_MVT(*a, ptdv, class);
        for (i = 0; i < rows * cols; i++)
        {
          if (rmvt[i] < R_SCALAR(*b, valr))
            L_MVT(*mvt_desc, ptdv, class)[i] = TRUE;
          else
            L_MVT(*mvt_desc, ptdv, class)[i] = FALSE;
        }
        break;
      default:
        controlled_exit("t_equal: unknown type");
    }
  }
  DBUG_RETURN(mvt_desc);
}

/**************************/
/* MVT to LIST            */
/**************************/
T_PTD t_to_list(T_PTD a, int class, int type)
{
  int dim, rows, cols, i, j;
  PTR_DESCRIPTOR h_desc, r_desc;

  DBUG_ENTER("t_to_list");
  rows = R_MVT(DESC(a), nrows, class);  
  cols = R_MVT(DESC(a), ncols, class);  
  if (0 == cols * rows)
    mvt_desc = _nil;
  else
  {
    switch(class)
    {
      case C_VECTOR:
      case C_TVECTOR:
        dim = rows * cols;
        MAKEDESC(mvt_desc, 1, C_LIST, TY_UNDEF);
        L_LIST(*mvt_desc, ptdd) = NULL;
        L_LIST(*mvt_desc, special) = NULL;
        L_LIST(*mvt_desc, dim) = dim;
        GET_HEAP(dim, A_LIST(*mvt_desc, ptdv));
        RES_HEAP;
        pth = R_LIST(*mvt_desc,ptdv);
        RES_HEAP;
        switch(type)
        {
          case TY_INTEGER:
            for (i = 0; i < dim; i++)
              pth[i] = TAG_INT(R_MVT(DESC(a), ptdv, class)[i]);
            break;
          case TY_REAL:
            {
              double *rmvt, valr;
              rmvt = (double *)R_MVT(DESC(a), ptdv, class);
              for (i = 0; i < dim; i++)
              {
                MAKEDESC(h_desc, 1, C_SCALAR, TY_REAL);
                L_SCALAR(*h_desc, valr) = rmvt[i];
                pth[i] = (T_HEAPELEM)h_desc; 
              }
            }
            break;
          case TY_BOOL:
            for (i = 0; i < dim; i++)
              pth[i] = R_MVT(DESC(a), ptdv, class)[i] ? SA_TRUE : SA_FALSE;
            break;
          default: controlled_exit("unknown type in t_to_list");
        }
        REL_HEAP;
        break;
      case C_MATRIX:
        MAKEDESC(mvt_desc, 1, C_LIST, TY_UNDEF);
        L_LIST(*mvt_desc, ptdd) = NULL;
        L_LIST(*mvt_desc, special) = NULL;
        L_LIST(*mvt_desc, dim) = rows;
        GET_HEAP(rows, A_LIST(*mvt_desc, ptdv));
        switch(type)
        {
          case TY_INTEGER:
            for (i = 0; i < rows; i++)
            {
              MAKEDESC(h_desc, 1, C_LIST, TY_UNDEF);
              GET_HEAP(cols, A_LIST(*h_desc, ptdv));
              RES_HEAP;
              L_LIST(*mvt_desc, ptdv)[i] = (T_HEAPELEM)h_desc;
              L_LIST(*h_desc, ptdd) = NULL;
              L_LIST(*h_desc, special) = NULL;
              L_LIST(*h_desc, dim) = cols;
              pth = R_LIST(*h_desc, ptdv);
              for (j = 0; j < cols; j++)
                pth[j] = TAG_INT(R_MVT(DESC(a), ptdv, class)[i * cols + j]);
              REL_HEAP;
            }
            break;
          case TY_REAL:
            {
              double *rmvt, valr;
              for (i = 0; i < rows; i++)
              {
                MAKEDESC(h_desc, 1, C_LIST, TY_UNDEF);
                GET_HEAP(cols, A_LIST(*h_desc, ptdv));
                RES_HEAP;
                L_LIST(*mvt_desc, ptdv)[i] = (T_HEAPELEM)h_desc;
                L_LIST(*h_desc, ptdd) = NULL;
                L_LIST(*h_desc, special) = NULL;
                L_LIST(*h_desc, dim) = cols;
                pth = R_LIST(*h_desc, ptdv);
                rmvt = (double *)R_MVT(DESC(a), ptdv, class);
                REL_HEAP;
                for (j = 0; j < cols; j++)
                {
                  MAKEDESC(r_desc, 1, C_SCALAR, TY_REAL);
                  RES_HEAP;
                  L_SCALAR(*r_desc, valr) = rmvt[i * cols + j];
                  pth[j] = (T_HEAPELEM)r_desc; 
                  REL_HEAP;
                }
              }
            }
            break;
          case TY_BOOL:
            for (i = 0; i < rows; i++)
            {
              MAKEDESC(h_desc, 1, C_LIST, TY_UNDEF);
              GET_HEAP(cols, A_LIST(*h_desc, ptdv));
              RES_HEAP;
              L_LIST(*mvt_desc, ptdv)[i] = (T_HEAPELEM)h_desc;
              L_LIST(*h_desc, ptdd) = NULL;
              L_LIST(*h_desc, special) = NULL;
              L_LIST(*h_desc, dim) = cols;
              pth = R_LIST(*h_desc, ptdv);
              for (j = 0; j < cols; j++)
                pth[j] = R_MVT(DESC(a), ptdv, class)[i * cols + j] ? SA_TRUE : SA_FALSE;
              REL_HEAP;
            }
            break;
          default: controlled_exit("unknown type in t_to_list");
        }
        break;
    }
  }
  DBUG_RETURN(mvt_desc);
}


T_PTD t_vvcut(int a, T_PTD b, int class, int type)
{
  int dim, i, pos; 
  register int *ip, *ipnew;
  register double *rp, *rpnew;

  DBUG_ENTER("t_vvcut");
  dim = R_MVT(DESC(b), ncols, class);

  if (a >= 0) {                                        /* cutfirst       */
    dim -=a;
    pos  = a;
  }
  else {                                                 /* cutlast        */
    dim += a;
    pos  = 0;
  }
  if (dim < 0)
    controlled_exit("vcut: vect to short");
  if (0 == dim)
  {
    INC_REFCNT(_nilvect);
    DBUG_RETURN(_nilvect);
  }
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT((*mvt_desc), ptdd, class) = NULL;
  L_MVT((*mvt_desc), nrows, class) = 1;
  L_MVT((*mvt_desc), ncols, class) = dim;
  switch(type)
  {
    case TY_INTEGER:
    case TY_BOOL:
      GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, class));
      RES_HEAP;
      ip = (int *) R_MVT(DESC(b), ptdv, class);
      ipnew = (int *) R_MVT(*mvt_desc, ptdv, class);
      for (i = 0; i < dim; i++, pos++)
        ipnew[i] = ip[pos];
      REL_HEAP;
      break;
    case TY_REAL:
      GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, class));
      RES_HEAP;
      rp = (double *) R_MVT(DESC(b), ptdv, class);
      rpnew = (double *) R_MVT(*mvt_desc, ptdv, class);
      for (i = 0; i < dim; i++, pos++)
        rpnew[i] = rp[pos];
      REL_HEAP;
      break;
  }
  DBUG_RETURN(mvt_desc);
}


T_PTD t_tvcut(int a, T_PTD b, int class, int type)
{
  int dim, i, pos; 
  register int *ip, *ipnew;
  register double *rp, *rpnew;

  DBUG_ENTER("t_tvcut");
  dim = R_MVT(DESC(b), nrows, class);

  if (a >= 0) {                                        /* cutfirst       */
    dim -=a;
    pos  = a;
  }
  else {                                                 /* cutlast        */
    dim += a;
    pos  = 0;
  }
  if (dim < 0)
    controlled_exit("vcut: tvect to short");
  if (0 == dim)
  {
    INC_REFCNT(_niltvect);
    DBUG_RETURN(_niltvect);
  }
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT((*mvt_desc), ptdd, class) = NULL;
  L_MVT((*mvt_desc), ncols, class) = 1;
  L_MVT((*mvt_desc), nrows, class) = dim;
  switch(type)
  {
    case TY_INTEGER:
    case TY_BOOL:
      GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, class));
      RES_HEAP;
      ip = (int *) R_MVT(DESC(b), ptdv, class);
      ipnew = (int *) R_MVT(*mvt_desc, ptdv, class);
      for (i = 0; i < dim; i++, pos++)
        ipnew[i] = ip[pos];
      REL_HEAP;
      break;
    case TY_REAL:
      GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, class));
      RES_HEAP;
      rp = (double *) R_MVT(DESC(b), ptdv, class);
      rpnew = (double *) R_MVT(*mvt_desc, ptdv, class);
      for (i = 0; i < dim; i++, pos++)
        rpnew[i] = rp[pos];
      REL_HEAP;
      break;
  }
  DBUG_RETURN(mvt_desc);
}


T_PTD t_vselect(int a, T_PTD b, int class, int type)
{
  int h;
  DBUG_ENTER("t_vselect");
  
  if ((a < 1) || (a >= R_MVT(DESC(b), nrows, class) * R_MVT(DESC(b), ncols, class)))
    controlled_exit("vselect: (t)vect too short or index <= 0");
  switch(type)
  {
    case TY_INTEGER:
      DBUG_RETURN((T_PTD)TAG_INT(R_MVT(DESC(b), ptdv, class)[a - 1]));
      break;
    case TY_BOOL:
      h = R_MVT(DESC(b), ptdv, class)[a - 1];
      h = h ? SA_TRUE : SA_FALSE;
      DBUG_RETURN((T_PTD)h);
      break;
  }    
  DBUG_RETURN((T_PTD)0);
}


T_PTD t_vrselect(int a, T_PTD b, int class, int type)
{
  int h;
  register double *rmvt;
  DBUG_ENTER("t_vrselect");
  
  if ((a < 1) || (a >= R_MVT(DESC(b), nrows, class) * R_MVT(DESC(b), ncols, class)))
    controlled_exit("vselect: (t)vect too short or index <= 0");
  rmvt = (double *) R_MVT(DESC(b), ptdv, class);
  MAKEDESC(mvt_desc, 1, C_SCALAR, TY_REAL);
  L_SCALAR(*mvt_desc, valr) = rmvt[a - 1];
  DBUG_RETURN(mvt_desc);
}


T_PTD t_vvrotate(int a, T_PTD b, int class, int type)
{
  int dim = R_MVT(DESC(b), ncols, class);
  register int *ipnew, *ip, pos, elem, i;
  register double *rpnew, *rp;
  
  DBUG_ENTER("t_vvrotate");
  if (0 == dim)
  {
    INC_REFCNT(b);
    DBUG_RETURN((b));
  } 
  a = -a;
  if (0 == (a = a % dim))
  {
    INC_REFCNT(_nilvect);
    DBUG_RETURN((_nilvect));
  }
  else if (a < 1) a += dim;
  
  pos = R_MVT(DESC(b),ncols,class);
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, ncols, class) = dim;
  L_MVT(*mvt_desc, nrows, class) = 1;
  switch(type)
  {
    case TY_INTEGER:
    case TY_BOOL:
      GET_HEAP(dim, A_MVT((*mvt_desc), ptdv, class));
      RES_HEAP;
      ipnew = (int *) R_MVT((*mvt_desc),ptdv,class);
      ip= (int *) R_MVT(DESC(b),ptdv,class);
      for (i = 0; i < pos; i++)
      {
        ipnew[a] = ip[i];
        a++;
        if (a == pos)
          a = 0;
      }
      REL_HEAP;
      break;
    case TY_REAL:
      GET_HEAP(dim * sizeof(double), A_MVT((*mvt_desc), ptdv, class));
      RES_HEAP;
      rpnew = (double *) R_MVT((*mvt_desc),ptdv,class);
      rp= (double *) R_MVT(DESC(b),ptdv,class);
      for (i = 0; i < pos; i++)
      {
        rpnew[a] = rp[i];
        a++;
        if (a == pos)
          a = 0;
      }
      REL_HEAP;
      break;
  }
  DBUG_RETURN(mvt_desc);
}


T_PTD t_tvrotate(int a, T_PTD b, int class, int type)
{
  int dim = R_MVT(DESC(b), nrows, class);
  register int *ipnew, *ip, pos, elem, i;
  double *rpnew, *rp;
  
  DBUG_ENTER("t_tvrotate");
  if (0 == dim)
  {
    INC_REFCNT(_niltvect);
    DBUG_RETURN((_niltvect));
  } 
  a = -a;
  if (0 == (a = a % dim))
  {
    INC_REFCNT(b);
    DBUG_RETURN((b));
  }
  else if (a < 1) a += dim;
  
  pos = R_MVT(DESC(b),nrows,class);
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = dim;
  L_MVT(*mvt_desc, ncols, class) = 1;
  switch(type)
  {
    case TY_INTEGER:
    case TY_BOOL:
      GET_HEAP(dim, A_MVT((*mvt_desc), ptdv, class));
      RES_HEAP;
      ipnew = (int *) R_MVT((*mvt_desc),ptdv,class);
      ip= (int *) R_MVT(DESC(b),ptdv,class);
      for (i = 0; i < pos; i++)
      {
        ipnew[a] = ip[i];
        a++;
        if (a == pos)
          a = 0;
      }
      REL_HEAP;
      break;
    case TY_REAL:
      GET_HEAP(dim * sizeof(double), A_MVT((*mvt_desc), ptdv, class));
      RES_HEAP;
      rpnew = (double *) R_MVT((*mvt_desc),ptdv,class);
      rp= (double *) R_MVT(DESC(b),ptdv,class);
      for (i = 0; i < pos; i++)
      {
        rpnew[a] = rp[i];
        a++;
        if (a == pos)
          a = 0;
      }
      REL_HEAP;
      break;
  }
  DBUG_RETURN(mvt_desc);
}

T_PTD t_vv_unite_empty(T_PTD a)
{
  DBUG_ENTER("t_vv_unite_empty");
  INC_REFCNT(a);
  DBUG_RETURN(a);
}

T_PTD t_vv_unite(T_PTD a, T_PTD b, int class, int type)
{
  int dim, dima, dimb, i;
  DBUG_ENTER("t_vv_unite");
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  switch(class)
  {
    case C_VECTOR:
      dima = R_MVT(DESC(a), ncols, class);
      dimb = R_MVT(DESC(b), ncols, class);
      dim = dima + dimb;
      L_MVT(*mvt_desc, nrows, class) = 1;
      L_MVT(*mvt_desc, ncols, class) = dim;
      break;
    case C_TVECTOR:
      dima = R_MVT(DESC(a), nrows, class);
      dimb = R_MVT(DESC(b), nrows, class);
      dim = dima + dimb;
      L_MVT(*mvt_desc, ncols, class) = 1;
      L_MVT(*mvt_desc, nrows, class) = dim;
      break;
  }   
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, class));
  RES_HEAP;
  for (i = 0; i < dima; i++)
    L_MVT(*mvt_desc, ptdv, class)[i] = R_MVT(DESC(a), ptdv, class)[i];
  for (i = 0; i < dimb; i++)
    L_MVT(*mvt_desc, ptdv, class)[i + dima] = R_MVT(DESC(b), ptdv, class)[i];
  REL_HEAP;
  if (0 == dim)
  {
    if (C_TVECTOR == class)
    {
      INC_REFCNT(_niltvect);
      mvt_desc = _niltvect;
    }
    else
    {
      INC_REFCNT(_nilvect);
      mvt_desc = _nilvect;
    }
  }
  DBUG_RETURN(mvt_desc);
}
 
T_PTD t_vv_unite_rr(T_PTD a, T_PTD b, int class, int type)
{
  int dim, dima, dimb, i;
  register double *armvt, *brmvt, *resrmvt;
  DBUG_ENTER("t_vv_unite_rr");
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  switch(class)
  {
    case C_VECTOR:
      dima = R_MVT(DESC(a), ncols, class);
      dimb = R_MVT(DESC(b), ncols, class);
      dim = dima + dimb;
      L_MVT(*mvt_desc, nrows, class) = 1;
      L_MVT(*mvt_desc, ncols, class) = dim;
      break;
    case C_TVECTOR:
      dima = R_MVT(DESC(a), nrows, class);
      dimb = R_MVT(DESC(b), nrows, class);
      dim = dima + dimb;
      L_MVT(*mvt_desc, ncols, class) = 1;
      L_MVT(*mvt_desc, nrows, class) = dim;
      break;
  }   
  GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, class));
  resrmvt = (double *)R_MVT(*mvt_desc, ptdv, class);  
  armvt = (double *)R_MVT(DESC(a), ptdv, class);
  brmvt = (double *)R_MVT(DESC(b), ptdv, class);
  RES_HEAP;
  for (i = 0; i < dima; i++)
    resrmvt[i] = armvt[i];
  for (i = 0; i < dimb; i++)
    resrmvt[i + dima] = brmvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_vv_unite_ri(T_PTD a, T_PTD b, int class, int type)
{
  int dim, dima, dimb, i, *bimvt;
  register double *armvt, *resrmvt;
  DBUG_ENTER("t_vv_unite_ri");
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  switch(class)
  {
    case C_VECTOR:
      dima = R_MVT(DESC(a), ncols, class);
      dimb = R_MVT(DESC(b), ncols, class);
      dim = dima + dimb;
      L_MVT(*mvt_desc, nrows, class) = 1;
      L_MVT(*mvt_desc, ncols, class) = dim;
      break;
    case C_TVECTOR:
      dima = R_MVT(DESC(a), nrows, class);
      dimb = R_MVT(DESC(b), nrows, class);
      dim = dima + dimb;
      L_MVT(*mvt_desc, ncols, class) = 1;
      L_MVT(*mvt_desc, nrows, class) = dim;
      break;
  }   
  GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, class));
  resrmvt = (double *)R_MVT(*mvt_desc, ptdv, class);  
  armvt = (double *)R_MVT(DESC(a), ptdv, class);
  bimvt = (int *)R_MVT(DESC(b), ptdv, class);
  RES_HEAP;
  for (i = 0; i < dima; i++)
    resrmvt[i] = armvt[i];
  for (i = 0; i < dimb; i++)
    resrmvt[i + dima] = (double)bimvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}



T_PTD t_vv_unite_ir(T_PTD a, T_PTD b, int class, int type)
{
  int dim, dima, dimb, i, *aimvt;
  register double *brmvt, *resrmvt;
  DBUG_ENTER("t_vv_unite_ri");
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  switch(class)
  {
    case C_VECTOR:
      dima = R_MVT(DESC(a), ncols, class);
      dimb = R_MVT(DESC(b), ncols, class);
      dim = dima + dimb;
      L_MVT(*mvt_desc, nrows, class) = 1;
      L_MVT(*mvt_desc, ncols, class) = dim;
      break;
    case C_TVECTOR:
      dima = R_MVT(DESC(a), nrows, class);
      dimb = R_MVT(DESC(b), nrows, class);
      dim = dima + dimb;
      L_MVT(*mvt_desc, ncols, class) = 1;
      L_MVT(*mvt_desc, nrows, class) = dim;
      break;
  }   
  GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, class));
  resrmvt = (double *)R_MVT(*mvt_desc, ptdv, class);  
  brmvt = (double *)R_MVT(DESC(b), ptdv, class);
  aimvt = (int *)R_MVT(DESC(a), ptdv, class);
  RES_HEAP;
  for (i = 0; i < dima; i++)
    resrmvt[i] = (double)aimvt[i];
  for (i = 0; i < dimb; i++)
    resrmvt[i + dima] = brmvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_v_replace(int a, int b, T_PTD c, int class, int type)
{
  register int dim, i, *imvt;
  DBUG_ENTER("t_v_replace");
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  switch(class)
  {
    case C_VECTOR:
      dim = R_MVT(DESC(c), ncols, class);
      L_MVT(*mvt_desc, nrows, class) = 1;
      L_MVT(*mvt_desc, ncols, class) = dim;
      break;
    case C_TVECTOR:
      dim = R_MVT(DESC(c), nrows, class);
      L_MVT(*mvt_desc, ncols, class) = 1;
      L_MVT(*mvt_desc, nrows, class) = dim;
      break;
  }   
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, class));
  imvt = (int *)R_MVT(*mvt_desc, ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = R_MVT(DESC(c), ptdv, class)[i];
  if (TY_BOOL == type)
    imvt[a] = (b == SA_FALSE ? FALSE : TRUE);
  else
    imvt[a] = b;
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}

T_PTD t_vr_replace(int a, double b, T_PTD c, int class, int type)
{
  int dim, i;
  register double *rmvt, *crmvt;
  
  DBUG_ENTER("t_vr_replace");
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  switch(class)
  {
    case C_VECTOR:
      dim = R_MVT(DESC(c), ncols, class);
      L_MVT(*mvt_desc, nrows, class) = 1;
      L_MVT(*mvt_desc, ncols, class) = dim;
      break;
    case C_TVECTOR:
      dim = R_MVT(DESC(c), nrows, class);
      L_MVT(*mvt_desc, ncols, class) = 1;
      L_MVT(*mvt_desc, nrows, class) = dim;
      break;
  }   
  GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, class));
  rmvt = (double *)R_MVT(*mvt_desc, ptdv, class);
  crmvt = (double *)R_MVT(DESC(c), ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    rmvt[i] = crmvt[i];
  rmvt[a] = b;
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}

T_PTD t_mcut(int r, int c, T_PTD p, int type)
{
  int rows, cols, i, pos, nrows, ncols;
  register int *imvt, *amvt;

  DBUG_ENTER("t_mcut");
  rows = R_MVT(DESC(p), nrows, C_MATRIX);
  cols = R_MVT(DESC(p), ncols, C_MATRIX);
  nrows = rows - abs(r);
  ncols = cols - abs(c);
  if ((nrows == 0) || (ncols == 0))
  {
    INC_REFCNT(_nilmat);
    DBUG_RETURN(_nilmat);
  }
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
  L_MVT(*mvt_desc, nrows, C_MATRIX) = nrows;
  L_MVT(*mvt_desc, ncols, C_MATRIX) = ncols;
  GET_HEAP(nrows * ncols, A_MVT(*mvt_desc, ptdv, C_MATRIX));
  amvt = (int *)R_MVT(DESC(p), ptdv, C_MATRIX);
  if ((r >= 0) && (c >= 0))
  {
    if ((r > rows) || (c > cols))
      controlled_exit("dimensions don't fit in mcut");
    amvt += cols * r;
    imvt = (int *)R_MVT(*mvt_desc, ptdv, C_MATRIX); 
    RES_HEAP;
    pos = 0;
    for (i = 0; i < nrows * cols; i++)
    {
      if (i % cols >= c) 
      {
        imvt[pos] = amvt[i];
        pos++;
      }
    }
    REL_HEAP;
  }
  else if ((r >= 0) && (c < 0))
  {
    if ((r > rows) || (-c > cols))
      controlled_exit("dimensions don't fit in mcut");
    amvt += cols * r;
    imvt = (int *)R_MVT(*mvt_desc, ptdv, C_MATRIX); 
    RES_HEAP;
    pos = 0;
    c = cols + c;
    for (i = 0; i < nrows * cols; i++)
    {
      if (i % cols < c) 
      {
        imvt[pos] = amvt[i];
        pos++;
      }
    }
    REL_HEAP;
  }
  else if ((r < 0) && (c >= 0))
  {
    if ((-r > rows) || (c > cols))
      controlled_exit("dimensions don't fit in mcut");
    imvt = (int *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    RES_HEAP;
    pos = 0;
    for (i = 0; i < nrows * cols; i++)
    {
      if (i % cols >= c)        
      {
        imvt[pos] = amvt[i];
        pos++;
      }
    }
    REL_HEAP;
  }
  else        /* ((r < 0) && (c < 0)) */
  {
    if ((-r > rows) || (-c > cols))
      controlled_exit("dimensions don't fit in mcut");
    imvt = (int *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    RES_HEAP;
    pos = 0;
    c = cols + c;
    for (i = 0; i < nrows * cols; i++)
    {
      if (i % cols < c)        
      {
        imvt[pos] = amvt[i];
        pos++;
      }
    }
    REL_HEAP;
  }
  DBUG_RETURN(mvt_desc);
}



T_PTD t_mcutr(int r, int c, T_PTD p, int type)
{
  int rows, cols, i, pos, nrows, ncols;
  register double *imvt, *amvt;

  DBUG_ENTER("t_mcutr");
  rows = R_MVT(DESC(p), nrows, C_MATRIX);
  cols = R_MVT(DESC(p), ncols, C_MATRIX);
  nrows = rows - abs(r);
  ncols = cols - abs(c);
  if ((nrows == 0) || (ncols == 0))
  {
    INC_REFCNT(_nilmat);
    DBUG_RETURN(_nilmat);
  }
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
  L_MVT(*mvt_desc, nrows, C_MATRIX) = nrows;
  L_MVT(*mvt_desc, ncols, C_MATRIX) = ncols;
  GET_HEAP(nrows * ncols * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
  amvt = (double *)R_MVT(DESC(p), ptdv, C_MATRIX);
  if ((r >= 0) && (c >= 0))
  {
    if ((r > rows) || (c > cols))
      controlled_exit("dimensions don't fit in mcut");
    amvt += cols * r;
    imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX); 
    RES_HEAP;
    pos = 0;
    for (i = 0; i < nrows * cols; i++)
    {
      if (i % cols >= c) 
      {
        imvt[pos] = amvt[i];
        pos++;
      }
    }
    REL_HEAP;
  }
  else if ((r >= 0) && (c < 0))
  {
    if ((r > rows) || (-c > cols))
      controlled_exit("dimensions don't fit in mcut");
    amvt += cols * r;
    imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX); 
    RES_HEAP;
    pos = 0;
    c = cols + c;
    for (i = 0; i < nrows * cols; i++)
    {
      if (i % cols < c) 
      {
        imvt[pos] = amvt[i];
        pos++;
      }
    }
    REL_HEAP;
  }
  else if ((r < 0) && (c >= 0))
  {
    if ((-r > rows) || (c > cols))
      controlled_exit("dimensions don't fit in mcut");
    imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    RES_HEAP;
    pos = 0;
    for (i = 0; i < nrows * cols; i++)
    {
      if (i % cols >= c)        
      {
        imvt[pos] = amvt[i];
        pos++;
      }
    }
    REL_HEAP;
  }
  else        /* ((r < 0) && (c < 0)) */
  {
    if ((-r > rows) || (-c > cols))
      controlled_exit("dimensions don't fit in mcut");
    imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    RES_HEAP;
    pos = 0;
    c = cols + c;
    for (i = 0; i < nrows * cols; i++)
    {
      if (i % cols < c)        
      {
        imvt[pos] = amvt[i];
        pos++;
      }
    }
    REL_HEAP;
  }
  DBUG_RETURN(mvt_desc);
}

T_PTD t_transform(T_PTD a, int class, int type)
{
  int rows, cols, dim, i;
  register int *imvt;

  DBUG_ENTER("t_transform");
  MAKEDESC(mvt_desc, 1, C_LIST, TY_UNDEF);
  L_LIST((*mvt_desc), ptdd) = NULL;
  L_LIST((*mvt_desc), special) = NULL;
  rows = R_MVT(DESC(a), nrows, class);
  cols = R_MVT(DESC(a), ncols, class);
  dim = rows * cols;
  GET_HEAP(dim, A_LIST(*mvt_desc, ptdv));
  L_LIST(*mvt_desc, dim) = dim;
  imvt = (int *)R_MVT(DESC(a), ptdv, class);
  switch(type)
  {
    case TY_INTEGER:
      RES_HEAP;
      for (i = 0; i < dim; i++)
        L_LIST(*mvt_desc, ptdv)[i] = TAG_INT(imvt[i]);
      REL_HEAP;
      break;
    case TY_BOOL:
      RES_HEAP;
      for (i = 0; i < dim; i++)
        L_LIST(*mvt_desc, ptdv)[i] = (imvt[i] == SA_FALSE ? SA_FALSE : SA_TRUE);
      REL_HEAP;
      break;
    default:
      controlled_exit("unknown type in transform");
  }
  DBUG_RETURN(mvt_desc);
}

        
T_PTD t_transformr(T_PTD a, int class, int type)
{
  int rows, cols, dim, i;
  register double *imvt;
  PTR_DESCRIPTOR h_desc ;

  DBUG_ENTER("t_transformr");
  MAKEDESC(mvt_desc, 1, C_LIST, TY_UNDEF);
  L_LIST((*mvt_desc), ptdd) = NULL;
  L_LIST((*mvt_desc), special) = NULL;
  rows = R_MVT(DESC(a), nrows, class);
  cols = R_MVT(DESC(a), ncols, class);
  dim = rows * cols;
  GET_HEAP(dim, A_LIST(*mvt_desc, ptdv));
  L_LIST(*mvt_desc, dim) = dim;
  imvt = (double *)R_MVT(DESC(a), ptdv, class);
  for (i = 0; i < dim; i++)
  {
    MAKEDESC(h_desc, 1, C_SCALAR, TY_REAL);
    RES_HEAP;
    L_SCALAR(*h_desc, valr) = imvt[i];
    L_LIST(*mvt_desc, ptdv)[i] = (T_HEAPELEM)h_desc; 
    REL_HEAP;
  }
  DBUG_RETURN(mvt_desc);
}
  

T_PTD t_transpose_empty(T_PTD a)
{
  DBUG_ENTER("t_transpose_empty");
  INC_REFCNT(a);
  DBUG_RETURN(a);
}
  

T_PTD t_transpose_vt(T_PTD a, int class, int type)
{
  int dim, i;
  register int *imvt, *amvt;
  DBUG_ENTER("t_transpose_vt");
  switch(class)
  {
    case C_VECTOR:
      MAKEDESC(mvt_desc, 1, C_TVECTOR, type);
      L_MVT((*mvt_desc), ptdd, C_TVECTOR) = NULL;
      dim = R_MVT(DESC(a), ncols, C_VECTOR);
      L_MVT(*mvt_desc, nrows, C_TVECTOR) = dim;
      L_MVT(*mvt_desc, ncols, C_TVECTOR) = 1;
      GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, C_TVECTOR));
      amvt = (int *)R_MVT(DESC(a), ptdv, C_VECTOR);
      imvt = (int *)R_MVT(*mvt_desc, ptdv, C_TVECTOR);
      break;
    case C_TVECTOR:
      MAKEDESC(mvt_desc, 1, C_VECTOR, type);
      L_MVT((*mvt_desc), ptdd, C_VECTOR) = NULL;
      dim = R_MVT(DESC(a), nrows, C_TVECTOR);
      L_MVT(*mvt_desc, nrows, C_VECTOR) = 1;
      L_MVT(*mvt_desc, ncols, C_VECTOR) = dim;
      GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, C_VECTOR));
      amvt = (int *)R_MVT(DESC(a), ptdv, C_TVECTOR);
      imvt = (int *)R_MVT(*mvt_desc, ptdv, C_VECTOR);
      break;
    default:
      controlled_exit("unknown class in t_transpose");
  }
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = amvt[i];
  REL_HEAP;
  if (0 == dim)
  {
    if (C_TVECTOR == class)
    {
      INC_REFCNT(_niltvect);
      mvt_desc = _niltvect;
    }
    else
    {
      INC_REFCNT(_nilvect);
      mvt_desc = _nilvect;
    }
  }
  DBUG_RETURN(mvt_desc);
}


T_PTD t_transpose_vtr(T_PTD a, int class, int type)
{
  int dim, i;
  register double *imvt, *amvt;
  DBUG_ENTER("t_transpose_vtr");
  switch(class)
  {
    case C_VECTOR:
      MAKEDESC(mvt_desc, 1, C_TVECTOR, type);
      L_MVT((*mvt_desc), ptdd, C_TVECTOR) = NULL;
      dim = R_MVT(DESC(a), ncols, C_VECTOR);
      L_MVT(*mvt_desc, nrows, C_TVECTOR) = dim;
      L_MVT(*mvt_desc, ncols, C_TVECTOR) = 1;
      GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_TVECTOR));
      amvt = (double *)R_MVT(DESC(a), ptdv, C_VECTOR);
      imvt = (double *)R_MVT(*mvt_desc, ptdv, C_TVECTOR);
      break;
    case C_TVECTOR:
      MAKEDESC(mvt_desc, 1, C_VECTOR, type);
      L_MVT((*mvt_desc), ptdd, C_VECTOR) = NULL;
      dim = R_MVT(DESC(a), nrows, C_TVECTOR);
      L_MVT(*mvt_desc, nrows, C_VECTOR) = 1;
      L_MVT(*mvt_desc, ncols, C_VECTOR) = dim;
      GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_VECTOR));
      amvt = (double *)R_MVT(DESC(a), ptdv, C_TVECTOR);
      imvt = (double *)R_MVT(*mvt_desc, ptdv, C_VECTOR);
      break;
    default:
      controlled_exit("unknown class in t_transpose");
  }
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = amvt[i];
  REL_HEAP;
  if (0 == dim)
  {
    if (C_TVECTOR == class)
    {
      INC_REFCNT(_niltvect);
      mvt_desc = _niltvect;
    }
    else
    {
      INC_REFCNT(_nilvect);
      mvt_desc = _nilvect;
    }
  }
  DBUG_RETURN(mvt_desc);
}



T_PTD t_transpose_m(T_PTD a, int type)
{
  int dim, rows, cols, i, j;
  register int *imvt, *amvt;
  DBUG_ENTER("t_transpose_m");

  cols = R_MVT(DESC(a), ncols, C_MATRIX);
  rows = R_MVT(DESC(a), nrows, C_MATRIX);
  if ((0 == rows) || (0 == cols))
  {
    INC_REFCNT(_nilmat);
    mvt_desc = _nilmat;
  }
  else
  {
    MAKEDESC(mvt_desc, 1, C_MATRIX, type);
    L_MVT((*mvt_desc), ptdd, C_MATRIX) = NULL;
    L_MVT(*mvt_desc, nrows, C_MATRIX) = cols;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = rows;
    dim = rows * cols;
    GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, C_MATRIX));
    amvt = (int *)R_MVT(DESC(a), ptdv, C_MATRIX);
    imvt = (int *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    RES_HEAP;
    for (j = 0; j < rows; j++)
      for (i = 0; i < cols; i++)
        imvt[i * rows + j] = amvt[i + j * cols];
    REL_HEAP;
  }
  DBUG_RETURN(mvt_desc);
}



T_PTD t_transpose_mr(T_PTD a, int type)
{
  int dim, rows, cols, i, j;
  register double *imvt, *amvt;
  DBUG_ENTER("t_transpose_mr");

  cols = R_MVT(DESC(a), ncols, C_MATRIX);
  rows = R_MVT(DESC(a), nrows, C_MATRIX);
  if ((0 == rows) || (0 == cols))
  {
    INC_REFCNT(_nilmat);
    mvt_desc = _nilmat;
  }
  else
  {
    MAKEDESC(mvt_desc, 1, C_MATRIX, type);
    L_MVT((*mvt_desc), ptdd, C_MATRIX) = NULL;
    L_MVT(*mvt_desc, nrows, C_MATRIX) = cols;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = rows;
    dim = rows * cols;
    GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
    amvt = (double *)R_MVT(DESC(a), ptdv, C_MATRIX);
    imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    RES_HEAP;
    for (j = 0; j < rows; j++)
      for (i = 0; i < cols; i++)
        imvt[i * rows + j] = amvt[i + j * cols];
    REL_HEAP;
  }
  DBUG_RETURN(mvt_desc);
}

int t_mdim(int r_or_c, T_PTD a)
{
  DBUG_ENTER("t_mdim");
  if (1 == r_or_c)
    DBUG_RETURN(TAG_INT(R_MVT(DESC(a), nrows, C_MATRIX)));
  else if (2 == r_or_c)
    DBUG_RETURN(TAG_INT(R_MVT(DESC(a), ncols, C_MATRIX)));
  else
    controlled_exit("mdim: invalid first parameter");
  DBUG_RETURN(0);
}    

T_PTD t_mreplace_r(int a, T_PTD b, T_PTD c, int type)
{
  int rows, cols, vcols, dim, i;
  register int *imvt, *amvt;

  DBUG_ENTER("t_mreplace_r");
  cols = R_MVT(DESC(c), ncols, C_MATRIX);
  rows = R_MVT(DESC(c), nrows, C_MATRIX);
  vcols = R_MVT(DESC(b), ncols, C_VECTOR);
  dim = rows * cols;
  if (vcols != cols) 
    controlled_exit("dimensions don't fit in t_mreplace_r");
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT((*mvt_desc), ptdd, C_MATRIX) = NULL;
  L_MVT(*mvt_desc, nrows, C_MATRIX) = rows;
  L_MVT(*mvt_desc, ncols, C_MATRIX) = cols;
  amvt = (int *)R_MVT(DESC(c), ptdv, C_MATRIX);
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, C_MATRIX));
  imvt = (int *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = amvt[i];
  amvt = (int *)R_MVT(DESC(b), ptdv, C_VECTOR);
  imvt = &imvt[(a - 1) * cols];
  for (i = 0; i < vcols; i++)
    imvt[i] = amvt[i];
  
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_mreplace_rr(int a, T_PTD b, T_PTD c, int type)
{
  int rows, cols, vcols, dim, i;
  register double *imvt, *amvt;

  DBUG_ENTER("t_mreplace_rr");
  cols = R_MVT(DESC(c), ncols, C_MATRIX);
  rows = R_MVT(DESC(c), nrows, C_MATRIX);
  vcols = R_MVT(DESC(b), ncols, C_VECTOR);
  dim = rows * cols;
  if (vcols != cols) 
    controlled_exit("dimensions don't fit in t_mreplace_r");
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT((*mvt_desc), ptdd, C_MATRIX) = NULL;
  L_MVT(*mvt_desc, nrows, C_MATRIX) = rows;
  L_MVT(*mvt_desc, ncols, C_MATRIX) = cols;
  amvt = (double *)R_MVT(DESC(c), ptdv, C_MATRIX);
  GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
  imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = amvt[i];
  amvt = (double *)R_MVT(DESC(b), ptdv, C_VECTOR);
  imvt = &imvt[(a - 1) * cols];
  for (i = 0; i < vcols; i++)
    imvt[(a-1) * rows + i] = amvt[i];
  
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_mreplace_c(int a, T_PTD b, T_PTD c, int type)
{
  int rows, cols, vrows, dim, i;
  register int *imvt, *amvt;

  DBUG_ENTER("t_mreplace_c");
  cols = R_MVT(DESC(c), ncols, C_MATRIX);
  rows = R_MVT(DESC(c), nrows, C_MATRIX);
  vrows = R_MVT(DESC(b), nrows, C_TVECTOR);
  dim = rows * cols;
  if (vrows != rows) 
    controlled_exit("dimensions don't fit in t_mreplace_r");
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT((*mvt_desc), ptdd, C_MATRIX) = NULL;
  L_MVT(*mvt_desc, nrows, C_MATRIX) = rows;
  L_MVT(*mvt_desc, ncols, C_MATRIX) = cols;
  amvt = (int *)R_MVT(DESC(c), ptdv, C_MATRIX);
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, C_MATRIX));
  imvt = (int *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = amvt[i];
  amvt = (int *)R_MVT(DESC(b), ptdv, C_TVECTOR);
  for (i = 0; i < vrows; i++)
    imvt[(a - 1) + i * cols] = amvt[i];
  
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_mreplace_cr(int a, T_PTD b, T_PTD c, int type)
{
  int rows, cols, vrows, dim, i;
  register double *imvt, *amvt;

  DBUG_ENTER("t_mreplace_cr");
  cols = R_MVT(DESC(c), ncols, C_MATRIX);
  rows = R_MVT(DESC(c), nrows, C_MATRIX);
  vrows = R_MVT(DESC(b), nrows, C_TVECTOR);
  dim = rows * cols;
  if (vrows != rows) 
    controlled_exit("dimensions don't fit in t_mreplace_r");
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT((*mvt_desc), ptdd, C_MATRIX) = NULL;
  L_MVT(*mvt_desc, nrows, C_MATRIX) = rows;
  L_MVT(*mvt_desc, ncols, C_MATRIX) = cols;
  amvt = (double *)R_MVT(DESC(c), ptdv, C_MATRIX);
  GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
  imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = amvt[i];
  amvt = (double *)R_MVT(DESC(b), ptdv, C_TVECTOR);
  for (i = 0; i < vrows; i++)
    imvt[(a - 1) + cols * i] = amvt[i];
  
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}



T_PTD t_mrotate(int a, int b, T_PTD c, int type)
{
  register int dim, count;
  int rowrotation, colrotation, nrows, ncols, pos, newrow, newcol;
  int    *ipnew,*ip;

  DBUG_ENTER("t_mrotate");
  a = -a;
  nrows = R_MVT(DESC(c),nrows,C_MATRIX);
  ncols = R_MVT(DESC(c),ncols,C_MATRIX);
  if (ncols == 1) 
    if (0 == (a = a % nrows))
      goto nothingtodo;
    else 
    {
      dim = nrows;
      if (a > 0)
        pos = a;
      else
        pos = dim + a;
      goto alg1;
    }
  b = -b;
  if (1 == nrows)
    if (0 == (a % ncols))
      goto nothingtodo;
    else
    {
      dim = ncols;
      if (b > 0)
        pos = b;
      else
        pos = dim + b;
      goto alg1;
    }
  a = a % nrows;
  if (a < 0)
    a +=nrows;
  b = b % ncols;
  if (b < 0)
    b +=ncols;
  if (0 == b)
    if (0 == a)
      goto nothingtodo;
    else
    {
      dim = ncols * nrows;
      pos = a * ncols;
      goto alg1;
    }
    newrow = a * ncols;
    newcol = b;
    dim = nrows * ncols;
    MAKEDESC(mvt_desc, 1, C_MATRIX, type);
    L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
    L_MVT((*mvt_desc),nrows,C_MATRIX) = nrows;
    L_MVT((*mvt_desc),ncols,C_MATRIX) = ncols;
    GET_HEAP(dim,A_MVT((*mvt_desc),ptdv,C_MATRIX));
    RES_HEAP;
    ipnew = (int *) R_MVT((*mvt_desc),ptdv,C_MATRIX);
    ip    = (int *) R_MVT(DESC(c),ptdv,C_MATRIX);
    for (count = 0; count < dim; count++)
    {
      ipnew[newrow + newcol] = ip[count];
      newcol++;
      if (newcol == ncols) newcol = 0;
      else if (newcol == b) 
      {
        newrow += ncols;
        if (newrow == dim)
          newrow = 0;
      }
    }
    REL_HEAP;
    goto success;

alg1:
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
  L_MVT((*mvt_desc),nrows,C_MATRIX) = nrows;
  L_MVT((*mvt_desc),ncols,C_MATRIX) = ncols;
  GET_HEAP(dim,A_MVT((*mvt_desc),ptdv,C_MATRIX));
  RES_HEAP;
  ipnew = (int *) R_MVT((*mvt_desc),ptdv,C_MATRIX);
  ip    = (int *) R_MVT(DESC(c),ptdv,C_MATRIX);
    for (count = 0; count < dim; count++) {
      ipnew[pos] = ip[count];
      ++pos;
      if (pos == dim) pos = 0;
    }
  REL_HEAP;
  goto success;

nothingtodo:
  INC_REFCNT(c);
  DBUG_RETURN(c);
success:
  DBUG_RETURN(mvt_desc);
}


T_PTD t_mrotate_r(int a, int b, T_PTD c, int type)
{
  register int dim, count;
  int rowrotation, colrotation, nrows, ncols, pos, newrow, newcol;
  double *ipnew,*ip;

  DBUG_ENTER("t_mrotate_r");
  a = -a;
  nrows = R_MVT(DESC(c),nrows,C_MATRIX);
  ncols = R_MVT(DESC(c),ncols,C_MATRIX);
  if (ncols == 1) 
    if (0 == (a = a % nrows))
      goto nothingtodo;
    else 
    {
      dim = nrows;
      if (a > 0)
        pos = a;
      else
        pos = dim + a;
      goto alg1;
    }
  b = -b;
  if (1 == nrows)
    if (0 == (a % ncols))
      goto nothingtodo;
    else
    {
      dim = ncols;
      if (b > 0)
        pos = b;
      else
        pos = dim + b;
      goto alg1;
    }
  a = a % nrows;
  if (a < 0)
    a +=nrows;
  b = b % ncols;
  if (b < 0)
    b +=ncols;
  if (0 == b)
    if (0 == a)
      goto nothingtodo;
    else
    {
      dim = ncols * nrows;
      pos = a * ncols;
      goto alg1;
    }
    newrow = a * ncols;
    newcol = b;
    dim = nrows * ncols;
    MAKEDESC(mvt_desc, 1, C_MATRIX, type);
    L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
    L_MVT((*mvt_desc),nrows,C_MATRIX) = nrows;
    L_MVT((*mvt_desc),ncols,C_MATRIX) = ncols;
    GET_HEAP(dim * sizeof(double),A_MVT((*mvt_desc),ptdv,C_MATRIX));
    RES_HEAP;
    ipnew = (double *) R_MVT((*mvt_desc),ptdv,C_MATRIX);
    ip    = (double *) R_MVT(DESC(c),ptdv,C_MATRIX);
    for (count = 0; count < dim; count++)
    {
      ipnew[newrow + newcol] = ip[count];
      newcol++;
      if (newcol == ncols) newcol = 0;
      else if (newcol == b) 
      {
        newrow += ncols;
        if (newrow == dim)
          newrow = 0;
      }
    }
    REL_HEAP;
    goto success;

alg1:
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
  L_MVT((*mvt_desc),nrows,C_MATRIX) = nrows;
  L_MVT((*mvt_desc),ncols,C_MATRIX) = ncols;
  GET_HEAP(dim,A_MVT((*mvt_desc),ptdv,C_MATRIX));
  RES_HEAP;
  ipnew = (double *) R_MVT((*mvt_desc),ptdv,C_MATRIX);
  ip    = (double *) R_MVT(DESC(c),ptdv,C_MATRIX);
    for (count = 0; count < dim; count++) {
      ipnew[pos] = ip[count];
      ++pos;
      if (pos == dim) pos = 0;
    }
  REL_HEAP;
  goto success;

nothingtodo:
  INC_REFCNT(c);
  DBUG_RETURN(c);
success:
  DBUG_RETURN(mvt_desc);
}


T_PTD t_mreplace(int a, int b, int c, T_PTD d, int type)
{
  register int rows, cols, i, dim;
  DBUG_ENTER("t_mreplace");
  rows = R_MVT(DESC(d), nrows, C_MATRIX);
  cols = R_MVT(DESC(d), ncols, C_MATRIX);
  if ((a > rows) || (b > cols))
    controlled_exit("dimensions don't fit in t_mreplace");
  dim = rows * cols;
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT(DESC(d), ptdd, C_MATRIX) = NULL;
  L_MVT(*mvt_desc, nrows, C_MATRIX) = rows;
  L_MVT(*mvt_desc, ncols, C_MATRIX) = cols;
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, C_MATRIX));
  for (i = 0; i < dim; i++)
    L_MVT(*mvt_desc, ptdv, C_MATRIX)[i] = R_MVT(DESC(d), ptdv, C_MATRIX)[i];
  switch(type)
  {
    case TY_INTEGER:
      L_MVT(*mvt_desc, ptdv, C_MATRIX)[(a - 1) * cols + b - 1] = c;
      break;
    case TY_BOOL:
      L_MVT(*mvt_desc, ptdv, C_MATRIX)[(a - 1) * cols + b - 1] = (SA_FALSE == c ?
                                                                   FALSE : TRUE);
      break;
  }
  DBUG_RETURN(mvt_desc);
}


T_PTD t_mreplace_real(int a, int b, double c, T_PTD d, int type)
{
  register int rows, cols, i, dim;
  double *imvt, *amvt;
  DBUG_ENTER("t_mreplace_real");
  rows = R_MVT(DESC(d), nrows, C_MATRIX);
  cols = R_MVT(DESC(d), ncols, C_MATRIX);
  if ((a > rows) || (b > cols))
    controlled_exit("dimensions don't fit in t_mreplace");
  dim = rows * cols;
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT(DESC(d), ptdd, C_MATRIX) = NULL;
  L_MVT(*mvt_desc, nrows, C_MATRIX) = rows;
  L_MVT(*mvt_desc, ncols, C_MATRIX) = cols;
  GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
  amvt = (double *)R_MVT(DESC(d), ptdv, C_MATRIX);
  imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = amvt[i];
  imvt[(a - 1) * cols + b - 1] = c;
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_not_bmat(T_PTD a, int class)
{
  int arows, acols, i, dim, *imvt, *amvt;
  DBUG_ENTER("t_not_bmat");
  arows = R_MVT(DESC(a), nrows, class);
  acols = R_MVT(DESC(a), ncols, class);

  dim = arows * acols;
  if (0 == dim) 
    MAKEDESC(mvt_desc, 1, class, TY_UNDEF);
  else
    MAKEDESC(mvt_desc, 1, class, TY_BOOL);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = arows;
  L_MVT(*mvt_desc, ncols, class) = acols;
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, class));
  amvt = (int *)R_MVT(DESC(a), ptdv, class);
  imvt = (int *)R_MVT(*mvt_desc, ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = amvt[i] ? FALSE : TRUE;
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_and_bmat(T_PTD a, T_PTD b, int class)
{
  int arows, brows, acols, bcols, i, dim, *imvt, *amvt, *bmvt;
  DBUG_ENTER("t_and_bmat");
  arows = R_MVT(DESC(a), nrows, class);
  brows = R_MVT(DESC(b), nrows, class);
  acols = R_MVT(DESC(a), ncols, class);
  bcols = R_MVT(DESC(b), ncols, class);

  if ((acols != bcols) || (arows != brows))
    controlled_exit("dimensions don't fit in t_and_bmat");
  dim = arows * acols;
  MAKEDESC(mvt_desc, 1, class, TY_BOOL);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = arows;
  L_MVT(*mvt_desc, ncols, class) = acols;
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, class));
  amvt = (int *)R_MVT(DESC(a), ptdv, class);
  bmvt = (int *)R_MVT(DESC(b), ptdv, class);
  imvt = (int *)R_MVT(*mvt_desc, ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = amvt[i] && bmvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_or_bmat(T_PTD a, T_PTD b, int class)
{
  int arows, brows, acols, bcols, i, dim, *imvt, *amvt, *bmvt;
  DBUG_ENTER("t_or_bmat");
  arows = R_MVT(DESC(a), nrows, class);
  brows = R_MVT(DESC(b), nrows, class);
  acols = R_MVT(DESC(a), ncols, class);
  bcols = R_MVT(DESC(b), ncols, class);

  if ((acols != bcols) || (arows != brows))
    controlled_exit("dimensions don't fit in t_and_bmat");
  dim = arows * acols;
  MAKEDESC(mvt_desc, 1, class, TY_BOOL);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = arows;
  L_MVT(*mvt_desc, ncols, class) = acols;
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, class));
  amvt = (int *)R_MVT(DESC(a), ptdv, class);
  bmvt = (int *)R_MVT(DESC(b), ptdv, class);
  imvt = (int *)R_MVT(*mvt_desc, ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = amvt[i] || bmvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_xor_bmat(T_PTD a, T_PTD b, int class)
{
  int arows, brows, acols, bcols, i, dim, *imvt, *amvt, *bmvt;
  DBUG_ENTER("t_xor_bmat");
  arows = R_MVT(DESC(a), nrows, class);
  brows = R_MVT(DESC(b), nrows, class);
  acols = R_MVT(DESC(a), ncols, class);
  bcols = R_MVT(DESC(b), ncols, class);

  if ((acols != bcols) || (arows != brows))
    controlled_exit("dimensions don't fit in t_and_bmat");
  dim = arows * acols;
  MAKEDESC(mvt_desc, 1, class, TY_BOOL);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = arows;
  L_MVT(*mvt_desc, ncols, class) = acols;
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, class));
  amvt = (int *)R_MVT(DESC(a), ptdv, class);
  bmvt = (int *)R_MVT(DESC(b), ptdv, class);
  imvt = (int *)R_MVT(*mvt_desc, ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = amvt[i] != bmvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_b_xor_bmat(int a, T_PTD b, int class)
{
  int brows, bcols, i, dim, *imvt, *bmvt, arg;
  DBUG_ENTER("t_b_xor_bmat");
  brows = R_MVT(DESC(b), nrows, class);
  bcols = R_MVT(DESC(b), ncols, class);

  dim = brows * bcols;
  arg = (SA_FALSE == a) ? FALSE : TRUE;
  MAKEDESC(mvt_desc, 1, class, TY_BOOL);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = brows;
  L_MVT(*mvt_desc, ncols, class) = bcols;
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, class));
  bmvt = (int *)R_MVT(DESC(b), ptdv, class);
  imvt = (int *)R_MVT(*mvt_desc, ptdv, class);
  
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = (arg != bmvt[i]);
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_b_and_bmat(int a, T_PTD b, int class)
{
  int brows, bcols, i, dim, *imvt, *bmvt, arg;
  DBUG_ENTER("t_b_and_bmat");
  brows = R_MVT(DESC(b), nrows, class);
  bcols = R_MVT(DESC(b), ncols, class);

  dim = brows * bcols;
  arg = (SA_FALSE == a) ? FALSE : TRUE;
  MAKEDESC(mvt_desc, 1, class, TY_BOOL);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = brows;
  L_MVT(*mvt_desc, ncols, class) = bcols;
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, class));
  bmvt = (int *)R_MVT(DESC(b), ptdv, class);
  imvt = (int *)R_MVT(*mvt_desc, ptdv, class);
  
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = arg && bmvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_b_or_bmat(int a, T_PTD b, int class)
{
  int brows, bcols, i, dim, *imvt, *bmvt, arg;
  DBUG_ENTER("t_b_or_bmat");
  brows = R_MVT(DESC(b), nrows, class);
  bcols = R_MVT(DESC(b), ncols, class);

  dim = brows * bcols;
  arg = (SA_FALSE == a) ? FALSE : TRUE;
  MAKEDESC(mvt_desc, 1, class, TY_BOOL);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = brows;
  L_MVT(*mvt_desc, ncols, class) = bcols;
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, class));
  bmvt = (int *)R_MVT(DESC(b), ptdv, class);
  imvt = (int *)R_MVT(*mvt_desc, ptdv, class);
  
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = arg || bmvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}

T_PTD t_min_mixmi(T_PTD a, T_PTD b, int class, int type)
{
  int arows, brows, acols, bcols, i, dim, *imvt, *amvt, *bmvt;

  DBUG_ENTER("t_min_mixmi");
  arows = R_MVT(DESC(a), nrows, class);
  acols = R_MVT(DESC(a), ncols, class);
  brows = R_MVT(DESC(b), nrows, class);
  bcols = R_MVT(DESC(b), ncols, class);
  if ((acols != bcols) || (arows != brows))
    controlled_exit("dimensions don't fit in t_and_bmat");
  dim = arows * acols;
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = arows;
  L_MVT(*mvt_desc, ncols, class) = acols;
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, class));
  amvt = (int *)R_MVT(DESC(a), ptdv, class);
  bmvt = (int *)R_MVT(DESC(b), ptdv, class);
  imvt = (int *)R_MVT(*mvt_desc, ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = (amvt[i] < bmvt[i]) ? amvt[i] : bmvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}



T_PTD t_min_mrxmi(T_PTD a, T_PTD b, int class, int type)
{
  int arows, brows, acols, bcols, i, dim, *bmvt;
  double *amvt, *imvt;
  DBUG_ENTER("t_min_mrxmi");
  arows = R_MVT(DESC(a), nrows, class);
  acols = R_MVT(DESC(a), ncols, class);
  brows = R_MVT(DESC(b), nrows, class);
  bcols = R_MVT(DESC(b), ncols, class);
  if ((acols != bcols) || (arows != brows))
    controlled_exit("dimensions don't fit in t_and_bmat");
  dim = arows * acols;
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = arows;
  L_MVT(*mvt_desc, ncols, class) = acols;
  GET_HEAP(dim *sizeof(double), A_MVT(*mvt_desc, ptdv, class));
  amvt = (double *)R_MVT(DESC(a), ptdv, class);
  bmvt = (int *)R_MVT(DESC(b), ptdv, class);
  imvt = (double *)R_MVT(*mvt_desc, ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = (amvt[i] < bmvt[i]) ? amvt[i] : (double)bmvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_min_mrxmr(T_PTD a, T_PTD b, int class, int type)
{
  int arows, brows, acols, bcols, i, dim;
  double *amvt, *bmvt, *imvt;
  DBUG_ENTER("t_min_mrxmi");
  arows = R_MVT(DESC(a), nrows, class);
  acols = R_MVT(DESC(a), ncols, class);
  brows = R_MVT(DESC(b), nrows, class);
  bcols = R_MVT(DESC(b), ncols, class);
  if ((acols != bcols) || (arows != brows))
    controlled_exit("dimensions don't fit in t_and_bmat");
  dim = arows * acols;
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = arows;
  L_MVT(*mvt_desc, ncols, class) = acols;
  GET_HEAP(dim *sizeof(double), A_MVT(*mvt_desc, ptdv, class));
  amvt = (double *)R_MVT(DESC(a), ptdv, class);
  bmvt = (double *)R_MVT(DESC(b), ptdv, class);
  imvt = (double *)R_MVT(*mvt_desc, ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = (amvt[i] < bmvt[i]) ? amvt[i] : bmvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_max_mixmi(T_PTD a, T_PTD b, int class, int type)
{
  int arows, brows, acols, bcols, i, dim, *imvt, *amvt, *bmvt;

  DBUG_ENTER("t_max_mixmi");
  arows = R_MVT(DESC(a), nrows, class);
  acols = R_MVT(DESC(a), ncols, class);
  brows = R_MVT(DESC(b), nrows, class);
  bcols = R_MVT(DESC(b), ncols, class);
  if ((acols != bcols) || (arows != brows))
    controlled_exit("dimensions don't fit in t_and_bmat");
  dim = arows * acols;
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = arows;
  L_MVT(*mvt_desc, ncols, class) = acols;
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, class));
  amvt = (int *)R_MVT(DESC(a), ptdv, class);
  bmvt = (int *)R_MVT(DESC(b), ptdv, class);
  imvt = (int *)R_MVT(*mvt_desc, ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = (amvt[i] > bmvt[i]) ? amvt[i] : bmvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}



T_PTD t_max_mrxmi(T_PTD a, T_PTD b, int class, int type)
{
  int arows, brows, acols, bcols, i, dim, *bmvt;
  double *amvt, *imvt;
  DBUG_ENTER("t_max_mrxmi");
  arows = R_MVT(DESC(a), nrows, class);
  acols = R_MVT(DESC(a), ncols, class);
  brows = R_MVT(DESC(b), nrows, class);
  bcols = R_MVT(DESC(b), ncols, class);
  if ((acols != bcols) || (arows != brows))
    controlled_exit("dimensions don't fit in t_and_bmat");
  dim = arows * acols;
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = arows;
  L_MVT(*mvt_desc, ncols, class) = acols;
  GET_HEAP(dim *sizeof(double), A_MVT(*mvt_desc, ptdv, class));
  amvt = (double *)R_MVT(DESC(a), ptdv, class);
  bmvt = (int *)R_MVT(DESC(b), ptdv, class);
  imvt = (double *)R_MVT(*mvt_desc, ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = (amvt[i] > (double)bmvt[i]) ? amvt[i] : (double)bmvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_max_mrxmr(T_PTD a, T_PTD b, int class, int type)
{
  int arows, brows, acols, bcols, i, dim;
  double *amvt, *bmvt, *imvt;
  DBUG_ENTER("t_max_mrxmi");
  arows = R_MVT(DESC(a), nrows, class);
  acols = R_MVT(DESC(a), ncols, class);
  brows = R_MVT(DESC(b), nrows, class);
  bcols = R_MVT(DESC(b), ncols, class);
  if ((acols != bcols) || (arows != brows))
    controlled_exit("dimensions don't fit in t_and_bmat");
  dim = arows * acols;
  MAKEDESC(mvt_desc, 1, class, type);
  L_MVT(*mvt_desc, ptdd, class) = NULL;
  L_MVT(*mvt_desc, nrows, class) = arows;
  L_MVT(*mvt_desc, ncols, class) = acols;
  GET_HEAP(dim *sizeof(double), A_MVT(*mvt_desc, ptdv, class));
  amvt = (double *)R_MVT(DESC(a), ptdv, class);
  bmvt = (double *)R_MVT(DESC(b), ptdv, class);
  imvt = (double *)R_MVT(*mvt_desc, ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim; i++)
    imvt[i] = (amvt[i] > bmvt[i]) ? amvt[i] : bmvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_to_mat(int a, int type)
{
  DBUG_ENTER("t_to_mat");
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
  L_MVT(*mvt_desc, nrows, C_MATRIX) = 1;
  L_MVT(*mvt_desc, ncols, C_MATRIX) = 1;
  GET_HEAP(1, A_MVT(*mvt_desc, ptdv, C_MATRIX));
  if (type == TY_INTEGER)
    L_MVT(*mvt_desc, ptdv, C_MATRIX)[0] = a;
  else
    L_MVT(*mvt_desc, ptdv, C_MATRIX)[0] = (SA_FALSE == a) ? SA_FALSE : SA_TRUE;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_r_to_mat(double a, int type)
{
  double *rmvt;
  DBUG_ENTER("t_r_to_mat");
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
  L_MVT(*mvt_desc, nrows, C_MATRIX) = 1;
  L_MVT(*mvt_desc, ncols, C_MATRIX) = 1;
  GET_HEAP(1 * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
  rmvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
  rmvt[0] = a;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_v_to_mat(T_PTD a, int class, int type)
{
  int *amvt, *imvt, dim, i;
  DBUG_ENTER("t_v_to_mat");
  if (C_TVECTOR == class)
    dim = R_MVT(DESC(a), nrows, class);
  else
    dim = R_MVT(DESC(a), ncols, class);
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
  if (C_TVECTOR == class)
  {
    L_MVT(*mvt_desc, nrows, C_MATRIX) = dim;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = 1;
  }
  else
  {
    L_MVT(*mvt_desc, nrows, C_MATRIX) = 1;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = dim;
  }
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, C_MATRIX));
  imvt = (int *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
  amvt = (int *)R_MVT(DESC(a), ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim ; i++)
    imvt[i] = amvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}


T_PTD t_vr_to_mat(T_PTD a, int class, int type)
{
  double *amvt, *imvt;
  int dim, i;
  DBUG_ENTER("t_vr_to_mat");
  if (C_TVECTOR == class)
    dim = R_MVT(DESC(a), nrows, class);
  else
    dim = R_MVT(DESC(a), ncols, class);
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
  if (C_TVECTOR == class)
  {
    L_MVT(*mvt_desc, nrows, C_MATRIX) = dim;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = 1;
  }
  else
  {
    L_MVT(*mvt_desc, nrows, C_MATRIX) = 1;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = dim;
  }
  GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
  imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
  amvt = (double *)R_MVT(DESC(a), ptdv, class);
  RES_HEAP;
  for (i = 0; i < dim ; i++)
    imvt[i] = amvt[i];
  REL_HEAP;
  DBUG_RETURN(mvt_desc);
}

T_PTD t_munite_empty(T_PTD a)
{
  DBUG_ENTER("t_munite_empty");
  INC_REFCNT(a);
  DBUG_RETURN(a);
}

T_PTD t_munite_ii(int a, T_PTD b, T_PTD c, int class_b, int class_c, int restype)
{
  T_PTD help;
  int *bmvt, *cmvt, *imvt;
  int brows, bcols, crows, ccols, dim, nrows, ncols, i, j;
  DBUG_ENTER("t_munite_ii");
  
  brows = R_MVT(DESC(b), nrows, class_b);
  crows = R_MVT(DESC(c), nrows, class_c);
  bcols = R_MVT(DESC(b), ncols, class_b);
  ccols = R_MVT(DESC(c), ncols, class_c);
  if (TY_UNDEF == R_MVT(DESC(b), type, class_b))
    goto nilmat;
  if (TY_UNDEF == R_MVT(DESC(c), type, class_c))
  {
    help = b;
    b = c;
    c = help;
    i = class_b;
    class_b = class_c;
    class_c = i;
    goto nilmat;
  }
  
  bmvt = (int *)R_MVT(DESC(b), ptdv, class_b);
  cmvt = (int *)R_MVT(DESC(c), ptdv, class_c);
  if (1 == a)
  {
    if (bcols != ccols)
      controlled_exit("dimensions don't fit in munite");
    ncols = bcols;
    nrows = brows + crows;
    dim = ncols * nrows;
    MAKEDESC(mvt_desc, 1, C_MATRIX, restype);
    L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
    L_MVT(*mvt_desc, nrows, C_MATRIX) = nrows;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = ncols;
    GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, C_MATRIX));
    RES_HEAP;
    imvt = (int *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    dim = ncols * brows;
    for (i = 0; i < dim; i++)
      *imvt++ = *bmvt++;
    dim = ncols * crows;
    for (i = 0; i < dim; i++)
      *imvt++ = *cmvt++;
    REL_HEAP;
    goto success;
  } /* if (1 == a) */
  else if (2 == a)
  {
    if (brows != crows)
      controlled_exit("dimensions don't fit in munite");
    ncols = bcols + ccols;
    nrows = brows;
    dim = ncols * nrows;
    MAKEDESC(mvt_desc, 1, C_MATRIX, restype);
    L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
    L_MVT(*mvt_desc, nrows, C_MATRIX) = nrows;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = ncols;
    GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, C_MATRIX));
    RES_HEAP;
    imvt = (int *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    for (i = 0; i < nrows; i++)
    {
      for (j = 0; j < bcols; j++)
        *imvt++ = *bmvt++;
      for ( j = 0; j < ccols; j++)
        *imvt++ = *cmvt++;
    }     
    REL_HEAP;
    goto success;
  } /* if (2 == a) */
  else
    controlled_exit("first arg in munite is not 1 or 2");
nilmat:
/* argument 2 is empty mat */
  switch(class_c)
  {
    case C_MATRIX:
      if (TY_UNDEF == R_MVT(DESC(c), type, class_c))
      {
        INC_REFCNT(_nilmat);
        mvt_desc = _nilmat;
        goto success;
      }
      else
      { 
        INC_REFCNT(c);
        mvt_desc = (PTR_DESCRIPTOR)gen_many_id(C_MATRIX, (PTR_DESCRIPTOR)c);
        goto success;
      }
      break;
    case C_VECTOR:
    case C_TVECTOR:
      if (TY_UNDEF == R_MVT(DESC(c), type, class_c))
      {
        INC_REFCNT(_nilmat);
        mvt_desc = (PTR_DESCRIPTOR)_nilmat;
        goto success;
      }
      else
        mvt_desc = (PTR_DESCRIPTOR)gen_many_id(C_MATRIX, (PTR_DESCRIPTOR)c);
      break;
    default:
      controlled_exit("unknown class in munite");
  }
success:
  DBUG_RETURN(mvt_desc);
}



T_PTD t_munite_ri(int a, T_PTD b, T_PTD c, int class_b, int class_c, int restype)
{
  T_PTD help;
  double *bmvt, *imvt;
  int *cmvt;
  int brows, bcols, crows, ccols, dim, nrows, ncols, i, j;
  DBUG_ENTER("t_munite_ri");
  
  brows = R_MVT(DESC(b), nrows, class_b);
  crows = R_MVT(DESC(c), nrows, class_c);
  bcols = R_MVT(DESC(b), ncols, class_b);
  ccols = R_MVT(DESC(c), ncols, class_c);
  if (TY_UNDEF == R_MVT(DESC(b), type, class_b))
    goto nilmat;
  if (TY_UNDEF == R_MVT(DESC(c), type, class_c))
  {
    help = b;
    b = c;
    c = help;
    i = class_b;
    class_b = class_c;
    class_c = i;
    goto nilmat;
  }
  
  bmvt = (double *)R_MVT(DESC(b), ptdv, class_b);
  cmvt = (int *)R_MVT(DESC(c), ptdv, class_c);
  if (1 == a)
  {
    if (bcols != ccols)
      controlled_exit("dimensions don't fit in munite");
    ncols = bcols;
    nrows = brows + crows;
    dim = ncols * nrows;
    MAKEDESC(mvt_desc, 1, C_MATRIX, restype);
    L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
    L_MVT(*mvt_desc, nrows, C_MATRIX) = nrows;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = ncols;
    GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
    RES_HEAP;
    imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    dim = ncols * brows;
    for (i = 0; i < dim; i++)
      *imvt++ = *bmvt++;
    dim = ncols * crows;
    for (i = 0; i < dim; i++)
      *imvt++ = (double)*cmvt++;
    REL_HEAP;
    goto success;
  } /* if (1 == a) */
  else if (2 == a)
  {
    if (brows != crows)
      controlled_exit("dimensions don't fit in munite");
    ncols = bcols + ccols;
    nrows = brows;
    dim = ncols * nrows;
    MAKEDESC(mvt_desc, 1, C_MATRIX, restype);
    L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
    L_MVT(*mvt_desc, nrows, C_MATRIX) = nrows;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = ncols;
    GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
    RES_HEAP;
    imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    for (i = 0; i < nrows; i++)
    {
      for (j = 0; j < bcols; j++)
        *imvt++ = *bmvt++;
      for ( j = 0; j < ccols; j++)
        *imvt++ = (double)*cmvt++;
    }     
    REL_HEAP;
    goto success;
  } /* if (2 == a) */
  else
    controlled_exit("first arg in munite is not 1 or 2");
nilmat:
/* argument 2 is empty mat */
  switch(class_c)
  {
    case C_MATRIX:
      if (TY_UNDEF == R_MVT(DESC(c), type, class_c))
      {
        INC_REFCNT(_nilmat);
        mvt_desc = _nilmat;
        goto success;
      }
      else
      { 
        INC_REFCNT(c);
        mvt_desc = (PTR_DESCRIPTOR)gen_many_id(C_MATRIX, (PTR_DESCRIPTOR)c);
        goto success;
      }
      break;
    case C_VECTOR:
    case C_TVECTOR:
      if (TY_UNDEF == R_MVT(DESC(c), type, class_c))
      {
        INC_REFCNT(_nilmat);
        mvt_desc = (PTR_DESCRIPTOR)_nilmat;
        goto success;
      }
      else
        mvt_desc = (PTR_DESCRIPTOR)gen_many_id(C_MATRIX, (PTR_DESCRIPTOR)c);
      break;
    default:
      controlled_exit("unknown class in munite");
  }
success:
  DBUG_RETURN(mvt_desc);
}


T_PTD t_munite_ir(int a, T_PTD b, T_PTD c, int class_b, int class_c, int restype)
{
  T_PTD help;
  double *cmvt, *imvt;
  int *bmvt;
  int brows, bcols, crows, ccols, dim, nrows, ncols, i, j;
  DBUG_ENTER("t_munite_ir");
  
  brows = R_MVT(DESC(b), nrows, class_b);
  crows = R_MVT(DESC(c), nrows, class_c);
  bcols = R_MVT(DESC(b), ncols, class_b);
  ccols = R_MVT(DESC(c), ncols, class_c);
  if (TY_UNDEF == R_MVT(DESC(b), type, class_b))
    goto nilmat;
  if (TY_UNDEF == R_MVT(DESC(c), type, class_c))
  {
    help = b;
    b = c;
    c = help;
    i = class_b;
    class_b = class_c;
    class_c = i;
    goto nilmat;
  }
  
  bmvt = (int *)R_MVT(DESC(b), ptdv, class_b);
  cmvt = (double *)R_MVT(DESC(c), ptdv, class_c);
  if (1 == a)
  {
    if (bcols != ccols)
      controlled_exit("dimensions don't fit in munite");
    ncols = bcols;
    nrows = brows + crows;
    dim = ncols * nrows;
    MAKEDESC(mvt_desc, 1, C_MATRIX, restype);
    L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
    L_MVT(*mvt_desc, nrows, C_MATRIX) = nrows;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = ncols;
    GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
    RES_HEAP;
    imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    dim = ncols * brows;
    for (i = 0; i < dim; i++)
      *imvt++ = (double)*bmvt++;
    dim = ncols * crows;
    for (i = 0; i < dim; i++)
      *imvt++ = *cmvt++;
    REL_HEAP;
    goto success;
  } /* if (1 == a) */
  else if (2 == a)
  {
    if (brows != crows)
      controlled_exit("dimensions don't fit in munite");
    ncols = bcols + ccols;
    nrows = brows;
    dim = ncols * nrows;
    MAKEDESC(mvt_desc, 1, C_MATRIX, restype);
    L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
    L_MVT(*mvt_desc, nrows, C_MATRIX) = nrows;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = ncols;
    GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
    RES_HEAP;
    imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    for (i = 0; i < nrows; i++)
    {
      for (j = 0; j < bcols; j++)
        *imvt++ = (double)*bmvt++;
      for ( j = 0; j < ccols; j++)
        *imvt++ = *cmvt++;
    }     
    REL_HEAP;
    goto success;
  } /* if (2 == a) */
  else
    controlled_exit("first arg in munite is not 1 or 2");
nilmat:
/* argument 2 is empty mat */
  switch(class_c)
  {
    case C_MATRIX:
      if (TY_UNDEF == R_MVT(DESC(c), type, class_c))
      {
        INC_REFCNT(_nilmat);
        mvt_desc = _nilmat;
        goto success;
      }
      else
      { 
        INC_REFCNT(c);
        mvt_desc = (PTR_DESCRIPTOR)gen_many_id(C_MATRIX, (PTR_DESCRIPTOR)c);
        goto success;
      }
      break;
    case C_VECTOR:
    case C_TVECTOR:
      if (TY_UNDEF == R_MVT(DESC(c), type, class_c))
      {
        INC_REFCNT(_nilmat);
        mvt_desc = (PTR_DESCRIPTOR)_nilmat;
        goto success;
      }
      else
        mvt_desc = (PTR_DESCRIPTOR)gen_many_id(C_MATRIX, (PTR_DESCRIPTOR)c);
      break;
    default:
      controlled_exit("unknown class in munite");
  }
success:
  DBUG_RETURN(mvt_desc);
}



T_PTD t_munite_rr(int a, T_PTD b, T_PTD c, int class_b, int class_c, int restype)
{
  T_PTD help;
  double *bmvt, *cmvt, *imvt;
  int brows, bcols, crows, ccols, dim, nrows, ncols, i, j;
  DBUG_ENTER("t_munite_rr");
  
  brows = R_MVT(DESC(b), nrows, class_b);
  crows = R_MVT(DESC(c), nrows, class_c);
  bcols = R_MVT(DESC(b), ncols, class_b);
  ccols = R_MVT(DESC(c), ncols, class_c);
  if (TY_UNDEF == R_MVT(DESC(b), type, class_b))
    goto nilmat;
  if (TY_UNDEF == R_MVT(DESC(c), type, class_c))
  {
    help = b;
    b = c;
    c = help;
    i = class_b;
    class_b = class_c;
    class_c = i;
    goto nilmat;
  }
  
  bmvt = (double *)R_MVT(DESC(b), ptdv, class_b);
  cmvt = (double *)R_MVT(DESC(c), ptdv, class_c);
  if (1 == a)
  {
    if (bcols != ccols)
      controlled_exit("dimensions don't fit in munite");
    ncols = bcols;
    nrows = brows + crows;
    dim = ncols * nrows;
    MAKEDESC(mvt_desc, 1, C_MATRIX, restype);
    L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
    L_MVT(*mvt_desc, nrows, C_MATRIX) = nrows;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = ncols;
    GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
    RES_HEAP;
    imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    dim = ncols * brows;
    for (i = 0; i < dim; i++)
      *imvt++ = *bmvt++;
    dim = ncols * crows;
    for (i = 0; i < dim; i++)
      *imvt++ = *cmvt++;
    REL_HEAP;
    goto success;
  } /* if (1 == a) */
  else if (2 == a)
  {
    if (brows != crows)
      controlled_exit("dimensions don't fit in munite");
    ncols = bcols + ccols;
    nrows = brows;
    dim = ncols * nrows;
    MAKEDESC(mvt_desc, 1, C_MATRIX, restype);
    L_MVT(*mvt_desc, ptdd, C_MATRIX) = NULL;
    L_MVT(*mvt_desc, nrows, C_MATRIX) = nrows;
    L_MVT(*mvt_desc, ncols, C_MATRIX) = ncols;
    GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
    RES_HEAP;
    imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
    for (i = 0; i < nrows; i++)
    {
      for (j = 0; j < bcols; j++)
        *imvt++ = *bmvt++;
      for ( j = 0; j < ccols; j++)
        *imvt++ = *cmvt++;
    }     
    REL_HEAP;
    goto success;
  } /* if (2 == a) */
  else
    controlled_exit("first arg in munite is not 1 or 2");
nilmat:
/* argument 2 is empty mat */
  switch(class_c)
  {
    case C_MATRIX:
      if (TY_UNDEF == R_MVT(DESC(c), type, class_c))
      {
        INC_REFCNT(_nilmat);
        mvt_desc = _nilmat;
        goto success;
      }
      else
      { 
        INC_REFCNT(c);
        mvt_desc = (PTR_DESCRIPTOR)gen_many_id(C_MATRIX, (PTR_DESCRIPTOR)c);
        goto success;
      }
      break;
    case C_VECTOR:
    case C_TVECTOR:
      if (TY_UNDEF == R_MVT(DESC(c), type, class_c))
      {
        INC_REFCNT(_nilmat);
        mvt_desc = (PTR_DESCRIPTOR)_nilmat;
        goto success;
      }
      else
        mvt_desc = (PTR_DESCRIPTOR)gen_many_id(C_MATRIX, (PTR_DESCRIPTOR)c);
      break;
    default:
      controlled_exit("unknown class in munite");
  }
success:
  DBUG_RETURN(mvt_desc);
}
@


1.13
log
@ifdef -> if where necessary
@
text
@d1008 3
a1010 1
  switch(class)
d1012 16
a1027 21
    case C_VECTOR:
    case C_TVECTOR:
      dim = rows * cols;
      MAKEDESC(mvt_desc, 1, C_LIST, TY_UNDEF);
      L_LIST(*mvt_desc, ptdd) = NULL;
      L_LIST(*mvt_desc, special) = NULL;
      L_LIST(*mvt_desc, dim) = dim;
      GET_HEAP(dim, A_LIST(*mvt_desc, ptdv));
      RES_HEAP;
      pth = R_LIST(*mvt_desc,ptdv);
      RES_HEAP;
      switch(type)
      {
        case TY_INTEGER:
          for (i = 0; i < dim; i++)
            pth[i] = TAG_INT(R_MVT(DESC(a), ptdv, class)[i]);
          break;
        case TY_REAL:
          {
            double *rmvt, valr;
            rmvt = (double *)R_MVT(DESC(a), ptdv, class);
d1029 3
d1033 8
a1040 3
              MAKEDESC(h_desc, 1, C_SCALAR, TY_REAL);
              L_SCALAR(*h_desc, valr) = rmvt[i];
              pth[i] = (T_HEAPELEM)h_desc; 
d1042 18
a1059 37
          }
          break;
        case TY_BOOL:
          for (i = 0; i < dim; i++)
            pth[i] = R_MVT(DESC(a), ptdv, class)[i] ? SA_TRUE : SA_FALSE;
          break;
        default: controlled_exit("unknown type in t_to_list");
      }
      REL_HEAP;
      break;
    case C_MATRIX:
      MAKEDESC(mvt_desc, 1, C_LIST, TY_UNDEF);
      L_LIST(*mvt_desc, ptdd) = NULL;
      L_LIST(*mvt_desc, special) = NULL;
      L_LIST(*mvt_desc, dim) = rows;
      GET_HEAP(rows, A_LIST(*mvt_desc, ptdv));
      switch(type)
      {
        case TY_INTEGER:
          for (i = 0; i < rows; i++)
          {
            MAKEDESC(h_desc, 1, C_LIST, TY_UNDEF);
            GET_HEAP(cols, A_LIST(*h_desc, ptdv));
            RES_HEAP;
            L_LIST(*mvt_desc, ptdv)[i] = (T_HEAPELEM)h_desc;
            L_LIST(*h_desc, ptdd) = NULL;
            L_LIST(*h_desc, special) = NULL;
            L_LIST(*h_desc, dim) = cols;
            pth = R_LIST(*h_desc, ptdv);
            for (j = 0; j < cols; j++)
              pth[j] = TAG_INT(R_MVT(DESC(a), ptdv, class)[i * cols + j]);
            REL_HEAP;
          }
          break;
        case TY_REAL:
          {
            double *rmvt, valr;
d1070 2
a1071 1
              rmvt = (double *)R_MVT(DESC(a), ptdv, class);
d1073 6
a1078 1
	      for (j = 0; j < cols; j++)
d1080 2
a1081 1
                MAKEDESC(r_desc, 1, C_SCALAR, TY_REAL);
d1083 6
a1088 2
                L_SCALAR(*r_desc, valr) = rmvt[i * cols + j];
                pth[j] = (T_HEAPELEM)r_desc; 
d1090 8
d1100 21
a1120 21
          }
          break;
        case TY_BOOL:
          for (i = 0; i < rows; i++)
          {
            MAKEDESC(h_desc, 1, C_LIST, TY_UNDEF);
            GET_HEAP(cols, A_LIST(*h_desc, ptdv));
            RES_HEAP;
            L_LIST(*mvt_desc, ptdv)[i] = (T_HEAPELEM)h_desc;
            L_LIST(*h_desc, ptdd) = NULL;
            L_LIST(*h_desc, special) = NULL;
            L_LIST(*h_desc, dim) = cols;
            pth = R_LIST(*h_desc, ptdv);
            for (j = 0; j < cols; j++)
              pth[j] = R_MVT(DESC(a), ptdv, class)[i * cols + j] ? SA_TRUE : SA_FALSE;
            REL_HEAP;
          }
          break;
        default: controlled_exit("unknown type in t_to_list");
      }
      break;
d1286 2
a1287 2
    INC_REFCNT(b);
    DBUG_RETURN((b));
d1341 2
a1342 2
    INC_REFCNT(b);
    DBUG_RETURN((b));
d1429 13
d1733 2
d1736 1
d1924 13
d1975 13
a1998 2
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT((*mvt_desc), ptdd, C_MATRIX) = NULL;
d2001 21
a2021 11
  L_MVT(*mvt_desc, nrows, C_MATRIX) = cols;
  L_MVT(*mvt_desc, ncols, C_MATRIX) = rows;
  dim = rows * cols;
  GET_HEAP(dim, A_MVT(*mvt_desc, ptdv, C_MATRIX));
  amvt = (int *)R_MVT(DESC(a), ptdv, C_MATRIX);
  imvt = (int *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
  RES_HEAP;
  for (j = 0; j < rows; j++)
    for (i = 0; i < cols; i++)
      imvt[i * rows + j] = amvt[i + j * cols];
  REL_HEAP;
a2032 2
  MAKEDESC(mvt_desc, 1, C_MATRIX, type);
  L_MVT((*mvt_desc), ptdd, C_MATRIX) = NULL;
d2035 21
a2055 11
  L_MVT(*mvt_desc, nrows, C_MATRIX) = cols;
  L_MVT(*mvt_desc, ncols, C_MATRIX) = rows;
  dim = rows * cols;
  GET_HEAP(dim * sizeof(double), A_MVT(*mvt_desc, ptdv, C_MATRIX));
  amvt = (double *)R_MVT(DESC(a), ptdv, C_MATRIX);
  imvt = (double *)R_MVT(*mvt_desc, ptdv, C_MATRIX);
  RES_HEAP;
  for (j = 0; j < rows; j++)
    for (i = 0; i < cols; i++)
      imvt[i * rows + j] = amvt[i + j * cols];
  REL_HEAP;
@


1.12
log
@empty matrix operations
@
text
@a0 1
#ifndef WITHTILDE
a1 1
#endif
@


1.11
log
@and or xor on bmat
to_mat
max, min on mat
@
text
@d1389 7
d1619 2
d1622 1
d1863 8
d2395 26
d2842 457
@


1.10
log
@ltransform mreplace
@
text
@d2375 423
@


1.9
log
@mrotate mreplace_[cr] mdim transpose
@
text
@d2320 55
@


1.8
log
@transform
@
text
@d40 1
a40 1
  double *rmvt;
d203 1
a203 1
  double *rmvt;
d366 1
a366 1
  double *rmvt;
d528 1
a528 1
  double *rmvt;
d691 1
a691 1
  double *rmvt;
d853 1
a853 1
  double *rmvt;
d1126 2
a1127 2
  int *ip, *ipnew;
  double *rp, *rpnew;
d1180 2
a1181 2
  int *ip, *ipnew;
  double *rp, *rpnew;
d1256 1
a1256 1
  double *rmvt;
d1271 2
a1272 2
  int *ipnew, *ip, pos, elem, i;
  double *rpnew, *rp;
d1332 1
a1332 1
  int *ipnew, *ip, pos, elem, i;
d1539 1
a1539 1
  int dim, i, *imvt;
d1572 1
a1572 1
  double *rmvt, *crmvt;
d1853 466
@


1.7
log
@mcut
@
text
@d1788 66
@


1.6
log
@access macros corrected
vreplace
@
text
@d1600 188
@


1.5
log
@vselect, vunite vrotate, vcut
@
text
@d39 1
a39 1
  int rows, cols, i;
d45 9
a53 8
    rows = R_MVT(*b, nrows, 1);
    cols = R_MVT(*b, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*b, type, 1))
d58 2
a59 2
          if (R_MVT(*b, ptdv, 1)[i] == VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d61 1
a61 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d65 1
a65 1
        rmvt = (double *)R_MVT(*b, ptdv, 1);
d69 1
a69 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d71 1
a71 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d80 9
a88 8
    rows = R_MVT(*b, nrows, 1);
    cols = R_MVT(*b, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*b, type, 1))
d93 2
a94 2
          if ((double)(R_MVT(*b, ptdv, 1)[i] == R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d96 1
a96 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d100 1
a100 1
        rmvt = (double *)R_MVT(*b, ptdv, 1);
d104 1
a104 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d106 1
a106 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d115 9
a123 8
    rows = R_MVT(*a, nrows, 1);
    cols = R_MVT(*a, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*a, type, 1))
d128 2
a129 2
          if (R_MVT(*a, ptdv, 1)[i] == VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d131 1
a131 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d135 1
a135 1
        rmvt = (double *)R_MVT(*a, ptdv, 1);
d139 1
a139 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d141 1
a141 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d150 9
a158 8
    rows = R_MVT(*a, nrows, 1);
    cols = R_MVT(*a, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*a, type, 1))
d163 2
a164 2
          if ((double)(R_MVT(*a, ptdv, 1)[i] == R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d166 1
a166 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d170 1
a170 1
        rmvt = (double *)R_MVT(*a, ptdv, 1);
d174 1
a174 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d176 1
a176 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d201 1
d208 9
a216 8
    rows = R_MVT(*b, nrows, 1);
    cols = R_MVT(*b, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*b, type, 1))
d221 2
a222 2
          if (R_MVT(*b, ptdv, 1)[i] != VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d224 1
a224 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d228 1
a228 1
        rmvt = (double *)R_MVT(*b, ptdv, 1);
d232 1
a232 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d234 1
a234 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d243 9
a251 8
    rows = R_MVT(*b, nrows, 1);
    cols = R_MVT(*b, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*b, type, 1))
d256 2
a257 2
          if ((double)(R_MVT(*b, ptdv, 1)[i] != R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d259 1
a259 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d263 1
a263 1
        rmvt = (double *)R_MVT(*b, ptdv, 1);
d267 1
a267 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d269 1
a269 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d278 9
a286 8
    rows = R_MVT(*a, nrows, 1);
    cols = R_MVT(*a, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*a, type, 1))
d291 2
a292 2
          if (R_MVT(*a, ptdv, 1)[i] != VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d294 1
a294 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d298 1
a298 1
        rmvt = (double *)R_MVT(*a, ptdv, 1);
d302 1
a302 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d304 1
a304 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d313 9
a321 8
    rows = R_MVT(*a, nrows, 1);
    cols = R_MVT(*a, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*a, type, 1))
d326 2
a327 2
          if ((double)(R_MVT(*a, ptdv, 1)[i] != R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d329 1
a329 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d333 1
a333 1
        rmvt = (double *)R_MVT(*a, ptdv, 1);
d337 1
a337 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d339 1
a339 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d364 1
d371 9
a379 8
    rows = R_MVT(*b, nrows, 1);
    cols = R_MVT(*b, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*b, type, 1))
d384 2
a385 2
          if (R_MVT(*b, ptdv, 1)[i] >= VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d387 1
a387 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d391 1
a391 1
        rmvt = (double *)R_MVT(*b, ptdv, 1);
d395 1
a395 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d397 1
a397 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d406 9
a414 8
    rows = R_MVT(*b, nrows, 1);
    cols = R_MVT(*b, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*b, type, 1))
d419 2
a420 2
          if ((double)(R_MVT(*b, ptdv, 1)[i] >= R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d422 1
a422 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d426 1
a426 1
        rmvt = (double *)R_MVT(*b, ptdv, 1);
d430 1
a430 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d432 1
a432 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d441 9
a449 8
    rows = R_MVT(*a, nrows, 1);
    cols = R_MVT(*a, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*a, type, 1))
d454 2
a455 2
          if (R_MVT(*a, ptdv, 1)[i] <= VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d457 1
a457 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d461 1
a461 1
        rmvt = (double *)R_MVT(*a, ptdv, 1);
d465 1
a465 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d467 1
a467 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d476 9
a484 8
    rows = R_MVT(*a, nrows, 1);
    cols = R_MVT(*a, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*a, type, 1))
d489 2
a490 2
          if ((double)(R_MVT(*a, ptdv, 1)[i] >= R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d492 1
a492 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d496 1
a496 1
        rmvt = (double *)R_MVT(*a, ptdv, 1);
d500 1
a500 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d502 1
a502 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d526 1
d533 9
a541 8
    rows = R_MVT(*b, nrows, 1);
    cols = R_MVT(*b, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*b, type, 1))
d546 2
a547 2
          if (R_MVT(*b, ptdv, 1)[i] <= VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d549 1
a549 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d553 1
a553 1
        rmvt = (double *)R_MVT(*b, ptdv, 1);
d557 1
a557 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d559 1
a559 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d568 9
a576 8
    rows = R_MVT(*b, nrows, 1);
    cols = R_MVT(*b, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*b, type, 1))
d581 2
a582 2
          if ((double)(R_MVT(*b, ptdv, 1)[i] <= R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d584 1
a584 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d588 1
a588 1
        rmvt = (double *)R_MVT(*b, ptdv, 1);
d592 1
a592 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d594 1
a594 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d603 9
a611 8
    rows = R_MVT(*a, nrows, 1);
    cols = R_MVT(*a, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*a, type, 1))
d616 2
a617 2
          if (R_MVT(*a, ptdv, 1)[i] >= VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d619 1
a619 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d623 1
a623 1
        rmvt = (double *)R_MVT(*a, ptdv, 1);
d627 1
a627 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d629 1
a629 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d638 9
a646 8
    rows = R_MVT(*a, nrows, 1);
    cols = R_MVT(*a, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*a, type, 1))
d651 2
a652 2
          if ((double)(R_MVT(*a, ptdv, 1)[i] <= R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d654 1
a654 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d658 1
a658 1
        rmvt = (double *)R_MVT(*a, ptdv, 1);
d662 1
a662 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d664 1
a664 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d689 1
d696 9
a704 8
    rows = R_MVT(*b, nrows, 1);
    cols = R_MVT(*b, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*b, type, 1))
d709 2
a710 2
          if (R_MVT(*b, ptdv, 1)[i] < VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d712 1
a712 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d716 1
a716 1
        rmvt = (double *)R_MVT(*b, ptdv, 1);
d720 1
a720 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d722 1
a722 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d731 9
a739 8
    rows = R_MVT(*b, nrows, 1);
    cols = R_MVT(*b, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*b, type, 1))
d744 2
a745 2
          if ((double)(R_MVT(*b, ptdv, 1)[i] < R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d747 1
a747 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d751 1
a751 1
        rmvt = (double *)R_MVT(*b, ptdv, 1);
d755 1
a755 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d757 1
a757 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d766 9
a774 8
    rows = R_MVT(*a, nrows, 1);
    cols = R_MVT(*a, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*a, type, 1))
d779 2
a780 2
          if (R_MVT(*a, ptdv, 1)[i] > VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d782 1
a782 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d786 1
a786 1
        rmvt = (double *)R_MVT(*a, ptdv, 1);
d790 1
a790 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d792 1
a792 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d801 9
a809 8
    rows = R_MVT(*a, nrows, 1);
    cols = R_MVT(*a, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*a, type, 1))
d814 2
a815 2
          if ((double)(R_MVT(*a, ptdv, 1)[i] < R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d817 1
a817 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d821 1
a821 1
        rmvt = (double *)R_MVT(*a, ptdv, 1);
d825 1
a825 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d827 1
a827 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d851 1
d858 9
a866 8
    rows = R_MVT(*b, nrows, 1);
    cols = R_MVT(*b, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*b, type, 1))
d871 2
a872 2
          if (R_MVT(*b, ptdv, 1)[i] > VAL_INT((int)a))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d874 1
a874 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d878 1
a878 1
        rmvt = (double *)R_MVT(*b, ptdv, 1);
d882 1
a882 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d884 1
a884 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d893 9
a901 8
    rows = R_MVT(*b, nrows, 1);
    cols = R_MVT(*b, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*b, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*b, type, 1))
d906 2
a907 2
          if ((double)(R_MVT(*b, ptdv, 1)[i] > R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d909 1
a909 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d913 1
a913 1
        rmvt = (double *)R_MVT(*b, ptdv, 1);
d917 1
a917 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d919 1
a919 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d928 9
a936 8
    rows = R_MVT(*a, nrows, 1);
    cols = R_MVT(*a, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*a, type, 1))
d941 2
a942 2
          if (R_MVT(*a, ptdv, 1)[i] < VAL_INT((int)b))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d944 1
a944 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d948 1
a948 1
        rmvt = (double *)R_MVT(*a, ptdv, 1);
d952 1
a952 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d954 1
a954 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d963 9
a971 8
    rows = R_MVT(*a, nrows, 1);
    cols = R_MVT(*a, nrows, 1);
    MAKEDESC(mvt_desc, 1, R_MVT(*a, class, 1), TY_BOOL);
    L_MVT((*mvt_desc), ptdd, 1) = NULL;
    L_MVT(*mvt_desc, nrows, 1) = rows;
    L_MVT(*mvt_desc, ncols, 1) = cols;
    GET_HEAP(rows * cols, A_MVT((*mvt_desc), ptdv, 1));
    switch(R_MVT(*a, type, 1))
d976 2
a977 2
          if ((double)(R_MVT(*a, ptdv, 1)[i] > R_SCALAR(*a, valr)))
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d979 1
a979 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d983 1
a983 1
        rmvt = (double *)R_MVT(*a, ptdv, 1);
d987 1
a987 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = TRUE;
d989 1
a989 1
            L_MVT(*mvt_desc, ptdv, 1)[i] = FALSE;
d1532 65
@


1.4
log
@to_list
@
text
@d1092 414
@


1.3
log
@RES_HEAP <-> REL_HEAP corrected
@
text
@d22 1
a22 1
  
d966 123
@


1.2
log
@functions for comparison between int, real and mvt
@
text
@a50 1
    RES_HEAP;
a61 1
        REL_HEAP;
a71 1
        REL_HEAP;
a84 1
    RES_HEAP;
a95 1
        REL_HEAP;
a105 1
        REL_HEAP;
a118 1
    RES_HEAP;
a129 1
        REL_HEAP;
a139 1
        REL_HEAP;
a152 1
    RES_HEAP;
a163 1
        REL_HEAP;
a173 1
        REL_HEAP;
a208 1
    RES_HEAP;
a219 1
        REL_HEAP;
a229 1
        REL_HEAP;
a242 1
    RES_HEAP;
a253 1
        REL_HEAP;
a263 1
        REL_HEAP;
a276 1
    RES_HEAP;
a287 1
        REL_HEAP;
a297 1
        REL_HEAP;
a310 1
    RES_HEAP;
a321 1
        REL_HEAP;
a331 1
        REL_HEAP;
a366 1
    RES_HEAP;
a377 1
        REL_HEAP;
a387 1
        REL_HEAP;
a400 1
    RES_HEAP;
a411 1
        REL_HEAP;
a421 1
        REL_HEAP;
a434 1
    RES_HEAP;
a445 1
        REL_HEAP;
a455 1
        REL_HEAP;
a468 1
    RES_HEAP;
a479 1
        REL_HEAP;
a489 1
        REL_HEAP;
a523 1
    RES_HEAP;
a534 1
        REL_HEAP;
a544 1
        REL_HEAP;
a557 1
    RES_HEAP;
a568 1
        REL_HEAP;
a578 1
        REL_HEAP;
a591 1
    RES_HEAP;
a602 1
        REL_HEAP;
a612 1
        REL_HEAP;
a625 1
    RES_HEAP;
a636 1
        REL_HEAP;
a646 1
        REL_HEAP;
a681 1
    RES_HEAP;
a692 1
        REL_HEAP;
a702 1
        REL_HEAP;
a715 1
    RES_HEAP;
a726 1
        REL_HEAP;
a736 1
        REL_HEAP;
a749 1
    RES_HEAP;
a760 1
        REL_HEAP;
a770 1
        REL_HEAP;
a783 1
    RES_HEAP;
a794 1
        REL_HEAP;
a804 1
        REL_HEAP;
a838 1
    RES_HEAP;
a849 1
        REL_HEAP;
a859 1
        REL_HEAP;
a872 1
    RES_HEAP;
a883 1
        REL_HEAP;
a893 1
        REL_HEAP;
a906 1
    RES_HEAP;
a917 1
        REL_HEAP;
a927 1
        REL_HEAP;
a940 1
    RES_HEAP;
a951 1
        REL_HEAP;
a961 1
        REL_HEAP;
@


1.1
log
@Initial revision
@
text
@d58 1
a58 1
          if (R_MVT(*b, ptdv, 1)[i] == (int)a)
d132 1
a132 1
          if (R_MVT(*a, ptdv, 1)[i] == (int)b)
d228 1
a228 1
          if (R_MVT(*b, ptdv, 1)[i] != (int)a)
d302 1
a302 1
          if (R_MVT(*a, ptdv, 1)[i] != (int)b)
d398 1
a398 1
          if (R_MVT(*b, ptdv, 1)[i] >= (int)a)
d472 1
a472 1
          if (R_MVT(*a, ptdv, 1)[i] <= (int)b)
d567 1
a567 1
          if (R_MVT(*b, ptdv, 1)[i] <= (int)a)
d641 1
a641 1
          if (R_MVT(*a, ptdv, 1)[i] >= (int)b)
d737 1
a737 1
          if (R_MVT(*b, ptdv, 1)[i] < (int)a)
d811 1
a811 1
          if (R_MVT(*a, ptdv, 1)[i] > (int)b)
d906 1
a906 1
          if (R_MVT(*b, ptdv, 1)[i] > (int)a)
d980 1
a980 1
          if (R_MVT(*a, ptdv, 1)[i] < (int)b)
@
