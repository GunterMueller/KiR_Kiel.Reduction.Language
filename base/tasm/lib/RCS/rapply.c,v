head	1.33;
access;
symbols;
locks; strict;
comment	@ * @;


1.33
date	96.04.26.16.24.40;	author cr;	state Exp;
branches;
next	1.32;

1.32
date	96.03.11.14.48.32;	author cr;	state Exp;
branches;
next	1.31;

1.31
date	96.02.22.16.19.01;	author stt;	state Exp;
branches;
next	1.30;

1.30
date	96.02.20.14.46.13;	author stt;	state Exp;
branches;
next	1.29;

1.29
date	96.02.19.18.32.11;	author sf;	state Exp;
branches;
next	1.28;

1.28
date	96.02.13.16.36.56;	author sf;	state Exp;
branches;
next	1.27;

1.27
date	96.02.07.11.30.05;	author sf;	state Exp;
branches;
next	1.26;

1.26
date	96.02.05.10.31.43;	author sf;	state Exp;
branches;
next	1.25;

1.25
date	95.07.19.12.34.35;	author sf;	state Exp;
branches;
next	1.24;

1.24
date	95.07.10.13.59.46;	author car;	state Exp;
branches;
next	1.23;

1.23
date	95.06.29.11.00.48;	author sf;	state Exp;
branches;
next	1.22;

1.22
date	95.06.28.12.17.33;	author sf;	state Exp;
branches;
next	1.21;

1.21
date	95.06.28.09.58.43;	author sf;	state Exp;
branches;
next	1.20;

1.20
date	95.05.23.08.18.44;	author sf;	state Exp;
branches;
next	1.19;

1.19
date	95.05.09.11.05.49;	author sf;	state Exp;
branches;
next	1.18;

1.18
date	95.04.05.13.56.38;	author sf;	state Exp;
branches;
next	1.17;

1.17
date	95.03.24.09.07.40;	author sf;	state Exp;
branches;
next	1.16;

1.16
date	95.03.15.08.27.56;	author sf;	state Exp;
branches;
next	1.15;

1.15
date	95.03.10.16.15.04;	author sf;	state Exp;
branches;
next	1.14;

1.14
date	95.03.08.12.32.00;	author sf;	state Exp;
branches;
next	1.13;

1.13
date	95.03.07.16.17.26;	author sf;	state Exp;
branches;
next	1.12;

1.12
date	95.03.06.16.55.47;	author sf;	state Exp;
branches;
next	1.11;

1.11
date	95.03.06.15.49.05;	author sf;	state Exp;
branches;
next	1.10;

1.10
date	95.02.02.14.09.47;	author sf;	state Exp;
branches;
next	1.9;

1.9
date	95.01.06.16.52.00;	author sf;	state Exp;
branches;
next	1.8;

1.8
date	95.01.02.12.23.21;	author sf;	state Exp;
branches;
next	1.7;

1.7
date	94.12.29.14.46.53;	author sf;	state Exp;
branches;
next	1.6;

1.6
date	94.12.29.10.28.33;	author sf;	state Exp;
branches;
next	1.5;

1.5
date	94.12.22.13.45.40;	author sf;	state Exp;
branches;
next	1.4;

1.4
date	94.12.21.16.37.04;	author sf;	state Exp;
branches;
next	1.3;

1.3
date	94.12.20.09.21.03;	author sf;	state Exp;
branches;
next	1.2;

1.2
date	94.12.16.13.47.24;	author sf;	state Exp;
branches;
next	1.1;

1.1
date	94.12.16.08.16.06;	author sf;	state Exp;
branches;
next	;


desc
@initial revision
@


1.33
log
@need T_PTD in rmkclos.h
@
text
@#define WITHTILDE 1
#include "rprimf.h"

#define PROLOG_EXTERN
#include "prolog.h"
#include "rmkclos.h"

/* rts() only for popfree_t */
#define rts()          DBUG_RETURN(kill_bits(pop(r)))

extern int call_func;


extern int lab;
extern int red_cnt;

#ifdef __sparc__
#if (0==NO_STACK_REG)
  register int *st_h asm ("g5");
  register int *st_w asm ("g7");
  register int *st_a asm ("g6");
#else
  extern int *st_h;
  extern int *st_w;
  extern int *st_a;
#endif
#else
  extern int *st_h;
  extern int *st_w;
  extern int *st_a;
#endif

extern int *st_t;
extern int *st_r;
extern PTR_DESCRIPTOR funcdesctable[];
extern char *functable[];
extern FCTPTR dealloc_tab[];
extern T_DESCRIPTOR *newdesc();
extern int newheap(int, T_HEAPELEM);
extern FCTPTR red_func_tab[];

int rest_args;

extern int withtilde;
extern int number_of_descs;
extern PTR_DESCRIPTOR _desc;

PTR_HEAPELEM pth; /* pointer to heapelement */
T_PTD ptdesc;     /* pointer to descriptor */
T_PTD help_pt;     /* pointer to descriptor */



/**********************************************************************/

int f_popfree_t(void)
{
  int killvar;
  DBUG_ENTER("f_popfree_t");
  
  killvar = pop(r);
  while (killvar > 0) 
  {
    ptdesc = (T_PTD)pop(t);
    T_DEC_REFCNT(ptdesc);
    killvar--;
  }
  rts();
}  

/**********************************************************************/
/* calls a primitive function from the reduma runtime library         */
/* n        : number of actual parameters (fits the needed parameters)*/ 
/* d_ptdesc : the primitive function to call                          */
/**********************************************************************/

void delta_reduct(int n, T_PTD d_ptdesc)
{
  int delta_ok = 1;

  DBUG_ENTER("delta_reduct");
  
  drop(w, 1);
  switch(n)
  {
  case 1:
  {
    if (!(*(red_func_tab[FUNC_INDEX((int)d_ptdesc)]))(top(w)))
    {
      f_mkdclos(-1, 1, 1, (int)d_ptdesc);
      delta_ok = 0;
    }
    break;
  }
  case 2:
  {
    if (!(*(red_func_tab[FUNC_INDEX((int)d_ptdesc)]))(top(w), peek(w,1)))
    {
      f_mkdclos(-1, 2, 2, (int)d_ptdesc);
      delta_ok = 0;
    }
    break;
  }
  case 3:
  {
    if (!(*(red_func_tab[FUNC_INDEX((int)d_ptdesc)]))(top(w), peek(w,1), \
                                                    peek(w,2)))
    {
      f_mkdclos(-1, 3, 3, (int)d_ptdesc);
      delta_ok = 0;
    }
    break;
  }
  case 4:
  {
    if (!(*(red_func_tab[FUNC_INDEX((int)d_ptdesc)]))(top(w), peek(w,1), \
                                                    peek(w,2), peek(w,3)))
    {
      f_mkdclos(-1, 4, 4, (int)d_ptdesc);
      delta_ok = 0;
    }
    break;
  }
  default:
  {
    fprintf(stderr, "f_apply: pf_arity out of range (apply)");
    exit(1);
  }
  } /* END switch(n) */
  
  if (delta_ok)
  {
    drop(w, n);
    push((int)_desc);
    _desc = NULL;
  }
  DBUG_VOID_RETURN;
}

/**********************************************************************/
/* n    : actual args  (on top of stack R)                            */
/*        return label (second on Stack R)                            */
/*        return function (third on Stack R)                          */
/* result : NULL if no (gamma)beta call, else address of function     */
/*          to call                                                   */
/* if func is a userdefined function, it is always a closure, even if */
/* there haven't been any actual arguments (closure with no args)     */
/**********************************************************************/

int f_apply(void)
{
  int arg, nfv, sargs;
  int n;

  DBUG_ENTER("f_apply");

    n = pop(r);

LabSwitch:
L0:  
  ptdesc = (T_PTD)top(w);
  
/********************************************************************/
/* test, if PRIM FUNC                            test, if PRIM FUNC */
/********************************************************************/
  if(T_FUNC((int) ptdesc))
  {
    if (0 == red_cnt) 
    { 
      drop(w, 1);
      f_mkdclos(-1, FUNC_ARITY((int)ptdesc), n, (int)ptdesc);
      flip_tail();                      /* avoid stackswitch */
      rtf();
    }
/* ENOUGH ARGUMENTS */          
    if (FUNC_ARITY((int)ptdesc) == n)
    {
      delta_reduct(n, ptdesc);
      flip_tail();                      /* avoid stackswitch */
      rtf();
    } /* END if (FUNC_ARITY((int)ptdesc) == n) */
    else 
/* NOT ENOUGH ARGUMENTS */          
    if (FUNC_ARITY((int)ptdesc) > n)
    {
      drop(w, 1);  /* 'cause f_mkdclos() pushes the function itself */
      f_mkdclos(-1, FUNC_ARITY((int)ptdesc), n, (int)ptdesc);
      flip_tail();                      /* avoid stackswitch */
      rtf();
    } /* END if (FUNC_ARITY((int)ptdesc) < n) */
/* TOO MANY ARGUMENTS */          
    else  /* FUNC_ARITY((int)ptdesc) < n */
    {
too_many_delta:
      if (LSELECT == (int)ptdesc)
      {
        delta_reduct(2, ptdesc);
        n -= 2; /* start a new apply with n - 2 act args */
        goto L0;
      }
      else
      {
        rest_args = n - FUNC_ARITY((int)ptdesc);

        delta_reduct(FUNC_ARITY((int)ptdesc), ptdesc);

        /* auslagern einer applikation vgl. store_e in rstpro.c */
        MAKEDESC(ptdesc, 1, C_EXPRESSION, TY_EXPR);
        GET_HEAP(rest_args + 3, (int)A_EXPR(*ptdesc, pte));
        RES_HEAP;
        pth    = (PTR_HEAPELEM)R_EXPR(*ptdesc, pte);
        *pth++ = (T_HEAPELEM)(rest_args + 2);             /* groesse     */
        *pth++ = (T_HEAPELEM)SET_ARITY(AP, (rest_args + 1)); /* konstruktor */
        pth += rest_args;
        do {
          *pth-- = (T_HEAPELEM)pop(w);
        } while (--rest_args >= 0);
        REL_HEAP;
        push((int)ptdesc);
      }        
      flip_tail();                      /* avoid stackswitch */
      rtf();
    }  /* END FUNC_ARITY((int)ptdesc) > n */
  } /* END if(T_FUNC((int) ptdesc)) */
/********************************************************************/
/* END IF PRIMFUNC                                  END IF PRIMFUNC */
/********************************************************************/

/********************************************************************/
/* test, if INTERACTION                        test, if INTERACTION */
/********************************************************************/
  else if(T_IAFUNC((int) ptdesc))
  {
    if (FUNC_ARITY((int)ptdesc) == n)           /* ENOUGH ARGUMENTS */
    {
      drop(w,1);
      mkintact((int) ptdesc);
      flip_tail();
      rtf();
    }
    else if (FUNC_ARITY((int)ptdesc) > n)   /* NOT ENOUGH ARGUMENTS */
    {
      f_mkiclos(n);
      flip_tail();
      rtf();
    }
    else                                      /* TOO MANY ARGUMENTS */
    {
      drop(w,1);
      mkintact((int) ptdesc);

      n -= FUNC_ARITY((int)ptdesc);
      goto T_mkap;
    }
  }
/********************************************************************/
/* END, if INTERACTION                          END, if INTERACTION */
/********************************************************************/

/********************************************************************/
/* test, if POINTER to closure                     test, if POINTER */
/********************************************************************/
  else if (T_POINTER(ptdesc))
  {
    if (C_FUNC == R_DESC(*ptdesc, class))
    {

/* test, if a closure */
      if (TY_CLOS == R_DESC(*ptdesc, type))
      {
        arg = R_CLOS(*ptdesc, nargs);
/* arg : needed arguments, nfv : free variables */
/********************************************************************/
/* test, if primitive function closure                              */
/********************************************************************/
        if (TY_PRIM == R_CLOS(*ptdesc, ftype))
        {
          if (0 == red_cnt)
          {
            dyn_mkbclos(n);
            flip_tail();                      /* avoid stackswitch */
            rtf();
          }
                                                                
/* ENOUGH ARGUMENTS */          
          if (n == arg)
          {
            nfv = 0;
            sargs = R_CLOS(*ptdesc, args);
            n += sargs;  /* prepare the GOTO L0; to execute the delta_red */
            drop(w, 1);  /* POP function */
            pth = R_CLOS(*ptdesc, pta);
            pth = pth + sargs + nfv;
            while (sargs-- > 0) /* restore the argument frame */
            {
              help_pt = (T_PTD)*pth--;
              T_INC_REFCNT(help_pt);
              push((int)help_pt);
            } 
            
/* NO stflip(a,w); 'cause it's now a DELTA-call */

            help_pt = ptdesc;              
            ptdesc = (T_PTD)*R_CLOS(*ptdesc, pta);
            DEC_REFCNT(help_pt);
            push((int)ptdesc);
            goto L0;
          } /* END (arg == n) in PRIM CLOS */
          else
/* NOT ENOUGH ARGUMENTS */          
          if (n < arg)
          {
            dyn_mkbclos(n);
            flip_tail();                      /* avoid stackswitch */
            rtf();
          } /* END (n < arg) */
/* TOO MANY ARGUMENTS */          
          else /* (n > arg) */
          {
            sargs = R_CLOS(*ptdesc, args);
            n += sargs;  /* prepare the GOTO L0; to execute the delta_red */
            drop(w, 1);  /* POP closure */
            pth = R_CLOS(*ptdesc, pta);
            pth += sargs;
            while (sargs-- > 0) /* restore the argument frame */
            {
              help_pt = (T_PTD)*pth--;
              T_INC_REFCNT(help_pt);
              push((int)help_pt);
            } 
/* NO stflip(a,w); 'cause it's now a DELTA-call */

            help_pt = ptdesc;              
            ptdesc = (T_PTD)*R_CLOS(*ptdesc, pta);
            DEC_REFCNT(help_pt);
            push((int)ptdesc);
            goto too_many_delta;
          } /* END n > arg */
        } 
/********************************************************************/
/* END primitive function closure                                   */
/********************************************************************/
          
/********************************************************************/
/* test, if interaction closure                                     */
/********************************************************************/
        else if (TY_INTACT == R_CLOS(*ptdesc, ftype))
        {
          /* Closure 'auspacken', n um Anzahl vorhandener Argumente */
          /* erhoehen und goto nach L0:                             */
          sargs = R_CLOS(*ptdesc, args);
          n += sargs;  /* prepare the GOTO L0; */
          drop(w, 1);  /* drop closure */
          pth = R_CLOS(*ptdesc, pta);
          pth = pth + sargs;
          while (sargs-- >= 0) /* restore the argument frame */
          {
            help_pt = (T_PTD)*pth--;
            T_INC_REFCNT(help_pt);
            push((int)help_pt);
          }
          DEC_REFCNT(ptdesc);
          goto L0;
        }
/********************************************************************/
/* END,  if interaction closure                                     */
/********************************************************************/

/********************************************************************/
/* test, if userdefined function closure                            */
/********************************************************************/
        else if ((TY_CASE == R_CLOS(*ptdesc, ftype)) ||
            (TY_COMB == R_CLOS(*ptdesc, ftype)))
        {
          if (0 == red_cnt)
          {
            dyn_mkbclos(n);
            flip_tail();                      /* avoid stackswitch */
            rtf();
          }

/* ENOUGH ARGUMENTS */          
          if (n == arg)
          {
            if (withtilde)
              nfv = R_CLOS(*ptdesc,nfv);
            else
              nfv = 0;
            sargs = R_CLOS(*ptdesc, args);
            drop(w, 1);
            pth = R_CLOS(*ptdesc, pta);
            pth = pth + sargs + nfv;
            if (withtilde)
            {
              int dummy = nfv;
              
              while (dummy-- > 0)  /* tilde frame */
              {
                help_pt = (T_PTD)*pth--;
                T_INC_REFCNT(help_pt);
                push_t((int)help_pt);
              }
              while (sargs-- > 0)  /* argument frame */
              {
                help_pt = (T_PTD)*pth--;
                T_INC_REFCNT(help_pt);
                push((int)help_pt);
              }
            }	    
            else 
            {
              while (sargs-- > 0)
              {
                help_pt = (T_PTD)*pth--;
                T_INC_REFCNT(help_pt);
                push((int)help_pt);
              } 
            }
            
            if (withtilde)
            {  
              if (nfv > 0) 
              {
                push_r(nfv);                 /* f_for popfree_t */
                push_r(((int)&f_popfree_t | FUNCTIONRETURN));    
              }
            }

            if (TY_COMB == R_CLOS(*ptdesc, ftype)) 
            {
              stflip(a,w);                     /* don't flip if CASE */
            }
            else
            {
              flip_tail();                    /* but avoid when returning */
            }
            help_pt = ptdesc; 
            { /* cr 11.03.96: first get the information (ptdesc,myptc),
                              then give away the reference (help_pt) */
              T_HEAPELEM *myptc;

              ptdesc = (T_PTD)*R_CLOS(*ptdesc, pta);

              if (TY_CASE == R_DESC(*ptdesc, type))
                myptc = ((int)(R_CASE(*ptdesc, ptc)));
              else
                myptc = ((int)(R_COMB(*ptdesc, ptc)));
              DEC_REFCNT(help_pt); 
              push_r(0); /* so that the called function knows
                            where to start (L0:) */
              DBUG_RETURN((int)myptc);
            }
            /* the fitting rtf() will find the return to the function
                which called the apply (if no other call is in between 
                or if there are free vars to kill it first will find the
                address of f_popfree_t() and f_popfree_t's rtf will find
                the way back  */
          } /* END (arg == n) */
          else
/* NOT ENOUGH ARGUMENTS */            
          if (n < arg)
          {
            dyn_mkbclos(n);
            flip_tail();                      /* avoid stackswitch */
            rtf();
          } /* END (arg < n) */
          else  /* arg > n */
/* TOO MANY ARGUMENTS */            
          {
            if (TY_COMB == R_CLOS(*ptdesc, ftype))
              rest_args = n - R_COMB(*ptdesc, nargs);
            else
              rest_args = n - R_CASE(*ptdesc, nargs);
            push_r(rest_args);
            push_r((int)&f_apply | FUNCTIONRETURN);
            if (TY_COMB == R_CLOS(*ptdesc, ftype))
              n  = R_COMB(*ptdesc, nargs);
            else
              n  = R_CASE(*ptdesc, nargs);

            goto L0;
          }  /* END FUNC_ARITY((int)ptdesc) > n */
        } 
/********************************************************************/
/* END if userdefined function closure Rand CASE                    */
/********************************************************************/
/********************************************************************/
/* test, if conditional closure                                     */
/********************************************************************/
        else if (TY_CONDI == R_CLOS(*ptdesc, ftype))
        {
/* ENOUGH ARGUMENTS */   
/* all COND descriptor accesses via X_COMB 
   `cause it`s saved in COMBINATOR format */
          if (n == arg)
          {
            if (withtilde)
              nfv = R_CLOS(*ptdesc,nfv);
            else
              nfv = 0;
            sargs = R_CLOS(*ptdesc, args);
            pth = R_CLOS(*ptdesc, pta);
            pth = pth + sargs + nfv;
            if (withtilde)
            {
              int dummy = nfv;
              
              while (dummy-- > 0)  /* tilde frame */
              {
                help_pt = (T_PTD)*pth--;
                T_INC_REFCNT(help_pt);
                push_t((int)help_pt);
              }
              while (sargs-- > 0)  /* argument frame */
              {
                help_pt = (T_PTD)*pth--;
                T_INC_REFCNT(help_pt);
                push_a((int)help_pt);
              }
            }	    
            else 
            {
              while (sargs-- > 0)
              {
                help_pt = (T_PTD)*pth--;
                T_INC_REFCNT(help_pt);
                push_a((int)help_pt);
              } 
            }
            if (withtilde)
            {  
              if (nfv > 0) 
              {
                push_r(nfv);                 /* f_for popfree_t */
                push_r(((int)&f_popfree_t | FUNCTIONRETURN));    
              }
            }
            help_pt = ptdesc; 
            ptdesc = (T_PTD)*R_CLOS(*ptdesc, pta);
            DEC_REFCNT(help_pt);
            drop(w, 1);
            flip_tail();       /* avoid stack_switch */
            push_r(0); /* so that the called function knows
                          where to start (L0:) */

            DBUG_RETURN((int)(R_CONDI(*ptdesc, ptc)));
            /* the fitting rtf() will find the return to the function
               which called the apply (if no other call is in between 
               or if there are free vars to kill it first will find the
               address of f_popfree_t() and f_popfree_t's rtf will find
               the way back  */
          } /* END (arg == n) */
          else
          if (n < arg)
          {
            rest_args = n - R_CONDI(*ptdesc, nargs);
            push_r(rest_args);
            push_r((int)&f_apply | FUNCTIONRETURN);
            n  = R_CONDI(*ptdesc, nargs);
            goto L0;
          }

        }
/********************************************************************/
/* END if conditional closure                                       */
/********************************************************************/
      }
    }
    /* All other (e.g. interaction descriptor) goto T_mkap */
    goto T_mkap;
  }
/********************************************************************/
/* END   if POINTER                                END   if POINTER */
/********************************************************************/
  else   /* something irreducible like "ap 5 to [7]" ... */
  {
T_mkap:    
    MAKEDESC(ptdesc, 1, C_EXPRESSION, TY_EXPR);
    GET_HEAP(n + 3, (int)A_EXPR(*ptdesc, pte));
    RES_HEAP;
    pth = (PTR_HEAPELEM)R_EXPR(*ptdesc, pte);
    *pth++ = (T_HEAPELEM)(n + 2);
    *pth++ = (T_HEAPELEM)SET_ARITY(AP,(n + 1));
    pth += n;
    do
    {
      *pth-- = (T_HEAPELEM)pop(w);
    } while (--n >= 0);
    REL_HEAP;
    push((int)ptdesc);
    flip_tail();                      /* avoid stackswitch */
    rtf();
  }
} /* END f_apply() */

@


1.32
log
@don't DEC_REFCNT a pointer if you dereference it later
@
text
@a2 1
#include "rmkclos.h"
d6 1
@


1.31
log
@intact closure
@
text
@d438 15
a452 8
            ptdesc = (T_PTD)*R_CLOS(*ptdesc, pta);
            DEC_REFCNT(help_pt);
            push_r(0); /* so that the called function knows
                          where to start (L0:) */
            if (TY_CASE == R_DESC(*ptdesc, type))
              DBUG_RETURN((int)(R_CASE(*ptdesc, ptc)));
            else
              DBUG_RETURN((int)(R_COMB(*ptdesc, ptc)));
@


1.30
log
@in f_apply() cases for interactions and interaction descriptors added.
@
text
@d204 1
a204 1
        
a222 1

d252 2
a253 16
      rest_args = n - FUNC_ARITY((int)ptdesc);

      MAKEDESC(ptdesc, 1, C_EXPRESSION, TY_EXPR);
      GET_HEAP(rest_args + 3, (int)A_EXPR(*ptdesc, pte));
      RES_HEAP;
      pth    = (PTR_HEAPELEM)R_EXPR(*ptdesc, pte);
      *pth++ = (T_HEAPELEM)(rest_args + 2);             /* groesse     */
      *pth++ = (T_HEAPELEM)SET_ARITY(AP, (rest_args + 1)); /* konstruktor */
      pth += rest_args;
      do {
        *pth-- = (T_HEAPELEM)pop(w);
      } while (--rest_args >= 0);
      REL_HEAP;
      push((int)ptdesc);
      flip_tail();
      rtf();
d277 2
d280 5
a284 7
            if (0 == red_cnt)
            {
              dyn_mkbclos(n);
              flip_tail();                      /* avoid stackswitch */
              rtf();
            }
                                                                  
d286 9
a294 1
            if (n == arg)
d296 5
a300 13
              nfv = 0;
              sargs = R_CLOS(*ptdesc, args);
              n += sargs;  /* prepare the GOTO L0; to execute the delta_red */
              drop(w, 1);  /* POP function */
              pth = R_CLOS(*ptdesc, pta);
              pth = pth + sargs + nfv;
              while (sargs-- > 0) /* restore the argument frame */
              {
                help_pt = (T_PTD)*pth--;
                T_INC_REFCNT(help_pt);
                push((int)help_pt);
              } 
              
d303 7
a309 7
              help_pt = ptdesc;              
              ptdesc = (T_PTD)*R_CLOS(*ptdesc, pta);
              DEC_REFCNT(help_pt);
              push((int)ptdesc);
              goto L0;
            } /* END (arg == n) in PRIM CLOS */
            else
d311 6
a316 6
            if (n < arg)
            {
              dyn_mkbclos(n);
              flip_tail();                      /* avoid stackswitch */
              rtf();
            } /* END (n < arg) */
d318 8
a325 1
            else /* (n > arg) */
d327 4
a330 11
              sargs = R_CLOS(*ptdesc, args);
              n += sargs;  /* prepare the GOTO L0; to execute the delta_red */
              drop(w, 1);  /* POP closure */
              pth = R_CLOS(*ptdesc, pta);
              pth += sargs;
              while (sargs-- > 0) /* restore the argument frame */
              {
                help_pt = (T_PTD)*pth--;
                T_INC_REFCNT(help_pt);
                push((int)help_pt);
              } 
d333 7
a339 9
              help_pt = ptdesc;              
              ptdesc = (T_PTD)*R_CLOS(*ptdesc, pta);
              DEC_REFCNT(help_pt);
              push((int)ptdesc);
              goto too_many_delta;
            } /* END n > arg */
              
            
          } 
d345 25
d372 4
a375 1
        if ((TY_CASE == R_CLOS(*ptdesc, ftype)) || (TY_COMB == R_CLOS(*ptdesc, ftype)))
d377 4
a380 6
            if (0 == red_cnt)
            {
              dyn_mkbclos(n);
              flip_tail();                      /* avoid stackswitch */
              rtf();
            }
d383 11
a393 1
            if (n == arg)
d395 3
a397 9
              if (withtilde)
                nfv = R_CLOS(*ptdesc,nfv);
              else
                nfv = 0;
              sargs = R_CLOS(*ptdesc, args);
              drop(w, 1);
              pth = R_CLOS(*ptdesc, pta);
              pth = pth + sargs + nfv;
              if (withtilde)
d399 5
a403 16
                int dummy = nfv;
                
                while (dummy-- > 0)  /* tilde frame */
                {
                  help_pt = (T_PTD)*pth--;
                  T_INC_REFCNT(help_pt);
                  push_t((int)help_pt);
                }
                while (sargs-- > 0)  /* argument frame */
                {
                  help_pt = (T_PTD)*pth--;
                  T_INC_REFCNT(help_pt);
                  push((int)help_pt);
                }
              }	    
              else 
d405 3
a407 6
                while (sargs-- > 0)
                {
                  help_pt = (T_PTD)*pth--;
                  T_INC_REFCNT(help_pt);
                  push((int)help_pt);
                } 
d409 4
a412 11
              
              if (withtilde)
              {  
                if (nfv > 0) 
                {
                  push_r(nfv);                 /* f_for popfree_t */
                  push_r(((int)&f_popfree_t | FUNCTIONRETURN));    
                }
              }

              if (TY_COMB == R_CLOS(*ptdesc, ftype)) 
d414 9
a422 3
                stflip(a,w);                     /* don't flip if CASE */
              }
              else
d424 2
a425 1
                flip_tail();                    /* but avoid when returning */
d427 17
a443 15
              help_pt = ptdesc; 
              ptdesc = (T_PTD)*R_CLOS(*ptdesc, pta);
              DEC_REFCNT(help_pt);
              push_r(0); /* so that the called function knows
                            where to start (L0:) */
              if (TY_CASE == R_DESC(*ptdesc, type))
                DBUG_RETURN((int)(R_CASE(*ptdesc, ptc)));
              else
                DBUG_RETURN((int)(R_COMB(*ptdesc, ptc)));
              /* the fitting rtf() will find the return to the function
                 which called the apply (if no other call is in between 
                 or if there are free vars to kill it first will find the
                 address of f_popfree_t() and f_popfree_t's rtf will find
                 the way back  */
            } /* END (arg == n) */
d445 8
d454 7
a460 7
            if (n < arg)
            {
              dyn_mkbclos(n);
              flip_tail();                      /* avoid stackswitch */
              rtf();
            } /* END (arg < n) */
            else  /* arg > n */
d462 15
a476 15
            {
              if (TY_COMB == R_CLOS(*ptdesc, ftype))
                rest_args = n - R_COMB(*ptdesc, nargs);
              else
                rest_args = n - R_CASE(*ptdesc, nargs);
              push_r(rest_args);
              push_r((int)&f_apply | FUNCTIONRETURN);
              if (TY_COMB == R_CLOS(*ptdesc, ftype))
                n  = R_COMB(*ptdesc, nargs);
              else
                n  = R_CASE(*ptdesc, nargs);

              goto L0;
            }  /* END FUNC_ARITY((int)ptdesc) > n */
          } 
d483 1
a483 1
        if (TY_CONDI == R_CLOS(*ptdesc, ftype))
d561 2
a562 1
    }         
@


1.29
log
@reference count adjusted
@
text
@d219 1
a219 1
        push(ptdesc);
d226 26
a251 1
  else
d253 18
d272 1
a272 1
/* END IF PRIMFUNC                                  END IF PRIMFUNC */
d274 1
d278 2
a279 2
    if (T_POINTER(ptdesc))
    {
d558 11
a568 1
    else   /* something irreducible like "ap 5 to [7]" ... */
d570 7
a576 17
T_mkap:    
      MAKEDESC(ptdesc, 1, C_EXPRESSION, TY_EXPR);
      GET_HEAP(n + 3, (int)A_EXPR(*ptdesc, pte));
      RES_HEAP;
      pth = (PTR_HEAPELEM)R_EXPR(*ptdesc, pte);
      *pth++ = (T_HEAPELEM)(n + 2);
      *pth++ = (T_HEAPELEM)SET_ARITY(AP,(n + 1));
      pth += n;
      do
      {
        *pth-- = (T_HEAPELEM)pop(w);
      } while (--n >= 0);
      REL_HEAP;
      push((int)ptdesc);
      flip_tail();                      /* avoid stackswitch */
      rtf();
    }
@


1.28
log
@ifdef -> if where necessary
@
text
@d219 1
a219 1
        push_p(ptdesc);
@


1.27
log
@unused macros removed
@
text
@a0 1
#ifndef WITHTILDE
a1 1
#endif
d18 1
a18 1
#ifndef NO_STACK_REG
@


1.26
log
@red_func_tab is extern
@
text
@a13 50
/*
#define TAIL_FLAG      1
#define flip_tail()    top(r) = top(r) ^ TAIL_FLAG
#define rtf()          switch(top(r) & 3)       \
                       {                        \
                         case 0:                \
                         {                      \
                            lab=kill_bits(pop(r));         \
                            stflip(a, w);       \
                            moveaw();           \
                            goto LabSwitch;     \
                         }                      \
                         case 1:                \
                         {                      \
                            lab=kill_bits(pop(r));         \
                            goto LabSwitch;     \
                         }                      \
                         case 2:                \
                         {                      \
                           stflip(a, w);        \
                           moveaw();            \
                           DBUG_RETURN(kill_bits(pop(r))); \
                         }                      \
                         case 3:                \
                         {                      \
                           DBUG_RETURN(kill_bits(pop(r))); \
                         }                     \
                       }
#define FUNCTIONRETURN       2 
#define BITSTOKILLMASK (0xfffffffc) 
#define kill_bits(f)   ((f) & BITSTOKILLMASK) 
#define moveaw()             (*++st_w = *st_a--)
#define repl(n,s,x)          (st_##s[-n]=(x))         
#define push(x)              (*++st_w = (x))
#define push_a(x)            (*++st_a = (x))
#define push_p(x)            INC_REFCNT(x); push((int)x)
#define push_t(x)            (*++st_t = (x))
#define push_r(x)            (*++st_r = (x))
#define pop(s)               (*st_##s--)
#define top(s)               (*st_##s)
#define drop(s,n)            (st_##s-=n)
#define peek(s,n)            (st_##s[-(n)])
#define stflip(s,t)          st_h=st_##s;             \
                             st_##s=st_##t;           \
                             st_##t=st_h
#define GRAB_DESC(p)         p = ((T_PTD *)p)[-1]
#define TAIL_FLAG            1
#define TEST_TAIL_FLAG()     ((top(r) & TAIL_FLAG) == TAIL_FLAG)
#define DEL_TAIL_FLAG()      repl(0, r, top(r) & ~TAIL_FLAG)
*/
@


1.25
log
@GET_PTR removed
@
text
@d92 1
a92 1
FCTPTR red_func_tab[];
@


1.24
log
@db_prolog.h removed
@
text
@a11 1
#define GET_PTR(n)           (n & 0xfffffffe)
a62 1
#define GET_PTR(n)           (n & 0xfffffffe)
a189 36
}
/**********************************************************************/
/* searches for a function by the address of the equivalent C-function*/
/* returns the index in the static funcdesctable if TY_COMB or TY_CASE*/
/* returns -1 if TY_CONDI or not in list                              */
/**********************************************************************/

int search_func(int func)
{
  int i = 0, tmpptr = 1;
  DBUG_ENTER("search_func"); 
  while ((func != tmpptr) && (i<number_of_descs))
  {
    switch(R_DESC(*(funcdesctable[i]), type))
    {
      case TY_COMB:
        tmpptr = GET_PTR((int)R_COMB(*(funcdesctable[i]), ptc));
        break;
      case TY_CASE:
        tmpptr = GET_PTR((int)R_CASE(*(funcdesctable[i]), ptc));
        break;
      case TY_CONDI:
        tmpptr = GET_PTR((int)R_CONDI(*(funcdesctable[i]), ptc));
        break;
      default:
        controlled_exit("Unknown type in funcdesctable");
        break;
    }
    i++;
  }
  if ((i < number_of_descs) && 
      (TY_CASE==R_DESC(*(funcdesctable[i]),type)) ||
      (TY_COMB==R_DESC(*(funcdesctable[i]), type)))
    DBUG_RETURN (i);
else
  DBUG_RETURN (-1);
@


1.23
log
@access macros corrected
@
text
@a7 3
#ifdef DEBUG
#include "db_prolog.h"
#else
a8 1
#endif
@


1.22
log
@one more indirection in the descriptor table funcdesctable
which is now called stat_funcdesctable
funcdesctable is now an array of pointers to descriptors
@
text
@d205 19
a223 4
  int i = 0;
  DBUG_ENTER("search_func");  
  while (func != GET_PTR((int)R_COMB(*(funcdesctable[i]), ptc)) &&    \
         (i<number_of_descs))
d225 1
d483 4
a486 1
              DBUG_RETURN((int)(R_COMB(*ptdesc, ptc)));
d504 4
a507 2
        
              rest_args = n - R_COMB(*ptdesc, nargs);
d510 4
a513 1
              n  = R_COMB(*ptdesc, nargs);
d580 1
a580 1
            DBUG_RETURN((int)(R_COMB(*ptdesc, ptc)));
d590 1
a590 1
            rest_args = n - R_COMB(*ptdesc, nargs);
d593 1
a593 1
            n  = R_COMB(*ptdesc, nargs);
@


1.21
log
@includes now (db_)prolog.h
@
text
@d93 1
a93 1
extern T_DESCRIPTOR funcdesctable[];
d207 1
a207 1
  while (func != GET_PTR((int)R_COMB(funcdesctable[i], ptc)) &&    \
d211 2
a212 1
      (TY_CASE==R_DESC(funcdesctable[i],type))||(TY_COMB==R_DESC(funcdesctable[i], type)))
@


1.20
log
@bug fix in handling of CASE closures
@
text
@a3 3
#include <stdio.h>
#include <stdlib.h>
#include "dbug.h"
a4 4
#include "rstdinc.h"
#include "rstelem.h"
#include "rheapty.h"
#include "rstackty.h"
d7 11
d19 1
a21 2
/* rts() only for popfree_t */
#define rts()          DBUG_RETURN(kill_bits(pop(r)))
d48 2
a49 2
#define BITSTOKILLMASK (0xfffffffc) /* see comment on top of prolog.h */
#define kill_bits(f)   ((f) & BITSTOKILLMASK) /* deletes bits 0 'n' 1 */
d69 3
a97 1
extern void post_mortem(char *);
@


1.19
log
@f_mkdclos(0, ...) -> f_mkdclos(-1, ...)
@
text
@d15 2
a16 2

#define flip_tail()    repl(0, r,top(r) ^ 1)
d451 4
@


1.18
log
@additional parameter to f_mkdclos()
@
text
@d143 1
a143 1
      f_mkdclos(0, 1, 1, (int)d_ptdesc);
d152 1
a152 1
      f_mkdclos(0, 2, 2, (int)d_ptdesc);
d162 1
a162 1
      f_mkdclos(0, 3, 3, (int)d_ptdesc);
d172 1
a172 1
      f_mkdclos(0, 4, 4, (int)d_ptdesc);
d243 1
a243 1
      f_mkdclos(0, FUNC_ARITY((int)ptdesc), n, (int)ptdesc);
d259 1
a259 1
      f_mkdclos(0, FUNC_ARITY((int)ptdesc), n, (int)ptdesc);
@


1.17
log
@*** empty log message ***
@
text
@d143 1
a143 1
      f_mkdclos(1, 1, (int)d_ptdesc);
d152 1
a152 1
      f_mkdclos(2, 2, (int)d_ptdesc);
d162 1
a162 1
      f_mkdclos(3, 3, (int)d_ptdesc);
d172 1
a172 1
      f_mkdclos(4, 4, (int)d_ptdesc);
d243 1
a243 1
      f_mkdclos(FUNC_ARITY((int)ptdesc), n, (int)ptdesc);
d259 1
a259 1
      f_mkdclos(FUNC_ARITY((int)ptdesc), n, (int)ptdesc);
@


1.16
log
@pm implemented
@
text
@d74 4
d449 1
d451 1
a451 1

@


1.15
log
@minor change, warnings removed
@
text
@d70 1
d74 1
d190 1
a190 1
/* returns the index in the static funcdesctable if TY_COMB           */
d201 2
a202 1
  if ((i < number_of_descs) && (TY_COMB == R_DESC(funcdesctable[i], type)))
d388 1
a388 1
        if (TY_COMB == R_CLOS(*ptdesc, ftype))
d444 2
a445 1
              stflip(a,w);
d480 1
a480 1
/* END if userdefined function closure                              */
@


1.14
log
@closing of unreducible expressions like 'ap 5 to [7]'
@
text
@d130 1
a130 1
  pop(w);
d235 1
a235 1
      pop(w);
d251 1
a251 1
      pop(w);  /* 'cause f_mkdclos() pushes the function itself */
d327 1
a327 1
              pop(w);  /* POP function */
d358 1
a358 1
              pop(w);  /* POP closure */
d402 1
a402 1
              pop(w);
d532 1
a532 1
            pop(w);
@


1.13
log
@will always be compiled with WITHTILDE defined
@
text
@d67 1
d233 7
d299 2
a300 1

d314 7
d387 7
d544 10
d560 2
d565 19
a584 2


@


1.12
log
@prepared for separated modules
@
text
@d1 3
@


1.11
log
@*** empty log message ***
@
text
@a8 1
#include "mytypes.h"
d65 1
a65 1
#ifdef h__sparc__
d263 1
a263 1
        GET_HEAP(rest_args + 3, A_EXPR(*ptdesc, pte));
@


1.10
log
@*** empty log message ***
@
text
@d66 1
a66 1
#ifdef __sparc__
@


1.9
log
@minor bugfix
@
text
@d66 1
a66 1
#ifdef BLUBBER_BLUBB  /*__sparc__*/
@


1.8
log
@*** empty log message ***
@
text
@d250 1
a250 1
      if (p_lselect == (int)ptdesc)
@


1.7
log
@bugfix in number of free vars in case of conditional closure
@
text
@d65 11
a75 3
register int *st_h asm ("g5");
register int *st_w asm ("g6");
register int *st_a asm ("g7");
@


1.6
log
@cond-bug fixed in freevar handling
@
text
@d16 1
a16 1
#define rts()          return(kill_bits(pop(r)))
d35 1
a35 1
                           return(kill_bits(pop(r))); \
d39 1
a39 1
                           return(kill_bits(pop(r))); \
d65 3
a67 3
extern int *st_h;
extern int *st_w;
extern int *st_a;
d95 2
a96 1

d184 1
a184 1
  
d189 1
a189 1
    return (i);
d191 1
a191 1
  return (-1);
d415 1
a415 1
              return((int)(R_COMB(*ptdesc, ptc)));
d456 1
a456 1
              nfv = R_CLOS(*ptdesc,nfv) /*>> 2*/;
d504 1
a504 1
            return((int)(R_COMB(*ptdesc, ptc)));
@


1.5
log
@Conditionals
@
text
@d455 1
a455 1
              nfv = R_CLOS(*ptdesc,nfv) >> 2;
@


1.4
log
@*** empty log message ***
@
text
@d455 1
a455 1
              nfv = R_CLOS(*ptdesc,nfv);
@


1.3
log
@*** empty log message ***
@
text
@d48 1
d177 1
a177 1
/* returns -1 if TY_COND or not in list                               */
d444 70
a513 1

a515 1

@


1.2
log
@*** empty log message ***
@
text
@d10 1
d15 2
d72 3
d87 22
d193 3
a195 3
/* n    : actual args                                                 */
/* l    : return label                                                */
/* func : return function (NULL if self recursive call                */
d198 2
d204 2
a205 2
  int arg, nfv, sargs, i;
  int n, l, func;
d207 1
a207 1
  DBUG_ENTER("apply");
a208 2
/*    func = pop(r);*/
/*    l = pop(r);*/
a210 1
/*	lab = kill_bits(pop(r));*/
a211 10
/*	switch (lab) {*/
/*	case 0:*/
/*		goto L0;*/
/*	case 4:*/
/*		goto L4;*/
/*	default:{*/
/*			fprintf(stderr, "Wrong Label: L%d;", lab);*/
/*		}*/
/*	}*/

d220 1
d228 1
d232 1
a232 1
      f_mkdclos(FUNC_ARITY((int)ptdesc), n, ptdesc);
d236 1
d239 1
d277 1
a277 1
/* test, if POINTER                                test, if POINTER */
a281 1
      int func_desc_index;
d288 3
a290 1
/* CLOSURE with a primitive function */
d293 1
d318 1
d324 24
a347 1
            } /* END (arg < n) */
d349 4
a352 1
          } /* END CLOSURE with a primitive function */
d354 3
a356 1
/* CLOSURE with a userdefined function */
d359 1
d397 8
a404 7
                
/*              for (i = 0; i<sargs; i++, pth--)*/
/*              {*/
/*                push((int)*pth);*/
/*              }*/
                   
/*              DEC_REFCNT(ptdesc);  */
a405 2
              push_r(0); /* so that the called function knows
                            where to start (L0:) */
d411 2
a412 3
/*********************************************************/
/* hier gehoert die POPFREE_T Vorbereitung rein          */
/*********************************************************/
d414 5
a418 2
              /* the next rtf() will find the return to the function
                 which called the apply (if no other call is in between */
d421 1
a427 1
/*********************************************************************/
d429 1
d436 1
a436 1
L4:
d439 5
a443 4
        
/*********************************************************************/
            
          } /* END CLOSURE with a userdefined function */
d446 1
@


1.1
log
@Initial revision
@
text
@d13 1
d45 1
a45 1
#define push_p(x)      INC_REFCNT(x); push((int)x)
d206 1
d210 1
a210 1
    if (FUNC_ARITY((int)ptdesc) < n)
d214 1
d217 1
a217 1
    else  /* FUNC_ARITY((int)ptdesc) > n */
d245 1
d275 1
a291 2
              delta_reduct(n, ptdesc);
              n += sargs;
d298 1
d359 3
d370 1
a377 1
              push_r(0);
d379 1
a379 2
              push_r(l);
              push_r(func);
@
