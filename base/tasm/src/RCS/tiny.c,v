head	1.91;
access;
symbols;
locks; strict;
comment	@ * @;


1.91
date	96.03.12.17.01.22;	author stt;	state Exp;
branches;
next	1.90;

1.90
date	96.02.28.09.33.02;	author um;	state Exp;
branches;
next	1.89;

1.89
date	96.02.28.09.27.47;	author um;	state Exp;
branches;
next	1.88;

1.88
date	96.02.28.09.16.58;	author um;	state Exp;
branches;
next	1.87;

1.87
date	96.02.19.13.54.20;	author cr;	state Exp;
branches;
next	1.86;

1.86
date	96.02.16.07.32.54;	author um;	state Exp;
branches;
next	1.85;

1.85
date	96.02.13.16.25.00;	author stt;	state Exp;
branches;
next	1.84;

1.84
date	96.01.18.10.43.29;	author um;	state Exp;
branches;
next	1.83;

1.83
date	95.08.15.07.32.41;	author um;	state Exp;
branches;
next	1.82;

1.82
date	95.08.14.10.15.23;	author um;	state Exp;
branches;
next	1.81;

1.81
date	95.08.02.10.09.07;	author um;	state Exp;
branches;
next	1.80;

1.80
date	95.08.02.08.32.37;	author um;	state Exp;
branches;
next	1.79;

1.79
date	95.08.02.08.05.04;	author um;	state Exp;
branches;
next	1.78;

1.78
date	95.07.12.09.59.03;	author um;	state Exp;
branches;
next	1.77;

1.77
date	95.07.10.07.38.38;	author um;	state Exp;
branches;
next	1.76;

1.76
date	95.07.04.11.04.29;	author um;	state Exp;
branches;
next	1.75;

1.75
date	95.07.04.09.34.02;	author um;	state Exp;
branches;
next	1.74;

1.74
date	95.06.27.08.15.48;	author um;	state Exp;
branches;
next	1.73;

1.73
date	95.06.22.08.37.59;	author um;	state Exp;
branches;
next	1.72;

1.72
date	95.06.22.08.15.58;	author um;	state Exp;
branches;
next	1.71;

1.71
date	95.06.15.10.22.32;	author um;	state Exp;
branches;
next	1.70;

1.70
date	95.06.15.10.02.39;	author um;	state Exp;
branches;
next	1.69;

1.69
date	95.06.07.07.50.18;	author um;	state Exp;
branches;
next	1.68;

1.68
date	95.06.06.10.25.24;	author um;	state Exp;
branches;
next	1.67;

1.67
date	95.05.29.12.01.49;	author um;	state Exp;
branches;
next	1.66;

1.66
date	95.05.23.11.54.34;	author um;	state Exp;
branches;
next	1.65;

1.65
date	95.05.17.12.41.54;	author um;	state Exp;
branches;
next	1.64;

1.64
date	95.05.15.10.17.21;	author um;	state Exp;
branches;
next	1.63;

1.63
date	95.05.12.11.57.31;	author um;	state Exp;
branches;
next	1.62;

1.62
date	95.05.12.07.10.38;	author um;	state Exp;
branches;
next	1.61;

1.61
date	95.05.08.08.46.20;	author um;	state Exp;
branches;
next	1.60;

1.60
date	95.05.03.07.39.57;	author um;	state Exp;
branches;
next	1.59;

1.59
date	95.05.02.08.11.48;	author um;	state Exp;
branches;
next	1.58;

1.58
date	95.05.02.07.42.05;	author um;	state Exp;
branches;
next	1.57;

1.57
date	95.04.28.07.38.43;	author um;	state Exp;
branches;
next	1.56;

1.56
date	95.04.27.07.23.59;	author um;	state Exp;
branches;
next	1.55;

1.55
date	95.04.21.12.10.40;	author um;	state Exp;
branches
	1.55.1.1;
next	1.54;

1.54
date	95.04.21.11.22.13;	author um;	state Exp;
branches;
next	1.53;

1.53
date	95.04.21.08.36.59;	author um;	state Exp;
branches;
next	1.52;

1.52
date	95.04.20.12.14.17;	author um;	state Exp;
branches;
next	1.51;

1.51
date	95.04.20.10.07.43;	author um;	state Exp;
branches;
next	1.50;

1.50
date	95.04.18.06.42.08;	author um;	state Exp;
branches;
next	1.49;

1.49
date	95.04.13.09.38.13;	author um;	state Exp;
branches;
next	1.48;

1.48
date	95.04.12.07.51.15;	author um;	state Exp;
branches;
next	1.47;

1.47
date	95.04.11.09.36.19;	author um;	state Exp;
branches;
next	1.46;

1.46
date	95.04.11.08.19.35;	author um;	state Exp;
branches;
next	1.45;

1.45
date	95.04.05.10.14.12;	author um;	state Exp;
branches;
next	1.44;

1.44
date	95.03.28.08.33.25;	author um;	state Exp;
branches;
next	1.43;

1.43
date	95.03.27.11.30.25;	author um;	state Exp;
branches;
next	1.42;

1.42
date	95.03.27.08.44.09;	author um;	state Exp;
branches;
next	1.41;

1.41
date	95.03.22.10.41.48;	author um;	state Exp;
branches;
next	1.40;

1.40
date	95.03.20.09.17.15;	author um;	state Exp;
branches;
next	1.39;

1.39
date	95.03.16.09.01.36;	author um;	state Exp;
branches;
next	1.38;

1.38
date	95.03.15.08.24.50;	author um;	state Exp;
branches;
next	1.37;

1.37
date	95.03.13.10.59.42;	author um;	state Exp;
branches;
next	1.36;

1.36
date	95.03.08.08.46.24;	author um;	state Exp;
branches;
next	1.35;

1.35
date	95.03.07.13.41.16;	author um;	state Exp;
branches;
next	1.34;

1.34
date	95.03.07.07.57.34;	author um;	state Exp;
branches;
next	1.33;

1.33
date	95.03.06.09.51.03;	author um;	state Exp;
branches;
next	1.32;

1.32
date	95.03.02.15.21.35;	author um;	state Exp;
branches;
next	1.31;

1.31
date	95.02.15.09.54.47;	author um;	state Exp;
branches;
next	1.30;

1.30
date	95.02.14.08.56.32;	author um;	state Exp;
branches;
next	1.29;

1.29
date	95.02.14.08.07.49;	author um;	state Exp;
branches;
next	1.28;

1.28
date	95.02.07.08.54.02;	author um;	state Exp;
branches;
next	1.27;

1.27
date	95.02.03.10.21.27;	author um;	state Exp;
branches;
next	1.26;

1.26
date	95.02.02.13.21.44;	author um;	state Exp;
branches;
next	1.25;

1.25
date	95.01.30.15.09.40;	author um;	state Exp;
branches;
next	1.24;

1.24
date	95.01.26.09.57.19;	author um;	state Exp;
branches;
next	1.23;

1.23
date	95.01.18.07.50.52;	author um;	state Exp;
branches;
next	1.22;

1.22
date	95.01.16.07.25.00;	author um;	state Exp;
branches;
next	1.21;

1.21
date	94.12.28.09.14.30;	author um;	state Exp;
branches;
next	1.20;

1.20
date	94.12.23.08.46.51;	author um;	state Exp;
branches;
next	1.19;

1.19
date	94.12.22.11.15.49;	author um;	state Exp;
branches;
next	1.18;

1.18
date	94.12.22.08.23.29;	author um;	state Exp;
branches;
next	1.17;

1.17
date	94.12.19.16.02.30;	author um;	state Exp;
branches;
next	1.16;

1.16
date	94.12.16.08.03.34;	author um;	state Exp;
branches;
next	1.15;

1.15
date	94.12.15.09.36.42;	author um;	state Exp;
branches;
next	1.14;

1.14
date	94.12.09.09.42.10;	author um;	state Exp;
branches;
next	1.13;

1.13
date	94.12.08.15.26.12;	author um;	state Exp;
branches;
next	1.12;

1.12
date	94.12.08.09.49.53;	author um;	state Exp;
branches;
next	1.11;

1.11
date	94.12.06.09.48.48;	author um;	state Exp;
branches;
next	1.10;

1.10
date	94.12.02.09.53.44;	author um;	state Exp;
branches;
next	1.9;

1.9
date	94.12.01.16.11.49;	author um;	state Exp;
branches;
next	1.8;

1.8
date	94.12.01.14.29.48;	author um;	state Exp;
branches;
next	1.7;

1.7
date	94.11.29.08.39.04;	author um;	state Exp;
branches;
next	1.6;

1.6
date	94.11.29.07.28.25;	author um;	state Exp;
branches;
next	1.5;

1.5
date	94.11.28.15.45.40;	author um;	state Exp;
branches;
next	1.4;

1.4
date	94.11.25.12.52.02;	author um;	state Exp;
branches;
next	1.3;

1.3
date	94.11.25.08.57.55;	author um;	state Exp;
branches;
next	1.2;

1.2
date	94.11.24.09.55.41;	author um;	state Exp;
branches;
next	1.1;

1.1
date	94.11.21.09.08.01;	author car;	state Exp;
branches;
next	;

1.55.1.1
date	95.05.12.09.19.20;	author um;	state Exp;
branches;
next	;


desc
@initial incomplete version
@


1.91
log
@cases p_to_char, p_to_ord, p_sprintf, p_sscanf added.
@
text
@#include <stdarg.h>
#include <malloc.h>
#include <string.h>
#include <ctype.h>
#include "mytypes.h"
#include "loctypes.h"
#include "tiny.h"
#include "tis.h"
#include "buildtree.h"
#include "comp_support.h"
#include "dbug.h"
#include "error.h"

extern PROGRAM *program_start;
extern char *primf_tab[];
const char *prim_type_names[]={"none","int","real","digit","bool","char","empty",
			       "atom","freevar",NULL};
const char *s_prim_type_names[]={"?","i","r","d","b","$","e","a","v"};
const char *ext_type_names[]={"scalar","list","vect","tvect","matrix","string",NULL};
const char *s_ext_type_names[]={NULL,"l","v","t","m","s"};
const char *other_type_names[]={"prim","clos","func",NULL};
const char *s_other_type_names[]={"p","c","f"};

/* #ifndef DBUG_OFF */
/************************************************************************/
/* displays stacks all given stacks != NULL				*/
/* (function is not compiled if debugging is off)			*/
/************************************************************************/
void stack_display()
{
DBUG_ENTER("stack_display");
if (_db_keyword_("STACKS"))			/* option -#d,STACKS set */
  {
  printf("w:\t");				/* print w stack ... */
  if (NULL!=w)
    stelm_display(GETSTACKENTRY(w,stack),GETTOPOFSTACK(w));
  printf("\na:\t");
  if (NULL!=a)
    stelm_display(GETSTACKENTRY(a,stack),GETTOPOFSTACK(a));
  printf("\nt:\t");
  if (NULL!=t)
    stelm_display(GETSTACKENTRY(t,stack),GETTOPOFSTACK(t));
  printf("\nr:\t");
  if (NULL!=r)
    stelm_display(GETSTACKENTRY(r,stack),GETTOPOFSTACK(r));
  printf("\n");
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* displays i elements form array of STELM wich is referenced by stelm	*/
/* (function is not compiled if debugging is off)			*/
/************************************************************************/
void stelm_display(STELM *stelm, long i)
{
long j;

DBUG_ENTER("stelm_display");
for (j=0; j<i; j++)				/* all STELMs of stelm */
  {
  switch (stelm[j].type)
    {
    case tp_badrecur:
    case tp_illegal:
      {
      printf(" ([illegal])");
      break;
      }
    case tp_char:
    case tp_none:
    case tp_int:
    case tp_bool:
    case tp_real:
      {
      printf(" (%s)",prim_type_names[stelm[j].type]);
      break;
      }
    case tp_func:
      {
      if (NULL==stelm[j].dat.desc)
	printf(" (function)");			/* it's a unknown function */
      else
	printf(" (%s)",GETDESCENTRY(stelm[j].dat.desc,label));
      break;
      }
    case tp_prim:
      {
      printf(" (%s)",primf_tab[GETPRF(stelm[j].dat.prim)]);
      break;
      }
    case tp_clos:
      {
      if (_db_keyword_("CLOSURE"))	/* if -#d,CLOSURE then display frames */
	{
        printf(" (closure[w:");
	stelm_display(stelm[j].dat.clos->w,stelm[j].dat.clos->i);
	if (NULL!=stelm[j].dat.clos->desc)
	  {
	  printf(",t:");
	  stelm_display(stelm[j].dat.clos->t,stelm[j].dat.clos->k);
	  }
	printf("])");
	}
      else
	printf(" (closure[...])");
      break;
      }
    case tp_string:				/* string is shown as '...` */
      {
      printf(" '%s`",(tp_none!=stelm[j].subtype.type & PRIM_MASK) ?
	     prim_type_names[stelm[j].subtype.type & PRIM_MASK] :
	     ext_type_names[(stelm[j].subtype.type & EXT_MASK)>>4]);
      break;
      }
    case tp_list:				/* list is shown as [...] */
      {
      printf(" [%s]",(tp_none!=stelm[j].subtype.type & PRIM_MASK) ?
	     prim_type_names[stelm[j].subtype.type & PRIM_MASK] :
	     ext_type_names[(stelm[j].subtype.type & EXT_MASK)>>4]);
      break;
      }
    case tp_vect:				/* vect is shown as <...> */
      {
      printf(" <%s>",(tp_none!=stelm[j].subtype.type & PRIM_MASK) ?
	     prim_type_names[stelm[j].subtype.type & PRIM_MASK] :
	     ext_type_names[(stelm[j].subtype.type & EXT_MASK)>>4]);
      break;
      }
    case tp_tvect:				/* tvect is shown as >...< */
      {
      printf(" >%s<",(tp_none!=stelm[j].subtype.type & PRIM_MASK) ?
	     prim_type_names[stelm[j].subtype.type & PRIM_MASK] :
	     ext_type_names[(stelm[j].subtype.type & EXT_MASK)>>4]);
      break;
      }
    case tp_matrix:				/* matrix is shown as <:...:> */
      {
      printf(" <:%s:>",(tp_none!=stelm[j].subtype.type & PRIM_MASK) ?
	     prim_type_names[stelm[j].subtype.type & PRIM_MASK] :
	     ext_type_names[(stelm[j].subtype.type & EXT_MASK)>>4]);
      break;
      }
    case tp_var:
      {
      printf(" var");
      break;
      }
    default:
      yyfail("%s","unknown type for stelm_output");
    }
  }
DBUG_VOID_RETURN;
}
/* #endif */

/************************************************************************/
/* calculates the duplication index of the n given arguments on a STACK	*/
/* returns float value representing the arguments.			*/
/************************************************************************/
float calc_args_val(STELM *a,int n)
{
int i;
float res=0;

DBUG_ENTER("calc_args_val");
for (i=0; i<n; i++,a++)			/* with all arguments calculate*/
  {					/* duplication index */
  switch(a->type)
    {
    case tp_int:
      res+=VTP_INT;
      break;
    case tp_bool:
      res+=VTP_BOOL;
      break;
    case tp_prim:
      res+=VTP_PRIM;
      break;
    case tp_real:
      res+=VTP_REAL;
      break;
    case tp_func:
      res+=VTP_FUNC;
      break;
    case tp_list:
      res+=VTP_LIST;
      break;
    case tp_clos:
      res+=VTP_CLOS;
      break;
    case tp_vect:
    case tp_tvect:
      res+=VTP_VECT;
      break;
    case tp_matrix:
      res+=VTP_MATRIX;
      break;
    case tp_string:
      res+=VTP_STRING;
      break;
    case tp_atom:
      res+=VTP_ATOM;
      break;
    case tp_var:
      res+=VTP_VAR;
      break;
    case tp_none:
      res+=VTP_NONE;
      break;
    default:
      yyfail("%s","unknown type for argumentvalue calculation");
      break;
    }
  }
res/=n;						/* calculates average */
DBUG_RETURN(res);
}

/************************************************************************/
/* searches for ord on ret-STACK and sets ret(branch) to ord(branch)	*/
/* and clears ord(branch).						*/
/************************************************************************/
void backupoldjcond()
{
int i;

DBUG_ENTER("backupoldjcond");
for (i=GETTOPOFSTACK(ret)-1;i>=0;i--)
  {
  if (JCONDS(GETORDERENTRY(GETSTACKENTRY(ret,stack)[i].dat.ret->ord,command)) &&
      (0==GETSTACKENTRY(ret,stack)[i].dat.ret->branch))
    					/* if command == jcond and no branch is */
    					/* stored in returnadress, the executed */
    					/* branches get stored in returnadress */
    {
    GETSTACKENTRY(ret,stack)[i].dat.ret->branch=
      GETORDERENTRY(GETSTACKENTRY(ret,stack)[i].dat.ret->ord,branch);
    SETORDERENTRY(GETSTACKENTRY(ret,stack)[i].dat.ret->ord,branch)=0;
    }
  if (ord==GETSTACKENTRY(ret,stack)[i].dat.ret->ord)	/* actuell order reached */
    break;
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* checks if function/closure stelm has to be dumped and builds up	*/
/* enviroment if needed.						*/
/************************************************************************/
void dump_list_func(STELM *stelm)
{
CLOSURE *clos;
FUNDESC *des;
RETURNADR *rt;
int j;

DBUG_ENTER("dump_list_func");
if (tp_func==GETSTELMTYPE(stelm))		/* do we have a function ? */
  {
  if (NULL==(rt=malloc(sizeof(RETURNADR))))	/* get mem for returnadress */
    yyfail("%s","no memory for returnadress!");
  rt->a=NULL;					/* all stacks empty */
  rt->w=NULL;
  rt->t=NULL;
  rt->r=NULL;
  rt->status=CLOS_EXE;
  rt->branch=0;
  if (DT_CONDITIONAL==GETDESCENTRY(GETSTELMDATA(stelm,desc),tag))
    {
    for (j=0;j<GETSTELMDATA(stelm,desc)->nv;j++)
      rt->a=st_push(rt->a,&CONST_NONE);
    rt->w=st_push(rt->w,&CONST_NONE);
    }
  else						/* common function */
    {
    for (j=0;j<GETSTELMDATA(stelm,desc)->nv;j++)
      rt->w=st_push(rt->w,&CONST_NONE);
    }
  rt->w=st_push(rt->w,stelm);			/* store function label */
  rt->ord=new_order(apply,GETSTELMDATA(stelm,desc)->nv); /* create apply */
  rt->ord->next=&CONST_EXT;			/* and ext */
  rt->ord->prev=NULL;
  func_dump=st_push(func_dump,new_stelm(tp_returnadr,rt)); /* save on func_dump */
  }
if ((tp_clos==GETSTELMTYPE(stelm)) &&	    	/* closure, ... */
    (NULL!=GETSTELMDATA(stelm,clos)->desc))	/* ... but no deltaclos */
  {
  if (NULL==(rt=malloc(sizeof(RETURNADR))))	/* get mem for returnadress */
    yyfail("%s","no memory for returnadress!");
  rt->a=NULL;					/* all stacks empty */
  rt->w=NULL;
  rt->t=NULL;
  rt->r=NULL;
  rt->status=CLOS_EXE;
  rt->branch=0;
  clos=GETSTELMDATA(stelm,clos);
  des=clos->desc;
  if (DT_CONDITIONAL==GETDESCENTRY(des,tag))	/* createing missing arguments */
    {
    for (j=1;j<des->nv-clos->i;j++)
      rt->a=st_push(rt->a,&CONST_NONE);
    rt->w=st_push(rt->w,&CONST_NONE);
    }
  else						/* common [gamma]betaclos */
    {
    for (j=0;j<des->nv-clos->i;j++)
      rt->w=st_push(rt->w,&CONST_NONE);
    }
  rt->w=st_push(rt->w,stelm);			/* store closure */
  rt->ord=new_order(apply,des->nv-clos->i);	/* create apply */
  rt->ord->next=&CONST_EXT;			/* and ext */
  rt->ord->prev=NULL;
  func_dump=st_push(func_dump,new_stelm(tp_returnadr,rt)); /* save on func_dump */
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* checks on ret-stack for previous match with same fail-lable		*/
/* returns NULL if no previous match with same fail-label found else    */
/* returns returnadress of previous match				*/
/************************************************************************/
STELM *gotofail()
{
STELM *retur;
ORDER *ord1;

DBUG_ENTER("gotofail");
ord1=find_label(GETNEXTORDER(ord),GETORDERARGS(ord,label));
retur=st_read(ret,1);		/* search on returnstack for the same label */
if (MATCHX(GETORDERENTRY(retur->dat.ret->ord,command)) &&
    (ord1==find_label(retur->dat.ret->ord,
		       GETORDERARGS(retur->dat.ret->ord,label))))
  {
  SETORDERENTRY(ord,branch)=0;			/* clear executed branches */
  st_pop(ret);
  retur=st_pop(ret);
  DBUG_RETURN(retur);				/* returns adress to return */
  }
DBUG_RETURN((STELM *)NULL);			/* label not found on ret-STACK */
}

/************************************************************************/
/* clears functionresultentries for all depending not cleared functions */
/************************************************************************/
void clear_cache(FUNTYPES *ft)
{
DEPEND *dep;

DBUG_ENTER("clear_cache");
if ((kn_clear!=ft->knowledge) || (tp_none!=ft->result.type))
  					/* if cache-entry isn't cleared or */
					/* of type none */
  {
  ft->knowledge=kn_clear;		/* clear cache entry */
  while (NULL!=ft->depend)		/* clear depending entry, too */
    {
    clear_cache(ft->depend->func);
    dep=ft->depend->next;
    free(ft->depend);
    ft->depend=dep;
    }
  ft->knowledge=kn_no;			/* no result stored */
  ft->result.type=tp_illegal;
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* pops entries of RETURNADR-STACK until stelm is reached - clears all	*/
/* depending function-cache entries					*/
/************************************************************************/
void return_to_call(STELM *stelm)
{
RETURNADR *radr;
FUNDESC *des;
FUNLIST *fl;
FUNTYPES *ft;
STELM result,*dummy;

DBUG_ENTER("return_to_call");
while (st_read(ret,0)!=stelm)
  {
  dummy=st_pop(ret);
  if (JCONDS(dummy->dat.ret->ord->command))	
    				/* if poped ORDER is JCONDS then clear branches */
    dummy->dat.ret->ord->branch=0;
  }
radr=stelm->dat.ret;
des=find_desc(GETFIRSTDESC(program_start),radr->ord->args.label);
fl=searchfunlist(des->label);		/* searches for function-cache entry */
if (apply!=radr->ord->command)
  ft=searchftypes(fl->funtypes,(0==des->nv ) ? NULL : st_read(radr->w,des->nv-1),
		               (0==des->nfv) ? NULL : st_read(radr->t,des->nfv-1),
		  des->nv,des->nfv);
else
  ft=searchftypes(fl->funtypes,(0==des->nv ) ? NULL : st_read(radr->w,des->nv),
		               (0==des->nfv) ? NULL : st_read(radr->t,des->nfv-1),
		  des->nv,des->nfv);
stelm_cpy(&result,&ft->result,1);		/* backup stored result */
clear_cache(ft);				/* clear cache entries */
stelm_cpy(&ft->result,&result,1);		/* store back result */
DBUG_VOID_RETURN;
}

/************************************************************************/
/* sets depend pointer in FUNLIST of des to function old_func		*/
/************************************************************************/
void set_depend(FUNDESC *des,STACK *w, STACK *t,STELM *old_func)
{
FUNLIST *fl;
FUNTYPES *fts,*ftd;
RETURNADR *radr;
FUNDESC *s_des;
DEPEND *dep;

DBUG_ENTER("set_depend");
DBUG_PRINT("ORDERS",("calling set_depend ..."));
if ((NULL==old_func) || 
    (0==strcmp(des->label,old_func->dat.ret->ord->args.label))) /* selfdepend */
  DBUG_VOID_RETURN;
fl=searchfunlist(des->label);			/* get FUNLIST entry of des */
DBUG_ASSERT(NULL!=fl,"set_depend failed!");
if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
  ftd=searchftypes(fl->funtypes,(0==des->nv ) ? NULL : st_read(w,des->nv-1),
		                (0==des->nfv) ? NULL : st_read(t,des->nfv-1),
		   des->nv,des->nfv);
else						/* it a conditional */
  ftd=searchftypes(fl->funtypes,
		   (0==des->nv-1 ) ? NULL : st_read(w,des->nv-2),
		   (0==des->nfv/4) ? NULL : st_read(t,(des->nfv/4)-1),
		   des->nv-1,des->nfv/4);  
DBUG_ASSERT(NULL!=ftd,"set_depend failed!");
radr=old_func->dat.ret;
s_des=find_desc(GETFIRSTDESC(program_start),radr->ord->args.label);
fl=searchfunlist(s_des->label);
DBUG_ASSERT(NULL!=fl,"set_depend failed!");
if (apply==radr->ord->command)
  {
  if (DT_CONDITIONAL!=GETDESCENTRY(s_des,tag))
    {
    fts=searchftypes(fl->funtypes,
		     (0==s_des->nv ) ? NULL : st_read(radr->w,s_des->nv-1+1),
		     (0==s_des->nfv) ? NULL : st_read(radr->t,s_des->nfv-1),
		     s_des->nv,s_des->nfv);
    }
  else
    {
    fts=searchftypes(fl->funtypes,
		     (0==s_des->nv-1 ) ? NULL : st_read(radr->w,s_des->nv-2+1),
		     (0==s_des->nfv/4) ? NULL : st_read(radr->t,(s_des->nfv/4)-1),
		     s_des->nv-1,s_des->nfv/4);
    }
  }
else						/* must be [gamma]beta */
  {
  fts=searchftypes(fl->funtypes,
		   (0==s_des->nv ) ? NULL : st_read(radr->w,s_des->nv-1),
		   (0==s_des->nfv) ? NULL : st_read(radr->t,s_des->nfv-1),
		   s_des->nv,s_des->nfv);
  }
DBUG_ASSERT(NULL!=fts,"set_depend failed!");
dep=ftd->depend;				/* set dependency */
while (NULL!=dep)				/* follow dependencies */
  {
  if (fts==dep->func)
    DBUG_VOID_RETURN;
  dep=dep->next;
  }
if (NULL==(dep=malloc(sizeof(DEPEND))))
  yyfail("%s","no memory for dependecies!");
dep->next=ftd->depend;				/* append new dependency */
dep->func=fts;
ftd->depend=dep;
DBUG_VOID_RETURN;
}

/************************************************************************/
/* displays n elements form array of TP_TYPES				*/
/************************************************************************/
void print_types(TP_TYPES * types, int n)
  {
  int i;
  TP_TYPES *dummy;
  
  DBUG_ENTER("print_types");
  for (i = 0; i < n; i++)
    {
    switch (types[i] & (EXT_MASK | OTHER_MASK))
      {
      case tp_none:				/* prim_types */
        {
	fprintf(yyout, "%s",prim_type_names[types[i]]);
        break;
	}
      case tp_list:
        {
	fprintf(yyout, "[");
	if (NULL==(dummy=malloc(sizeof(TP_TYPES))))
	  yyfail("%s","can't allocmem for temporary type!");
	*dummy=types[i]^tp_list;
	print_types(dummy,1);
	free(dummy);
	fprintf(yyout, "]");
        break;
	}
      case (tp_list|OTHER_MASK):		/* list is shown as [...] */
	{
	fprintf(yyout, "[%s]",other_type_names[types[i]^(tp_list|OTHER_MASK)]);
	break;
	}
      case tp_string:				/* string is shown as '...` */
	{
	fprintf(yyout, "'");
	if (NULL==(dummy=malloc(sizeof(TP_TYPES))))
	  yyfail("%s","can't allocmem for temporary type!");
	*dummy=types[i]^tp_string;
	print_types(dummy,1);
	free(dummy);
	fprintf(yyout, "`");
        break;
	}	
      case tp_vect:				/* vect is shown as <...> */
	{
	fprintf(yyout,"<");
	if (NULL==(dummy=malloc(sizeof(TP_TYPES))))
	  yyfail("%s","can't allocmem for temporary type!");
	*dummy=types[i]^tp_vect;
	print_types(dummy,1);
	free(dummy);
	fprintf(yyout, ">");
	break;
	}
      case tp_tvect:				/* tvect is shown as >...< */
	{
	fprintf(yyout,">");
	if (NULL==(dummy=malloc(sizeof(TP_TYPES))))
	  yyfail("%s","can't allocmem for temporary type!");
	*dummy=types[i]^tp_tvect;
	print_types(dummy,1);
	free(dummy);
	fprintf(yyout, "<");
	break;
	}
      case tp_matrix:				/* matrix is shown as <:...:> */
	{
	fprintf(yyout,"<:");
	if (NULL==(dummy=malloc(sizeof(TP_TYPES))))
	  yyfail("%s","can't allocmem for temporary type!");
	*dummy=types[i]^tp_matrix;
	print_types(dummy,1);
	free(dummy);
	fprintf(yyout, ":>");
	break;
	}
      case tp_prim:
      case tp_func:
      case tp_clos:
	{
	fprintf(yyout, "%s",other_type_names[types[i] & (PRIM_MASK | EXT_MASK)]);
	break;
	}
      default:
        yyfail("%s","illegal type");
      }
    if (i+1 < n)
      fprintf(yyout, " ");
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* searchs on ret STACK for ord						*/
/* returns NULL if ord not found, ord if no legal jcond found until ord */
/* or returns pointer to legal found jcond				*/
/************************************************************************/
ORDER *search_ret(ORDER *ord)
{
long i,found=0;

DBUG_ENTER("search_ret");
if ((NULL==ret) || (1==new_params))
  DBUG_RETURN((ORDER *)NULL);
for (i=0; i<GETTOPOFSTACK(ret); i++)		/* search for ord on return-STACK */
  {
  if (ord==GETSTACKENTRY(ret,stack)[i].dat.ret->ord)
    found=1;
  }
if (0!=found)
  {
  for (i=GETTOPOFSTACK(ret)-1; i>=0; i--)	/* search for still executable */
    						/* JCONDS on ret-STACK */
    {
    if JCONDS(GETORDERENTRY(GETSTACKENTRY(ret,stack)[i].dat.ret->ord,command))
      {
      if (1==GETSTACKENTRY(ret,stack)[i].dat.ret->branch)	/* found */
	DBUG_RETURN(GETSTACKENTRY(ret,stack)[i].dat.ret->ord);
      if (1==GETORDERENTRY(GETSTACKENTRY(ret,stack)[i].dat.ret->ord,branch))
								/* found */
	DBUG_RETURN(GETSTACKENTRY(ret,stack)[i].dat.ret->ord);
      }
    }
  DBUG_RETURN(ord);				/* no JCONDS found */
  }
DBUG_RETURN((ORDER *)NULL);
}

/************************************************************************/
/* searchs on ret STACK for functioncall with label "label"		*/
/************************************************************************/
STACK *findfcall(STELM *stelm)
{
int i=0;
char *label;
FUNDESC *des;
STACK *dummy;
STELM *result;

DBUG_ENTER("findlabel");
if (NULL==(label=malloc(strlen(GETORDERARGS(GETSTELMDATA(stelm,ret)->ord,label))+1)))
  yyfail("%s","no memory for label!");
strcpy(label,GETORDERARGS(GETSTELMDATA(stelm,ret)->ord,label));
while ((i<GETTOPOFSTACK(ret)) && 
       ((NULL==GETORDERARGS(GETSTELMDATA(st_read(ret,i),ret)->ord,label)) ||
       (0!=strcmp(label,GETORDERARGS(GETSTELMDATA(st_read(ret,i),ret)->ord,label)))))
  i++;
if (i!=GETTOPOFSTACK(ret))			/* found something ? */
  {
  if (apply==GETORDERENTRY(GETSTELMDATA(st_read(ret,i),ret)->ord,command))
    {
    des=find_desc(GETFIRSTDESC(program_start),label);
    dummy=st_make(GETSTELMDATA(st_read(ret,i),ret)->w,GETDESCENTRY(des,nv)+1);
    st_pop(dummy);				/* remove function form w STACK */
    result=get_result(label,dummy,GETDESCENTRY(des,nv),
		      GETSTELMDATA(st_read(ret,i),ret)->t,GETDESCENTRY(des,nfv));
    st_free(dummy);
    if (NULL==result)				/* no result stored ? */
      {
      free(label);
      DBUG_RETURN((STACK *)NULL);
      }
    }
  else						/* [gamma]beta */
    {
    des=find_desc(GETFIRSTDESC(program_start),label);
    result=get_result(label,GETSTELMDATA(st_read(ret,i),ret)->w,GETDESCENTRY(des,nv),
		      GETSTELMDATA(st_read(ret,i),ret)->t,GETDESCENTRY(des,nfv));
    if (NULL==result)				/* no result stored */
      {
      free(label);
      DBUG_RETURN((STACK *)NULL);
      }
    }
  while (i>0)
    {
    result=st_pop(ret);
    if (JCONDS(GETORDERENTRY(GETSTELMDATA(result,ret)->ord,command)))
      					/* for all poped JCONDS clear branch */
      SETORDERENTRY(GETSTELMDATA(result,ret)->ord,branch)=0;
    st_free(GETSTELMDATA(result,ret)->w);	/* remove stored STACKs */
    st_free(GETSTELMDATA(result,ret)->a);
    st_free(GETSTELMDATA(result,ret)->r);
    st_free(GETSTELMDATA(result,ret)->t);
    i--;
    }
  free(label);
  DBUG_RETURN(ret);			/* return new ret STACK */
  }
free(label);
yyfail("%s","bad label for findcall!");
DBUG_RETURN((STACK *)NULL);
}

/************************************************************************/
/* searchs on ret STACK for last function call				*/
/* returns STELM of ret from last function call				*/
/************************************************************************/
STELM *getfunc_ret()
{
long i;

DBUG_ENTER("getfunc_ret");
for (i=GETTOPOFSTACK(ret)-1; i>=0; i--)
  {
  if BETAFUNCS(GETORDERENTRY(GETSTACKENTRY(ret,stack)[i].dat.ret->ord,command))
    DBUG_RETURN(&(GETSTACKENTRY(ret,stack)[i]));
  }
DBUG_RETURN((STELM *)NULL);
}

/************************************************************************/
/* restores enviroment of function ord and cleans ret			*/
/************************************************************************/
void restore_ret(ORDER *old_ord)
{
STELM *elm;

DBUG_ENTER("restore_ret");
elm=st_pop(ret);
while ((GETSTELMDATA(elm,ret)->ord!=old_ord) || 
       ((0==GETSTELMDATA(elm,ret)->branch) && 
	(3==GETORDERENTRY(GETSTELMDATA(elm,ret)->ord,branch))))
  {
  st_free(GETSTELMDATA(elm,ret)->w);		/* free stored STACKS */
  st_free(GETSTELMDATA(elm,ret)->a);
  st_free(GETSTELMDATA(elm,ret)->t);
  st_free(GETSTELMDATA(elm,ret)->r);
  elm=st_pop(ret);
  }
ord=elm->dat.ret->ord;				/* restore ORDER */
clos_exe=(GETSTELMDATA(elm,ret)->status&CLOS_EXE)/CLOS_EXE;
new_params=(GETSTELMDATA(elm,ret)->status&NEW_PARAMS)/NEW_PARAMS;
if (0!=GETSTELMDATA(elm,ret)->branch)		/* branch stored ? */
  SETORDERENTRY(ord,branch)=GETSTELMDATA(elm,ret)->branch;
w=elm->dat.ret->w;				/* restore STACKS */
a=elm->dat.ret->a;
if (((gammabeta==GETORDERENTRY(ord,command)) ||
     (gammacase==GETORDERENTRY(ord,command))) ||
    (Gamma==GETORDERENTRY(ord,command)))
  {						/* STACK switch */
  r=elm->dat.ret->t;
  t=elm->dat.ret->r;
  }
else
  {
  r=elm->dat.ret->r;
  t=elm->dat.ret->t;
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* returns const pointer of short-type-string of type			*/
/************************************************************************/
const char *short_type_names(TP_TYPES type)
{
char *dummy;

DBUG_ENTER("short_type_names");
if ((0<=type) && (OTHER_MASK>type))		/* normal prim or ext type */
  {
  if (PRIM_MASK<type)				/* extended type */
    {
    if ((tp_list==(type & EXT_MASK)) ||		/* check for list */
	(tp_string==(type & EXT_MASK)))
      DBUG_RETURN(s_ext_type_names[CALC_EXT(type)]);
    else				/* it must be vect, tvect or matrix */
      {
      if (NULL==(dummy=malloc(3)))		/* mem for two chars + \0 */
	yyfail("%s","can't alloc mem for temporary string!");
      dummy[0]=s_ext_type_names[CALC_EXT(type)][0];
      dummy[1]=s_prim_type_names[type & PRIM_MASK][0];
      dummy[2]=0;
      DBUG_RETURN(dummy);			/* returning string */
      }
    }
  else						/* prim type */
    DBUG_RETURN(s_prim_type_names[type]);
  }
else						/* other or special type */
  {
  if (OTHER_MASK<type)
    {
    if (tp_list==(type & tp_list))		/* that a list */
      DBUG_RETURN(s_ext_type_names[CALC_EXT(type & tp_list)]);
    else
      yyfail("%s","dunno type!");
    }
  else
    {
    if (0>type)						/* special type */
      yyfail("%s","type is not printable");
    else						/* other type */
      DBUG_RETURN(s_other_type_names[type-OTHER_MASK]);
    }
  }
DBUG_RETURN((char *)NULL);
}

/************************************************************************/
/* returns const pointer of type-string	of type				*/
/************************************************************************/
const char *long_type_names(TP_TYPES type)
{
DBUG_ENTER("long_type_names");
if ((0<=type) && (OTHER_MASK>type))		/* normal prim or ext type */
  {
  if (PRIM_MASK<type)				/* extended type */
    DBUG_RETURN(ext_type_names[CALC_EXT(type)]);
  else						/* prim type */
    DBUG_RETURN(prim_type_names[type]);
  }
else						/* other or special type */
  if (0>type)					/* special type */
    yyfail("%s","type is not printable");
  else						/* other type */
    DBUG_RETURN(other_type_names[type-OTHER_MASK]);
DBUG_RETURN((char *)NULL);
}

/************************************************************************/
/* searches for object address in FUNLIST and DATA			*/
/* returns pointer to new build STELM					*/
/************************************************************************/
STELM *find_address(void *adr)
{
STELM *res=NULL;
FUNDESC *froot;
DATANODE *data;

DBUG_ENTER("find_address");
froot=GETFIRSTDESC(program_start);			/* start with FUNDESCs */
while ((NULL!=froot) && (NULL==res))
  {
  if (GETDESCENTRY(froot,address)==(int)adr)		/* function found */
    res=new_stelm(tp_func,froot);		/* remember FUNDESC in STELM */
  else
    froot=GETNEXTDESC(froot);
  }
data=GETFIRSTDATA(program_start);			/* first DATANODE */
while ((NULL!=data) && (NULL==res))
  {
  if (GETDATAENTRY(data,address)==(int)adr)		/* dataadress found */
    {
    switch (GETDATAENTRY(data,tag))
      {
      case d_name:					/* free variable */
	{
	res=new_stelm(tp_var,NULL);
	break;
        }
      case d_real:					/* real value */
	{
        res=new_stelm(tp_real,NULL);
	break;
	}
      case d_list:					/* list */
	{
	int size,help,j;
	SUBTYPE tp={tp_empty,NULL};		/* init with empty subtype */
	STELM *dummy;
	
	size=GETDATAENTRY(data,u.v.size);		
	for (j=0; j<size; j++)				/* explore all elements */
	  {
	  help=GETDATAENTRY(data,u.v.data[j]);
	  if ((ISINT(help)) && 				/* int element */
	      ((tp_empty==tp.type) || (tp_int==tp.type))) /* list empty or */
							  /* int untill now */
	    tp.type=tp_int;
          else 
	    {
	    if ((ISBOOL(help)) && ((tp_empty==tp.type) || (tp_bool==tp.type)))
	      tp.type=tp_bool;				/* s.o. with bool */
            else
	      {
	      if ((ISPRF(help)) && ((tp_empty==tp.type) || (tp_prim==tp.type)))
		tp.type=tp_prim;			/* s.o. prim */
	      else 					/* build up complex type */
		{
		dummy=find_address((void *)help);
		if ((NULL!=dummy) && ((tp.type==GETSTELMTYPE(dummy)) ||
				      (tp_empty==tp.type)))
		  {
		  if ((((tp_list==GETSTELMTYPE(dummy)) ||
		        (tp_vect==GETSTELMTYPE(dummy))) ||
		       ((tp_tvect==GETSTELMTYPE(dummy)) ||
		        (tp_matrix==GETSTELMTYPE(dummy)))) ||
		      (tp_string==GETSTELMTYPE(dummy)))
		    {
		    if (tp_empty==tp.type)
		      {
		      tp.type=GETSTELMTYPE(dummy);
		      tp.next=subtype_cpy(&dummy->subtype);
		      }
		    else
		      {
		      tp.type=GETSTELMTYPE(dummy);
		      subtypecmp(tp.next,&dummy->subtype);
		      }
		    }
		  else
		    tp.type=GETSTELMTYPE(dummy);
		  }
                else
		  {
		  SUBTYPE *subt,*dsubt;
		  
                  tp.type=tp_none;
		  subt=tp.next;
		  while (NULL!=subt)			/* free whole structure */
		    {
		    dsubt=subt->next;
		    free(subt);
		    subt=dsubt;
		    }
		  tp.next=NULL;
		  }
		}
	      }
	    }
	  }
	res=new_stelm(tp_list,(void *)&tp);
	break;
	}
      case d_string:					/* string */
	{
	int size,help,j;
	SUBTYPE tp={tp_empty,NULL};
	
	size=GETDATAENTRY(data,u.v.size);
	for (j=0; j<size; j++)
	  {
	  help=GETDATAENTRY(data, u.v.data[j]);
	  if ((ISCHAR(help)) && ((tp_empty==tp.type) || (tp_char==tp.type)))
	    tp.type=tp_char;
          else
            tp.type=tp_none;
	  }
	res=new_stelm(tp_string,(void *)&tp);
	break;
	}
      case d_mat:					/* matrix */
      case d_vect:					/* vect */
      case d_tvect:					/* tvect */
	{
	SUBTYPE tp={tp_empty,NULL};
	
	switch (GETDATAENTRY(data,u.w.tag))
	  {
	  case d_int:
	    tp.type=tp_int;
	    break;
	  case d_bool:
	    tp.type=tp_bool;
	    break;
	  case d_string:
	    tp.type=tp_string;
	    break;
	  case d_real:
	    tp.type=tp_real;
	    break;
	  case d_undef:
	    break;
	  default:
	    yyfail("%s","unknown type in datanode");
	    break;
	  }
	if (d_mat==GETDATAENTRY(data,tag))
	  res=new_stelm(tp_matrix,(void *)&tp);
	else
	  {
	  if (d_vect==GETDATAENTRY(data,tag))
	    res=new_stelm(tp_vect,(void *)&tp);
	  else
	    {
	    if (d_tvect==GETDATAENTRY(data,tag))
	      res=new_stelm(tp_tvect,(void *)&tp);
	    else
	      yyfail("%s","unknown type in datanode");
	    }
	  }
	break;
	}
      default:
	{
        yyfail("%s","unknown type in datanode");
	break;
	}
      }
    }
  else
    data=GETNEXTDATA(data);
  }
DBUG_RETURN(res);			/* return found and translated data */
}

/************************************************************************/
/* checks for args hash                                                 */
/* returns 0 for false and 1 for true                                   */
/************************************************************************/
long check_hash_args(ORDER *ord)
{
DBUG_ENTER("check_hash_args");
if ((hashargs==GETORDERENTRY(ord,command)) || 
    (hashtildeargs==GETORDERENTRY(ord,command)))
  DBUG_RETURN(1);
DBUG_RETURN(0);
}

/************************************************************************/
/* inserts args as hash in orderlist					*/
/************************************************************************/
void insert_args(STACK *w,long n,STACK *t,long nf,ORDER *ord)
{
long i;
TP_TYPES *argtp;

DBUG_ENTER("insert_args");
if (0==check_hash_args(ord))			/* hash_args allready present */
  {
  if (0<n)					/* if there are args */
    {
    if (NULL==(argtp=malloc(n*sizeof(TP_TYPES))))  /* alloc type array */
      yyfail("%s","no memory for argtypes of function!\n");
    for (i=0; i<n; i++)				/* for all args */
      argtp[i]=(GETSTELMTYPE(st_read(w,i)))|(st_read(w,i)->subtype.type);
    insert_order_list(new_order(hashargs,n,argtp),ord);
    }
  if (0<nf)					/* if there are tildeargs */
    {
    if (NULL==(argtp=malloc(nf*sizeof(TP_TYPES)))) /* alloc type array */
      yyfail("%s","no memory for tildeargtypes of function!\n");
    for (i=0; i<nf; i++)			/* for all tildeargs */
      argtp[i]=(GETSTELMTYPE(st_read(t,i)))|(st_read(t,i)->subtype.type);
    insert_order_list(new_order(hashtildeargs,nf,argtp),ord);
    }
  }
else						/* args hash present */
  {
  if (0<n)					/* if there are args */
    {
    if (NULL==(argtp=malloc(n*sizeof(TP_TYPES))))
      yyfail("%s","no memory for argtypes of function!\n");
    for (i=0; i<n; i++)				/* for all args */
      {
      argtp[i]=(GETSTELMTYPE(st_read(w,i)))|(st_read(w,i)->subtype.type);
      if (argtp[i]!=GETORDERARGS(ord,argtp[i])) /* do types differ ? */
	{
	if ((tp_list==GETSTELMTYPE(st_read(w,i))) &&
	    (tp_empty==st_read(w,i)->subtype.type) &&
	    (tp_list==(GETORDERARGS(ord,argtp[i]) & tp_list)))
	  {
	  argtp[i]=GETORDERARGS(ord,argtp[i]);
	  st_read(w,i)->subtype.type=GETORDERARGS(ord,argtp[i])-tp_list;
	  }
	else
	  {
	  if ((tp_list!=GETSTELMTYPE(st_read(w,i))) ||
	      (tp_empty!=GETORDERARGS(ord,argtp[i])-tp_list) ||
	      (tp_list!=(GETORDERARGS(ord,argtp[i]) & tp_list)))
	    argtp[i]=tp_none;			/* then type is none */
	  }
	}
      }
    free(GETORDERARGS(ord,argtp));		/* free old args */
    SETORDERARGS(ord,argtp)=argtp;		/* store new args */
    ord=GETNEXTORDER(ord);
    }
  if (0<nf)					/* if there are tildeargs */
    {
    if (NULL==(argtp=malloc(nf*sizeof(TP_TYPES))))
      yyfail("%s","no memory for argtypes of function!\n");
    for (i=0; i<nf; i++)			/* for all tildeargs */
      {
      argtp[i]=(GETSTELMTYPE(st_read(t,i)))|(st_read(t,i)->subtype.type);
      if (argtp[i]!=GETORDERARGS(ord,argtp[i]))	/* do types differ ? */
	{
	if ((tp_list==GETSTELMTYPE(st_read(t,i))) &&
	    (tp_empty==st_read(t,i)->subtype.type) &&
	    (tp_list==(GETORDERARGS(ord,argtp[i]) & tp_list)))
	  {
	  argtp[i]=GETORDERARGS(ord,argtp[i]);
	  st_read(t,i)->subtype.type=GETORDERARGS(ord,argtp[i])-tp_list;
	  }
	else
	  {
	  if ((tp_list!=GETSTELMTYPE(st_read(t,i))) ||
	      (tp_empty!=GETORDERARGS(ord,argtp[i])-tp_list) ||
	      (tp_list!=(GETORDERARGS(ord,argtp[i]) & tp_list)))
	    argtp[i]=tp_none;			/* then type is none */
	  }
	}
      }
    free(GETORDERARGS(ord,argtp));		/* free old tildeargs */
    SETORDERARGS(ord,argtp)=argtp;		/* store new tildeargs */
    }
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* inserts restype as hash in orderlist					*/
/************************************************************************/
void insert_restype(STELM *res, ORDER *o)
{
ORDER *ord;
TP_TYPES *argtp;

DBUG_ENTER("insert_restype");
if (NULL==o->prev)				/* is there no previous ORDER ? */
  DBUG_VOID_RETURN;
if (hashrestype!=GETORDERENTRY(GETORDERENTRY(o,prev),command))
  {
  if ((tp_list==GETSTELMTYPE(res)) || (tp_string==GETSTELMTYPE(res)) ||
      (tp_vect==GETSTELMTYPE(res)) || (tp_tvect==GETSTELMTYPE(res)) ||
      (tp_matrix==GETSTELMTYPE(res)))
    {
    if (NULL==(argtp=malloc(sizeof(TP_TYPES))))
      yyfail("%s","no memory for restype!");
    argtp[0]=GETSTELMTYPE(res) | res->subtype.type;
    ord=new_order(hashrestype,1,argtp);			/* create hash ORDER */
    insert_order_list(ord,o);
    }
  else
    {
    if (NULL==(argtp=malloc(sizeof(TP_TYPES))))
      yyfail("%s","no memory for restype!");
    argtp[0]=GETSTELMTYPE(res);
    ord=new_order(hashrestype,1,argtp);			/* create hash ORDER */
    insert_order_list(ord,o);
    }
  }
else						/* restype allready set */
  {
  o=GETPREVORDER(o);
  SETORDERARGS(o,argtp[0])=GETSTELMTYPE(res)|res->subtype.type;
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* searches for matching functionresult in FUNLIST			*/
/* returns pointer to matching STELM located in FUNTYPE			*/
/* sets global variable 'know' to stored KNOWLEDGE			*/
/************************************************************************/
STELM *get_result(char *s, STACK *a, long n, STACK *t, long nt)
{
STELM *res=NULL;				/* preset to nothing found */
FUNLIST *flp;
FUNTYPES *ft;

DBUG_ENTER("get_result");
DBUG_PRINT("FUNLIST",("->Fun: %s Par.: %d TPar.: %d",s,n,nt));
flp=searchfunlist(s);				/* search for cache-entry */
if (NULL!=flp)						/* is there a match */
  {
  ft=searchftypes(flp->funtypes,(0==n ) ? NULL : st_read(a,n-1),
		                (0==nt) ? NULL : st_read(t,nt-1),
		  n,nt);		/* is there an entry with this args ? */
  if (NULL!=ft)						/* found match */
    {
    res=&(ft->result);					/* set stored result */
    know=ft->knowledge;					/* set knowledge */
    if ((apply!=GETORDERENTRY(ord,command)) && 		/* BETAFUNCS but no apply */
	BETAFUNCS(GETORDERENTRY(ord,command)))
      {
      free(SETORDERARGS(ord,label));			/* free old label */
      if (NULL==(SETORDERARGS(ord,label)=malloc(strlen(ft->label)+1)))
        yyfail("%s","no memory for label!");
      strcpy(SETORDERARGS(ord,label),ft->label); /* set new label for these args */
      }
    new_params=0;					/* no new parameter */
    }
  else
    {
    insert_functype(s,a,n,t,nt,NULL,kn_no);		/* init function cache */
    know=kn_no;
    new_params=1; 					/* new parameter */
    }
  }
else							/* create new cache entry */
  {
  insert_functype(s,a,n,t,nt,NULL,kn_no);
  know=kn_no;
  new_params=0;
  }
DBUG_PRINT("FUNLIST",("<-Result: %d",(NULL==res) ? tp_illegal : GETSTELMTYPE(res)));
DBUG_RETURN(res);					/* return cached result */
}

/************************************************************************/
/* frees subtypes structure						*/
/************************************************************************/
void free_subtype(STELM *stelm)
{
SUBTYPE *st,*dst;

DBUG_ENTER("free_subtype");
st=stelm->subtype.next;				/* goto fist dynamic substruct */
while (NULL!=st)				/* free whole structure */
  {
  dst=st->next;
  free(st);
  st=dst;
  }
stelm->subtype.next=NULL;
DBUG_VOID_RETURN;
}

/************************************************************************/
/* copies subtypes to new created subtype and				*/
/* returns pointer to new subtype or NULL if empty			*/
/************************************************************************/
SUBTYPE *subtype_cpy(SUBTYPE *st)
{
SUBTYPE *dst,*ost;

DBUG_ENTER("subtype_cpy");
if (NULL==st)						/* no subtype */
  DBUG_RETURN((SUBTYPE *)NULL);
if (NULL==(ost=(dst=malloc(sizeof(SUBTYPE)))))
  yyfail("%s","no memory for subtypestructure");
while (NULL!=st->next)					/* goto beginning */
  {
  dst->type=st->type;					/* copy type */
  if (NULL==(dst->next=malloc(sizeof(SUBTYPE))))
    yyfail("%s","no memory for subtypestructure");
  st=st->next;						/* goto next entry */
  dst=dst->next;
  }
dst->type=st->type;
dst->next=NULL;						/* the end my friend */
DBUG_RETURN(ost);					/* return copy */
}

/************************************************************************/
/* compares two subtypes of lists, removes all unmatched subtypes of 	*/ 
/* subtype one								*/
/************************************************************************/
void subtypecmp(SUBTYPE *st1,SUBTYPE *st2)
{
DBUG_ENTER("subtypecmp");
if (NULL!=st1)					/* is there a subtype ? */
  {
  while ((NULL!=st1) && (NULL!=st2))		/* while data present */
    {
    if (st1->type!=st2->type)			/* types do not match */
      {
      st1->type=tp_none;			/* set type to none */
      st2=st1->next;
      st1->next=NULL;				/* end of subtype */
      while (NULL!=st2)				/* clear the tail */
	{
	st1=st2->next;
	free(st2);
	st2=st1;
	}
      }
    else
      {
      st1=st1->next;				/* advance to next type */
      st2=st2->next;
      }
    }
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* compares two arrays of STELM	type					*/
/* returns 0 if both arrays are equal, else -1				*/
/************************************************************************/
int stelmcmp(STELM *stelm1,STELM *stelm2,int n)
{
int i;

DBUG_ENTER("stelmcmp");
for (i=0; i<n; i++)				/* for all args do ... */
  {
  if (stelm1[i].type!=stelm2[i].type)		/* if types aren't equal */
    DBUG_RETURN(-1);
  else						/* checking subtypes */
    {
    switch (stelm1[i].type)
      {      
      case tp_func:
	{
	if (stelm1[i].dat.desc!=stelm2[i].dat.desc) /* the same function */
	  DBUG_RETURN(-1);
	break;
	}
      case tp_vect:
      case tp_tvect:
      case tp_matrix:
      case tp_string:
      case tp_list:
	{
	if (stelm1[i].subtype.type!=stelm2[i].subtype.type)
	  DBUG_RETURN(-1);
	break;
	}
      case tp_clos:
	{
	if (stelm1[i].dat.clos->desc!=stelm2[i].dat.clos->desc)
	  					/* closure of same function */
	  DBUG_RETURN(-1);
	if (((stelm1[i].dat.clos->i!=stelm2[i].dat.clos->i) ||
	     (stelm1[i].dat.clos->j!=stelm2[i].dat.clos->j)) ||
	    (stelm1[i].dat.clos->k!=stelm2[i].dat.clos->k))
	  				/* same number of stored args & tildeargs */
	  DBUG_RETURN(-1);
	if (0!=stelmcmp(stelm1[i].dat.clos->w,stelm2[i].dat.clos->w,
		         stelm1[i].dat.clos->i))	/* do the args match */
	  DBUG_RETURN(-1);
	if ((NULL!=stelm1[i].dat.clos->desc) &&
	    (0!=stelmcmp(stelm1[i].dat.clos->t,stelm2[i].dat.clos->t,
			 stelm1[i].dat.clos->k)))	/* do the tildeargs match */
	  DBUG_RETURN(-1);
	break;
	}
      case tp_var:
      case tp_illegal:
      case tp_badrecur:
      case tp_int:
      case tp_real:
      case tp_bool:
      case tp_prim:
      case tp_none:
      case tp_returnadr:
      case tp_empty:
      case tp_char:
	break;						/* nothing to do */
      default:
	yyfail("%s","unknown stelmtype!");
      }
    }
  }
DBUG_RETURN(0);						/* args do match */
}

/************************************************************************/
/* searches for function in functionlist with matching a & t frames	*/
/* returns pointer to matching funtype or NULL for no match		*/
/************************************************************************/
FUNTYPES *searchftypes(FUNTYPES *ft, STELM *a, STELM *t, long n, long nt)
{
char found=0;

DBUG_ENTER("searchftypes");
DBUG_PRINT("FUNLIST",("->Par.: %d TPar.: %d",n,nt));
while ((NULL!=ft) && (0==found))
  {
  if (((0==n ) || (0==stelmcmp(a,ft->params,n))) &&
      ((0==nt) || (0==stelmcmp(t,ft->tparams,nt))))
    found=1;						/* we have a match */
  else
    ft=ft->next;					/* goto next entry */
  }
DBUG_PRINT("FUNLIST",("<-Res.: %s",(NULL==ft) ? "not found" : "found"));
DBUG_RETURN(ft);
}

/************************************************************************/
/* searches for matching name in FUNLIST				*/
/* returns pointer to matching FUNLIST entry or NULL			*/
/************************************************************************/
FUNLIST *searchfunlist(char *name)
{
char found=0;
FUNLIST *root=flbase;

DBUG_ENTER("searchfunlist");
DBUG_PRINT("FUNLIST",("->Fun. Name: %s",name));
while ((NULL!=root) && (0==found))
  {
  if (0==strcmp(root->name,name))		/* name comparison */
    found=1;					/* we have a match */
  else
    root=root->next;				/* goto next entry */
  }
DBUG_PRINT("FUNLIST",("<-Res.: %s",(NULL==root) ? "not found" : "found"));
if ((NULL!=root) && (NULL!=root->org))	/* if root exists goto substructure */
  root=root->org;
DBUG_RETURN(root);
}

/************************************************************************/
/* inserts new/old functiontype in FUNLIST or modifies storage		*/
/* return int != 0 if typeclash occures					*/
/************************************************************************/
int insert_functype(char *name,STACK *a,long n,STACK *t,long nt,STELM *res,
		    KNOWLEDGE kn)
{
FUNLIST *flp,*flp_dup;
FUNTYPES *ft;
FUNDESC *des;
int sd;
float val;

DBUG_ENTER("insert_functype");
DBUG_PRINT("FUNLIST",("->Fun. Name: %s Par.: %d TPar.: %d Res.: %d",name,n,nt,
		      (NULL==res) ? tp_illegal : GETSTELMTYPE(res)));
flp=searchfunlist(name);			/* search for FUNLIST entry */
if (NULL==flp)					/* no entry -> build new entry */
  {
  if (NULL==(flp=malloc(sizeof(FUNLIST))))
    yyfail("%s","no memory for functionlist!");
  if (NULL==(flp->name=malloc(strlen(name)+1)))
    yyfail("%s","no memory for funtion name!");
  strcpy(flp->name,name);			/* store funcname */
  flp->a=n;					/* store arity */
  flp->t=nt;					/* store tildearity */
  flp->org=NULL;				/* it's the original */
  flp->next=flbase;
  flbase=flp;
  flp->funtypes=NULL;				/* no types set until now */
  }
ft=searchftypes(flp->funtypes,(NULL==a) ? NULL : st_read(a,n-1),
		              (NULL==t) ? NULL : st_read(t,nt-1),
		n,nt);
if (NULL==ft)					/* no matching type */
  {
  if (NULL==(ft=malloc(sizeof(FUNTYPES))))
    yyfail("%s","no memory for function parameters!");
  ft->next=flp->funtypes;			/* insert new type */
  ft->depend=NULL;				/* no dependecies */
  des=find_desc(GETFIRSTDESC(program_start),name);
  val= (NULL==a) ? 0.0 : calc_args_val(st_read(a,n-1),n)*2;
  val+=(NULL==t) ? 0.0 : calc_args_val(st_read(t,nt-1),nt);
  val=val/3;
  if (((0!=do_dupe) && (apply!=GETORDERENTRY(ord,command)) && (0<des->nv)) &&
      ((0==arg_check) || (1.0>=val)))
    					/* is there any code to be duplicated */
    {
    if (NULL==(ft->label=malloc(strlen(name)+4))) /* get mem for new label */
      yyfail("%s","no memory for label!");
    sd=((long)searchforfuncname(name))-((long)name);
    strncpy(ft->label,name,sd);
    sprintf(&(ft->label[sd]),"%d",dup_count);
    sprintf(&(ft->label[strlen(ft->label)]),
	    "_%s",searchfor_(name));		/* new name created */
    dup_count++;				/* duplication counter */
    if (dup_count==dup_num)			/* if max reached */
      do_dupe=0;				/* set no further duplication */
    conc_desc(GETFIRSTDESC(program_start),new_desc(des->tag,
	      max_desc_adr+(dup_count*16),des->nfv,des->nv,des->graph,ft->label));
    						/* new desc build up */
    ft->ord=dup_func(find_func(GETFIRSTFUNCTION(program_start),name),1);
    conc_function(GETFIRSTFUNCTION(program_start),new_function(ft->label,ft->ord));
    if (NULL==(SETORDERARGS(ord,label)=malloc(strlen(ft->label)+1)))
      yyfail("%s","no memory for label!");
    strcpy(GETORDERARGS(ord,label),ft->label);
    if (NULL==(flp_dup=malloc(sizeof(FUNLIST))))
      yyfail("%s","no memory for functionlist!");
    if (NULL==(flp_dup->name=malloc(strlen(ft->label)+1)))
      yyfail("%s","no memory for funtion name!");
    strcpy(flp_dup->name,ft->label);		/* store funcname */
    flp_dup->a=n;				/* store arity */
    flp_dup->t=nt;				/* store tildearity */
    flp_dup->org=flp;				/* there is the original */
    flp_dup->next=flbase;
    flbase=flp_dup;
    flp_dup->funtypes=NULL;			/* no types set until now */
    }
  else						/* no duplication */
    {
    if (NULL==(ft->label=malloc(strlen(name)+1)))
      yyfail("%s","no memory for label!");
    strcpy(ft->label,name);			/* save function name */
    }
  flp->funtypes=ft;
  know=kn;					/* set knowledge */
  if (0<n)					/* get memory for a frame */
    {
    if (NULL==(ft->params=malloc(n*sizeof(STELM))))
      yyfail("%s","no memory for function parameters!");
    stelm_cpy(ft->params,st_read(a,n-1),n); 	/* copy frame */
    }
  else						/* no frame */
    ft->params=NULL;
  if (0<nt)					/* get memory for t frame */
    {
    if (NULL==(ft->tparams=malloc(nt*sizeof(STELM))))
      yyfail("%s","no memory for function parameters!");
    stelm_cpy(ft->tparams,st_read(t,nt-1),nt); /* copy frame */
    }
  else						/* no frame */
    ft->tparams=NULL;
  if (NULL!=res)
    stelm_cpy(&ft->result,res,1);		/* store result */
  else						/* no result to store */
   {
   ft->result.type=tp_illegal;
   ft->result.subtype.type=tp_none;
   ft->result.subtype.next=NULL;
   }
  DBUG_PRINT("FUNLIST",("<-new entry in FUNLIST %s %d %d %d",name,n,nt,
			(NULL==res) ? tp_illegal : GETSTELMTYPE(res)));
  }
else						/* change searchfuntype */
  {
  if (tp_illegal!=ft->result.type)		/* prev stored type exists */
    {
    if ((0!=stelmcmp(&(ft->result),res,1)) &&
	(tp_none!=ft->result.type))		/* old restype != newrestype */
      {
      if (tp_clos==GETSTELMTYPE(res))		/* closure must be executed */
	{
	dump_list_func(res);
	if (tp_clos==ft->result.type)
	  dump_list_func(&(ft->result));
	}
      if ((ft->result.type==res->type) && 
	  ((tp_list==res->type) || (tp_matrix==res->type) ||
	   (tp_tvect==res->type) || (tp_vect==res->type)))
	{
	if (tp_empty==ft->result.subtype.type)
	  {
	  ft->result.subtype.type=res->subtype.type;
	  ft->result.subtype.next=NULL;
	  ft->result.dat.desc=GETSTELMDATA(res,desc);
	  }
	else
	  {
	  if (tp_empty!=res->subtype.type)
	    {
	    ft->result.type=tp_none;
      	    ft->result.dat.desc=GETSTELMDATA(res,desc);
            know=kn_sure;
            DBUG_RETURN(1);
	    }
	  }
	}
      else
	{
        ft->result.type=tp_none;
        ft->result.dat.desc=GETSTELMDATA(res,desc);
        know=kn_sure;
        DBUG_RETURN(1);
	}
      }
    }
  else						/* no type stored */
    {
    if (NULL!=res)
      {
      stelm_cpy(&ft->result,res,1);		/* store result */
      know=kn;
      }
    else
      {
      ft->result.type=tp_illegal;   
      know=kn_no;
      }
    }
  }
DBUG_RETURN(0);
}

/************************************************************************/
/* searches FUNLIST for function named s				*/
/* returns first ORDER of function or NULL				*/
/************************************************************************/
ORDER *find_func(FUNCTION *fun,char *s)
{
DBUG_ENTER("find_func");
while ((NULL!=fun) && (0!=strcmp(s,GETNAME(fun))))
  fun=GETNEXTFUNCTION(fun);
DBUG_RETURN(GETFIRSTORDER(fun));
}

/************************************************************************/
/* searches for function named label in functiondescriptorlist 		*/
/* returns pointer of FUNDESC or NULL					*/
/************************************************************************/
FUNDESC *find_desc(FUNDESC *des,char *label)
{
char found=0;

DBUG_ENTER("finddesc");
while ((NULL!=des) && (0==found))
  {
  if (0==strcmp(label, GETDESCENTRY(des,label)))  /* function names match */
    found=1;					/* we have a match */
  else
    des=GETNEXTDESC(des);			/* goto next entry */
  }
DBUG_RETURN(des);
}

/************************************************************************/
/* searches for functionlabel s in given orderlist ord			*/
/* returns pointer of first order after label s				*/
/************************************************************************/
ORDER *find_label(ORDER *ord, char *s)
{
char found=0;
ORDER *d;

DBUG_ENTER("find_label");
d=ord;
while ((0==found) && (end!=GETORDERENTRY(ord,command)))	/* search forward */
  {
  if ((label==GETORDERENTRY(ord,command)) && (0==strcmp(s,GETORDERARGS(ord,label))))
    found=1;						/* we have a match */
  ord=GETNEXTORDER(ord);				/* advance to next ORDER */
  }
while (0==found)					/* search backward */
  {
  if ((label==GETORDERENTRY(ord,command)) && (0==strcmp(s,GETORDERARGS(ord,label))))
    found=1;						/* we have a match */
  else
    ord=GETPREVORDER(ord);				/* back to last ORDER */
  }  
while (label==GETORDERENTRY(ord,command))	/* goto first "real" ORDER */
  ord=GETNEXTORDER(ord);
DBUG_RETURN(ord);
}

/************************************************************************/
/* allocates and inititialises new stack element			*/
/* returns pointer of new STELM						*/
/************************************************************************/
STELM *new_stelm(TP_TYPES tp,void *data)
{
STELM *help;

DBUG_ENTER("new_stelm");
if (NULL==(help=malloc(sizeof(STELM))))			/* get memory */
  yyfail("couldn't allocate memory for stack element");
SETSTELMTYPE(help)=tp;					/* set type of STELM */
help->subtype.type=tp_none;				/* clear subtype */
help->subtype.next=NULL;
switch (tp)
  {
  case tp_func:
    {
    SETSTELMDATA(help,desc)=data;			/* set FUNDESC of STELM */
    break;
    }
  case tp_clos:
    {
    SETSTELMDATA(help,clos)=data;			/* set CLOSURE of STELM */
    break;
    }
  case tp_illegal:
  case tp_badrecur:
  case tp_int:
  case tp_real:
  case tp_bool:
  case tp_empty:
  case tp_prim:
  case tp_none:
  case tp_char:
  case tp_var:
    {
    SETSTELMDATA(help,desc)=data;			/* set additional data */
    break;
    }
  case tp_returnadr:
    {
    SETSTELMDATA(help,ret)=data;
    break;
    }
  case tp_string:
  case tp_vect:
  case tp_tvect:
  case tp_matrix:
  case tp_list:
    {    
    help->subtype.type=((SUBTYPE *)data)->type;
    help->subtype.next=((SUBTYPE *)data)->next;
    free(data);
    break;
    }
  default:
    {
    yyfail("%s","wrong type for stackelement");
    break;
    }
  }
DBUG_RETURN(help);
}

/************************************************************************/
/* copies stackelements with all possible structures			*/
/************************************************************************/
void stelm_cpy(STELM *stelm1,STELM *stelm2,long n)
{
long i;

DBUG_ENTER("stelm_cpy");
memcpy(stelm1, stelm2,n*sizeof(STELM));
for (i=0; i<n;i++)				/* for all args do ... */
  {
  switch (stelm2[i].type)
    {
    case tp_returnadr:				/* returnadress */
      {
      if (NULL==(stelm1->dat.ret=malloc(sizeof(RETURNADR))))
	yyfail("%s","no memory for returndata");
      SETSTELMDATA(stelm1,ret)->w=GETSTELMDATA(stelm2,ret)->w;	/* copy STACKs */
      SETSTELMDATA(stelm1,ret)->a=GETSTELMDATA(stelm2,ret)->a;
      SETSTELMDATA(stelm1,ret)->r=GETSTELMDATA(stelm2,ret)->r;
      SETSTELMDATA(stelm1,ret)->t=GETSTELMDATA(stelm2,ret)->t;
      SETSTELMDATA(stelm1,ret)->ord=GETSTELMDATA(stelm2,ret)->ord;      
      SETSTELMDATA(stelm1,ret)->status=GETSTELMDATA(stelm2,ret)->status;
      SETSTELMDATA(stelm1,ret)->branch=GETSTELMDATA(stelm2,ret)->branch;
      break;
      }
    case tp_none:				/* nothing to do */
    case tp_char:
    case tp_int:
    case tp_bool:
    case tp_prim:
    case tp_real:
    case tp_illegal:
    case tp_var:
      break;
    case tp_func:				/* function */
      {
      stelm1[i].dat.desc=stelm2[i].dat.desc;
      break;
      }
    case tp_clos:				/* closure */
      {
      CLOSURE *clos;
      
      if (NULL!=stelm2[i].dat.clos)		/* if there are any data */
	{
	if (NULL==(clos=malloc(sizeof(CLOSURE))))
	  yyfail("%s","no memory for new closure");
	stelm1[i].dat.clos=clos;		/* save pointer of clos in STELM */
	if (NULL==(clos->w=malloc(stelm2[i].dat.clos->i*sizeof(STELM))))
	  yyfail("%s","no memory for new closure");
	stelm_cpy(clos->w,stelm2[i].dat.clos->w,
		  stelm2[i].dat.clos->i); 	/* copy A frame */
	clos->i=stelm2[i].dat.clos->i;
	clos->j=stelm2[i].dat.clos->j;
	clos->k=stelm2[i].dat.clos->k;
	clos->desc=stelm2[i].dat.clos->desc;
	if (NULL!=clos->desc)			/* clos->desc!=NULL => func */
	  {
	  if (0!=stelm2[i].dat.clos->k)
	    {
	    if (NULL==(clos->t=malloc(stelm2[i].dat.clos->k*sizeof(STELM))))
	      yyfail("%s","no memory for new closure");
	    stelm_cpy(clos->t,stelm2[i].dat.clos->t,
		      stelm2[i].dat.clos->k);	/* copy T frame */
	    }
	  else					/* no tilde frame */
	    clos->t=NULL;
	  }
	else					/* prim func */
	  clos->t=NULL;
	}
      break;
      }
    case tp_string:
    case tp_vect:
    case tp_tvect:
    case tp_matrix:
      {
      stelm1[i].subtype.type=stelm2[i].subtype.type;
      stelm1[i].subtype.next=NULL;
      break;
      }
    case tp_list:				/* list */
      {
      SUBTYPE *sb1,*sb2;
      
      stelm1[i].subtype.type=stelm2[i].subtype.type;
      sb2=stelm2[i].subtype.next;
      sb1=&(stelm1[i].subtype);
      while (NULL!=sb2)				/* copy subtype structure */
	{
	if (NULL==(sb1->next=malloc(sizeof(SUBTYPE))))
	  yyfail("%s","no momory for subtype");
	sb1=sb1->next;
	sb1->type=sb2->type;
	sb2=sb2->next;
	}
      sb1->next=NULL;				/* set end of structure */
      break;
      }
    default:
      yyfail("%s","no known STELM type");
    }
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* frees stackelements with all possible substructures			*/
/************************************************************************/
void stelm_free(STELM *stelm)
{
DBUG_ENTER("stelm_free");
switch (GETSTELMTYPE(stelm))
  {
  case tp_none:					/* nothing to do */
  case tp_int:
  case tp_bool:
  case tp_func:
  case tp_prim:
  case tp_illegal:
  case tp_badrecur:
  case tp_real:
  case tp_empty:
  case tp_string:
  case tp_vect:
  case tp_tvect:
  case tp_matrix:
  case tp_char:
  case tp_var:
    break;
  case tp_list:					/* list */
    {
    free_subtype(stelm);			/* free subtype structure */
    break;
    }
  case tp_returnadr:				/* returnadress */
    {
    free(GETSTELMDATA(stelm,ret));
    break;
    }
  case tp_clos:				/* stelm_free of all frame elements */
    {
    CLOSURE *clos;
    long i;
    
    if (NULL!=stelm->dat.clos)			/* if data stored */
      {
      clos=stelm->dat.clos;
      if (NULL!=clos->w)			/* if W frame */
	for (i=0; i<clos->i; i++)		/* free all elements */
	  stelm_free(&(clos->w[i]));
      if (NULL!=clos->t)			/* if T frame */
	for (i=0; i<clos->k; i++)		/* free all elements */
	  stelm_free(&(clos->t[i]));
      free(clos);				/* free closure data */
      }
    break;
    }
  default:
    yyfail("%s","illegal stackelement found");
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* frees stack with all elements 					*/
/************************************************************************/
void st_free(STACK *st)
{
long i;

DBUG_ENTER("st_free");
if (NULL!=st)					/* no stack allocated */
  {
  for (i=0; i<GETTOPOFSTACK(st); i++)		/* for all STACKelements */
    stelm_free(&(st->stack[i]));		/* free STELMs of stack */
  free(st->stack);				/* free structure */
  free(st);
  st=NULL;					/* set STACK to NULL means empty */
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* builds a stack with a copy of the first n elements of st		*/
/* returns new allocated an initialiesed STACK				*/
/************************************************************************/
STACK *st_make(STACK *st, long n)
{
STACK *nst=NULL;
long l;

DBUG_ENTER("st_make");
if (0!=n)						/* no STELMs to copy */
  {
  if (NULL==(nst=malloc(sizeof(STACK))))
    yyfail("%s","no memory for stack creation!");
  l=MIN_STACK_SIZE;					/* set initial STACKsize */
  while (l<=n)						/* calc needed size */
    l*=4;
  if (NULL==(SETSTACKENTRY(nst,stack)=malloc(l*sizeof(STELM))))
    yyfail("%s","no memory for local stack!");
  SETSTACKENTRY(nst,length)=l;				/* store size */
  SETSTACKENTRY(nst,topofstack)=n;		/* store number of elements */	
  stelm_cpy(GETSTACKENTRY(nst,stack),st_read(st,n-1),n); 	/* copy STELMs */
  }
DBUG_RETURN(nst);					/* return new STACK */
}

/************************************************************************/
/* pops elemet top of stack st						*/
/* returns pointer of STELM top of stack st				*/
/************************************************************************/
STELM *st_pop(STACK *st)
{
STELM *stelm;

DBUG_ENTER("st_pop");
SETTOPOFSTACK(st)--;			/* decrement top of stack pointer */
stelm=&(GETSTACKENTRY(st,stack)[GETTOPOFSTACK(st)]);
DBUG_RETURN(stelm);			/* return pointer to element */
}

/************************************************************************/
/* reads stack element number i counted form top of stack st		*/
/* returns pointer of STELM i counted form top of stack st		*/
/************************************************************************/
STELM *st_read(STACK *st, long i)
{
STELM *stelm;

DBUG_ENTER("st_read");
stelm=&(GETSTACKENTRY(st,stack)[GETTOPOFSTACK(st)-i-1]);
DBUG_RETURN(stelm);				/* return pointer to element */
}

/************************************************************************/
/* pushes STELM vt on top of STACK st					*/
/* returns pointer of STACK st (may be changed)				*/
/************************************************************************/
STACK *st_push(STACK *st, STELM *vt)
{
DBUG_ENTER("st_push");
if (NULL==st)						/* empty STACK */
  {
  if (NULL==(st=malloc(sizeof(STACK))))
    yyfail("%s","no memory for new stack!");
  if (NULL==(SETSTACKENTRY(st,stack)=malloc(MIN_STACK_SIZE*sizeof(STELM))))
    yyfail("%s","no memory for new stack!");
  SETSTACKENTRY(st,length)=MIN_STACK_SIZE;		/* set initial size */
  SETTOPOFSTACK(st)=0;
  }
else							/* stack exists */
  {
  if (GETSTACKENTRY(st,length)==GETTOPOFSTACK(st))	/* modify stacklength */
    {
    if (NULL==(SETSTACKENTRY(st,stack)=realloc(GETSTACKENTRY(st,stack),
			    sizeof(STELM)*4*GETSTACKENTRY(st,length))))
      yyfail("%s","no memory for bigger stack!");
    SETSTACKENTRY(st,length)*=4;			/* set new STACKsize */
    }
  }
stelm_cpy(&(GETSTACKENTRY(st,stack)[GETTOPOFSTACK(st)]),vt,1);
						/* write STELM to STACK */
SETTOPOFSTACK(st)++;			/* increment top of stack pointer */
DBUG_RETURN(st);				/* return pointer of (new) STACK */
}

/************************************************************************/
/* converts hexadecimal number placed in a string into integer		*/
/* returns converted int						*/
/************************************************************************/
int atox(const char * s)
{
int n = 0;
extern int toupper();

DBUG_ENTER("atox");
while(*s)				/* for all chars in string do */
  {
  n=n*16+(isdigit(*s) ? *s-'0' : toupper(*s)-'A'+10);
  s++;						/* next char */
  }
DBUG_RETURN(n);					/* return int */
}

/************************************************************************/
/* searches for '9876543210_' in given string search			*/
/* returns pointer of first char befor '9876543210_'			*/
/************************************************************************/
char *searchforfuncname(char *search)
{
DBUG_ENTER("searchforfuncname");
while (('_'!=search[0]) && (('0'>search[0]) || ('9'<search[0])))
  search++;					/* next char */
DBUG_RETURN(search);
}

/************************************************************************/
/* searches for '_' in given string search				*/
/* returns pointer of first char behind '_'				*/
/************************************************************************/
char *searchfor_(char *search)
{
DBUG_ENTER("searchfor_");
while (search[0]!='_')
  search++;					/* goto next char */
search++;					/* goto char behind '_' */
DBUG_RETURN(search);
}

/************************************************************************/
/* checks if TP_TYPES are tp_int or tp_real and returns most general 	*/
/* type of this two TP_TYPES						*/
/************************************************************************/
static TP_TYPES check_int_real(const TP_TYPES tp0,const TP_TYPES tp1)
{
DBUG_ENTER("check_int_real");
if ((tp_empty==tp0) && (tp0==tp1))
  DBUG_RETURN(tp_empty);
if ((((tp_int==tp0) && (tp0==tp1)) || ((tp_int==tp0) && (tp_empty==tp1))) ||
    ((tp_int==tp1) && (tp_empty==tp0)))
  DBUG_RETURN(tp_int);
if ((((tp_int==tp0) || (tp_real==tp0)) || (tp_empty==tp0)) &&
    (((tp_int==tp1) || (tp_real==tp1)) || (tp_empty==tp1)))
  DBUG_RETURN(tp_real);
DBUG_RETURN(tp_none);
}

/************************************************************************/
/* checks if TP_TYPES tp are tp_vect or tp_vect and tp_int or tp_real	*/
/* returns most general of lt and tp					*/
/************************************************************************/
static TP_TYPES check_vect_num(const TP_TYPES tp0,const TP_TYPES lt0,
			       const TP_TYPES tp1,const TP_TYPES lt1)
{
TP_TYPES dt;

DBUG_ENTER("check_vect_num");
if ((tp_vect==tp0) && (tp0==tp1))
  {
  dt=check_int_real(lt0,lt1);
  DBUG_RETURN(dt);
  }  
if (tp_vect==tp0)
  {
  dt=check_int_real(lt0,tp1);
  DBUG_RETURN(dt);
  }
if (tp_vect==tp1)
  {
  dt=check_int_real(lt1,tp0);
  DBUG_RETURN(dt);
  }
DBUG_RETURN(tp_none);
}

/************************************************************************/
/* checks if TP_TYPES tp are tp_vect or tp_vect and tp_bool returns	*/
/* most general of lt and tp						*/
/************************************************************************/
static TP_TYPES check_vect_bool(const TP_TYPES tp0,const TP_TYPES lt0,
			        const TP_TYPES tp1,const TP_TYPES lt1)
{
DBUG_ENTER("check_vect_num");
if ((tp_vect==tp0) && (tp0==tp1))
  {
  if (tp_bool==(lt0==lt1))
    DBUG_RETURN(tp_bool);
  }  
if (tp_vect==tp0)
  {
  if (tp_bool==(lt0==tp1))
    DBUG_RETURN(tp_bool);
  }
if (tp_vect==tp1)
  {
  if ((tp_bool==tp0) && (lt1==tp0))
    DBUG_RETURN(tp_bool);
  }
DBUG_RETURN(tp_none);
}

/************************************************************************/
/* checks if TP_TYPES tp are tp_tvect or tp_tvect and tp_int or tp_real	*/
/* returns most general of lt and tp					*/
/************************************************************************/
static TP_TYPES check_tvect_num(const TP_TYPES tp0,const TP_TYPES lt0,
			        const TP_TYPES tp1,const TP_TYPES lt1)
{
TP_TYPES dt;

DBUG_ENTER("check_tvect_num");
if ((tp_tvect==tp0) && (tp0==tp1))
  {
  dt=check_int_real(lt0,lt1);
  DBUG_RETURN(dt);
  }  
if (tp_tvect==tp0)
  {
  dt=check_int_real(lt0,tp1);
  DBUG_RETURN(dt);
  }
if (tp_tvect==tp1)
  {
  dt=check_int_real(lt1,tp0);
  DBUG_RETURN(dt);
  }
DBUG_RETURN(tp_none);
}

/************************************************************************/
/* checks if TP_TYPES tp are tp_tvect or tp_tvect and tp_bool returns	*/
/* most general of lt and tp						*/
/************************************************************************/
static TP_TYPES check_tvect_bool(const TP_TYPES tp0,const TP_TYPES lt0,
			         const TP_TYPES tp1,const TP_TYPES lt1)
{
DBUG_ENTER("check_vect_num");
if ((tp_tvect==tp0) && (tp0==tp1))
  {
  if ((tp_bool==lt0) && (lt0==lt1))
    DBUG_RETURN(tp_bool);
  }  
if (tp_tvect==tp0)
  {
  if ((tp_bool==tp1) && (lt0==tp1))
    DBUG_RETURN(tp_bool);
  }
if (tp_tvect==tp1)
  {
  if ((tp_bool==tp0) && (lt1==tp0))
    DBUG_RETURN(tp_bool);
  }
DBUG_RETURN(tp_none);
}

/************************************************************************/
/* checks if TP_TYPES tp are tp_matrix or tp_matrix and tp_int or	*/
/* tp_real returns most general of lt and tp				*/
/************************************************************************/
static TP_TYPES check_mat_num(const TP_TYPES tp0,const TP_TYPES lt0,
		              const TP_TYPES tp1,const TP_TYPES lt1)
{
TP_TYPES dt;

DBUG_ENTER("check_mat_num");
if ((tp_matrix==tp0) && (tp0==tp1))
  {
  dt=check_int_real(lt0,lt1);
  DBUG_RETURN(dt);
  }  
if (tp_matrix==tp0)
  {
  dt=check_int_real(lt0,tp1);
  DBUG_RETURN(dt);
  }
if (tp_matrix==tp1)
  {
  dt=check_int_real(lt1,tp0);
  DBUG_RETURN(dt);
  }
DBUG_RETURN(tp_none);
}

/************************************************************************/
/* checks if TP_TYPES tp are tp_matrix or tp_matrix and tp_bool returns	*/
/* most general of lt and tp						*/
/************************************************************************/
static TP_TYPES check_mat_bool(const TP_TYPES tp0,const TP_TYPES lt0,
		               const TP_TYPES tp1,const TP_TYPES lt1)
{
DBUG_ENTER("check_mat_num");
if ((tp_matrix==tp0) && (tp0==tp1))
  {
  if ((tp_bool==lt0) && (lt0==lt1))
    DBUG_RETURN(tp_bool);
  }  
if (tp_matrix==tp0)
  {
  if ((tp_bool==tp1) && (lt0==tp1))
    DBUG_RETURN(tp_bool);
  }
if (tp_matrix==tp1)
  {
  if ((tp_bool==tp0) && (tp0==lt1))
    DBUG_RETURN(tp_bool);
  }
DBUG_RETURN(tp_none);
}

/************************************************************************/
/* executes primitiv function primf					*/
/************************************************************************/
void exe_prim1(PRIMF primf)
{
STELM d_stelm,*tp0;
TP_TYPES t=tp_none;

DBUG_ENTER("exe_prim1");
tp0=st_pop(w);						/* get parameter */
if (GETORDERENTRY(ord,typestouched)==0)
  {
  if (tp_list==GETSTELMTYPE(tp0))
    t=GETSTELMTYPE(tp0);
  else
    t=GETSTELMTYPE(tp0) | tp0->subtype.type;
  SETORDERENTRY(ord,types)=TYPES2LONG(t,tp_none,tp_none,tp_none);
  SETORDERENTRY(ord,typestouched)=1;
  }
else
  {
  if (tp_list==GETTYPE(0,GETORDERENTRY(ord,types)))
    {
    if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
    }
  else
    {
    if ((GETSTELMTYPE(tp0)|tp0->subtype.type)
        !=GETTYPE(0,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
    }
  }
stelm_cpy(&d_stelm,&CONST_NONE,1);
switch (GETPRF(primf))
  {
  case p_not:
    {
    if (tp_bool==GETSTELMTYPE(tp0))
      d_stelm.type=tp_bool;
    else
      {
      if (((tp_vect==GETSTELMTYPE(tp0)) || (tp_matrix==GETSTELMTYPE(tp0)) ||
	   (tp_tvect==GETSTELMTYPE(tp0)))
	  && ((tp_bool==tp0->subtype.type) || (tp_empty==tp0->subtype.type)))
	stelm_cpy(&d_stelm,tp0,1);
      else
        d_stelm.type=tp_none;
      }
    break;
    }
  case p_floor:
  case p_ceil:
  case p_trunc:
    {
    if ((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0)))
      {
      d_stelm.type=tp_int;
      d_stelm.subtype.type=tp_none;
      d_stelm.subtype.next=NULL;
      }
    else
      {
      if ((((tp_vect==GETSTELMTYPE(tp0)) || (tp_tvect==GETSTELMTYPE(tp0))) ||
	  (tp_matrix==GETSTELMTYPE(tp0))) &&
	 ((tp_int==tp0->subtype.type) || (tp_real==tp0->subtype.type) ||
	  (tp_empty==tp0->subtype.type)))
        {
        d_stelm.type=GETSTELMTYPE(tp0);
        d_stelm.subtype.type=tp_int;
        d_stelm.subtype.next=NULL;
        }
      else
        d_stelm.type=tp_none;
      }
    break;
    }
  case p_frac:
    {
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) ||
	((((tp_vect==GETSTELMTYPE(tp0)) || (tp_tvect==GETSTELMTYPE(tp0))) ||
	  (tp_matrix==GETSTELMTYPE(tp0))) &&
	 (((tp_int==tp0->subtype.type) || (tp_real==tp0->subtype.type) ||
	   (tp_empty==tp0->subtype.type)))))
      {
      d_stelm.type=GETSTELMTYPE(tp0);
      d_stelm.subtype.type=tp0->subtype.type;
      d_stelm.subtype.next=NULL;
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_vdim:
    {
    if ((tp_vect==GETSTELMTYPE(tp0)) || (tp_tvect==GETSTELMTYPE(tp0)))
      d_stelm.type=tp_int;
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_transpose:
    {
    if (((tp_vect==GETSTELMTYPE(tp0)) || (tp_tvect==GETSTELMTYPE(tp0))) ||
	(tp_matrix==GETSTELMTYPE(tp0)))
      {
      if (tp_vect==GETSTELMTYPE(tp0))
	d_stelm.type=tp_tvect;
      else
	{
	if (tp_tvect==GETSTELMTYPE(tp0))
	  d_stelm.type=tp_vect;
	else
	  d_stelm.type=tp_matrix;
	}
      d_stelm.subtype.type=tp0->subtype.type;
      d_stelm.subtype.next=NULL;
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_reverse:
    {
    if ((tp_list==GETSTELMTYPE(tp0)) || (tp_string==GETSTELMTYPE(tp0)))
      stelm_cpy(&d_stelm,tp0,1);
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_transform:
    {
    if (((tp_vect==GETSTELMTYPE(tp0)) || (tp_tvect==GETSTELMTYPE(tp0))) ||
	(tp_matrix==GETSTELMTYPE(tp0)))
      {
      d_stelm.type=tp_list;
      d_stelm.subtype.type=tp0->subtype.type;
      d_stelm.subtype.next=NULL;
      }
    else
      d_stelm.type=tp_none;
    break;
    }    
  case p_to_vect:
    {
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) ||
	(tp_bool==GETSTELMTYPE(tp0)))
      {
      d_stelm.type=tp_vect;
      d_stelm.subtype.type=tp0->subtype.type;
      d_stelm.subtype.next=NULL;
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_to_tvect:
    {
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) ||
	(tp_bool==GETSTELMTYPE(tp0)))
      {
      d_stelm.type=tp_tvect;
      d_stelm.subtype.type=tp0->subtype.type;
      d_stelm.subtype.next=NULL;
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_to_mat:
    {
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) ||
	(tp_bool==GETSTELMTYPE(tp0)))
      {
      d_stelm.type=tp_matrix;
      d_stelm.subtype.type=GETSTELMTYPE(tp0);
      d_stelm.subtype.next=NULL;
      }
    else
      {
      if ((tp_vect==GETSTELMTYPE(tp0)) || (tp_tvect==GETSTELMTYPE(tp0)))
	{
	d_stelm.type=tp_matrix;
	d_stelm.subtype.type=tp0->subtype.type;
	d_stelm.subtype.next=NULL;
	}
      else
        d_stelm.type=tp_none;
      }
    break;
    }
  case p_to_scal:
    {
    d_stelm.type=tp_none;
    break;
    }
  case p_to_list:
    {
    if ((tp_vect==GETSTELMTYPE(tp0)) || (tp_tvect==GETSTELMTYPE(tp0)))
      {
      d_stelm.type=tp_list;
      d_stelm.subtype.type=tp0->subtype.type;
      d_stelm.subtype.next=NULL;
      }
    else
      {
      if (tp_matrix==GETSTELMTYPE(tp0))
	{
	d_stelm.type=tp_list;
	if (tp_empty==tp0->subtype.type)
	  {
	  d_stelm.subtype.type=tp_empty;
	  d_stelm.subtype.next=NULL;
	  }
	else
	  {
	  d_stelm.subtype.type=tp_list;
	  if (NULL==(d_stelm.subtype.next=malloc(sizeof(SUBTYPE))))
	    yyfail("%s","no memory for subtype!");
	  d_stelm.subtype.next->type=tp0->subtype.type;
	  d_stelm.subtype.next->next=NULL;
	  }
	}
      else
        d_stelm.type=tp_none;
      }
    break;
    }
  case p_type:
  case p_class:
    {
    if ((tp_func==GETSTELMTYPE(tp0)) || (tp_clos==GETSTELMTYPE(tp0)))
      d_stelm.type=tp_none;
    else
      d_stelm.type=tp_atom;
    break;
    }
  case p_to_field:
    {
    if ((tp_list==GETSTELMTYPE(tp0)) && (((tp_bool==tp0->subtype.type) ||
	(tp_int==tp0->subtype.type)) || (tp_real==tp0->subtype.type)))
      {
      d_stelm.type=tp_vect;
      d_stelm.subtype.type=tp0->subtype.type;
      d_stelm.subtype.next=NULL;
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_vc_max:
  case p_vc_min:
    {
    if (((tp_vect==GETSTELMTYPE(tp0)) || (tp_tvect==GETSTELMTYPE(tp0))) &&
        (((tp_int==tp0->subtype.type) || (tp_real==tp0->subtype.type)) ||
	 (tp_bool==tp0->subtype.type) || (tp_empty==tp0->subtype.type)))
      {
      if (tp_empty==tp0->subtype.type)
	d_stelm.type=tp_int;
      else
        d_stelm.type=tp0->subtype.type;
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_vc_plus:
  case p_vc_minus:
  case p_vc_mult:
    {
    if (((tp_vect==GETSTELMTYPE(tp0)) || (tp_tvect==GETSTELMTYPE(tp0))) &&
        ((tp_int==tp0->subtype.type) || (tp_real==tp0->subtype.type) ||
	 (tp_empty==tp0->subtype.type)))
      {
      if (tp_empty==tp0->subtype.type)
	d_stelm.type=tp_int;
      else
        d_stelm.type=tp0->subtype.type;
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_vc_div:
    {
    if (((tp_vect==GETSTELMTYPE(tp0)) || (tp_tvect==GETSTELMTYPE(tp0))) &&
        ((tp_int==tp0->subtype.type) || (tp_real==tp0->subtype.type) ||
	 (tp_empty==tp0->subtype.type)))
      {
      if (tp_empty==tp0->subtype.type)
	d_stelm.type=tp_int;
      else
        d_stelm.type=tp_real;
      }
    else
      d_stelm.type=tp_none;
    break;
    }    
  case p_empty:
    {
    if ((tp_list==GETSTELMTYPE(tp0)) || (tp_string==GETSTELMTYPE(tp0)))
      d_stelm.type=tp_bool;
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_tan:
  case p_ln:
  case p_exp:
  case p_sin:
  case p_cos:
    {
    if ((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0)))
      d_stelm.type=tp_real;
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_abs:
  case p_neg:
    {
    if ((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0)))
      d_stelm.type=GETSTELMTYPE(tp0);
    else
      {
      if (((tp_vect==GETSTELMTYPE(tp0)) || (tp_tvect==GETSTELMTYPE(tp0)) ||
           (tp_matrix==GETSTELMTYPE(tp0))) &&
          ((tp_real==tp0->subtype.type) || (tp_int==tp0->subtype.type) ||
	   (tp_empty==tp0->subtype.type)))
        {
        d_stelm.type=GETSTELMTYPE(tp0);
        d_stelm.subtype.type=tp0->subtype.type;
        d_stelm.subtype.next=NULL;
        }
      else
        d_stelm.type=tp_none;
      }
    break;
    }
  case p_to_char:
    {
    if (tp_int==GETSTELMTYPE(tp0))
      d_stelm.type=tp_string;
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_to_ord:
    {
    if (tp_string==GETSTELMTYPE(tp0))
      d_stelm.type=tp_int;
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_ldim: 
    {
    if ((tp_list==GETSTELMTYPE(tp0)) || (tp_string==GETSTELMTYPE(tp0)))
      d_stelm.type=tp_int;
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_f_slots: /* cr 19.02.96 */
      d_stelm.type=tp_none;
      break;
  default:
    {
    yyfail("%s","that's no known unary primitive function");
    break;
    }
  }
w=st_push(w,&d_stelm);					/* result to W STACK */
insert_restype(&d_stelm,ord);				/* insert hash restype */
DBUG_VOID_RETURN;
}
  
/************************************************************************/
/* executes primitiv function primf					*/
/************************************************************************/
void exe_prim2(PRIMF primf)
{
STELM d_stelm,*tp0,*tp1;
TP_TYPES t0=tp_none,t1=tp_none;

DBUG_ENTER("exe_prim2");
tp0=st_pop(w);
tp1=st_pop(w);
if (GETORDERENTRY(ord,typestouched)==0)
  {
  if (tp_list==GETSTELMTYPE(tp0))
    t0=GETSTELMTYPE(tp0);
  else
    t0=GETSTELMTYPE(tp0) | tp0->subtype.type;
  if (tp_list==GETSTELMTYPE(tp1))
    t1=GETSTELMTYPE(tp1);
  else
    t1=GETSTELMTYPE(tp1) | tp1->subtype.type;
  SETORDERENTRY(ord,types)=TYPES2LONG(t0,t1,tp_none,tp_none);	/* internal types */
  SETORDERENTRY(ord,typestouched)=1;
  }
else
  {
  if (tp_list==GETTYPE(0,GETORDERENTRY(ord,types)))
    {
    if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
    }
  else
    {
    if ((GETSTELMTYPE(tp0)|tp0->subtype.type)
        !=GETTYPE(0,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
    }
  if (tp_list==GETTYPE(1,GETORDERENTRY(ord,types)))
    {
    if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
    }
  else
    {
    if ((GETSTELMTYPE(tp1)|tp1->subtype.type)
        !=GETTYPE(1,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
    }
  }
stelm_cpy(&d_stelm,&CONST_NONE,1);
switch (GETPRF(primf))
  {        
  case p_plus:
  case p_minus:
  case p_mult:
    {
    d_stelm.type=check_int_real(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1));
    if (tp_none==d_stelm.type)
      {
      d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				  GETSTELMTYPE(tp1),tp1->subtype.type);
      if (tp_none!=d_stelm.type)
	{
	if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp1->subtype.type))
	  {
	  d_stelm.subtype.type=d_stelm.type;
	  d_stelm.type=tp_vect;
	  d_stelm.subtype.next=NULL;
	  }
	else
	  d_stelm.type=tp_none;
	}
      else
	{
        d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				     GETSTELMTYPE(tp1),tp1->subtype.type);
        if (tp_none!=d_stelm.type)
	  {
	  if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp1->subtype.type))
	    {
	    d_stelm.subtype.type=d_stelm.type;
	    d_stelm.subtype.next=NULL;
	    d_stelm.type=tp_tvect;
	    }
	  else
	    d_stelm.type=tp_none;
	  }
	else
	  {
	  d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				     GETSTELMTYPE(tp1),tp1->subtype.type);
	  if (tp_none!=d_stelm.type)
	    {
	    if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp1->subtype.type))
	      {
	      d_stelm.subtype.type=d_stelm.type;
	      d_stelm.subtype.next=NULL;
	      d_stelm.type=tp_matrix;
	      }
	    else
	      d_stelm.type=tp_none;
	    }
	  }
	}
      }
    break;
    }
  case p_div:
    {
    d_stelm.type=check_int_real(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1));
    if (tp_none!=d_stelm.type)
      d_stelm.type=tp_real;
    else
      {
      d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				  GETSTELMTYPE(tp1),tp1->subtype.type);
      if (tp_none!=d_stelm.type)
	{
	if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp1->subtype.type))
	  {
	  d_stelm.subtype.type=tp_real;
	  d_stelm.subtype.next=NULL;
	  d_stelm.type=tp_vect;
	  }
	else
	  d_stelm.type=tp_none;
	}
      else
	{
        d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				     GETSTELMTYPE(tp1),tp1->subtype.type);
        if (tp_none!=d_stelm.type)
	  {
	  if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp1->subtype.type))
	    {
	    d_stelm.subtype.type=tp_real;
	    d_stelm.subtype.next=NULL;
	    d_stelm.type=tp_tvect;
	    }
	  else
	    d_stelm.type=tp_none;
	  }
	else
	  {
	  d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				     GETSTELMTYPE(tp1),tp1->subtype.type);
	  if (tp_none!=d_stelm.type)
	    {
	    if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp1->subtype.type))
	      {
	      d_stelm.subtype.type=tp_real;
	      d_stelm.subtype.next=NULL;
	      d_stelm.type=tp_matrix;
	      }
	    else
	      d_stelm.type=tp_none;
	    }
	  }
	}
      }
    break;
    }
  case p_mod:
    {
    d_stelm.type=check_int_real(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1));
    if (tp_none==d_stelm.type)
      {
      d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				  GETSTELMTYPE(tp1),tp1->subtype.type);
      if (tp_none!=d_stelm.type)
	{
	if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp1->subtype.type))
	  {
	  d_stelm.subtype.type=tp_int;
	  d_stelm.subtype.next=NULL;
	  d_stelm.type=tp_vect;
	  }
	else
	  d_stelm.type=tp_none;
	}
      else
	{
        d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				     GETSTELMTYPE(tp1),tp1->subtype.type);
        if (tp_none!=d_stelm.type)
	  {
	  if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp1->subtype.type))
	    {
	    d_stelm.subtype.type=tp_int;
	    d_stelm.subtype.next=NULL;
	    d_stelm.type=tp_tvect;
	    }
	  else
	    d_stelm.type=tp_none;
	  }
	else
	  {
	  d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				     GETSTELMTYPE(tp1),tp1->subtype.type);
	  if (tp_none!=d_stelm.type)
	    {
	    if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp1->subtype.type))
	      {
	      d_stelm.subtype.type=tp_int;
	      d_stelm.subtype.next=NULL;
	      d_stelm.type=tp_matrix;
	      }
	    else
	      d_stelm.type=tp_none;
	    }
	  }
	}
      }
    break;
    }
  case p_or:
  case p_and:
  case p_xor:
    {
    if ((tp_bool==GETSTELMTYPE(tp0)) && (GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)))
      d_stelm.type=tp_bool;
    else
      {
      d_stelm.type=check_vect_bool(GETSTELMTYPE(tp0),tp0->subtype.type,
				   GETSTELMTYPE(tp1),tp1->subtype.type);
      if (tp_none!=d_stelm.type)
	{
	if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp1->subtype.type))
	  {
	  d_stelm.type=tp_vect;
	  d_stelm.subtype.type=tp_bool;
	  d_stelm.subtype.next=NULL;
	  }
	else
	  d_stelm.type=tp_none;
	}
      else
	{
	d_stelm.type=check_tvect_bool(GETSTELMTYPE(tp0),tp0->subtype.type,
				      GETSTELMTYPE(tp1),tp1->subtype.type);
        if (tp_none!=d_stelm.type)
	  {
	  if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp1->subtype.type))
	    {
	    d_stelm.type=tp_tvect;
	    d_stelm.subtype.type=tp_bool;
	    d_stelm.subtype.next=NULL;
	    }
	  else
	    d_stelm.type=tp_none;
	  }
        else
	  {
	  d_stelm.type=check_mat_bool(GETSTELMTYPE(tp0),tp0->subtype.type,
				      GETSTELMTYPE(tp1),tp1->subtype.type);
	  if (tp_none!=d_stelm.type)
	    {
	    if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp1->subtype.type))
	      {
	      d_stelm.type=tp_matrix;
	      d_stelm.subtype.type=tp_bool;
	      d_stelm.subtype.next=NULL;
	      }
	    else
	      d_stelm.type=tp_none;
	    }
	  }
	}
      }
    break;
    }
  case p_eq:
  case p_ne:
    {
    if ((tp_clos==GETSTELMTYPE(tp0)) || (tp_clos==GETSTELMTYPE(tp1)) ||
	(tp_none==GETSTELMTYPE(tp0)) || (tp_none==GETSTELMTYPE(tp1)) ||
	((tp_list==GETSTELMTYPE(tp0)) && (tp_list==GETSTELMTYPE(tp1))))
      d_stelm.type=tp_none;
    else
      d_stelm.type=tp_bool;
    break;
    }
  case p_lt:
  case p_le:
  case p_gt:
  case p_ge:
    {
    d_stelm.type=check_int_real(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1));
    if (tp_none!=d_stelm.type)
      d_stelm.type=tp_bool;
    else
      {
      if ((GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)) &&
	  ((tp_bool==GETSTELMTYPE(tp0)) ||
	    (tp_string==GETSTELMTYPE(tp0))))
	d_stelm.type=tp_bool;
      else
	{
	d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				    GETSTELMTYPE(tp1),tp1->subtype.type);
        if (tp_none!=d_stelm.type)
	  {
	  if ((tp_empty==tp0->subtype.type) || (tp_empty==tp1->subtype.type))
	    d_stelm.type=tp_none;
	  else
	    {
	    d_stelm.subtype.type=tp_bool;
	    d_stelm.subtype.next=NULL;
	    d_stelm.type=tp_vect;
	    }
	  }
        else
	  {
	  d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				       GETSTELMTYPE(tp1),tp1->subtype.type);
          if (tp_none!=d_stelm.type)
	    {
	    if ((tp_empty==tp0->subtype.type) || (tp_empty==tp1->subtype.type))
	      d_stelm.type=tp_none;
	    else
	      {
	      d_stelm.subtype.type=tp_bool;
	      d_stelm.subtype.next=NULL;
	      d_stelm.type=tp_tvect;
	      }
	    }
	  else
	    {
	    d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				       GETSTELMTYPE(tp1),tp1->subtype.type);
	    if (tp_none!=d_stelm.type)
	      {
	      if ((tp_empty==tp0->subtype.type) || (tp_empty==tp1->subtype.type))
	        d_stelm.type=tp_none;
	      else
	        {
	        d_stelm.subtype.type=tp_bool;
	        d_stelm.subtype.next=NULL;
	        d_stelm.type=tp_matrix;
		}
	      }
	    else
	      {
	      d_stelm.type=check_vect_bool(GETSTELMTYPE(tp0),tp0->subtype.type,
					   GETSTELMTYPE(tp1),tp1->subtype.type);
	      if (tp_none!=d_stelm.type)
		{
		if ((tp_empty==tp0->subtype.type) || (tp_empty==tp1->subtype.type))
	          d_stelm.type=tp_none;
	        else
	          {
	          d_stelm.type=tp_vect;
		  d_stelm.subtype.type=tp_bool;
		  d_stelm.subtype.next=NULL;
		  }
		}
	      else
		{
		d_stelm.type=check_tvect_bool(GETSTELMTYPE(tp0),tp0->subtype.type,
					      GETSTELMTYPE(tp1),tp1->subtype.type);
		if (tp_none!=d_stelm.type)
		  {
		  if ((tp_empty==tp0->subtype.type) || (tp_empty==tp1->subtype.type))
	            d_stelm.type=tp_none;
	          else
	            {
	            d_stelm.type=tp_tvect;
		    d_stelm.subtype.type=tp_bool;
		    d_stelm.subtype.next=NULL;
		    }
		  }
		else
		  {
		  d_stelm.type=check_mat_bool(GETSTELMTYPE(tp0),tp0->subtype.type,
					      GETSTELMTYPE(tp1),tp1->subtype.type);
		  if (tp_none!=d_stelm.type)
		    {
		    if ((tp_empty==tp0->subtype.type) || (tp_empty==tp1->subtype.type))
	              d_stelm.type=tp_none;
	            else
	              {
	              d_stelm.type=tp_matrix;
		      d_stelm.subtype.type=tp_bool;
		      d_stelm.subtype.next=NULL;
		      }
		    }
		  }
		}
	      }
	    }
     	  }
	}
      }
    break;
    }
  case p_lcut:
    {
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	(tp_list==GETSTELMTYPE(tp1)))
      {
      stelm_cpy(&d_stelm,tp1,1);
      if (tp_empty==tp1->subtype.type)
        d_stelm.type=tp_none;
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_lselect:
    {
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	(tp_list==GETSTELMTYPE(tp1)))
      {
      if (tp_empty!=tp1->subtype.type)
	d_stelm.type=tp1->subtype.type;
      else
	d_stelm.type=tp_none;
      if ((((tp_list==d_stelm.type) || (tp_vect==d_stelm.type)) ||
	   ((tp_tvect==d_stelm.type) || (tp_matrix==d_stelm.type))) ||
	  (tp_string==d_stelm.type))
	{
	d_stelm.subtype.type=tp1->subtype.next->type;
	if (NULL!=tp1->subtype.next->next)
	  d_stelm.subtype.next=subtype_cpy(tp1->subtype.next->next);
	else
	  d_stelm.subtype.next=NULL;
	}
      }
    else
      {
      if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	  (tp_string==GETSTELMTYPE(tp1)))
	{
	d_stelm.type=tp_string;
	d_stelm.subtype.type=tp1->subtype.type;
	}
      else
        d_stelm.type=tp_none;
      }
    break;
    }
  case p_lunite:				/* fix subtype of empty-list args */
    {
    if ((tp_list==GETSTELMTYPE(tp0)) && (tp_list==GETSTELMTYPE(tp1)))
      {
      stelm_cpy(&d_stelm,tp0,1);
      if ((tp_empty!=tp0->subtype.type) &&
	  (tp_empty!=tp1->subtype.type))
	subtypecmp(&(d_stelm.subtype),&(tp1->subtype));
      else
	{
        if (tp_empty==tp0->subtype.type)
	  stelm_cpy(&d_stelm,tp1,1);
	else
          stelm_cpy(&d_stelm,tp0,1);
	}
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_min:
  case p_max:
    {
    if ((GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)) &&
	((((tp_int==GETSTELMTYPE(tp0)) ||
	(tp_real==GETSTELMTYPE(tp0))) ||
 	( /* (tp_string==GETSTELMTYPE(tp0)) || */
	(tp_bool==GETSTELMTYPE(tp0)))) ||
	(((tp_vect==GETSTELMTYPE(tp0)) ||
	(tp_tvect==GETSTELMTYPE(tp0))) ||
	(tp_matrix==GETSTELMTYPE(tp0)))))
      {
      if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp1->subtype.type))
	{
	d_stelm.type=GETSTELMTYPE(tp0);
        d_stelm.subtype.type=tp0->subtype.type;
        d_stelm.subtype.next=NULL;
	}
      else
	d_stelm.type=tp_none;
      }
    else
      {
      d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				  GETSTELMTYPE(tp1),tp1->subtype.type);
      if (tp_none!=d_stelm.type)
	{
	d_stelm.type=tp_vect;
	if ((tp_vect==GETSTELMTYPE(tp0)) && 
	    (GETSTELMTYPE(tp1)==tp0->subtype.type))
	  {
	  d_stelm.subtype.type=GETSTELMTYPE(tp1);
	  d_stelm.subtype.next=NULL;
	  }
	else
	  {
	  d_stelm.subtype.next=NULL;
	  if ((tp_vect==GETSTELMTYPE(tp1)) && 
	      (GETSTELMTYPE(tp0)==tp1->subtype.type))
	    d_stelm.subtype.type=GETSTELMTYPE(tp0);
	  else
	    d_stelm.subtype.type=tp_none;
	  }
	}
      else
	{
	d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				     GETSTELMTYPE(tp1),tp1->subtype.type);
        if (tp_none!=d_stelm.type)
	  {
	  d_stelm.type=tp_tvect;
	  if ((tp_tvect==GETSTELMTYPE(tp0)) && 
	      (GETSTELMTYPE(tp1)==tp0->subtype.type))
	    {
	    d_stelm.subtype.type=GETSTELMTYPE(tp1);
	    d_stelm.subtype.next=NULL;
	    }
	  else
	    {
	    d_stelm.subtype.next=NULL;
	    if ((tp_tvect==GETSTELMTYPE(tp1)) && 
		(GETSTELMTYPE(tp0)==tp1->subtype.type))
	      d_stelm.subtype.type=GETSTELMTYPE(tp0);
	    else
	      d_stelm.subtype.type=tp_none;
	    }
	  }
        else
	  {
	  d_stelm.type=check_vect_bool(GETSTELMTYPE(tp0),tp0->subtype.type,
				       GETSTELMTYPE(tp1),tp1->subtype.type);
          if (tp_none!=d_stelm.type)
	    {
	    d_stelm.subtype.type=tp_bool;
	    d_stelm.subtype.next=NULL;
	    d_stelm.type=tp_vect;
	    }
	  else
	    {
	    d_stelm.type=check_tvect_bool(GETSTELMTYPE(tp0),tp0->subtype.type,
				          GETSTELMTYPE(tp1),tp1->subtype.type);
	    if (tp_none!=d_stelm.type)
	      {
	      d_stelm.subtype.type=tp_bool;
	      d_stelm.subtype.next=NULL;
	      d_stelm.type=tp_tvect;
	      }
	    else
	      {
	      d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),tp0->subtype.type,
				         GETSTELMTYPE(tp1),tp1->subtype.type);
	      if (tp_none!=d_stelm.type)
		{
		d_stelm.type=tp_matrix;
		d_stelm.subtype.next=NULL;
		if ((tp_matrix==GETSTELMTYPE(tp0)) &&
		   (tp0->subtype.type==GETSTELMTYPE(tp1)))
		  d_stelm.subtype.type=tp0->subtype.type;
		else
		  {
		  if ((tp_matrix==GETSTELMTYPE(tp1)) &&
		     (tp1->subtype.type==GETSTELMTYPE(tp0)))
		    d_stelm.subtype.type=tp1->subtype.type;
		  else
		    d_stelm.subtype.type=tp_none;
		  }
		}
	      else
		{
		d_stelm.type=check_mat_bool(GETSTELMTYPE(tp0),tp0->subtype.type,
				            GETSTELMTYPE(tp1),tp1->subtype.type);
		if (tp_none!=d_stelm.type)
		  {
		  d_stelm.type=tp_matrix;
		  d_stelm.subtype.type=tp_bool;
		  d_stelm.subtype.next=NULL;
		  }
		}
	      }
	    }
	  }
	}
      }
    break;
    }
  case p_quot:
    {
    if ((tp_int==GETSTELMTYPE(tp0)) && (GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)))
      d_stelm.type=tp_int;
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_ip:
    {
    if ((tp_matrix==GETSTELMTYPE(tp0)) || (tp_empty!=tp0->subtype.type))
      {
      if ((tp_matrix==GETSTELMTYPE(tp1)) || (tp_empty!=tp1->subtype.type))
	{
	d_stelm.type=tp_matrix;
	d_stelm.subtype.type=check_int_real(tp0->subtype.type,tp1->subtype.type);
	d_stelm.subtype.next=NULL;
	}
      else
	{
	if ((tp_tvect==GETSTELMTYPE(tp1))  || (tp_empty!=tp1->subtype.type))
	  {
	  d_stelm.type=tp_tvect;
	  d_stelm.subtype.type=check_int_real(tp0->subtype.type,tp1->subtype.type);
	  d_stelm.subtype.next=NULL;
	  }
	else
	  d_stelm.type=tp_none;
	}
      }
    else
      {
      if ((tp_vect==GETSTELMTYPE(tp0)) || (tp_empty!=tp0->subtype.type))
	{
	if ((tp_tvect==GETSTELMTYPE(tp1)) || (tp_empty!=tp1->subtype.type))
	  d_stelm.type=check_int_real(tp0->subtype.type,tp1->subtype.type);
	else
	  {
	  if ((tp_matrix==GETSTELMTYPE(tp1)) || (tp_empty!=tp1->subtype.type))
	    {
	    d_stelm.type=tp_vect;
	    d_stelm.subtype.type=check_int_real(tp0->subtype.type,tp1->subtype.type);
	    d_stelm.subtype.next=NULL;
	    }
	  else
	    d_stelm.type=tp_none;
	  }
	}
      else
	{
	if ((tp_tvect==GETSTELMTYPE(tp0)) || (tp_empty!=tp0->subtype.type))
	  {
	  if ((tp_vect==GETSTELMTYPE(tp1)) || (tp_empty!=tp1->subtype.type))
	    {
	    d_stelm.type=tp_matrix;
	    d_stelm.subtype.type=check_int_real(tp0->subtype.type,tp1->subtype.type);
	    d_stelm.subtype.next=NULL;
	    }
	  else
	    d_stelm.type=tp_none;
	  }
	else
	  d_stelm.type=tp_none;
	}
      }
    break;
    }
  case p_dim:
    {
    if ((tp_int==GETSTELMTYPE(tp0)) &&
	((((tp_list==GETSTELMTYPE(tp1)) || (tp_string==GETSTELMTYPE(tp1))) ||
	  ((tp_vect==GETSTELMTYPE(tp1)) || (tp_tvect==GETSTELMTYPE(tp1)))) ||
	(tp_matrix==GETSTELMTYPE(tp1))))
      d_stelm.type=tp_int;
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_mdim:
    {
    if ((tp_int==GETSTELMTYPE(tp0)) && (tp_matrix==GETSTELMTYPE(tp1)))
      d_stelm.type=tp_int;
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_vrotate:
  case p_vcut:
    {
    if ((tp_int==GETSTELMTYPE(tp0)) && ((tp_vect==GETSTELMTYPE(tp1)) ||
					(tp_tvect==GETSTELMTYPE(tp1))))
      {
      d_stelm.type=GETSTELMTYPE(tp1);
      d_stelm.subtype.type=tp1->subtype.type;
      d_stelm.subtype.next=NULL;
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_vselect:
    {
    if ((tp_int==GETSTELMTYPE(tp0)) && ((tp_vect==GETSTELMTYPE(tp1)) ||
					(tp_tvect==GETSTELMTYPE(tp1))) &&
	(tp_empty!=tp1->subtype.type))				/* no empty vect */
      d_stelm.type=tp1->subtype.type;
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_lrotate:
    {
    if ((tp_int==GETSTELMTYPE(tp0)) && (tp_list==GETSTELMTYPE(tp1)))
      stelm_cpy(&d_stelm,tp1,1);
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_vunite:
    {
    if (((tp_vect==GETSTELMTYPE(tp0)) && (GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1))) ||
	((tp_tvect==GETSTELMTYPE(tp0)) && (GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1))))
      {
      stelm_cpy(&d_stelm,tp1,1);
      if (tp_empty==tp1->subtype.type)
	d_stelm.subtype.type=tp0->subtype.type;
      else
	{
	if (tp_empty!=tp0->subtype.type)
          subtypecmp(&(d_stelm.subtype),&(tp0->subtype));
	}
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_c_max:
  case p_c_min:
  case p_c_plus:
  case p_c_minus:
  case p_c_mult:
  case p_c_div: 
    {
    d_stelm.type=tp_none;				/* that's bad !!! */
    break;
    }
  case p_f_eq:
  case p_f_ne:
    {
    if (((GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)) &&
	(tp0->subtype.type==tp1->subtype.type)) &&
	(((tp_matrix==GETSTELMTYPE(tp0)) || (tp_vect==GETSTELMTYPE(tp0))) ||
	 (tp_tvect==GETSTELMTYPE(tp0))))
      {
      d_stelm.type=GETSTELMTYPE(tp0);
      d_stelm.subtype.type=tp_bool;
      d_stelm.subtype.next=NULL;
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_f_delete: /* cr 19.02.96 */
      d_stelm.type=tp_none;
      break;
  case p_f_test: /* cr 19.02.96 */
      d_stelm.type=tp_none;
      break;
  case p_f_select: /* cr 19.02.96 */
      d_stelm.type=tp_none;
      break;
  case p_sprintf:
    {
    if ((tp_string==GETSTELMTYPE(tp0)) &&
        ((tp_int==GETSTELMTYPE(tp1)) || (tp_real==GETSTELMTYPE(tp1))) )
      d_stelm.type=tp_string;
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_sscanf:
    {
    d_stelm.type=tp_none;
    break;
    }
  default:
    {
    yyfail("%s","that's no known binary primitive function");
    break;
    }
  }
w=st_push(w,&d_stelm);					/* result to W STACK */
insert_restype(&d_stelm,ord);				/* insert hash restype */
DBUG_VOID_RETURN;
}

/************************************************************************/
/* executes primitiv function primf					*/
/************************************************************************/
void exe_prim3(PRIMF primf)
{
STELM d_stelm,*tp0,*tp1,*tp2;
TP_TYPES t0=tp_none,t1=tp_none,t2=tp_none;

DBUG_ENTER("exe_prim3");
tp0=st_pop(w);
tp1=st_pop(w);
tp2=st_pop(w);
if (GETORDERENTRY(ord,typestouched)==0)
  {
  if (tp_list==GETSTELMTYPE(tp0))
    t0=GETSTELMTYPE(tp0);
  else
    t0=GETSTELMTYPE(tp0) | tp0->subtype.type;
  if (tp_list==GETSTELMTYPE(tp1))
    t1=GETSTELMTYPE(tp1);
  else
    t1=GETSTELMTYPE(tp1) | tp1->subtype.type;
  if (tp_list==GETSTELMTYPE(tp2))
    t2=GETSTELMTYPE(tp2);
  else
    t2=GETSTELMTYPE(tp2) | tp2->subtype.type;
  SETORDERENTRY(ord,types)=TYPES2LONG(t0,t1,t2,tp_none);	/* internal types */
  SETORDERENTRY(ord,typestouched)=1;
  }
else
  {
  if (tp_list==GETTYPE(0,GETORDERENTRY(ord,types)))
    {
    if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
    }
  else
    {
    if ((GETSTELMTYPE(tp0)|tp0->subtype.type)
        !=GETTYPE(0,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
    }
  if (tp_list==GETTYPE(1,GETORDERENTRY(ord,types)))
    {
    if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
    }
  else
    {
    if ((GETSTELMTYPE(tp1)|tp1->subtype.type)
        !=GETTYPE(1,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
    }
  if (tp_list==GETTYPE(2,GETORDERENTRY(ord,types)))
    {
    if (GETSTELMTYPE(tp2)!=GETTYPE(2,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(2,tp_none);
    }
  else
    {
    if ((GETSTELMTYPE(tp2)|tp1->subtype.type)
        !=GETTYPE(2,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(2,tp_none);
    }
  }
stelm_cpy(&d_stelm,&CONST_NONE,1);
switch (GETPRF(primf))
  {
  case p_lreplace:
    {
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0)))
	&& (tp_list==GETSTELMTYPE(tp2)))
      {
      if (tp_empty==tp2->subtype.type)
        d_stelm.type=tp_none;
      if (GETSTELMTYPE(tp1)==tp2->subtype.type)
	stelm_cpy(&d_stelm,tp2,1);
      else
	{
	d_stelm.type=tp_list;
	d_stelm.subtype.type=tp_none;
	d_stelm.subtype.next=NULL;
	}
      }
    else
      {
      if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0)))
	  && (tp_string==GETSTELMTYPE(tp2)) && (tp_string==GETSTELMTYPE(tp1)))
	{
	if (tp1->subtype.type==tp2->subtype.type)
	  stelm_cpy(&d_stelm,tp2,1);
        else
	  {
	  d_stelm.type=tp_string;
	  d_stelm.subtype.type=tp_none;
	  d_stelm.subtype.next=NULL;
	  }
	}
      else
	d_stelm.type=tp_none;
      }
    break;
    }
  case p_rotate:
  case p_cut:
  case p_substr:
    {
    d_stelm.type=tp_none;
    break;
    }
  case p_mrotate: 
  case p_mcut:
    {
    if ((((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	 ((tp_int==GETSTELMTYPE(tp1)) || (tp_real==GETSTELMTYPE(tp1)))) &&
	(tp_matrix==GETSTELMTYPE(tp2)))
      stelm_cpy(&d_stelm,tp2,1);
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_ltransform:
    {    
    if (((((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	  ((tp_int==GETSTELMTYPE(tp1)) || (tp_real==GETSTELMTYPE(tp1)))) &&
	 (tp_list==GETSTELMTYPE(tp2))) &&
	(((tp_vect!=tp2->subtype.type) && (tp_tvect!=tp2->subtype.type)) &&
	 ((tp_matrix!=tp2->subtype.type) && (tp_none!=tp2->subtype.type) &&
	  (tp_empty!=tp2->subtype.type))))
      {
      d_stelm.type=tp_matrix;
      d_stelm.subtype.type=tp2->subtype.type;
      d_stelm.subtype.next=NULL;
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_select: 
    {
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	  ((tp_int==GETSTELMTYPE(tp1)) || (tp_real==GETSTELMTYPE(tp1))))
      {
      if (((tp_list==GETSTELMTYPE(tp2)) || (tp_vect==GETSTELMTYPE(tp2))) ||
	  (tp_tvect==GETSTELMTYPE(tp2)))
	{
	if (tp_empty==tp2->subtype.type)
	  d_stelm.type=tp_none;
        else
          {
	  d_stelm.type=GETSTELMTYPE(tp2);
	  d_stelm.subtype.type=tp2->subtype.type;
	  d_stelm.subtype.next=NULL;
          }
	}
      else
	d_stelm.type=tp_none;
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_vreplace:
    {
    if ((((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	 ((tp_vect==GETSTELMTYPE(tp2)) || (tp_tvect==GETSTELMTYPE(tp2)))) &&
	(tp2->subtype.type==GETSTELMTYPE(tp1)))
      stelm_cpy(&d_stelm,tp2,1);
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_mselect:
  case p_unite:
  case p_munite:
    {
    d_stelm.type=tp_none;
    break;
    }
  case p_mre_c:
    {
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	((tp_tvect==GETSTELMTYPE(tp1)) && (tp_matrix==GETSTELMTYPE(tp2))))
      {
      d_stelm.type=tp_matrix;
      d_stelm.subtype.type=check_int_real(tp1->subtype.type,tp2->subtype.type);
      d_stelm.subtype.next=NULL;
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  case p_mre_r:
    {
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	((tp_vect==GETSTELMTYPE(tp1)) && (tp_matrix==GETSTELMTYPE(tp2))))
      {
      d_stelm.type=tp_matrix;
      d_stelm.subtype.type=check_int_real(tp1->subtype.type,tp2->subtype.type);
      d_stelm.subtype.next=NULL;
      }
    else
      d_stelm.type=tp_none;    
    break;
    }
  case p_f_update: /* cr 19.02.96 */
      d_stelm.type=tp_none;
      break;
  default:
    {
    yyfail("%s","that's no known 3-ary primitive function");
    break;
    }
  }
w=st_push(w,&d_stelm);					/* result to W STACK */
insert_restype(&d_stelm,ord);				/* insert hash restype */
DBUG_VOID_RETURN;
}

/************************************************************************/
/* executes primitiv function primf					*/
/************************************************************************/
void exe_prim4(PRIMF primf)
{
STELM d_stelm,*tp0,*tp1,*tp2,*tp3;
TP_TYPES t0=tp_none,t1=tp_none,t2=tp_none,t3=tp_none;

DBUG_ENTER("exe_prim4");
tp0=st_pop(w);
tp1=st_pop(w);
tp2=st_pop(w);
tp3=st_pop(w);
if (GETORDERENTRY(ord,typestouched)==0)
  {
  if (tp_list==GETSTELMTYPE(tp0))
    t0=GETSTELMTYPE(tp0);
  else
    t0=GETSTELMTYPE(tp0) | tp0->subtype.type;
  if (tp_list==GETSTELMTYPE(tp1))
    t1=GETSTELMTYPE(tp1);
  else
    t1=GETSTELMTYPE(tp1) | tp1->subtype.type;
  if (tp_list==GETSTELMTYPE(tp2))
    t2=GETSTELMTYPE(tp2);
  else
    t2=GETSTELMTYPE(tp2) | tp2->subtype.type;
  if (tp_list==GETSTELMTYPE(tp3))
    t3=GETSTELMTYPE(tp3);
  else
    t3=GETSTELMTYPE(tp3) | tp3->subtype.type;
  SETORDERENTRY(ord,types)=TYPES2LONG(t0,t1,t2,t3);		/* internal types */
  SETORDERENTRY(ord,typestouched)=1;
  }
else
  {
  if (tp_list==GETTYPE(0,GETORDERENTRY(ord,types)))
    {
    if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
    }
  else
    {
    if ((GETSTELMTYPE(tp0)|tp0->subtype.type)
        !=GETTYPE(0,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
    }
  if (tp_list==GETTYPE(1,GETORDERENTRY(ord,types)))
    {
    if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
    }
  else
    {
    if ((GETSTELMTYPE(tp1)|tp1->subtype.type)
        !=GETTYPE(1,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
    }
  if (tp_list==GETTYPE(2,GETORDERENTRY(ord,types)))
    {
    if (GETSTELMTYPE(tp2)!=GETTYPE(2,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(2,tp_none);
    }
  else
    {
    if ((GETSTELMTYPE(tp2)|tp2->subtype.type)
        !=GETTYPE(2,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(2,tp_none);
    }
  if (tp_list==GETTYPE(3,GETORDERENTRY(ord,types)))
    {
    if (GETSTELMTYPE(tp3)!=GETTYPE(3,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(3,tp_none);
    }
  else
    {
    if ((GETSTELMTYPE(tp3)|tp3->subtype.type)
        !=GETTYPE(3,GETORDERENTRY(ord,types)))
      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(3,tp_none);
    }
  }
stelm_cpy(&d_stelm,&CONST_NONE,1);
switch (GETPRF(primf))
  {
  case p_repstr:
    {
    d_stelm.type=tp_none;
    break;
    }
  case p_replace:
    {
    d_stelm.type=tp_none;
    break;
    }
  case p_mreplace:
    {
    if ((((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	((tp_int==GETSTELMTYPE(tp1)) || (tp_real==GETSTELMTYPE(tp1)))) &&
	(tp_matrix==GETSTELMTYPE(tp3)))
      {
      d_stelm.type=tp_matrix;
      d_stelm.subtype.next=NULL;
      if (tp3->subtype.type==GETSTELMTYPE(tp2))
	d_stelm.subtype.type=tp3->subtype.type;
      else
	{
	d_stelm.type=tp_none;
	d_stelm.subtype.type=tp_none;
	}
      }
    else
      d_stelm.type=tp_none;
    break;
    }
  default:
    {
    yyfail("%s","that's no known 4-ary primitive function");
    break;
    }
  }
w=st_push(w,&d_stelm);					/* result to W STACK */
insert_restype(&d_stelm,ord);				/* insert hash restype */
DBUG_VOID_RETURN;
}
@


1.90
log
@*** empty log message ***
@
text
@d2499 16
d3294 14
@


1.89
log
@locker
Upsi! Fehler in select und lcut behoben!
Funktion quitprimf entfernt!
@
text
@d3436 7
a3442 7
	  {
	  quitprimf();
	  DBUG_VOID_RETURN;
	  }
	d_stelm.type=GETSTELMTYPE(tp2);
	d_stelm.subtype.type=tp2->subtype.type;
	d_stelm.subtype.next=NULL;
@


1.88
log
@Fehler in lselect behoben
@
text
@a157 29
/* returns imediately form primitiv function, because of wrong type	*/
/* of arguments.							*/
/************************************************************************/
void quitprimf()
{
STELM *freturn;
      
DBUG_ENTER("quitprimf");
SETORDERENTRY(ord,types)=TYPES2LONG(tp_none,tp_none,tp_none,tp_none);
SETORDERENTRY(ord,typestouched)=0;
st_free(w);
st_free(a);
st_free(r);
st_free(t);
if (NULL!=ret)
  {
  do
    freturn=st_pop(ret); 
  while BETAFUNCS(GETORDERENTRY(GETSTELMDATA(freturn,ret)->ord,command));
  w=GETSTELMDATA(freturn,ret)->w;
  a=GETSTELMDATA(freturn,ret)->a;
  r=GETSTELMDATA(freturn,ret)->r;
  t=GETSTELMDATA(freturn,ret)->t;
  ord=GETSTELMDATA(freturn,ret)->ord;
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
d2923 1
a2923 4
	{
	quitprimf();
	DBUG_VOID_RETURN;
	}
d3363 1
a3363 4
	{
	quitprimf();
	DBUG_VOID_RETURN;
	}
@


1.87
log
@dummy entries (no information) for frame operations
@
text
@d172 11
a182 8
do
  freturn=st_pop(ret); 
while BETAFUNCS(GETORDERENTRY(GETSTELMDATA(freturn,ret)->ord,command));
w=GETSTELMDATA(freturn,ret)->w;
a=GETSTELMDATA(freturn,ret)->a;
r=GETSTELMDATA(freturn,ret)->r;
t=GETSTELMDATA(freturn,ret)->t;
ord=GETSTELMDATA(freturn,ret)->ord;
d2969 1
a2969 4
	{
	quitprimf();
	DBUG_VOID_RETURN;
	}
@


1.86
log
@trunc, ceil, floor problem fixed
@
text
@d2533 3
d3301 9
d3529 3
@


1.85
log
@ISFUNC replaced by ISPRF.
@
text
@d2241 1
a2241 5
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) ||
	((((tp_vect==GETSTELMTYPE(tp0)) || (tp_tvect==GETSTELMTYPE(tp0))) ||
	  (tp_matrix==GETSTELMTYPE(tp0))) &&
	 ((tp_int==tp0->subtype.type) || (tp_real==tp0->subtype.type) ||
	  (tp_empty==tp0->subtype.type))))
d2243 2
a2244 2
      d_stelm.type=GETSTELMTYPE(tp0);
      d_stelm.subtype.type=tp_int;
d2248 13
a2260 1
      d_stelm.type=tp_none;
@


1.84
log
@missing type var fixed
@
text
@d884 1
a884 1
	      if ((ISFUNC(help)) && ((tp_empty==tp.type) || (tp_prim==tp.type)))
@


1.83
log
@list types in primitiv functions optimized
@
text
@d144 5
@


1.82
log
@primitiv functions with empty-list-arguments changed
@
text
@d2202 11
a2212 3
  if ((GETSTELMTYPE(tp0)|tp0->subtype.type)
      !=GETTYPE(0,GETORDERENTRY(ord,types)))
    SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
d2557 22
a2578 6
  if ((GETSTELMTYPE(tp0)|tp0->subtype.type)
      !=GETTYPE(0,GETORDERENTRY(ord,types)))
    SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
  if ((GETSTELMTYPE(tp1)|tp1->subtype.type)
      !=GETTYPE(1,GETORDERENTRY(ord,types)))
    SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
d3327 33
a3359 9
  if ((GETSTELMTYPE(tp0)|tp0->subtype.type)
      !=GETTYPE(0,GETORDERENTRY(ord,types)))
    SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
  if ((GETSTELMTYPE(tp1)|tp1->subtype.type)
      !=GETTYPE(1,GETORDERENTRY(ord,types)))
    SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
  if ((GETSTELMTYPE(tp2)|tp2->subtype.type)
      !=GETTYPE(2,GETORDERENTRY(ord,types)))
    SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(2,tp_none);
d3551 44
a3594 12
  if ((GETSTELMTYPE(tp0)|tp0->subtype.type)
      !=GETTYPE(0,GETORDERENTRY(ord,types)))
    SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
  if ((GETSTELMTYPE(tp1)|tp1->subtype.type)
      !=GETTYPE(1,GETORDERENTRY(ord,types)))
    SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
  if ((GETSTELMTYPE(tp2)|tp2->subtype.type)
      !=GETTYPE(2,GETORDERENTRY(ord,types)))
    SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(2,tp_none);
  if ((GETSTELMTYPE(tp3)|tp3->subtype.type)
      !=GETTYPE(3,GETORDERENTRY(ord,types)))
    SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(3,tp_none);
@


1.81
log
@list bug fixed
@
text
@d153 26
d1051 16
a1066 1
	argtp[i]=tp_none;			/* then type is none */
d1080 16
a1095 1
	argtp[i]=tp_none;			/* then type is none */
d2402 1
a2402 1
  case p_to_field:					/* can't handle */
d2906 1
d2908 6
d2926 4
a2929 1
	d_stelm.type=tp_none;
d2954 1
a2954 1
  case p_lunite:
d2959 10
a2968 1
      subtypecmp(&(d_stelm.subtype),&(tp1->subtype));
d3321 5
d3397 5
@


1.80
log
@bugfix for nilmat, nilvect ...
@
text
@d740 2
a741 1
    if (tp_list==(type & EXT_MASK))		/* check for list */
d2131 1
d2137 5
a2141 2
  SETORDERENTRY(ord,types)=TYPES2LONG((GETSTELMTYPE(tp0) | tp0->subtype.type),
				      tp_none,tp_none,tp_none);
d2473 1
d2480 9
a2488 3
  SETORDERENTRY(ord,types)=TYPES2LONG((GETSTELMTYPE(tp0)|tp0->subtype.type),
				      (GETSTELMTYPE(tp1)|tp1->subtype.type),
				      tp_none,tp_none); /* internal types */
d2890 1
a2890 1
    if ((tp_list==GETSTELMTYPE(tp0)) && (GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)))
d3203 1
d3211 13
a3223 4
  SETORDERENTRY(ord,types)=TYPES2LONG((GETSTELMTYPE(tp0)|tp0->subtype.type),
				      (GETSTELMTYPE(tp1)|tp1->subtype.type),
				      (GETSTELMTYPE(tp2)|tp2->subtype.type),
				      tp_none); /* internal types */
d3388 1
d3397 17
a3413 4
  SETORDERENTRY(ord,types)=TYPES2LONG((GETSTELMTYPE(tp0)|tp0->subtype.type),
				      (GETSTELMTYPE(tp1)|tp1->subtype.type),
				      (GETSTELMTYPE(tp2)|tp2->subtype.type),
				      (GETSTELMTYPE(tp3)|tp3->subtype.type));
@


1.79
log
@primitiv functions changed
@
text
@d2502 1
a2502 1
	if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp0->subtype.type))
d2517 1
a2517 1
	  if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp0->subtype.type))
d2532 1
a2532 1
	    if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp0->subtype.type))
d2557 1
a2557 1
	if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp0->subtype.type))
d2572 1
a2572 1
	  if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp0->subtype.type))
d2587 1
a2587 1
	    if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp0->subtype.type))
d2610 1
a2610 1
	if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp0->subtype.type))
d2625 1
a2625 1
	  if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp0->subtype.type))
d2640 1
a2640 1
	    if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp0->subtype.type))
d2666 1
a2666 1
	if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp0->subtype.type))
d2681 1
a2681 1
	  if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp0->subtype.type))
d2696 1
a2696 1
	    if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp0->subtype.type))
d2899 1
a2899 1
      if ((tp_empty!=tp0->subtype.type) && (tp_empty!=tp0->subtype.type))
@


1.78
log
@mreplace changed
@
text
@a938 1
	    DBUG_RETURN(&CONST_NONE);
d1082 1
a1082 2
  if (GETORDERARGS(o,argtp[0])!=GETSTELMTYPE(res))	/* old type != new type */
    SETORDERARGS(o,argtp[0])=tp_none;
d1459 28
a1486 4
      ft->result.type=tp_none;
      ft->result.dat.desc=GETSTELMDATA(res,desc);
      know=kn_sure;
      DBUG_RETURN(1);
d2154 3
a2156 2
      if (((tp_vect==GETSTELMTYPE(tp0)) || (tp_matrix==GETSTELMTYPE(tp0)))
	  && (tp_bool==tp0->subtype.type))
d2170 2
a2171 1
	 ((tp_int==tp0->subtype.type) || (tp_real==tp0->subtype.type))))
d2186 2
a2187 1
	 ((tp_int==tp0->subtype.type) || (tp_real==tp0->subtype.type))))
d2313 13
a2325 5
	d_stelm.subtype.type=tp_list;
	if (NULL==(d_stelm.subtype.next=malloc(sizeof(SUBTYPE))))
	  yyfail("%s","no memory for subtype!");
	d_stelm.subtype.next->type=tp0->subtype.type;
	d_stelm.subtype.next->next=NULL;
d2359 7
a2365 2
	 (tp_bool==tp0->subtype.type)))
      d_stelm.type=tp0->subtype.type;
d2375 8
a2382 2
        ((tp_int==tp0->subtype.type) || (tp_real==tp0->subtype.type)))
      d_stelm.type=tp0->subtype.type;
d2390 8
a2397 2
        ((tp_int==tp0->subtype.type) || (tp_real==tp0->subtype.type)))
      d_stelm.type=tp_real;
d2431 2
a2432 1
          ((tp_real==tp0->subtype.type) || (tp_int==tp0->subtype.type)))
d2502 8
a2509 3
	d_stelm.subtype.type=d_stelm.type;
	d_stelm.type=tp_vect;
	d_stelm.subtype.next=NULL;
d2517 8
a2524 3
	  d_stelm.subtype.type=d_stelm.type;
	  d_stelm.subtype.next=NULL;
	  d_stelm.type=tp_tvect;
d2532 8
a2539 3
	    d_stelm.subtype.type=d_stelm.type;
	    d_stelm.subtype.next=NULL;
	    d_stelm.type=tp_matrix;
d2557 8
a2564 3
	d_stelm.subtype.type=tp_real;
	d_stelm.subtype.next=NULL;
	d_stelm.type=tp_vect;
d2572 8
a2579 3
	  d_stelm.subtype.type=tp_real;
	  d_stelm.subtype.next=NULL;
	  d_stelm.type=tp_tvect;
d2587 8
a2594 3
	    d_stelm.subtype.type=tp_real;
	    d_stelm.subtype.next=NULL;
	    d_stelm.type=tp_matrix;
d2610 8
a2617 3
	d_stelm.subtype.type=tp_int;
	d_stelm.subtype.next=NULL;
	d_stelm.type=tp_vect;
d2625 8
a2632 3
	  d_stelm.subtype.type=tp_int;
	  d_stelm.subtype.next=NULL;
	  d_stelm.type=tp_tvect;
d2640 8
a2647 3
	    d_stelm.subtype.type=tp_int;
	    d_stelm.subtype.next=NULL;
	    d_stelm.type=tp_matrix;
d2666 8
a2673 3
	d_stelm.type=tp_vect;
	d_stelm.subtype.type=tp_bool;
	d_stelm.subtype.next=NULL;
d2681 8
a2688 3
	  d_stelm.type=tp_tvect;
	  d_stelm.subtype.type=tp_bool;
	  d_stelm.subtype.next=NULL;
d2696 8
a2703 3
	    d_stelm.type=tp_matrix;
	    d_stelm.subtype.type=tp_bool;
	    d_stelm.subtype.next=NULL;
d2741 8
a2748 3
	  d_stelm.subtype.type=tp_bool;
	  d_stelm.subtype.next=NULL;
	  d_stelm.type=tp_vect;
d2756 8
a2763 3
	    d_stelm.subtype.type=tp_bool;
	    d_stelm.subtype.next=NULL;
	    d_stelm.type=tp_tvect;
d2771 8
a2778 3
	      d_stelm.subtype.type=tp_bool;
	      d_stelm.subtype.next=NULL;
	      d_stelm.type=tp_matrix;
d2786 8
a2793 3
		d_stelm.type=tp_vect;
		d_stelm.subtype.type=tp_bool;
		d_stelm.subtype.next=NULL;
d2801 8
a2808 3
		  d_stelm.type=tp_tvect;
		  d_stelm.subtype.type=tp_bool;
		  d_stelm.subtype.next=NULL;
d2816 8
a2823 3
		    d_stelm.type=tp_matrix;
		    d_stelm.subtype.type=tp_bool;
		    d_stelm.subtype.next=NULL;
d2899 8
a2906 3
      d_stelm.type=GETSTELMTYPE(tp0);
      d_stelm.subtype.type=tp0->subtype.type;
      d_stelm.subtype.next=NULL;
d3022 1
a3022 1
    if (tp_matrix==GETSTELMTYPE(tp0))
d3024 1
a3024 1
      if (tp_matrix==GETSTELMTYPE(tp1))
d3032 1
a3032 1
	if (tp_tvect==GETSTELMTYPE(tp1))
d3044 1
a3044 1
      if (tp_vect==GETSTELMTYPE(tp0))
d3046 1
a3046 1
	if (tp_tvect==GETSTELMTYPE(tp1))
d3050 1
a3050 1
	  if (tp_matrix==GETSTELMTYPE(tp1))
d3062 1
a3062 1
	if (tp_tvect==GETSTELMTYPE(tp0))
d3064 1
a3064 1
	  if (tp_vect==GETSTELMTYPE(tp1))
d3115 2
a3116 1
					(tp_tvect==GETSTELMTYPE(tp1))))
d3136 7
a3142 1
      subtypecmp(&(d_stelm.subtype),&(tp0->subtype));
@


1.77
log
@dist*, wait, pushh & poph implemented
@
text
@d3123 2
a3124 1
	 ((tp_matrix!=tp2->subtype.type) && (tp_none!=tp2->subtype.type))))
d3266 1
d3268 2
@


1.76
log
@nilvect, niltvect & nilmat implemented
@
text
@d1346 1
d1376 3
d1380 1
a1380 1
      ((0==arg_check) || (1.0>=calc_args_val(st_read(a,n-1),n))))
@


1.75
log
@! some primitiv functions changed !
@
text
@d938 3
@


1.74
log
@bugfix in setdepent
@
text
@d2247 1
a2247 1
      d_stelm.subtype.type=tp0->subtype.type;
d2251 10
a2260 1
      d_stelm.type=tp_none;
d2265 1
a2265 5
    if (((tp_vect==GETSTELMTYPE(tp0)) || (tp_tvect==GETSTELMTYPE(tp0))) ||
	(tp_matrix==GETSTELMTYPE(tp0)))
      d_stelm.type=tp0->subtype.type;
    else
      d_stelm.type=tp_none;
d2745 1
a2745 1
	((tp_string==GETSTELMTYPE(tp0)) ||
d2750 1
d2752 3
d3096 1
a3096 8
    if ((((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	 ((tp_int==GETSTELMTYPE(tp1)) || (tp_real==GETSTELMTYPE(tp1)))) &&
	((((tp_list==GETSTELMTYPE(tp2)) || (tp_string==GETSTELMTYPE(tp2))) ||
	  ((tp_vect==GETSTELMTYPE(tp2)) || (tp_tvect==GETSTELMTYPE(tp2)))) ||
	 (tp_matrix==GETSTELMTYPE(tp2))))
      stelm_cpy(&d_stelm,tp2,1);
    else
      d_stelm.type=tp_none;
a3144 5
  case p_mselect:
    {
    d_stelm.type=tp_none;				/* that's bad !!! */
    break;
    }
d3155 1
a3156 9
    {
    if ((((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	 (GETSTELMTYPE(tp1)==GETSTELMTYPE(tp2))) &&
	((tp_list==GETSTELMTYPE(tp1)) || (tp_string==GETSTELMTYPE(tp1))))
      stelm_cpy(&d_stelm,tp1,1);
    else
      d_stelm.type=tp_none;
    break;
    }
d3159 1
a3159 13
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	(((GETSTELMTYPE(tp1)==GETSTELMTYPE(tp2)) &&
	  (((tp_matrix==GETSTELMTYPE(tp1)) || (tp_vect==GETSTELMTYPE(tp1))) ||
	   (tp_tvect==GETSTELMTYPE(tp1)))) ||
	 (((tp_matrix==GETSTELMTYPE(tp1)) && (tp_vect==GETSTELMTYPE(tp2))) ||
	  ((tp_matrix==GETSTELMTYPE(tp2)) && (tp_vect==GETSTELMTYPE(tp1))))))
      {
      d_stelm.type=tp_matrix;
      d_stelm.subtype.type=check_int_real(tp1->subtype.type,tp2->subtype.type);
      d_stelm.subtype.next=NULL;
      }
    else
      d_stelm.type=tp_none;
d3239 1
a3239 29
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	((tp_int==GETSTELMTYPE(tp1)) || (tp_real==GETSTELMTYPE(tp1))))
      {
      if ((tp_string==GETSTELMTYPE(tp2)) && (GETSTELMTYPE(tp2)==GETSTELMTYPE(tp3)))
	{
	d_stelm.type=tp_string;
	d_stelm.subtype.next=NULL;
	if ((tp_char==tp2->subtype.type) && (tp2->subtype.type==tp3->subtype.type))
	  d_stelm.subtype.type=tp_char;
	else
	  d_stelm.subtype.type=tp_none;
	}
      else
	{
	if ((tp_list==GETSTELMTYPE(tp2)) && (GETSTELMTYPE(tp2)==GETSTELMTYPE(tp3)))
	  {
	  d_stelm.type=tp_list;
	  d_stelm.subtype.next=NULL;
	  if ((tp2->subtype.type==tp3->subtype.type))
	    d_stelm.subtype.type=tp3->subtype.type;
	  else
	    d_stelm.subtype.type=tp_none;
	  }
	else
	  d_stelm.type=tp_none;
	}
      }
    else
      d_stelm.type=tp_none;
d3244 1
a3244 42
    if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	((tp_int==GETSTELMTYPE(tp1)) || (tp_real==GETSTELMTYPE(tp1))))
      {
      if (tp_list==GETSTELMTYPE(tp3))
	{
	d_stelm.type=tp_list;
	d_stelm.subtype.next=NULL;
	if (tp3->subtype.type==GETSTELMTYPE(tp2))
	  d_stelm.subtype.type=tp3->subtype.type;
	else
	  d_stelm.subtype.type=tp_none;
	}
      else
	{
	if ((tp_string==GETSTELMTYPE(tp3)) && (GETSTELMTYPE(tp3)==GETSTELMTYPE(tp2)))
	  {
	  d_stelm.type=tp_string;
	  d_stelm.subtype.next=NULL;
	  if (tp3->subtype.type==tp2->subtype.type)
	    d_stelm.subtype.type=tp2->subtype.type;
	  else
	    d_stelm.subtype.type=tp_none;
	  }
	else
	  {
	  if (((tp_vect==GETSTELMTYPE(tp3)) || (tp_tvect==GETSTELMTYPE(tp3))) ||
	      (tp_matrix==GETSTELMTYPE(tp3)))
	    {
	    d_stelm.type=GETSTELMTYPE(tp3);
	    d_stelm.subtype.next=NULL;
	    if (tp3->subtype.type==GETSTELMTYPE(tp2))
	      d_stelm.subtype.type=tp3->subtype.type;
	    else
	      d_stelm.type=tp_none;
	    }
	  else
	    d_stelm.type=tp_none;
	  }
	}
      }
    else
      d_stelm.type=tp_none;
@


1.73
log
@bugfix neg(real) ! not reduma like
@
text
@d1026 1
a1027 1
  ord=GETNEXTORDER(ord);
@


1.72
log
@bugfix in ceil & floor
@
text
@d2366 12
a2377 1
      d_stelm.type=tp_none;
@


1.71
log
@tvect bug removed
@
text
@d2135 1
d2143 1
a2143 1
      d_stelm.subtype.type=tp0->subtype.type;
a2147 32
    break;
    }
  case p_trunc:
    {
    switch (GETSTELMTYPE(tp0))
      {
      case tp_int:
      case tp_real:
	{
	d_stelm.type=tp_int;
	break;
	}
      case tp_vect:
      case tp_tvect:
      case tp_matrix:
	{
	if ((tp_int==tp0->subtype.type) || (tp_real==tp0->subtype.type))
	  {
	  d_stelm.type=GETSTELMTYPE(tp0);
	  d_stelm.subtype.type=tp_int;
	  d_stelm.subtype.next=NULL;
	  }
	else
	  d_stelm.type=tp_none;
	break;
	}
      default:
        {
	d_stelm.type=tp_none;
	break;
	}
      }
@


1.70
log
@some bugfixes in gamma handling and matchX
@
text
@d740 1
a740 1
    if (tp_list==(type & tp_list))		/* check for list */
@


1.69
log
@vect, tvect & matrix implemented
@
text
@d82 1
a82 1
	printf(" (function)");
d109 1
a109 1
    case tp_string:
d116 1
a116 1
    case tp_list:
d123 1
a123 1
    case tp_vect:
d130 1
a130 1
    case tp_tvect:
d137 1
a137 1
    case tp_matrix:
d153 1
a153 1
/* calculates the internal value of the n given arguments on a		*/
d162 2
a163 2
for (i=0; i<n; i++,a++)
  {
d211 1
a211 1
res/=n;
d228 3
d236 1
a236 1
  if (ord==GETSTACKENTRY(ret,stack)[i].dat.ret->ord)
d254 1
a254 1
if (tp_func==GETSTELMTYPE(stelm))
d256 1
a256 1
  if (NULL==(rt=malloc(sizeof(RETURNADR))))
d258 1
a258 1
  rt->a=NULL;
d270 1
a270 1
  else
d275 3
a277 3
  rt->w=st_push(rt->w,stelm);
  rt->ord=new_order(apply,GETSTELMDATA(stelm,desc)->nv);
  rt->ord->next=&CONST_EXT;
d279 1
a279 1
  func_dump=st_push(func_dump,new_stelm(tp_returnadr,rt));
d281 2
a282 2
if ((tp_clos==GETSTELMTYPE(stelm)) &&	    /* closure, but no deltaclos */
    (NULL!=GETSTELMDATA(stelm,clos)->desc))
d284 1
a284 1
  if (NULL==(rt=malloc(sizeof(RETURNADR))))
d286 1
a286 1
  rt->a=NULL;
d294 1
a294 1
  if (DT_CONDITIONAL==GETDESCENTRY(des,tag))
d300 1
a300 1
  else
d305 3
a307 3
  rt->w=st_push(rt->w,stelm);
  rt->ord=new_order(apply,des->nv-clos->i);
  rt->ord->next=&CONST_EXT;
d309 1
a309 1
  func_dump=st_push(func_dump,new_stelm(tp_returnadr,rt));
d326 1
a326 1
retur=st_read(ret,1);
d331 1
a331 1
  SETORDERENTRY(ord,branch)=0;
d334 1
a334 1
  DBUG_RETURN(retur);
d336 1
a336 1
DBUG_RETURN((STELM *)NULL);
d348 2
d351 2
a352 2
  ft->knowledge=kn_clear;
  while (NULL!=ft->depend)
d359 1
a359 1
  ft->knowledge=kn_no;
d381 2
a382 1
  if (JCONDS(dummy->dat.ret->ord->command))
d387 1
a387 1
fl=searchfunlist(des->label);
d396 3
a398 3
stelm_cpy(&result,&ft->result,1);
clear_cache(ft);
stelm_cpy(&ft->result,&result,1);
d415 2
a416 1
if ((NULL==old_func) || (0==strcmp(des->label,old_func->dat.ret->ord->args.label)))
d418 1
a418 1
fl=searchfunlist(des->label);
d424 1
a424 1
else
d451 1
a451 1
else
d459 2
a460 2
dep=ftd->depend;
while (NULL!=dep)
d468 1
a468 1
dep->next=ftd->depend;
d487 1
a487 1
      case tp_none:
d503 1
a503 1
      case (tp_list|OTHER_MASK):
d508 1
a508 1
      case tp_string:
d519 1
a519 1
      case tp_vect:
d530 1
a530 1
      case tp_tvect:
d541 1
a541 1
      case tp_matrix:
d580 1
a580 1
for (i=0; i<GETTOPOFSTACK(ret); i++)
d587 2
a588 1
  for (i=GETTOPOFSTACK(ret)-1; i>=0; i--)
d592 1
a592 4
      if (1==GETSTACKENTRY(ret,stack)[i].dat.ret->branch)
	{
/*	SETORDERENTRY(GETSTACKENTRY(ret,stack)[i].dat.ret->ord,branch)=
	  GETSTACKENTRY(ret,stack)[i].dat.ret->branch; 				*/
a593 1
	}
d595 1
d599 1
a599 1
  DBUG_RETURN(ord);
d623 1
a623 1
if (i!=GETTOPOFSTACK(ret))
d629 1
a629 1
    st_pop(dummy);
d633 1
a633 1
    if (NULL==result)				/* old result stored */
d639 1
a639 1
  else
d644 1
a644 1
    if (NULL==result)				/* old result stored */
d654 1
d656 1
a656 1
    st_free(GETSTELMDATA(result,ret)->w);
d663 1
a663 1
  DBUG_RETURN(ret);
d700 1
a700 1
  st_free(GETSTELMDATA(elm,ret)->w);
d706 1
a706 1
ord=elm->dat.ret->ord;
d709 1
a709 1
if (0!=GETSTELMDATA(elm,ret)->branch)
d711 1
a711 1
w=elm->dat.ret->w;
d713 12
a724 2
r=elm->dat.ret->r;
t=elm->dat.ret->t;
d740 1
a740 1
    if (tp_list==(type & tp_list))
d742 1
a742 1
    else
d744 1
a744 1
      if (NULL==(dummy=malloc(4)))
d748 2
a749 1
      DBUG_RETURN(dummy);
d759 1
a759 1
    if (tp_list==(type & tp_list))
d762 1
a762 1
      yyfail("%s","not implemented yet!");
d822 1
a822 1
      case d_name:
d827 1
a827 1
      case d_real:
d832 1
a832 1
      case d_list:
d835 1
a835 1
	SUBTYPE tp={tp_empty,NULL};
d838 2
a839 2
	size=GETDATAENTRY(data,u.v.size);
	for (j=0; j<size; j++)
d842 3
a844 1
	  if ((ISINT(help)) && ((tp_empty==tp.type) || (tp_int==tp.type)))
d849 1
a849 1
	      tp.type=tp_bool;
d853 2
a854 2
		tp.type=tp_prim;
	      else 
d881 3
d885 9
d901 1
a901 1
      case d_string:
d918 3
a920 3
      case d_mat:
      case d_vect:
      case d_tvect:
d968 1
a968 1
DBUG_RETURN(res);
d978 2
a979 1
if (hashargs==GETORDERENTRY(ord,command))
d993 1
a993 1
if (0==check_hash_args(ord))
d995 1
a995 1
  if (0<n)
d997 1
a997 1
    if (NULL==(argtp=malloc(n*sizeof(TP_TYPES))))
d999 1
a999 1
    for (i=0; i<n; i++)
d1003 1
a1003 1
  if (0<nf)
d1005 1
a1005 1
    if (NULL==(argtp=malloc(nf*sizeof(TP_TYPES))))
d1007 2
a1008 6
    for (i=0; i<nf; i++)
      {
      argtp[i]=GETSTELMTYPE(st_read(t,i));
      if (tp_list==argtp[i])
	argtp[i]=argtp[i]|(st_read(t,i)->subtype.type);
      }
d1014 1
a1014 1
  if (0<n)
d1018 1
a1018 1
    for (i=0; i<n; i++)
d1020 3
a1022 3
      argtp[i]=GETSTELMTYPE(st_read(w,i));
      if (argtp[i]!=GETORDERARGS(ord,argtp[i]))
	argtp[i]=tp_none;
d1024 2
a1025 2
    free(GETORDERARGS(ord,argtp));
    SETORDERARGS(ord,argtp)=argtp;
d1028 1
a1028 1
  if (0<nf)
d1032 1
a1032 1
    for (i=0; i<nf; i++)
d1034 3
a1036 3
      argtp[i]=GETSTELMTYPE(st_read(t,i));
      if (argtp[i]!=GETORDERARGS(ord,argtp[i]))
	argtp[i]=tp_none;
d1038 2
a1039 2
    free(GETORDERARGS(ord,argtp));
    SETORDERARGS(ord,argtp)=argtp;
d1054 1
a1054 1
if (NULL==o->prev)
d1080 1
a1080 1
  if (GETORDERARGS(o,argtp[0])!=GETSTELMTYPE(res))
d1099 1
a1099 1
flp=searchfunlist(s);
d1104 1
a1104 1
		  n,nt);
d1108 2
a1109 2
    know=ft->knowledge;
    if ((apply!=GETORDERENTRY(ord,command)) && 
d1112 1
a1112 1
      free(SETORDERARGS(ord,label));
d1115 1
a1115 1
      strcpy(SETORDERARGS(ord,label),ft->label);
d1117 1
a1117 1
    new_params=0;
d1121 1
a1121 1
    insert_functype(s,a,n,t,nt,NULL,kn_no);
d1123 1
a1123 1
    new_params=1; 
d1126 1
a1126 1
else
d1133 1
a1133 1
DBUG_RETURN(res);
d1144 2
a1145 2
st=stelm->subtype.next;
while (NULL!=st)
d1164 2
d1168 1
a1168 1
while (NULL!=st->next)
d1170 1
a1170 1
  dst->type=st->type;
d1173 1
a1173 1
  st=st->next;
d1177 2
a1178 2
dst->next=NULL;
DBUG_RETURN(ost);
d1188 1
a1188 1
if (NULL!=st1)
d1190 1
a1190 1
  while ((NULL!=st1) && (NULL!=st2))
d1192 1
a1192 1
    if (st1->type!=st2->type)
d1194 1
a1194 1
      st1->type=tp_none;
d1196 2
a1197 2
      st1->next=NULL;
      while (NULL!=st2)
d1206 1
a1206 1
      st1=st1->next;
d1223 1
a1223 1
for (i=0; i<n; i++)
d1225 1
a1225 1
  if (stelm1[i].type!=stelm2[i].type)
d1227 1
a1227 1
  else
d1233 1
a1233 1
	if (stelm1[i].dat.desc!=stelm2[i].dat.desc)
d1250 1
d1255 1
d1258 1
a1258 1
		         stelm1[i].dat.clos->i))
d1262 1
a1262 1
			 stelm1[i].dat.clos->k)))
d1277 1
a1277 1
	break;
d1283 1
a1283 1
DBUG_RETURN(0);
d1287 1
a1287 1
/* searches for function in functionlist with matching a&t frames	*/
d1300 1
a1300 1
    found=1;
d1302 1
a1302 1
    ft=ft->next;
d1322 1
a1322 1
    found=1;
d1324 1
a1324 1
    root=root->next;
d1327 1
a1327 1
if ((NULL!=root) && (NULL!=root->org))
d1356 1
a1356 1
  flp->t=nt;                                  /* store tildearity */
d1370 1
a1370 1
  ft->depend=NULL;
d1374 1
d1376 1
a1376 1
    if (NULL==(ft->label=malloc(strlen(name)+4)))
d1382 4
a1385 4
	    "_%s",searchfor_(name));
    dup_count++;
    if (dup_count==dup_num)
      do_dupe=0;
d1387 2
a1388 1
		max_desc_adr+(dup_count*16),des->nfv,des->nv,des->graph,ft->label));
d1406 1
a1406 1
  else
d1410 1
a1410 1
    strcpy(ft->label,name);
d1413 1
a1413 1
  know=kn;
d1418 1
a1418 1
    stelm_cpy(ft->params,st_read(a,n-1),n); /* copy frame */
d1422 1
a1422 1
  if (0<nt)                                   /* get memory for t frame */
d1432 1
a1432 1
  else
d1443 1
a1443 1
  if (tp_illegal!=ft->result.type)
d1445 2
a1446 2
    if ((ft->result.type!=GETSTELMTYPE(res)) &&
	(tp_none!=ft->result.type))	/* old restype != newrestype */
d1448 6
d1501 1
a1501 1
    found=1;
d1503 1
a1503 1
    des=GETNEXTDESC(des);
d1519 1
a1519 1
while ((0==found) && (end!=GETORDERENTRY(ord,command)))
d1522 2
a1523 2
    found=1;
  ord=GETNEXTORDER(ord);
d1525 1
a1525 1
while (0==found)
d1528 1
a1528 1
    found=1;
d1530 1
a1530 1
    ord=GETPREVORDER(ord);
d1549 2
a1550 1
help->subtype.type=tp_none;
d1611 1
a1611 1
for (i=0; i<n;i++)
d1615 1
a1615 1
    case tp_returnadr:
d1619 1
a1619 1
      SETSTELMDATA(stelm1,ret)->w=GETSTELMDATA(stelm2,ret)->w;
d1637 1
a1637 1
    case tp_func:
d1642 1
a1642 1
    case tp_clos:				/* build new closure */
d1646 1
a1646 1
      if (NULL!=stelm2[i].dat.clos)
d1650 1
a1650 1
	stelm1[i].dat.clos=clos;			/* save pointer of clos in STELM */
d1668 1
a1668 1
	  else
d1685 1
a1685 1
    case tp_list:
d1692 1
a1692 1
      while (NULL!=sb2)
d1700 1
a1700 1
      sb1->next=NULL;
d1734 1
a1734 1
  case tp_list:
d1736 1
a1736 1
    free_subtype(stelm);
d1739 1
a1739 1
  case tp_returnadr:
d1749 1
a1749 1
    if (NULL!=stelm->dat.clos)
d1752 2
a1753 2
      if (NULL!=clos->w)
	for (i=0; i<clos->i; i++)
d1755 2
a1756 2
      if (NULL!=clos->t)
	for (i=0; i<clos->k; i++)
d1758 1
a1758 1
      free(clos);
d1778 1
a1778 1
  for (i=0; i<GETTOPOFSTACK(st); i++)
d1782 1
a1782 1
  st=NULL;
d1801 1
a1801 1
  l=MIN_STACK_SIZE;					
d1806 2
a1807 2
  SETSTACKENTRY(nst,length)=l;					/* store size */
  SETSTACKENTRY(nst,topofstack)=n;
d1810 1
a1810 1
DBUG_RETURN(nst);
d1824 1
a1824 1
DBUG_RETURN(stelm);
d1837 1
a1837 1
DBUG_RETURN(stelm);
d1863 1
a1863 1
    SETSTACKENTRY(st,length)*=4;
d1868 2
a1869 2
SETTOPOFSTACK(st)++;				/* increment top of stack pointer */
DBUG_RETURN(st);
d1882 1
a1882 1
while(*s) 
d1885 1
a1885 1
  s++;
d1887 1
a1887 1
DBUG_RETURN(n);
d1898 1
a1898 1
  search++;
d1910 2
a1911 2
  search++;
search++;
@


1.68
log
@PM bugs removed
@
text
@d132 1
a132 1
      printf(" <t:%s>",(tp_none!=stelm[j].subtype.type & PRIM_MASK) ?
d139 1
a139 1
      printf(" <<%s>>",(tp_none!=stelm[j].subtype.type & PRIM_MASK) ?
d525 1
a525 1
	fprintf(yyout,"<t:");
d531 1
a531 1
	fprintf(yyout, ">");
d536 1
a536 1
	fprintf(yyout,"<<");
d542 1
a542 1
	fprintf(yyout, ">>");
d717 2
d723 12
a734 1
    DBUG_RETURN(s_ext_type_names[CALC_EXT(type)]);
d743 1
a743 1
      DBUG_RETURN(s_ext_type_names[((type & tp_list)>>4)]);
@


1.67
log
@infinit loop removed
@
text
@d123 21
d511 11
a522 2
	
      case tp_vect:
d524 10
d536 7
a542 1
	yyfail("%s","not yet implemented!");
a874 1
	break;
a875 1
	break;
d877 35
d913 1
d1017 3
a1019 1
  if ((tp_list==GETSTELMTYPE(res)) || (tp_string==GETSTELMTYPE(res)))
@


1.66
log
@bug with recursiv functions with changing parameters removed
@
text
@d132 63
d658 1
a658 1
  ord->branch=GETSTELMDATA(elm,ret)->branch;
d1245 2
a1246 1
  if ((0!=do_dupe) && (apply!=GETORDERENTRY(ord,command)) && (0<des->nv))
@


1.65
log
@mklist problem fixed
@
text
@d132 24
d175 2
a176 1
  rt->status=EXE_CLOS;
d203 2
a204 1
  rt->status=EXE_CLOS;
d462 1
a462 1
if (NULL==ret)
d475 6
d581 3
a583 1
while (GETSTELMDATA(elm,ret)->ord!=old_ord)
d592 4
a595 4
if (EXE_CLOS==(GETSTELMDATA(elm,ret)->status|EXE_CLOS))
  clos_exe=1;
else
  clos_exe=0;
d931 1
d944 1
d1425 1
d2534 4
a2537 1
	d_stelm.type=tp1->subtype.type;
@


1.64
log
@mklist with functions and/or closures bugfixed
@
text
@d132 70
d473 3
a475 2
while ((0!=strcmp(label,GETORDERARGS(GETSTELMDATA(st_read(ret,i),ret)->ord,label)))
       && (i<GETTOPOFSTACK(ret)))
d529 1
a529 1
long i,df=0;
d536 1
a536 7
  else 
    if (ext==GETORDERENTRY(GETSTACKENTRY(ret,stack)[i].dat.ret->ord,command))	
      df=1;					/* end of dump execution */
  }
if (1==df)
  DBUG_RETURN((STELM *)NULL);
yyfail("%s","no function found on return Stack");
d558 4
d836 2
d902 1
d1388 1
@


1.63
log
@tildeargs reimplemented in function cache
@
text
@d366 1
a366 1
if ((NULL==ret) || (1==new_params))
a829 1
    new_params=1;					/* new function parameter */
d1336 1
a1336 12
      if (NULL==(clos=malloc(sizeof(CLOSURE))))
	yyfail("%s","no memory for new closure");
      stelm1[i].dat.clos=clos;			/* save pointer of clos in STELM */
      if (NULL==(clos->w=malloc(stelm2[i].dat.clos->i*sizeof(STELM))))
	yyfail("%s","no memory for new closure");
      stelm_cpy(clos->w,stelm2[i].dat.clos->w,
		stelm2[i].dat.clos->i); 	/* copy A frame */
      clos->i=stelm2[i].dat.clos->i;
      clos->j=stelm2[i].dat.clos->j;
      clos->k=stelm2[i].dat.clos->k;
      clos->desc=stelm2[i].dat.clos->desc;
      if (NULL!=clos->desc)			/* clos->desc!=NULL => func */
d1338 12
a1349 1
	if (0!=stelm2[i].dat.clos->k)
d1351 9
a1359 4
	  if (NULL==(clos->t=malloc(stelm2[i].dat.clos->k*sizeof(STELM))))
	    yyfail("%s","no memory for new closure");
          stelm_cpy(clos->t,stelm2[i].dat.clos->t,
		    stelm2[i].dat.clos->k);	/* copy T frame */
d1361 1
a1361 1
	else
a1363 2
      else					/* prim func */
	clos->t=NULL;
d1439 11
a1449 7
    clos=stelm->dat.clos;
    for (i=0; i<clos->i; i++)
      stelm_free(&(clos->w[i]));
    if (NULL!=clos->t)
      for (i=0; i<clos->k; i++)
        stelm_free(&(clos->t[i]));
    free(clos);
@


1.62
log
@some primitiv functions fixed & jcond bug removed
@
text
@d203 3
a205 1
  ft=searchftypes(fl->funtypes,(0==des->nv)?NULL:st_read(radr->w,des->nv-1),des->nv);
d207 3
a209 1
  ft=searchftypes(fl->funtypes,(0==des->nv)?NULL:st_read(radr->w,des->nv),des->nv);
d234 3
a236 1
  ftd=searchftypes(fl->funtypes,(0==des->nv)?NULL:st_read(w,des->nv-1),des->nv);
d238 4
a241 1
  ftd=searchftypes(fl->funtypes,(0==des->nv-1)?NULL:st_read(w,des->nv-2),des->nv-1);  
d251 4
a254 2
    fts=searchftypes(fl->funtypes,(0==s_des->nv)?NULL:st_read(radr->w,s_des->nv-1+1),
		     s_des->nv);
d258 4
a261 2
    fts=searchftypes(fl->funtypes,(0==s_des->nv-1)?NULL:st_read(radr->w,s_des->nv-2+1),
		     s_des->nv-1);
d266 4
a269 2
  fts=searchftypes(fl->funtypes,(0==s_des->nv)?NULL:st_read(radr->w,s_des->nv-1),
		   s_des->nv);
d413 2
a414 1
    result=get_result(label,dummy,GETDESCENTRY(des,nv));
d425 2
a426 2
    result=get_result(label,GETSTELMDATA(st_read(ret,i),ret)->w,
		      GETDESCENTRY(des,nv));
d800 1
a800 1
STELM *get_result(char *s, STACK *a, long n)
d807 1
a807 1
DBUG_PRINT("FUNLIST",("->Fun: %s Par.: %d TPar.: %d",s,n));
d811 3
a813 1
  ft=searchftypes(flp->funtypes,(0==n)?NULL:st_read(a,n-1),n);
d829 1
a829 1
    insert_functype(s,a,n,NULL,kn_no);
d836 1
a836 1
  insert_functype(s,a,n,NULL,kn_no);
d993 1
a993 1
FUNTYPES *searchftypes(FUNTYPES *ft, STELM *a, long n)
d998 1
a998 1
DBUG_PRINT("FUNLIST",("->Par.: %d TPar.: %d",n));
d1001 2
a1002 1
  if ((0==n) || (0==stelmcmp(a,ft->params,n)))
d1039 2
a1040 1
int insert_functype(char *name,STACK *a,long n,STELM *res,KNOWLEDGE kn)
d1048 1
a1048 1
DBUG_PRINT("FUNLIST",("->Fun. Name: %s Par.: %d TPar.: %d Res.: %d",name,n,
d1059 1
d1065 3
a1067 1
ft=searchftypes(flp->funtypes,(NULL==a)?NULL:st_read(a,n-1),n);
d1100 1
d1122 8
d1138 1
a1138 1
  DBUG_PRINT("FUNLIST",("<-new entry in FUNLIST %s %d %d %d",name,n,
@


1.61
log
@lselect und lreplace bug removed
@
text
@d351 1
a351 1
if (NULL==ret)
d812 1
d1776 7
a1782 1
      d_stelm.type=tp_none;
d1879 1
a1879 1
    if (tp_list==GETSTELMTYPE(tp0))
d2025 1
a2025 1
    if (tp_list==GETSTELMTYPE(tp0))
d2054 1
a2054 1
    if (tp_list==GETSTELMTYPE(tp0))
d2262 2
a2263 1
    if (((tp_clos==GETSTELMTYPE(tp0)) || (tp_clos==GETSTELMTYPE(tp1))) ||
@


1.60
log
@modulo corrected
@
text
@d81 4
a84 1
      printf(" (%s)",GETDESCENTRY(stelm[j].dat.desc,label));
d498 16
a513 4
  if (0>type)					/* special type */
    yyfail("%s","type is not printable");
  else						/* other type */
    DBUG_RETURN(s_other_type_names[type-OTHER_MASK]);
d2375 7
a2381 1
      d_stelm.type=tp_none;
d2726 16
a2741 1
      d_stelm.type=tp_none;
@


1.59
log
@*** empty log message ***
@
text
@d2161 1
a2161 3
    if (tp_none!=d_stelm.type)
      d_stelm.type=tp_int;
    else
d2240 2
a2241 1
    if ((tp_clos==GETSTELMTYPE(tp0)) || (tp_clos==GETSTELMTYPE(tp1)))
@


1.58
log
@*** empty log message ***
@
text
@d2242 1
a2242 1
    if ((tp_clos==GETSTELMTYPE(tp0)) && (GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)))
@


1.57
log
@tildeargs removed from functioncache
@
text
@d617 1
a617 1
	TP_TYPES tp=tp_empty;
d623 2
a624 2
	  if ((ISCHAR(help)) && ((tp_empty==tp) || (tp_char==tp)))
	    tp=tp_char;
d626 1
a626 1
            tp=tp_none;
d628 1
a628 1
	res=new_stelm(tp_string,(void *)tp);
@


1.56
log
@minor bug while inserting tildeargs removed
@
text
@d200 1
a200 4
  ft=searchftypes(fl->funtypes,
		  (0==des->nv)  ? NULL : st_read(radr->w,des->nv-1),
		  (0==des->nfv) ? NULL : st_read(radr->t,des->nfv-1),
		  des->nv,des->nfv);
d202 1
a202 4
  ft=searchftypes(fl->funtypes,
		  (0==des->nv)  ? NULL : st_read(radr->w,des->nv),
		  (0==des->nfv) ? NULL : st_read(radr->t,des->nfv-1),
		  des->nv,des->nfv);
d227 1
a227 3
  ftd=searchftypes(fl->funtypes,
		   (0==des->nv ) ? NULL : st_read(w,des->nv-1),
		   (0==des->nfv) ? NULL : st_read(t,des->nfv-1),des->nv,des->nfv);
d229 1
a229 4
  ftd=searchftypes(fl->funtypes,
		   (0==des->nv-1 ) ? NULL : st_read(w,des->nv-2),
		   (0==des->nfv/4) ? NULL : st_read(t,(des->nfv/4)-1),
		   des->nv-1,des->nfv/4);  
d239 2
a240 4
    fts=searchftypes(fl->funtypes,
		     (0==s_des->nv)  ? NULL : st_read(radr->w,s_des->nv-1+1),
		     (0==s_des->nfv) ? NULL : st_read(radr->t,s_des->nfv-1),
		     s_des->nv,s_des->nfv);
d244 2
a245 4
    fts=searchftypes(fl->funtypes,
		     (0==s_des->nv-1)  ? NULL : st_read(radr->w,s_des->nv-2+1),
		     (0==s_des->nfv/4) ? NULL : st_read(radr->t,(s_des->nfv/4)-1),
		     s_des->nv-1,s_des->nfv/4);
d250 2
a251 4
  fts=searchftypes(fl->funtypes,
		   (0==s_des->nv)  ? NULL : st_read(radr->w,s_des->nv-1),
		   (0==s_des->nfv) ? NULL : st_read(radr->t,s_des->nfv-1),
		   s_des->nv,s_des->nfv);
d395 1
a395 2
    result=get_result(label,dummy,GETDESCENTRY(des,nv),
  		      GETSTELMDATA(st_read(ret,i),ret)->t,GETDESCENTRY(des,nfv));
d406 2
a407 2
    result=get_result(label,GETSTELMDATA(st_read(ret,i),ret)->w,GETDESCENTRY(des,nv),
  		      GETSTELMDATA(st_read(ret,i),ret)->t,GETDESCENTRY(des,nfv));
d769 1
a769 1
STELM *get_result(char *s, STACK *a, long n, STACK *t, long nt)
d776 1
a776 1
DBUG_PRINT("FUNLIST",("->Fun: %s Par.: %d TPar.: %d",s,n,nt));
d780 1
a780 3
  ft=searchftypes(flp->funtypes, 
		  (0==n) ? NULL : st_read(a,n-1), 
		  (0==nt) ? NULL : st_read(t,nt-1),n,nt);
d796 1
a796 1
    insert_functype(s,a,n,t,nt,NULL,kn_no);
d802 1
a802 1
  insert_functype(s,a,n,t,nt,NULL,kn_no);
d959 1
a959 1
FUNTYPES *searchftypes(FUNTYPES *ft, STELM *a, STELM *t, long n, long nt)
d964 1
a964 1
DBUG_PRINT("FUNLIST",("->Par.: %d TPar.: %d",n,nt));
d967 1
a967 2
  if (((0==n) || (0==stelmcmp(a,ft->params,n))) &&
      ((0==nt) || (0==stelmcmp(t,ft->tparams,nt))))
d1004 1
a1004 2
int insert_functype(char *name,STACK *a,long n,STACK *t,long nt,STELM *res,
		    KNOWLEDGE kn)
d1012 1
a1012 1
DBUG_PRINT("FUNLIST",("->Fun. Name: %s Par.: %d TPar.: %d Res.: %d",name,n,nt,
a1022 1
  flp->t=nt;					/* store tildearity */
d1028 1
a1028 2
ft=searchftypes(flp->funtypes, (NULL==a) ? NULL : st_read(a,n-1),
		(NULL==t) ? NULL : st_read(t,nt-1), n, nt);
a1060 1
    flp_dup->t=nt;				/* store tildearity */
a1081 8
  if (0<nt)					/* get memory for t frame */
    {
    if (NULL==(ft->tparams=malloc(nt*sizeof(STELM))))
      yyfail("%s","no memory for function parameters!");
    stelm_cpy(ft->tparams,st_read(t,nt-1),nt); /* copy frame */
    }
  else						/* no frame */
    ft->tparams=NULL;
d1090 1
a1090 1
  DBUG_PRINT("FUNLIST",("<-new entry in FUNLIST %s %d %d %d",name,n,nt,
@


1.55
log
@duplicate function label corrected
@
text
@d709 1
a709 1
    insert_order_list(new_order(hashtildeargs,n,argtp),ord);
@


1.55.1.1
log
@*** empty log message ***
@
text
@d81 1
a81 4
      if (NULL==stelm[j].dat.desc)
	printf(" (function)");
      else
	printf(" (%s)",GETDESCENTRY(stelm[j].dat.desc,label));
d200 4
a203 1
  ft=searchftypes(fl->funtypes,(0==des->nv)?NULL:st_read(radr->w,des->nv-1),des->nv);
d205 4
a208 1
  ft=searchftypes(fl->funtypes,(0==des->nv)?NULL:st_read(radr->w,des->nv),des->nv);
d233 3
a235 1
  ftd=searchftypes(fl->funtypes,(0==des->nv)?NULL:st_read(w,des->nv-1),des->nv);
d237 4
a240 1
  ftd=searchftypes(fl->funtypes,(0==des->nv-1)?NULL:st_read(w,des->nv-2),des->nv-1);  
d250 4
a253 2
    fts=searchftypes(fl->funtypes,(0==s_des->nv)?NULL:st_read(radr->w,s_des->nv-1+1),
		     s_des->nv);
d257 4
a260 2
    fts=searchftypes(fl->funtypes,(0==s_des->nv-1)?NULL:st_read(radr->w,s_des->nv-2+1),
		     s_des->nv-1);
d265 4
a268 2
  fts=searchftypes(fl->funtypes,(0==s_des->nv)?NULL:st_read(radr->w,s_des->nv-1),
		   s_des->nv);
d412 2
a413 1
    result=get_result(label,dummy,GETDESCENTRY(des,nv));
d424 2
a425 2
    result=get_result(label,GETSTELMDATA(st_read(ret,i),ret)->w,
		      GETDESCENTRY(des,nv));
d513 4
a516 16
  {
  if (OTHER_MASK<type)
    {
    if (tp_list==(type & tp_list))
      DBUG_RETURN(s_ext_type_names[((type & tp_list)>>4)]);
    else
      yyfail("%s","not implemented yet!");
    }
  else
    {
    if (0>type)						/* special type */
      yyfail("%s","type is not printable");
    else						/* other type */
      DBUG_RETURN(s_other_type_names[type-OTHER_MASK]);
    }
  }
d635 1
a635 1
	SUBTYPE tp={tp_empty,NULL};
d641 2
a642 2
	  if ((ISCHAR(help)) && ((tp_empty==tp.type) || (tp_char==tp.type)))
	    tp.type=tp_char;
d644 1
a644 1
            tp.type=tp_none;
d646 1
a646 1
	res=new_stelm(tp_string,(void *)&tp);
d709 1
a709 1
    insert_order_list(new_order(hashtildeargs,nf,argtp),ord);
d787 1
a787 1
STELM *get_result(char *s, STACK *a, long n)
d794 1
a794 1
DBUG_PRINT("FUNLIST",("->Fun: %s Par.: %d TPar.: %d",s,n));
d798 3
a800 1
  ft=searchftypes(flp->funtypes,(0==n)?NULL:st_read(a,n-1),n);
d816 1
a816 1
    insert_functype(s,a,n,NULL,kn_no);
d822 1
a822 1
  insert_functype(s,a,n,NULL,kn_no);
d979 1
a979 1
FUNTYPES *searchftypes(FUNTYPES *ft, STELM *a, long n)
d984 1
a984 1
DBUG_PRINT("FUNLIST",("->Par.: %d TPar.: %d",n));
d987 2
a988 1
  if ((0==n) || (0==stelmcmp(a,ft->params,n)))
d1025 2
a1026 1
int insert_functype(char *name,STACK *a,long n,STELM *res,KNOWLEDGE kn)
d1034 1
a1034 1
DBUG_PRINT("FUNLIST",("->Fun. Name: %s Par.: %d TPar.: %d Res.: %d",name,n,
d1045 1
d1051 2
a1052 1
ft=searchftypes(flp->funtypes,(NULL==a)?NULL:st_read(a,n-1),n);
d1085 1
d1107 8
d1123 1
a1123 1
  DBUG_PRINT("FUNLIST",("<-new entry in FUNLIST %s %d %d %d",name,n,
d2194 3
a2196 1
    if (tp_none==d_stelm.type)
d2275 1
a2275 2
    if (((tp_clos==GETSTELMTYPE(tp0)) || (tp_clos==GETSTELMTYPE(tp1))) ||
	((tp_list==GETSTELMTYPE(tp0)) && (tp_list==GETSTELMTYPE(tp1))))
d2394 1
a2394 7
      {
      if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) &&
	  (tp_string==GETSTELMTYPE(tp1)))
	d_stelm.type=tp1->subtype.type;
      else
        d_stelm.type=tp_none;
      }
d2739 1
a2739 16
      {
      if (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0)))
	  && (tp_string==GETSTELMTYPE(tp2)) && (tp_string==GETSTELMTYPE(tp1)))
	{
	if (tp1->subtype.type==tp2->subtype.type)
	  stelm_cpy(&d_stelm,tp2,1);
        else
	  {
	  d_stelm.type=tp_string;
	  d_stelm.subtype.type=tp_none;
	  d_stelm.subtype.next=NULL;
	  }
	}
      else
	d_stelm.type=tp_none;
      }
@


1.54
log
@call of dup_func changed
@
text
@d1064 1
a1064 1
    sd=((long)searchfor_(name))-((long)name)-1;
d1068 1
a1068 1
	    "%s",&name[sd]);
d1557 12
@


1.53
log
@fundesc address made unique
@
text
@a684 1
ORDER *o;
d697 1
a697 2
    o=new_order(hashargs,n,argtp);
    insert_order_list(o,ord);
d709 1
a709 2
    o=new_order(hashtildeargs,n,argtp);
    insert_order_list(o,ord);
d1074 1
a1074 1
    ft->ord=dup_func(find_func(GETFIRSTFUNCTION(program_start),name));
@


1.52
log
@option -dx handling implemented
@
text
@d1069 1
a1069 1
    sprintf(&(ft->label[sd]),"%x",dup_count);
d1075 2
a1076 2
    conc_desc(GETFIRSTDESC(program_start),
	      new_desc(des->tag,des->address,des->nfv,des->nv,des->graph,ft->label));
@


1.51
log
@function duplication - first part
@
text
@d1073 2
@


1.50
log
@silly bug in primitive functions removed
@
text
@d10 1
d393 1
a393 1
char label[20];
d399 2
d416 2
d419 1
d427 2
d430 1
d443 1
d446 1
d808 8
d1019 2
d1031 1
a1031 1
FUNLIST *flp;
d1033 2
d1049 1
d1062 36
d1119 1
d1121 3
@


1.49
log
@STACKS & ORDER changed to global
@
text
@d1516 1
a1516 1
if (tp_empty==(tp0==tp1))
d1518 1
a1518 1
if (((tp_int==(tp0==tp1)) || ((tp_int==tp0) && (tp_empty==tp1))) ||
d1537 1
a1537 1
if (tp_vect==(tp0==tp1))
d1563 1
a1563 1
if (tp_vect==(tp0==tp1))
d1575 1
a1575 1
  if (tp_bool==(lt1==tp0))
d1591 1
a1591 1
if (tp_tvect==(tp0==tp1))
d1617 1
a1617 1
if (tp_tvect==(tp0==tp1))
d1619 1
a1619 1
  if (tp_bool==(lt0==lt1))
d1624 1
a1624 1
  if (tp_bool==(lt0==tp1))
d1629 1
a1629 1
  if (tp_bool==(lt1==tp0))
d1645 1
a1645 1
if (tp_matrix==(tp0==tp1))
d1671 1
a1671 1
if (tp_matrix==(tp0==tp1))
d1673 1
a1673 1
  if (tp_bool==(lt0==lt1))
d1678 1
a1678 1
  if (tp_bool==(lt0==tp1))
d1683 1
a1683 1
  if (tp_bool==(tp0==lt1))
d2160 1
a2160 1
    if (tp_bool==(GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)))
d2200 1
a2200 1
    if (tp_clos==(GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)))
d2324 1
a2324 1
    if (tp_list==(GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)))
d2336 8
a2343 7
    if ((((tp_int==(GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1))) ||
	  (tp_real==(GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)))) ||
	 ((tp_string==(GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1))) ||
	  (tp_bool==(GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1))))) ||
	(((tp_vect==(GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1))) ||
	  (tp_tvect==(GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)))) ||
	 (tp_matrix==(GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)))))
d2451 1
a2451 1
    if (tp_int==(GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)))
d2568 2
a2569 2
    if ((tp_vect==(GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1))) ||
	(tp_tvect==(GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1))))
d2849 1
a2849 1
      if (tp_string==(GETSTELMTYPE(tp2)==GETSTELMTYPE(tp3)))
d2853 1
a2853 1
	if (tp_char==(tp2->subtype.type==tp3->subtype.type))
d2860 1
a2860 1
	if (tp_list==(GETSTELMTYPE(tp2)==GETSTELMTYPE(tp3)))
d2893 1
a2893 1
	if (tp_string==(GETSTELMTYPE(tp3)==GETSTELMTYPE(tp2)))
@


1.48
log
@lselect on empty list changed
@
text
@d28 1
a28 1
void stack_display(STACK *w, STACK *a, STACK *r, STACK *t)
d132 1
a132 1
STELM *gotofail(ORDER *ord,STACK *ret)
d180 1
a180 1
void return_to_call(STELM *stelm,STACK *ret)
d217 1
a217 1
void set_depend(FUNDESC *des,STACK *w,STACK *t,STELM *old_func)
d359 1
a359 1
ORDER *search_ret(ORDER *ord,STACK *ret)
d389 1
a389 1
STACK *findfcall(STELM *stelm, STACK *ret)
d444 1
a444 1
STELM *getfunc_ret(STACK *ret)
d466 1
a466 1
STELM *restore_ret(ORDER *ord,STACK *ret)
d472 1
a472 1
while (GETSTELMDATA(elm,ret)->ord!=ord)
d480 6
a485 1
DBUG_RETURN(elm);
d656 1
a656 1
  
d658 2
a659 2
/* checks for args hash							*/
/* returns 0 for false and 1 for true					*/
d1007 2
a1008 2
int insert_functype(char*name,STACK *a,long n,STACK *t,long nt,STELM *res,
		     KNOWLEDGE kn)
d1692 1
a1692 1
void exe_prim1(ORDER *ord,STACK *w,PRIMF primf)
d1696 1
d2004 1
d2010 1
a2010 1
void exe_prim2(ORDER *ord,STACK *w,PRIMF primf)
d2014 1
d2611 1
d2617 1
a2617 1
void exe_prim3(ORDER *ord,STACK *w,PRIMF primf)
d2621 1
d2802 1
d2808 1
a2808 1
void exe_prim4(ORDER *ord,STACK *w,PRIMF primf)
d2812 1
d2947 1
@


1.47
log
@minor bugs removed
@
text
@d107 3
a109 3
      printf(" '%s`",(tp_none!=stelm[j].dat.subtype.type & PRIM_MASK) ?
	     prim_type_names[stelm[j].dat.subtype.type & PRIM_MASK] :
	     ext_type_names[(stelm[j].dat.subtype.type & EXT_MASK)>>4]);
d114 3
a116 3
      printf(" [%s]",(tp_none!=stelm[j].dat.subtype.type & PRIM_MASK) ?
	     prim_type_names[stelm[j].dat.subtype.type & PRIM_MASK] :
	     ext_type_names[(stelm[j].dat.subtype.type & EXT_MASK)>>4]);
d596 1
a596 1
		      tp.next=subtype_cpy(&dummy->dat.subtype);
d601 1
a601 1
		      subtypecmp(tp.next,&dummy->dat.subtype);
d681 1
a681 1
      argtp[i]=(GETSTELMTYPE(st_read(w,i)))|(st_read(w,i)->dat.subtype.type);
d693 1
a693 1
	argtp[i]=argtp[i]|(st_read(t,i)->dat.subtype.type);
d747 1
a747 1
    argtp[0]=GETSTELMTYPE(res) | res->dat.subtype.type;
d816 1
a816 1
st=stelm->dat.subtype.next;
d823 1
a823 1
stelm->dat.subtype.next=NULL;
d913 1
a913 1
	if (stelm1[i].dat.subtype.type!=stelm2[i].dat.subtype.type)
d1160 1
a1160 1
help->dat.subtype.type=tp_none;
d1198 2
a1199 2
    help->dat.subtype.type=((SUBTYPE *)data)->type;
    help->dat.subtype.next=((SUBTYPE *)data)->next;
d1286 2
a1287 2
      stelm1[i].dat.subtype.type=stelm2[i].dat.subtype.type;
      stelm1[i].dat.subtype.next=NULL;
d1294 3
a1296 3
      stelm1[i].dat.subtype.type=stelm2[i].dat.subtype.type;
      sb2=stelm2[i].dat.subtype.next;
      sb1=&(stelm1[i].dat.subtype);
d1694 1
a1694 1
  SETORDERENTRY(ord,types)=TYPES2LONG((GETSTELMTYPE(tp0) | tp0->dat.subtype.type),
d1700 1
a1700 1
  if ((GETSTELMTYPE(tp0)|tp0->dat.subtype.type)
d1721 1
a1721 1
	 ((tp_int==tp0->dat.subtype.type) || (tp_real==tp0->dat.subtype.type))))
d1724 2
a1725 2
      d_stelm.dat.subtype.type=tp0->dat.subtype.type;
      d_stelm.dat.subtype.next=NULL;
d1745 1
a1745 1
	if ((tp_int==tp0->dat.subtype.type) || (tp_real==tp0->dat.subtype.type))
d1748 2
a1749 2
	  d_stelm.dat.subtype.type=tp_int;
	  d_stelm.dat.subtype.next=NULL;
d1768 1
a1768 1
	 ((tp_int==tp0->dat.subtype.type) || (tp_real==tp0->dat.subtype.type))))
d1771 2
a1772 2
      d_stelm.dat.subtype.type=tp0->dat.subtype.type;
      d_stelm.dat.subtype.next=NULL;
d1800 2
a1801 2
      d_stelm.dat.subtype.type=tp0->dat.subtype.type;
      d_stelm.dat.subtype.next=NULL;
d1821 2
a1822 2
      d_stelm.dat.subtype.type=tp0->dat.subtype.type;
      d_stelm.dat.subtype.next=NULL;
d1834 2
a1835 2
      d_stelm.dat.subtype.type=tp0->dat.subtype.type;
      d_stelm.dat.subtype.next=NULL;
d1847 2
a1848 2
      d_stelm.dat.subtype.type=tp0->dat.subtype.type;
      d_stelm.dat.subtype.next=NULL;
d1860 2
a1861 2
      d_stelm.dat.subtype.type=tp0->dat.subtype.type;
      d_stelm.dat.subtype.next=NULL;
d1871 1
a1871 1
      d_stelm.type=tp0->dat.subtype.type;
d1881 2
a1882 2
      d_stelm.dat.subtype.type=tp0->dat.subtype.type;
      d_stelm.dat.subtype.next=NULL;
d1889 2
a1890 2
	d_stelm.dat.subtype.type=tp_list;
	if (NULL==(d_stelm.dat.subtype.next=malloc(sizeof(SUBTYPE))))
d1892 2
a1893 2
	d_stelm.dat.subtype.next->type=tp0->dat.subtype.type;
	d_stelm.dat.subtype.next->next=NULL;
d1911 2
a1912 2
    if ((tp_list==GETSTELMTYPE(tp0)) && (((tp_bool==tp0->dat.subtype.type) ||
	(tp_int==tp0->dat.subtype.type)) || (tp_real==tp0->dat.subtype.type)))
d1915 2
a1916 2
      d_stelm.dat.subtype.type=tp0->dat.subtype.type;
      d_stelm.dat.subtype.next=NULL;
d1926 3
a1928 3
        (((tp_int==tp0->dat.subtype.type) || (tp_real==tp0->dat.subtype.type)) ||
	 (tp_bool==tp0->dat.subtype.type)))
      d_stelm.type=tp0->dat.subtype.type;
d1938 2
a1939 2
        ((tp_int==tp0->dat.subtype.type) || (tp_real==tp0->dat.subtype.type)))
      d_stelm.type=tp0->dat.subtype.type;
d1947 1
a1947 1
        ((tp_int==tp0->dat.subtype.type) || (tp_real==tp0->dat.subtype.type)))
d2011 2
a2012 2
  SETORDERENTRY(ord,types)=TYPES2LONG((GETSTELMTYPE(tp0)|tp0->dat.subtype.type),
				      (GETSTELMTYPE(tp1)|tp1->dat.subtype.type),
d2018 1
a2018 1
  if ((GETSTELMTYPE(tp0)|tp0->dat.subtype.type)
d2021 1
a2021 1
  if ((GETSTELMTYPE(tp1)|tp1->dat.subtype.type)
d2035 2
a2036 2
      d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				  GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2039 1
a2039 1
	d_stelm.dat.subtype.type=d_stelm.type;
d2041 1
a2041 1
	d_stelm.dat.subtype.next=NULL;
d2045 2
a2046 2
        d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				     GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2049 2
a2050 2
	  d_stelm.dat.subtype.type=d_stelm.type;
	  d_stelm.dat.subtype.next=NULL;
d2055 2
a2056 2
	  d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				     GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2059 2
a2060 2
	    d_stelm.dat.subtype.type=d_stelm.type;
	    d_stelm.dat.subtype.next=NULL;
d2075 2
a2076 2
      d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				  GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2079 2
a2080 2
	d_stelm.dat.subtype.type=tp_real;
	d_stelm.dat.subtype.next=NULL;
d2085 2
a2086 2
        d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				     GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2089 2
a2090 2
	  d_stelm.dat.subtype.type=tp_real;
	  d_stelm.dat.subtype.next=NULL;
d2095 2
a2096 2
	  d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				     GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2099 2
a2100 2
	    d_stelm.dat.subtype.type=tp_real;
	    d_stelm.dat.subtype.next=NULL;
d2115 2
a2116 2
      d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				  GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2119 2
a2120 2
	d_stelm.dat.subtype.type=tp_int;
	d_stelm.dat.subtype.next=NULL;
d2125 2
a2126 2
        d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				     GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2129 2
a2130 2
	  d_stelm.dat.subtype.type=tp_int;
	  d_stelm.dat.subtype.next=NULL;
d2135 2
a2136 2
	  d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				     GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2139 2
a2140 2
	    d_stelm.dat.subtype.type=tp_int;
	    d_stelm.dat.subtype.next=NULL;
d2156 2
a2157 2
      d_stelm.type=check_vect_bool(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				   GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2161 2
a2162 2
	d_stelm.dat.subtype.type=tp_bool;
	d_stelm.dat.subtype.next=NULL;
d2166 2
a2167 2
	d_stelm.type=check_tvect_bool(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				      GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2171 2
a2172 2
	  d_stelm.dat.subtype.type=tp_bool;
	  d_stelm.dat.subtype.next=NULL;
d2176 2
a2177 2
	  d_stelm.type=check_mat_bool(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				      GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2181 2
a2182 2
	    d_stelm.dat.subtype.type=tp_bool;
	    d_stelm.dat.subtype.next=NULL;
d2214 2
a2215 2
	d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				    GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2218 2
a2219 2
	  d_stelm.dat.subtype.type=tp_bool;
	  d_stelm.dat.subtype.next=NULL;
d2224 2
a2225 2
	  d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				       GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2228 2
a2229 2
	    d_stelm.dat.subtype.type=tp_bool;
	    d_stelm.dat.subtype.next=NULL;
d2234 2
a2235 2
	    d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				       GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2238 2
a2239 2
	      d_stelm.dat.subtype.type=tp_bool;
	      d_stelm.dat.subtype.next=NULL;
d2244 2
a2245 2
	      d_stelm.type=check_vect_bool(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
					   GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2249 2
a2250 2
		d_stelm.dat.subtype.type=tp_bool;
		d_stelm.dat.subtype.next=NULL;
d2254 2
a2255 2
		d_stelm.type=check_tvect_bool(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
					      GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2259 2
a2260 2
		  d_stelm.dat.subtype.type=tp_bool;
		  d_stelm.dat.subtype.next=NULL;
d2264 2
a2265 2
		  d_stelm.type=check_mat_bool(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
					      GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2269 2
a2270 2
		    d_stelm.dat.subtype.type=tp_bool;
		    d_stelm.dat.subtype.next=NULL;
d2295 4
a2298 1
      d_stelm.type=tp1->dat.subtype.type;
d2303 3
a2305 3
	d_stelm.dat.subtype.type=tp1->dat.subtype.next->type;
	if (NULL!=tp1->dat.subtype.next->next)
	  d_stelm.dat.subtype.next=subtype_cpy(tp1->dat.subtype.next->next);
d2307 1
a2307 1
	  d_stelm.dat.subtype.next=NULL;
d2319 1
a2319 1
      subtypecmp(&(d_stelm.dat.subtype),&(tp1->dat.subtype));
d2338 2
a2339 2
      d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				  GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2344 1
a2344 1
	    (GETSTELMTYPE(tp1)==tp0->dat.subtype.type))
d2346 2
a2347 2
	  d_stelm.dat.subtype.type=GETSTELMTYPE(tp1);
	  d_stelm.dat.subtype.next=NULL;
d2351 1
a2351 1
	  d_stelm.dat.subtype.next=NULL;
d2353 2
a2354 2
	      (GETSTELMTYPE(tp0)==tp1->dat.subtype.type))
	    d_stelm.dat.subtype.type=GETSTELMTYPE(tp0);
d2356 1
a2356 1
	    d_stelm.dat.subtype.type=tp_none;
d2361 2
a2362 2
	d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				     GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2367 1
a2367 1
	      (GETSTELMTYPE(tp1)==tp0->dat.subtype.type))
d2369 2
a2370 2
	    d_stelm.dat.subtype.type=GETSTELMTYPE(tp1);
	    d_stelm.dat.subtype.next=NULL;
d2374 1
a2374 1
	    d_stelm.dat.subtype.next=NULL;
d2376 2
a2377 2
		(GETSTELMTYPE(tp0)==tp1->dat.subtype.type))
	      d_stelm.dat.subtype.type=GETSTELMTYPE(tp0);
d2379 1
a2379 1
	      d_stelm.dat.subtype.type=tp_none;
d2384 2
a2385 2
	  d_stelm.type=check_vect_bool(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				       GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2388 2
a2389 2
	    d_stelm.dat.subtype.type=tp_bool;
	    d_stelm.dat.subtype.next=NULL;
d2394 2
a2395 2
	    d_stelm.type=check_tvect_bool(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				          GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2398 2
a2399 2
	      d_stelm.dat.subtype.type=tp_bool;
	      d_stelm.dat.subtype.next=NULL;
d2404 2
a2405 2
	      d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				         GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2409 1
a2409 1
		d_stelm.dat.subtype.next=NULL;
d2411 2
a2412 2
		   (tp0->dat.subtype.type==GETSTELMTYPE(tp1)))
		  d_stelm.dat.subtype.type=tp0->dat.subtype.type;
d2416 2
a2417 2
		     (tp1->dat.subtype.type==GETSTELMTYPE(tp0)))
		    d_stelm.dat.subtype.type=tp1->dat.subtype.type;
d2419 1
a2419 1
		    d_stelm.dat.subtype.type=tp_none;
d2424 2
a2425 2
		d_stelm.type=check_mat_bool(GETSTELMTYPE(tp0),tp0->dat.subtype.type,
				            GETSTELMTYPE(tp1),tp1->dat.subtype.type);
d2429 2
a2430 2
		  d_stelm.dat.subtype.type=tp_bool;
		  d_stelm.dat.subtype.next=NULL;
d2455 2
a2456 2
	d_stelm.dat.subtype.type=check_int_real(tp0->dat.subtype.type,tp1->dat.subtype.type);
	d_stelm.dat.subtype.next=NULL;
d2463 2
a2464 2
	  d_stelm.dat.subtype.type=check_int_real(tp0->dat.subtype.type,tp1->dat.subtype.type);
	  d_stelm.dat.subtype.next=NULL;
d2475 1
a2475 1
	  d_stelm.type=check_int_real(tp0->dat.subtype.type,tp1->dat.subtype.type);
d2481 2
a2482 2
	    d_stelm.dat.subtype.type=check_int_real(tp0->dat.subtype.type,tp1->dat.subtype.type);
	    d_stelm.dat.subtype.next=NULL;
d2495 2
a2496 2
	    d_stelm.dat.subtype.type=check_int_real(tp0->dat.subtype.type,tp1->dat.subtype.type);
	    d_stelm.dat.subtype.next=NULL;
d2533 2
a2534 2
      d_stelm.dat.subtype.type=tp1->dat.subtype.type;
      d_stelm.dat.subtype.next=NULL;
d2544 1
a2544 1
      d_stelm.type=tp1->dat.subtype.type;
d2563 1
a2563 1
      subtypecmp(&(d_stelm.dat.subtype),&(tp0->dat.subtype));
d2583 1
a2583 1
	(tp0->dat.subtype.type==tp1->dat.subtype.type)) &&
d2588 2
a2589 2
      d_stelm.dat.subtype.type=tp_bool;
      d_stelm.dat.subtype.next=NULL;
d2617 3
a2619 3
  SETORDERENTRY(ord,types)=TYPES2LONG((GETSTELMTYPE(tp0)|tp0->dat.subtype.type),
				      (GETSTELMTYPE(tp1)|tp1->dat.subtype.type),
				      (GETSTELMTYPE(tp2)|tp2->dat.subtype.type),
d2625 1
a2625 1
  if ((GETSTELMTYPE(tp0)|tp0->dat.subtype.type)
d2628 1
a2628 1
  if ((GETSTELMTYPE(tp1)|tp1->dat.subtype.type)
d2631 1
a2631 1
  if ((GETSTELMTYPE(tp2)|tp2->dat.subtype.type)
d2643 1
a2643 1
      if (GETSTELMTYPE(tp1)==tp2->dat.subtype.type)
d2648 2
a2649 2
	d_stelm.dat.subtype.type=tp_none;
	d_stelm.dat.subtype.next=NULL;
d2686 2
a2687 2
	(((tp_vect!=tp2->dat.subtype.type) && (tp_tvect!=tp2->dat.subtype.type)) &&
	 ((tp_matrix!=tp2->dat.subtype.type) && (tp_none!=tp2->dat.subtype.type))))
d2690 2
a2691 2
      d_stelm.dat.subtype.type=tp2->dat.subtype.type;
      d_stelm.dat.subtype.next=NULL;
d2706 2
a2707 2
	d_stelm.dat.subtype.type=tp2->dat.subtype.type;
	d_stelm.dat.subtype.next=NULL;
d2725 1
a2725 1
	(tp2->dat.subtype.type==GETSTELMTYPE(tp1)))
d2751 2
a2752 2
      d_stelm.dat.subtype.type=check_int_real(tp1->dat.subtype.type,tp2->dat.subtype.type);
      d_stelm.dat.subtype.next=NULL;
d2764 2
a2765 2
      d_stelm.dat.subtype.type=check_int_real(tp1->dat.subtype.type,tp2->dat.subtype.type);
      d_stelm.dat.subtype.next=NULL;
d2777 2
a2778 2
      d_stelm.dat.subtype.type=check_int_real(tp1->dat.subtype.type,tp2->dat.subtype.type);
      d_stelm.dat.subtype.next=NULL;
d2807 4
a2810 4
  SETORDERENTRY(ord,types)=TYPES2LONG((GETSTELMTYPE(tp0)|tp0->dat.subtype.type),
				      (GETSTELMTYPE(tp1)|tp1->dat.subtype.type),
				      (GETSTELMTYPE(tp2)|tp2->dat.subtype.type),
				      (GETSTELMTYPE(tp3)|tp3->dat.subtype.type));
d2815 1
a2815 1
  if ((GETSTELMTYPE(tp0)|tp0->dat.subtype.type)
d2818 1
a2818 1
  if ((GETSTELMTYPE(tp1)|tp1->dat.subtype.type)
d2821 1
a2821 1
  if ((GETSTELMTYPE(tp2)|tp2->dat.subtype.type)
d2824 1
a2824 1
  if ((GETSTELMTYPE(tp3)|tp3->dat.subtype.type)
d2839 3
a2841 3
	d_stelm.dat.subtype.next=NULL;
	if (tp_char==(tp2->dat.subtype.type==tp3->dat.subtype.type))
	  d_stelm.dat.subtype.type=tp_char;
d2843 1
a2843 1
	  d_stelm.dat.subtype.type=tp_none;
d2850 3
a2852 3
	  d_stelm.dat.subtype.next=NULL;
	  if ((tp2->dat.subtype.type==tp3->dat.subtype.type))
	    d_stelm.dat.subtype.type=tp3->dat.subtype.type;
d2854 1
a2854 1
	    d_stelm.dat.subtype.type=tp_none;
d2872 3
a2874 3
	d_stelm.dat.subtype.next=NULL;
	if (tp3->dat.subtype.type==GETSTELMTYPE(tp2))
	  d_stelm.dat.subtype.type=tp3->dat.subtype.type;
d2876 1
a2876 1
	  d_stelm.dat.subtype.type=tp_none;
d2883 3
a2885 3
	  d_stelm.dat.subtype.next=NULL;
	  if (tp3->dat.subtype.type==tp2->dat.subtype.type)
	    d_stelm.dat.subtype.type=tp2->dat.subtype.type;
d2887 1
a2887 1
	    d_stelm.dat.subtype.type=tp_none;
d2895 3
a2897 3
	    d_stelm.dat.subtype.next=NULL;
	    if (tp3->dat.subtype.type==GETSTELMTYPE(tp2))
	      d_stelm.dat.subtype.type=tp3->dat.subtype.type;
d2917 3
a2919 3
      d_stelm.dat.subtype.next=NULL;
      if (tp3->dat.subtype.type==GETSTELMTYPE(tp2))
	d_stelm.dat.subtype.type=tp3->dat.subtype.type;
@


1.46
log
@primitive functions bugfixed
@
text
@d681 1
a681 5
      {
      argtp[i]=GETSTELMTYPE(st_read(w,i));
      if (tp_list==argtp[i])
	argtp[i]=argtp[i]|(st_read(w,i)->dat.subtype.type);
      }
d1694 2
a1695 1
  SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),tp_none,tp_none,tp_none);
d1700 2
a1701 1
  if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
d1704 1
d2011 2
a2012 1
  SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
d2018 2
a2019 1
  if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
d2021 2
a2022 1
  if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
d2025 1
d2614 4
a2617 2
  SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
				      GETSTELMTYPE(tp2),tp_none); /* internal types */
d2622 2
a2623 1
  if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
d2625 2
a2626 1
  if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
d2628 2
a2629 1
  if (GETSTELMTYPE(tp2)!=GETTYPE(2,GETORDERENTRY(ord,types)))
d2632 1
d2804 4
a2807 2
  SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
				      GETSTELMTYPE(tp2),GETSTELMTYPE(tp3));
d2812 2
a2813 1
  if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
d2815 2
a2816 1
  if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
d2818 2
a2819 1
  if (GETSTELMTYPE(tp2)!=GETTYPE(2,GETORDERENTRY(ord,types)))
d2821 2
a2822 1
  if (GETSTELMTYPE(tp3)!=GETTYPE(3,GETORDERENTRY(ord,types)))
d2825 1
@


1.45
log
@all primitive functions implemented
@
text
@d107 3
a109 3
      printf(" '%s`",(tp_none!=stelm[j].listtype & PRIM_MASK) ?
	     prim_type_names[stelm[j].listtype & PRIM_MASK] :
	     ext_type_names[(stelm[j].listtype & EXT_MASK)>>4]);
d114 3
a116 3
      printf(" [%s]",(tp_none!=stelm[j].listtype & PRIM_MASK) ?
	     prim_type_names[stelm[j].listtype & PRIM_MASK] :
	     ext_type_names[(stelm[j].listtype & EXT_MASK)>>4]);
d564 1
a564 1
	TP_TYPES tp=tp_empty;
d570 3
a572 3
	  help=GETDATAENTRY(data, u.v.data[j]);
	  if ((ISINT(help)) && ((tp_empty==tp) || (tp_int==tp)))
	    tp=tp_int;
d574 3
a576 2
	    if ((ISBOOL(help)) && ((tp_empty==tp) || (tp_bool==tp)))
	      tp=tp_bool;
d578 3
a580 2
	      if ((ISFUNC(help)) && ((tp_empty==tp) || (tp_prim==tp)))
		tp=tp_prim;
d584 23
a606 2
		if ((NULL!=dummy) && ((tp==GETSTELMTYPE(dummy)) || (tp_empty==tp)))
		  tp=GETSTELMTYPE(dummy);
d608 1
a608 1
                  tp=tp_none;
d610 2
d613 1
a613 1
	res=new_stelm(tp_list,(void *)tp);
d684 1
a684 1
	argtp[i]=argtp[i]|(st_read(w,i)->listtype);
d697 1
a697 1
	argtp[i]=argtp[i]|(st_read(t,i)->listtype);
d751 1
a751 1
    argtp[0]=GETSTELMTYPE(res) | GETSTELMLIST(res);
d813 1
a813 2
/* searches for STELM in STELMLIST					*/
/* returns 0 if STELM found, else -1					*/
d815 1
a815 1
int searchstelmlist(STELM *st,STELMLIST *sl)
d817 5
a821 2
DBUG_ENTER("searchstelmlist");
while (NULL!=sl)
d823 3
a825 3
  if (0==stelmcmp(st,sl->stelm,1))
    DBUG_RETURN(0);
  sl=sl->next;
d827 2
a828 1
DBUG_RETURN(-1);
d832 2
a833 2
/* compares two STELMLISTs						*/
/* returns 0 if both STELMLISTs are equal, else -1			*/
d835 1
a835 1
int cmpstelmlist(STELMLIST *sl1,STELMLIST *sl2)
d837 1
a837 1
STELMLIST *sl;
d839 4
a842 3
DBUG_ENTER("cmpstelmlist");
sl=sl1;
while (NULL!=sl)
d844 5
a848 3
  if (0!=searchstelmlist(sl->stelm,sl2))
    DBUG_RETURN(-1);
  sl=sl->next;
d850 13
a862 2
sl=sl2;
while (NULL!=sl)
d864 20
a883 3
  if (0!=searchstelmlist(sl->stelm,sl1))
    DBUG_RETURN(-1);  
  sl=sl->next;
d885 1
a885 1
DBUG_RETURN(0);
d911 3
d917 1
a917 1
	if (stelm1[i].listtype!=stelm2[i].listtype)
d1164 1
a1164 1
SETSTELMLIST(help)=tp_none;
d1197 3
d1202 3
a1204 1
    help->listtype=(TP_TYPES)data;
a1245 1
    case tp_empty:
a1246 2
    case tp_list:
    case tp_string:
d1285 27
a1335 1
  case tp_list:
d1337 3
d1343 5
d1722 1
a1722 1
	 ((tp_int==GETSTELMLIST(tp0)) || (tp_real==GETSTELMLIST(tp0)))))
d1725 2
a1726 1
      d_stelm.listtype=GETSTELMLIST(tp0);
d1746 1
a1746 1
	if ((tp_int==GETSTELMLIST(tp0)) || (tp_real==GETSTELMLIST(tp0)))
d1749 2
a1750 1
	  d_stelm.listtype=tp_int;
d1769 1
a1769 1
	 ((tp_int==GETSTELMLIST(tp0)) || (tp_real==GETSTELMLIST(tp0)))))
d1772 2
a1773 1
      d_stelm.listtype=GETSTELMLIST(tp0);
d1792 11
a1802 2
      d_stelm.type=GETSTELMTYPE(tp0);
      d_stelm.listtype=GETSTELMLIST(tp0);
d1811 1
a1811 4
      {
      d_stelm.type=GETSTELMTYPE(tp0);
      d_stelm.listtype=GETSTELMLIST(tp0);
      }
d1822 2
a1823 1
      d_stelm.listtype=GETSTELMLIST(tp0);
d1835 2
a1836 1
      d_stelm.listtype=GETSTELMTYPE(tp0);
d1848 2
a1849 1
      d_stelm.listtype=GETSTELMTYPE(tp0);
d1861 2
a1862 1
      d_stelm.listtype=GETSTELMTYPE(tp0);
d1872 1
a1872 1
      d_stelm.type=GETSTELMLIST(tp0);
d1882 2
a1883 1
      d_stelm.listtype=GETSTELMLIST(tp0);
d1890 5
a1894 1
	d_stelm.listtype=tp_none;
d1912 2
a1913 2
    if ((tp_list==GETSTELMTYPE(tp0)) && (((tp_bool==GETSTELMLIST(tp0)) ||
	(tp_int==GETSTELMLIST(tp0))) || (tp_real==GETSTELMLIST(tp0))))
d1916 2
a1917 1
      d_stelm.listtype=GETSTELMLIST(tp0);
d1927 3
a1929 3
        (((tp_int==GETSTELMLIST(tp0)) || (tp_real==GETSTELMLIST(tp0))) ||
	 (tp_bool==GETSTELMLIST(tp0))))
      d_stelm.type=GETSTELMLIST(tp0);
d1939 2
a1940 2
        ((tp_int==GETSTELMLIST(tp0)) || (tp_real==GETSTELMLIST(tp0))))
      d_stelm.type=GETSTELMLIST(tp0);
d1948 1
a1948 1
        ((tp_int==GETSTELMLIST(tp0)) || (tp_real==GETSTELMLIST(tp0))))
d2032 2
a2033 2
      d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				  GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2036 1
a2036 1
	d_stelm.listtype=d_stelm.type;
d2038 1
d2042 2
a2043 2
        d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				     GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2046 2
a2047 1
	  d_stelm.listtype=d_stelm.type;
d2052 2
a2053 2
	  d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				     GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2056 2
a2057 1
	    d_stelm.listtype=d_stelm.type;
d2072 2
a2073 2
      d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				  GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2076 2
a2077 1
	d_stelm.listtype=tp_real;
d2082 2
a2083 2
        d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				     GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2086 2
a2087 1
	  d_stelm.listtype=tp_real;
d2092 2
a2093 2
	  d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				     GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2096 2
a2097 1
	    d_stelm.listtype=tp_real;
d2112 2
a2113 2
      d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				  GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2116 2
a2117 1
	d_stelm.listtype=tp_int;
d2122 2
a2123 2
        d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				     GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2126 2
a2127 1
	  d_stelm.listtype=tp_int;
d2132 2
a2133 2
	  d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				     GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2136 2
a2137 1
	    d_stelm.listtype=tp_int;
d2153 2
a2154 2
      d_stelm.type=check_vect_bool(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				   GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2158 2
a2159 1
	d_stelm.listtype=tp_bool;
d2163 2
a2164 2
	d_stelm.type=check_tvect_bool(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				      GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2168 2
a2169 1
	  d_stelm.listtype=tp_bool;
d2173 2
a2174 2
	  d_stelm.type=check_mat_bool(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				      GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2178 2
a2179 1
	    d_stelm.listtype=tp_bool;
d2211 2
a2212 2
	d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				    GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2215 2
a2216 1
	  d_stelm.listtype=tp_bool;
d2221 2
a2222 2
	  d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				       GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2225 2
a2226 1
	    d_stelm.listtype=tp_bool;
d2231 2
a2232 2
	    d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				       GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2235 2
a2236 1
	      d_stelm.listtype=tp_bool;
d2241 2
a2242 2
	      d_stelm.type=check_vect_bool(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
					   GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2246 2
a2247 1
		d_stelm.listtype=tp_bool;
d2251 2
a2252 2
		d_stelm.type=check_tvect_bool(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
					      GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2256 2
a2257 1
		  d_stelm.listtype=tp_bool;
d2261 2
a2262 2
		  d_stelm.type=check_mat_bool(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
					      GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2266 2
a2267 1
		    d_stelm.listtype=tp_bool;
d2282 1
a2282 4
      {
      d_stelm.type=GETSTELMTYPE(tp1);
      d_stelm.listtype=GETSTELMLIST(tp1);
      }
d2291 13
a2303 1
      d_stelm.type=GETSTELMLIST(tp1);
d2312 2
a2313 5
      d_stelm.type=tp_list;
      if (GETSTELMLIST(tp0)==GETSTELMLIST(tp1))
	d_stelm.listtype=GETSTELMLIST(tp0);
      else
	d_stelm.listtype=tp_none;
d2332 2
a2333 2
      d_stelm.type=check_vect_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				  GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2338 5
a2342 2
	    (GETSTELMTYPE(tp1)==GETSTELMLIST(tp0)))
	  d_stelm.listtype=GETSTELMTYPE(tp1);
d2345 1
d2347 2
a2348 2
	      (GETSTELMTYPE(tp0)==GETSTELMLIST(tp1)))
	    d_stelm.listtype=GETSTELMTYPE(tp0);
d2350 1
a2350 1
	    d_stelm.listtype=tp_none;
d2355 2
a2356 2
	d_stelm.type=check_tvect_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				     GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2361 5
a2365 2
	      (GETSTELMTYPE(tp1)==GETSTELMLIST(tp0)))
	    d_stelm.listtype=GETSTELMTYPE(tp1);
d2368 1
d2370 2
a2371 2
		(GETSTELMTYPE(tp0)==GETSTELMLIST(tp1)))
	      d_stelm.listtype=GETSTELMTYPE(tp0);
d2373 1
a2373 1
	      d_stelm.listtype=tp_none;
d2378 2
a2379 2
	  d_stelm.type=check_vect_bool(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				       GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2382 2
a2383 1
	    d_stelm.listtype=tp_bool;
d2388 2
a2389 2
	    d_stelm.type=check_tvect_bool(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				          GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2392 2
a2393 1
	      d_stelm.listtype=tp_bool;
d2398 2
a2399 2
	      d_stelm.type=check_mat_num(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				         GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2403 1
d2405 2
a2406 2
		   (GETSTELMLIST(tp0)==GETSTELMTYPE(tp1)))
		  d_stelm.listtype=GETSTELMLIST(tp0);
d2410 2
a2411 2
		     (GETSTELMLIST(tp1)==GETSTELMTYPE(tp0)))
		    d_stelm.listtype=GETSTELMLIST(tp1);
d2413 1
a2413 1
		    d_stelm.listtype=tp_none;
d2418 2
a2419 2
		d_stelm.type=check_mat_bool(GETSTELMTYPE(tp0),GETSTELMLIST(tp0),
				            GETSTELMTYPE(tp1),GETSTELMLIST(tp1));
d2423 2
a2424 1
		  d_stelm.listtype=tp_bool;
d2449 2
a2450 1
	d_stelm.listtype=check_int_real(GETSTELMLIST(tp0),GETSTELMLIST(tp1));
d2457 2
a2458 1
	  d_stelm.listtype=check_int_real(GETSTELMLIST(tp0),GETSTELMLIST(tp1));
d2469 1
a2469 1
	  d_stelm.type=check_int_real(GETSTELMLIST(tp0),GETSTELMLIST(tp1));
d2475 2
a2476 1
	    d_stelm.listtype=check_int_real(GETSTELMLIST(tp0),GETSTELMLIST(tp1));
d2489 2
a2490 1
	    d_stelm.listtype=check_int_real(GETSTELMLIST(tp0),GETSTELMLIST(tp1));
d2527 2
a2528 1
      d_stelm.listtype=GETSTELMLIST(tp1);
d2538 1
a2538 1
      d_stelm.type=GETSTELMLIST(tp1);
d2546 1
a2546 4
      {
      d_stelm.type=GETSTELMTYPE(tp1);
      d_stelm.listtype=GETSTELMLIST(tp1);
      }
d2556 2
a2557 2
      d_stelm.type=GETSTELMTYPE(tp1);
      d_stelm.listtype=GETSTELMLIST(tp1);
d2577 1
a2577 1
	(GETSTELMLIST(tp0)==GETSTELMLIST(tp1))) &&
d2582 2
a2583 1
      d_stelm.listtype=tp_bool;
d2631 3
a2633 1
      if (GETSTELMTYPE(tp1)==GETSTELMLIST(tp2))
d2636 2
a2637 1
	d_stelm.listtype=GETSTELMLIST(tp2);
a2638 2
      else
	d_stelm.type=tp_none;
d2646 1
a2646 1
  case p_substruct:
d2653 1
a2653 4
      {
      d_stelm.type=GETSTELMTYPE(tp2);
      d_stelm.listtype=GETSTELMLIST(tp2);
      }
d2664 1
a2664 4
      {
      d_stelm.type=GETSTELMTYPE(tp2);
      d_stelm.listtype=GETSTELMLIST(tp2);
      }
d2674 2
a2675 2
	(((tp_vect!=GETSTELMLIST(tp2)) && (tp_tvect!=GETSTELMLIST(tp2))) &&
	 ((tp_matrix!=GETSTELMLIST(tp2)) && (tp_none!=GETSTELMLIST(tp2)))))
d2678 2
a2679 1
      d_stelm.listtype=GETSTELMLIST(tp2);
d2694 2
a2695 1
	d_stelm.listtype=GETSTELMLIST(tp2);
d2713 2
a2714 5
	(GETSTELMLIST(tp2)==GETSTELMTYPE(tp1)))
      {
      d_stelm.type=GETSTELMTYPE(tp2);
      d_stelm.listtype=GETSTELMLIST(tp2);
      }
d2724 1
a2724 4
      {
      d_stelm.type=GETSTELMTYPE(tp1);
      d_stelm.listtype=GETSTELMLIST(tp1);
      }
d2739 2
a2740 1
      d_stelm.listtype=check_int_real(GETSTELMLIST(tp1),GETSTELMLIST(tp2));
d2752 2
a2753 1
      d_stelm.listtype=check_int_real(GETSTELMLIST(tp1),GETSTELMLIST(tp2));
d2765 2
a2766 1
      d_stelm.listtype=check_int_real(GETSTELMLIST(tp1),GETSTELMLIST(tp2));
d2820 3
a2822 2
	if (tp_char==(GETSTELMLIST(tp2)==GETSTELMLIST(tp3)))
	  d_stelm.listtype=tp_char;
d2824 1
a2824 1
	  d_stelm.listtype=tp_none;
d2831 3
a2833 2
	  if ((GETSTELMLIST(tp2)==GETSTELMLIST(tp3)))
	    d_stelm.listtype=GETSTELMLIST(tp3);
d2835 1
a2835 1
	    d_stelm.listtype=tp_none;
d2853 3
a2855 2
	if (GETSTELMLIST(tp3)==GETSTELMTYPE(tp2))
	  d_stelm.listtype=GETSTELMLIST(tp3);
d2857 1
a2857 1
	  d_stelm.listtype=tp_none;
d2864 3
a2866 2
	  if (GETSTELMLIST(tp3)==GETSTELMLIST(tp2))
	    d_stelm.listtype=GETSTELMLIST(tp2);
d2868 1
a2868 1
	    d_stelm.listtype=tp_none;
d2876 3
a2878 2
	    if (GETSTELMLIST(tp3)==GETSTELMTYPE(tp2))
	      d_stelm.listtype=GETSTELMLIST(tp3);
d2898 3
a2900 2
      if (GETSTELMLIST(tp3)==GETSTELMTYPE(tp2))
	d_stelm.listtype=GETSTELMLIST(tp3);
@


1.44
log
@PM implemented
@
text
@d16 2
a17 2
			       "cmplx",NULL};
const char *s_prim_type_names[]={"?","i","r","d","b","$","e","x"};
d1411 180
d1593 1
a1593 1
void exe_prim(ORDER *ord,STACK *w,PRIMF primf)
d1595 1
a1595 1
STELM d_stelm,*tp0,*tp1,*tp2 /* ,*tp3 */;
d1597 11
d1610 1
a1610 1
  case p_neg:
d1612 2
a1613 3
    tp0=st_pop(w);
    if ((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0)))
      d_stelm.type=GETSTELMTYPE(tp0);
d1616 9
a1624 2
    d_stelm.dat.desc=NULL;
    if (GETORDERENTRY(ord,typestouched)==0)
d1626 2
a1627 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),
                                tp_none,tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d1630 6
d1637 24
a1660 2
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
        SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
a1661 2
    w=st_push(w,&d_stelm);                              /* result to W STACK */
    insert_restype(&d_stelm,ord);                       /* insert hash restype */
d1664 1
a1664 2
  case p_cos:
  case p_sin:
d1666 4
a1669 7
    tp0=st_pop(w);
    if ((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0)))
      d_stelm.type=tp_real;
    else
      d_stelm.type=tp_none;
    d_stelm.dat.desc=NULL;
    if (GETORDERENTRY(ord,typestouched)==0)
d1671 2
a1672 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),
                                tp_none,tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d1675 1
a1675 6
      {
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
        SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
      }
    w=st_push(w,&d_stelm);                              /* result to W STACK */
    insert_restype(&d_stelm,ord);                       /* insert hash restype */
d1678 1
a1678 1
  case p_trunc:
d1680 1
a1680 2
    tp0=st_pop(w);
    if ((tp_int==GETSTELMTYPE(tp0)) && (tp_real==GETSTELMTYPE(tp0)))
d1684 6
a1689 2
    d_stelm.dat.desc=NULL;
    if (GETORDERENTRY(ord,typestouched)==0)
d1691 2
a1692 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),
				tp_none,tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d1695 6
d1702 2
a1703 2
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
d1705 2
a1706 2
    w=st_push(w,&d_stelm);				/* result to W STACK */
    insert_restype(&d_stelm,ord);			/* insert hash restype */ 
d1709 1
a1709 2
  case p_eq:
  case p_ne:
d1711 2
a1712 5
    tp0=st_pop(w);					/* get args */
    tp1=st_pop(w);
    d_stelm.type=tp_bool;			/* for all args restype=tp_bool */
    d_stelm.dat.desc=NULL;
    if (GETORDERENTRY(ord,typestouched)==0)
d1714 2
a1715 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
					tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d1718 7
d1726 2
a1727 4
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
      if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
d1729 2
a1730 2
    w=st_push(w,&d_stelm);				/* result to W STACK */
    insert_restype(&d_stelm,ord);			/* insert hash restype */
d1733 1
a1733 4
  case p_ge:
  case p_le:
  case p_lt:
  case p_gt:	    
d1735 6
a1740 8
    tp0=st_pop(w);					/* get args */
    tp1=st_pop(w);
    if ((((GETSTELMTYPE(tp0)==GETSTELMTYPE(tp1)) && 	/* ii, rr, bb, ir ri */
	  (((tp_int==GETSTELMTYPE(tp0)) || (tp_real==GETSTELMTYPE(tp0))) ||
	   (tp_bool==GETSTELMTYPE(tp0)))) || ((tp_int==GETSTELMTYPE(tp0)) &&
					      (tp_real==GETSTELMTYPE(tp1)))) ||
	((tp_real==GETSTELMTYPE(tp0)) && (tp_int==GETSTELMTYPE(tp1))))
      d_stelm.type=tp_bool;
d1743 6
a1748 2
    d_stelm.dat.desc=NULL;
    if (GETORDERENTRY(ord,typestouched)==0)
d1750 2
a1751 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
					tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d1754 1
a1754 8
      {
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
      if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
      }
    w=st_push(w,&d_stelm);				/* result to W STACK */
    insert_restype(&d_stelm,ord);			/* insert hash restype */
d1757 1
a1757 3
  case p_minus:
  case p_plus:
  case p_mult:
d1759 3
a1761 4
    tp0=st_pop(w);
    tp1=st_pop(w);
    if ((tp_int==GETSTELMTYPE(tp0)) && (tp_int==GETSTELMTYPE(tp1))) /* intint */
      d_stelm.type=tp_int;
d1763 6
d1770 2
a1771 6
      if (((tp_int==GETSTELMTYPE(tp0)) ||		/* intreal, realint, */
	   (tp_real==GETSTELMTYPE(tp0))) && 		/* realreal */
	  ((tp_int==GETSTELMTYPE(tp1)) || (tp_real==GETSTELMTYPE(tp1))))
	d_stelm.type=tp_real;
      else						     
        d_stelm.type=tp_none;
d1773 1
a1773 2
    d_stelm.dat.desc=NULL;
    if (GETORDERENTRY(ord,typestouched)==0)
d1775 7
a1781 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
					tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d1783 7
d1791 7
d1799 2
a1800 4
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
      if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
d1802 42
a1843 3
    w=st_push(w,&d_stelm);				/* result to W STACK */
    insert_restype(&d_stelm,ord);			/* insert hash restype */
    break;	  
d1845 5
a1849 1
  case p_div:
d1851 1
a1851 5
    tp0=st_pop(w);
    tp1=st_pop(w);
    if (((tp_int==GETSTELMTYPE(tp0)) || 		/* intint, realreal  */
	 (tp_real==GETSTELMTYPE(tp0))) && 		/* intreal, realint, */
	((tp_int==GETSTELMTYPE(tp1)) || (tp_real==GETSTELMTYPE(tp1))))
d1855 59
a1913 2
    d_stelm.dat.desc=NULL;
    if (GETORDERENTRY(ord,typestouched)==0)
d1915 27
a1941 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
					tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d1943 7
d1952 27
a1978 4
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
      if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
d1980 1
a1980 3
    w=st_push(w,&d_stelm);				/* result to W STACK */
    insert_restype(&d_stelm,ord);			/* insert hash restype */
    break;	  
d1984 2
a1985 4
    tp0=st_pop(w);
    tp1=st_pop(w);
    if ((tp_int==GETSTELMTYPE(tp0)) && 
	((tp_int==GETSTELMTYPE(tp1)) || (tp_real==GETSTELMTYPE(tp1))))
d1989 7
a1995 2
      if ((tp_real==GETSTELMTYPE(tp0)) && (tp_int==GETSTELMTYPE(tp1)))
        d_stelm.type=tp_real;
d1997 19
a2015 1
        d_stelm.type=tp_none;
d2017 9
a2025 1
    if (GETORDERENTRY(ord,typestouched)==0)
d2027 27
a2053 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
					tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d2055 19
d2076 74
a2149 4
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
      if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
d2151 2
a2152 2
    w=st_push(w,&d_stelm);				/* result to W STACK */
    insert_restype(&d_stelm,ord);			/* insert hash restype */    
d2155 1
a2155 1
  case p_ldim:
d2157 3
a2159 3
    tp0=st_pop(w);
    if ((tp_list==GETSTELMTYPE(tp0)) || (tp_string==GETSTELMTYPE(tp0)))
      d_stelm.type=tp_int;
d2162 5
a2166 1
    if (GETORDERENTRY(ord,typestouched)==0)
d2168 5
a2172 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),tp_none,
					tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d2175 15
d2191 87
a2277 2
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
d2279 8
a2286 2
    w=st_push(w,&d_stelm);				/* result to W STACK */
    insert_restype(&d_stelm,ord);			/* insert hash restype */
d2289 1
a2289 1
  case p_lselect:
d2291 1
a2291 4
    tp0=st_pop(w);
    tp1=st_pop(w);
    if (((tp_list==GETSTELMTYPE(tp1)) || (tp_string==GETSTELMTYPE(tp1)))
	 && (tp_int==GETSTELMTYPE(tp0)))
d2293 5
a2297 2
      if (tp_list!=GETSTELMTYPE(tp1))
	stelm_cpy(&d_stelm,tp1,1);
d2299 17
a2315 3
        {
	d_stelm.type=GETSTELMLIST(tp1);
	switch (d_stelm.type)
d2317 1
a2317 14
	  case tp_char:
	  case tp_none:
	  case tp_int:
	  case tp_real:
	  case tp_bool:
	    break;
	  case tp_string:
	  case tp_list:
	    d_stelm.listtype=tp_none;
	    break;
	  case tp_clos:
	  case tp_func:
	  case tp_prim:
	  case tp_empty:
d2319 4
d2324 10
a2333 1
	    break;
d2335 2
a2336 2
	  default:
	    yyfail("%s","unknown type for primitiv function lselect!");
d2338 2
d2342 50
d2394 6
a2399 1
    if (GETORDERENTRY(ord,typestouched)==0)
d2401 2
a2402 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
					tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d2405 20
d2426 2
a2427 4
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
      if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
d2429 7
a2435 2
    w=st_push(w,&d_stelm);				/* result to W STACK */
    insert_restype(&d_stelm,ord);			/* insert hash restype */      
d2438 32
d2472 2
a2473 7
    tp0=st_pop(w);
    tp1=st_pop(w);
    tp2=st_pop(w);
    stelm_cpy(&d_stelm,tp2,1);
    if (((tp_list==GETSTELMTYPE(tp2)) ||
	 ((tp_string==GETSTELMTYPE(tp2)) && (tp_string==GETSTELMTYPE(tp1))))
	&& (tp_int==GETSTELMTYPE(tp0)))
d2475 1
a2475 1
      if (tp_string==GETSTELMTYPE(tp2))
d2477 2
a2478 2
	if (tp_none==GETSTELMLIST(tp1))
	  d_stelm.listtype=tp_none;
d2481 1
a2481 4
        {
	if (GETSTELMTYPE(tp1)!=GETSTELMLIST(tp2))
	  d_stelm.listtype=tp_none;
	}
d2485 11
a2495 1
    if (GETORDERENTRY(ord,typestouched)==0)
d2497 2
a2498 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
				GETSTELMTYPE(tp2),tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d2501 1
a2501 10
      {
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
      if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
      if (GETSTELMTYPE(tp2)!=GETTYPE(2,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(2,tp_none);
      }
    w=st_push(w,&d_stelm);				/* result to W STACK */
    insert_restype(&d_stelm,ord);			/* insert hash restype */   
d2504 2
a2505 1
  case p_lcut:
d2507 7
a2513 5
    tp0=st_pop(w);
    tp1=st_pop(w);
    if (((tp_list==GETSTELMTYPE(tp1)) || (tp_string==GETSTELMTYPE(tp1)))
	&& (tp_int==GETSTELMTYPE(tp0)))
      stelm_cpy(&d_stelm,tp1,1);
d2516 9
a2524 1
    if (GETORDERENTRY(ord,typestouched)==0)
d2526 2
a2527 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
					tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d2530 7
d2538 8
a2545 4
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
      if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
d2547 2
a2548 2
    w=st_push(w,&d_stelm);				/* result to W STACK */
    insert_restype(&d_stelm,ord);			/* insert hash restype */            
d2551 6
a2556 1
  case p_lunite:
d2558 3
a2560 5
    tp0=st_pop(w);
    tp1=st_pop(w);
    stelm_cpy(&d_stelm,tp0,1);
    if (((tp_list==GETSTELMTYPE(tp1)) && (tp_list==GETSTELMTYPE(tp0))) ||
	((tp_string==GETSTELMTYPE(tp1)) && (tp_string==GETSTELMTYPE(tp0))))
d2562 2
a2563 2
      if (GETSTELMLIST(tp1)!=GETSTELMLIST(tp0))
	d_stelm.listtype=tp_none;
d2567 7
a2573 1
    if (GETORDERENTRY(ord,typestouched)==0)
d2575 2
a2576 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
					tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d2579 11
d2591 2
a2592 4
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
      if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
d2594 2
a2595 2
    w=st_push(w,&d_stelm);				/* result to W STACK */
    insert_restype(&d_stelm,ord);			/* insert hash restype */            
d2598 1
a2598 1
  case p_empty:
d2600 6
a2605 3
    tp0=st_pop(w);
    if ((tp_list==GETSTELMTYPE(tp0)) || (tp_string==GETSTELMTYPE(tp0)))
      d_stelm.type=tp_bool;
d2608 6
a2613 1
    if (GETORDERENTRY(ord,typestouched)==0)
d2615 2
a2616 3
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),tp_none,
					tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d2619 47
d2667 21
a2687 2
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
d2689 2
a2690 2
    w=st_push(w,&d_stelm);				/* result to W STACK */
    insert_restype(&d_stelm,ord);			/* insert hash restype */    
d2693 1
a2693 2
  case p_or:
  case p_and:
d2695 37
a2731 4
    tp0=st_pop(w);
    tp1=st_pop(w);
    if ((tp_bool==GETSTELMTYPE(tp1)) && (tp_bool==GETSTELMTYPE(tp0)))
      d_stelm.type=tp_bool;
d2734 13
a2746 5
    if (GETORDERENTRY(ord,typestouched)==0)
      {
      SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
					tp_none,tp_none); /* internal types */
      SETORDERENTRY(ord,typestouched)=1;
d2749 1
a2749 8
      {
      if (GETSTELMTYPE(tp0)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
      if (GETSTELMTYPE(tp1)!=GETTYPE(1,GETORDERENTRY(ord,types)))
	SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(1,tp_none);
      }
    w=st_push(w,&d_stelm);				/* result to W STACK */
    insert_restype(&d_stelm,ord);			/* insert hash restype */    
d2753 4
a2756 1
    yyfail("%s","unkown primitiv function!\n");
d2758 3
a2760 1
}@


1.43
log
@strings inserted
@
text
@d69 1
d106 4
d111 1
d140 1
a140 1
if (MATCHS(GETORDERENTRY(retur->dat.ret->ord,command)) &&
d146 2
a147 1
  DBUG_RETURN(st_pop(ret));
d551 5
d876 1
d886 1
d1123 2
d1134 1
a1139 5
  case tp_string:
    {    
    help->listtype=(TP_TYPES)data;
    break;
    }
d1174 1
d1183 1
d1247 2
d1643 1
a1643 1
    if (tp_list==GETSTELMTYPE(tp0))
d1666 2
a1667 1
    if ((tp_list==GETSTELMTYPE(tp1)) && (tp_int==GETSTELMTYPE(tp0)))
d1669 6
a1674 16
      d_stelm.type=GETSTELMLIST(tp1);
      switch (d_stelm.type)
	{
	case tp_none:
	case tp_int:
	case tp_real:
	case tp_bool:
	case tp_string:
	  break;
	case tp_list:
	  d_stelm.listtype=tp_none;
	  break;
	case tp_clos:
	case tp_func:
	case tp_prim:
	case tp_empty:
d1676 20
a1695 2
	  d_stelm.type=tp_none;
	  break;
a1696 2
	default:
	  yyfail("%s","unknown type for primitiv function lselect!");
d1724 15
a1738 3
    if ((tp_list==GETSTELMTYPE(tp2)) && (tp_int==GETSTELMTYPE(tp0)))
      if (GETSTELMTYPE(tp1)!=GETSTELMLIST(tp2))
	d_stelm.listtype=tp_none;
d1764 2
a1765 1
    if ((tp_list==GETSTELMTYPE(tp1)) && (tp_int==GETSTELMTYPE(tp0)))
d1791 2
a1792 1
    if ((tp_list==GETSTELMTYPE(tp1)) && (tp_list==GETSTELMTYPE(tp0)))
d1819 1
a1819 1
    if (tp_list==GETSTELMTYPE(tp0))
@


1.42
log
@PM partly implemented
@
text
@d312 12
d579 17
a601 2
      case d_string:
	break;
d710 1
a710 1
  if (tp_list==GETSTELMTYPE(res))
d840 1
d1123 5
d1169 1
d1232 1
@


1.41
log
@jcond changed, now using branch
@
text
@d15 1
a15 1
const char *prim_type_names[]={"none","int","real","digit","bool","string","empty",
d17 3
a19 3
const char *s_prim_type_names[]={"?","i","r","d","b","s","e","x"};
const char *ext_type_names[]={"scalar","list","vect","tvect","matrix",NULL};
const char *s_ext_type_names[]={NULL,"l","v","t","m"};
d122 24
d380 1
a380 1
  while ((0!=strcmp(label,GETORDERARGS(GETSTELMDATA(st_read(ret,i),ret)->ord,label)))
d1026 1
d1029 7
d1040 4
a1044 1
  }
d1275 2
d1279 2
a1280 1
DBUG_RETURN(&(GETSTACKENTRY(st,stack)[GETTOPOFSTACK(st)]));
d1289 2
d1292 2
a1293 1
DBUG_RETURN(&(GETSTACKENTRY(st,stack)[GETTOPOFSTACK(st)-i-1]));
@


1.40
log
@minor bug in gammabeta removed
@
text
@d79 1
a79 1
      printf(" (%s)",GETDESCENTRY(stelm[j].dat.desclist->desc,label));
d93 5
a97 2
	printf(",t:");
	stelm_display(stelm[j].dat.clos->t,stelm[j].dat.clos->k);
d162 1
a162 1
    dummy->dat.ret->ord->args.k=0;
d334 1
a334 1
      if (1==GETORDERARGS(GETSTACKENTRY(ret,stack)[i].dat.ret->ord,k))
d384 1
a384 1
      SETORDERARGS(GETSTELMDATA(result,ret)->ord,k)=0;
a490 1
DESCLIST *dl;
d497 1
a497 7
    {
    if (NULL==(dl=malloc(sizeof(DESCLIST))))
      yyfail("%s","no memory for desciptor list");
    dl->desc=froot;
    dl->next=NULL;
    res=new_stelm(tp_func,dl);			/* remember FUNDESC in STELM */
    }
a724 32
/* searches for FUNDESC in DESCLIST					*/
/* returns 0 if FUNDESC found, else -1					*/
/************************************************************************/
int searchdesclist(FUNDESC *fd,DESCLIST *dl)
{
DBUG_ENTER("searchdesclist");
while (NULL!=dl)
  {
  if (dl->desc==fd)
    DBUG_RETURN(0);
  dl=dl->next;
  }
DBUG_RETURN(-1);
}

/************************************************************************/
/* searches for PRIM in PRIMLIST					*/
/* returns 0 if PRIM found, else -1					*/
/************************************************************************/
int searchprimlist(PRIMF st,PRIMLIST *sl)
{
DBUG_ENTER("searchprimlist");
while (NULL!=sl)
  {
  if (st==sl->prim)
    DBUG_RETURN(0);
  sl=sl->next;
  }
DBUG_RETURN(-1);
}

/************************************************************************/
a740 52
/* compares two DESCLISTs						*/
/* returns 0 if both DESCLISTs are equal, else -1			*/
/************************************************************************/
int cmpdesclist(DESCLIST *dl1,DESCLIST *dl2)
{
DESCLIST *dl;

DBUG_ENTER("cmpdesclist");
dl=dl1;
while (NULL!=dl)
  {
  if (0!=searchdesclist(dl->desc,dl2))
    DBUG_RETURN(-1);
  dl=dl->next;
  }
dl=dl2;
while (NULL!=dl)
  {
  if (0!=searchdesclist(dl->desc,dl1))
    DBUG_RETURN(-1);
  dl=dl->next;
  }
DBUG_RETURN(0);
}

/************************************************************************/
/* compares two PRIMLISTs						*/
/* returns 0 if both PRIMLISTs are equal, else -1			*/
/************************************************************************/
int cmpprimlist(PRIMLIST *sl1,PRIMLIST *sl2)
{
PRIMLIST *sl;

DBUG_ENTER("cmpprimlist");
sl=sl1;
while (NULL!=sl)
  {
  if (0!=searchprimlist(sl->prim,sl2))
    DBUG_RETURN(-1);
  sl=sl->next;
  }
sl=sl2;
while (NULL!=sl)
  {
  if (0!=searchprimlist(sl->prim,sl1))
    DBUG_RETURN(-1);  
  sl=sl->next;
  }
DBUG_RETURN(0);
}

/************************************************************************/
a772 1
DESCLIST *dl1,*dl2;
d785 2
a786 28
	dl1=stelm1[i].dat.desclist;
	while (NULL==dl1)
	  {
	  dl2=stelm2[i].dat.desclist;
	  while (NULL==dl2)
	    {
	    if (dl1->desc==dl2->desc)
	      break;
	    dl2=dl2->next;
	    }
	  if (NULL==dl2)
	    DBUG_RETURN(-1);
	  dl1=dl1->next;	  
	  }
	dl2=stelm2[i].dat.desclist;
	while (NULL==dl2)
	  {
	  dl1=stelm1[i].dat.desclist;
	  while (NULL==dl1)
	    {
	    if (dl2->desc==dl1->desc)
	      break;
	    dl1=dl1->next;
	    }
	  if (NULL==dl1)
	    DBUG_RETURN(-1);
	  dl2=dl2->next;
          }
d797 1
a797 2
	if (0!=
	    cmpdesclist(stelm1[i].dat.clos->desclist,stelm2[i].dat.clos->desclist))
d803 4
a806 2
	if ((0!=stelmcmp(stelm1[i].dat.clos->w,stelm2[i].dat.clos->w,
		         stelm1[i].dat.clos->i)) ||
d808 1
a808 1
		         stelm1[i].dat.clos->k)))
d942 1
a942 1
      ft->result.dat.desclist=GETSTELMDATA(res,desclist);
d1030 1
a1030 1
    SETSTELMDATA(help,desclist)=data;			/* set FUNDESC of STELM */
d1047 1
a1047 1
    SETSTELMDATA(help,desclist)=data;			/* set additional data */
d1104 1
a1104 13
      DESCLIST *dl,*dl2;
      
      dl=stelm2[i].dat.desclist;
      stelm1[i].dat.desclist=NULL;
      while (NULL!=dl)
	{
        if (NULL==(dl2=malloc(sizeof(DESCLIST))))
	  yyfail("%s","no memory for descriptorlist");
	dl2->desc=dl->desc;
	dl2->next=stelm1[i].dat.desclist;
	stelm1[i].dat.desclist=dl2;
	dl=dl->next;
	}
d1121 2
a1122 2
      clos->desclist=stelm2[i].dat.clos->desclist;
      if (NULL!=clos->desclist)			/* clos->desclist!=NULL => func */
d1334 1
a1334 1
    d_stelm.dat.desclist=NULL;
d1358 1
a1358 1
    d_stelm.dat.desclist=NULL;
d1381 1
a1381 1
    d_stelm.dat.desclist=NULL;
d1403 1
a1403 1
    d_stelm.dat.desclist=NULL;
d1436 1
a1436 1
    d_stelm.dat.desclist=NULL;
d1471 1
a1471 1
    d_stelm.dat.desclist=NULL;
d1499 1
a1499 1
    d_stelm.dat.desclist=NULL;
@


1.39
log
@minor bug in mkcclos and jcond removed
@
text
@d23 1
a23 1
#ifndef DBUG_OFF
d116 1
a116 1
#endif
d164 10
a173 4
ft=searchftypes(fl->funtypes,
		(0==des->nv)  ? NULL : st_read(radr->w,des->nv-1),
		(0==des->nfv) ? NULL : st_read(radr->t,des->nfv-1),
		des->nv,des->nfv);
d1022 1
d1402 1
a1402 1
					       4*GETSTACKENTRY(st,length))))
@


1.38
log
@lists bugfixed, implementation of PM started
@
text
@d915 2
a916 2
	    (0!=stelmcmp(stelm1[i].dat.clos->w,stelm2[i].dat.clos->w,
		         stelm1[i].dat.clos->j)))
d950 2
a951 2
  if (((0==n) || (0==stelmcmp(a,ft->params,n))) &&  /* NOCH NICHT FERTIG !!! */
       ((0==nt) || (0==stelmcmp(t,ft->tparams,nt))))
d1636 31
a1673 1
    d_stelm.dat.desclist=NULL;
d1710 1
d1820 48
@


1.37
log
@lists on their way
@
text
@a515 1
	PRIMLIST *pl=NULL,*dpl;
a527 1
	        {
a528 6
		if (NULL==(dpl=malloc(sizeof(PRIMLIST))))
		  yyfail("%s","can't alloc memory for list of primitiv functions");
		dpl->next=pl;
		pl=dpl;
		pl->prim=help>>4;
		}
d530 1
a530 1
	        {
d538 1
a538 1
	res=new_stelm(tp_list,new_stelm(tp,pl));
a901 25
	switch (stelm2[i].listtype)
	  {
	  case tp_real:
	  case tp_int:
	  case tp_bool:
	  case tp_string:
	  case tp_digit:
	  case tp_none:
	    break;
	  case tp_func:
	    {
	    if (0!=cmpstelmlist(stelm1[i].dat.stelmlist,stelm2[i].dat.stelmlist))
	      DBUG_RETURN(-1);
	    break;
	    }
	  case tp_list:
	  case tp_prim:
	    {
	    if (0!=cmpprimlist(stelm1[i].dat.primlist,stelm2[i].dat.primlist))
	      DBUG_RETURN(-1);
	    break;
	    }
	  default:
	    yyfail("%s","unknown listtype for comparision!");
	  }
d1164 1
a1164 37
    if (NULL!=data)
      {
      switch (((STELM *)data)->type)
	{
	case tp_empty:
	case tp_int:
	case tp_real:
	case tp_bool:
	case tp_none:
          {
	  help->listtype=((STELM *)data)->type;
          stelm_free(data);
	  break;
	  }
	case tp_prim:
	  {
	  help->listtype=tp_prim;
	  help->dat.primlist=((STELM *)data)->dat.primlist;
	  stelm_free(data);
	  break;
	  }
	case tp_func:
	  {
	  help->listtype=tp_func;
	  help->dat.desclist=((STELM *)data)->dat.desclist;
	  stelm_free(data);
	  break;
	  }
	default:
	  {
	  yyfail("%s","type of constant list unknown!");
	  break;
	  }
	}
      }
    else
      SETSTELMDATA(help,stelmlist)=data;
d1207 1
a1256 71
    case tp_list:
      {
      switch (stelm2[i].listtype)
	{
	case tp_func:
	  {
          STELMLIST *dsl,*sl1=NULL,*sl2;

	  sl2=stelm2[i].dat.stelmlist;
	  while (NULL!=sl2)
	    {
	    dsl=sl1;
	    if (NULL==(sl1=malloc(sizeof(STELMLIST))))
	      yyfail("%s","no memory for list");
	    sl1->next=dsl;
	    if (NULL==(sl1->stelm=malloc(sizeof(STELM))))
	      yyfail("%s","no memory for listelement");
	    stelm_cpy(sl1->stelm,sl2->stelm,1);
	    sl2=sl2->next;
	    }
	  stelm1[i].dat.stelmlist=sl1;
	  break;
	  }
	case tp_prim:
	  {
	  PRIMLIST *dpl,*spl1=NULL,*spl2;
	  
	  spl2=stelm2[i].dat.primlist;
	  while (NULL!=spl2)
	    {
	    dpl=spl1;
	    if (NULL==(spl1=malloc(sizeof(PRIMLIST))))
	      yyfail("%s","no memory for list of primitiv functions");
	    spl1->next=dpl;
	    spl1->prim=spl2->prim;
	    spl2=spl2->next;
	    }
	  stelm1[i].dat.primlist=spl1;
	  break;
	  }
	case tp_list:
	  {
	  STELMLIST *dsl,*sl1=NULL,*sl2;
	  
	  sl2=stelm2[i].dat.stelmlist;
	  while (NULL!=sl2)
	    {
	    dsl=sl1;
	    if (NULL==(sl1=malloc(sizeof(STELMLIST))))
	      yyfail("%s","no memory for stelmlist");
	    sl1->next=dsl;
	    if (NULL==(sl1->stelm=malloc(sizeof(STELM))))
	      yyfail("%s","no memory for listelement");
	    stelm_cpy(sl1->stelm,sl2->stelm,1);
	    sl2=sl2->next;
	    }
	  stelm1[i].dat.stelmlist=sl1;
	  break;
	  }
	case tp_real:
	case tp_int:
	case tp_none:
	case tp_bool:
	case tp_string:
	  break;
	default:
	  yyfail("%s","unknown listelement");
	  break;
	}
      break;
      }
d1281 1
a1301 44
  case tp_list:
    {    
    switch (stelm->listtype)
      {
      case tp_func:
	{
    	STELMLIST *sl,*dsl;
	
	sl=GETSTELMDATA(stelm,stelmlist);
	while (NULL!=sl)
	  {
	  dsl=sl;
	  stelm_free(sl->stelm);
	  sl=sl->next;
	  free(dsl);
	  }
	SETSTELMDATA(stelm,stelmlist)=NULL;
	break;
	}
      case tp_prim:
	{
	PRIMLIST *pl,*dpl;
	
	pl=GETSTELMDATA(stelm,primlist);
	while (NULL!=pl)
	  {
	  dpl=pl;
	  pl=pl->next;
	  free(dpl);
	  }
	SETSTELMDATA(stelm,primlist)=NULL;
	break;
	}
      case tp_none:
      case tp_int:
      case tp_real:
      case tp_string:
      case tp_bool:
	break;
      default:
	yyfail("%s","unknown listtype for free_stelm");
      }
    break;
    }
d1442 1
a1442 1
STELM d_stelm,*tp0,*tp1/* ,*tp2,*tp3 */;
d1661 44
d1709 26
d1739 21
d1764 25
@


1.36
log
@*** empty log message ***
@
text
@d516 1
d529 8
a536 1
	        tp=tp_prim;
d546 1
a546 1
	res=new_stelm(tp_list,new_stelm(tp,NULL));
d747 16
d805 26
d908 1
a908 2
	if ((stelm1[i].listtype!=stelm2[i].listtype) ||
	    (0!=cmpstelmlist(stelm1[i].dat.stelmlist,stelm2[i].dat.stelmlist)))
d910 25
d1187 1
a1187 1
    SETSTELMDATA(help,desclist)=data;			/* set NULL */
d1205 1
d1211 7
d1327 1
a1327 4
      STELMLIST *dsl,*sl1=NULL,*sl2;
      
      sl2=stelm2[i].dat.stelmlist;
      while (NULL!=sl2)
d1329 64
a1392 8
	dsl=sl1;
        if (NULL==(sl1=malloc(sizeof(STELMLIST))))
	  yyfail("%s","no memory for list");
        sl1->next=dsl;
	if (NULL==(sl1->stelm=malloc(sizeof(STELM))))
	  yyfail("%s","no memory for listelement");
	stelm_cpy(sl1->stelm,sl2->stelm,1);
	sl2=sl2->next;
a1393 1
      stelm1[i].dat.stelmlist=sl1;
d1441 2
a1442 5
    {
    STELMLIST *sl,*dsl;
    
    sl=GETSTELMDATA(stelm,stelmlist);
    while (NULL!=sl)
d1444 37
a1480 4
      dsl=sl;
      stelm_free(sl->stelm);
      sl=sl->next;
      free(dsl);
a1481 1
    SETSTELMDATA(stelm,stelmlist)=NULL;
d1860 1
a1860 1
}
@


1.35
log
@compare on lists and closures implemented
@
text
@d251 2
a252 1

d259 2
a260 1
        fprintf(yyout, "%s",prim_type_names[types[i]]);
d262 1
d264 8
a271 2
        fprintf(yyout, "[%s]",
            prim_type_names[types[i] & PRIM_MASK]);
d273 6
d591 1
d593 3
d604 1
d606 3
d1123 1
a1123 1
    if ((NULL!=data) && (tp_empty==((STELM *)data)->type))
d1125 24
a1148 2
      help->listtype=tp_empty;
      stelm_free(data);
@


1.34
log
@dependencies added to apply
@
text
@d187 1
a187 1
if (NULL==old_func)
d197 2
a198 2
		   (0==des->nv-1 )   ? NULL : st_read(w,des->nv-2),
		   (0==(des->nfv/4)) ? NULL : st_read(t,(des->nfv/4)-1),
d205 24
a228 4
fts=searchftypes(fl->funtypes,
		 (0==s_des->nv)  ? NULL : st_read(radr->w,s_des->nv-1),
		 (0==s_des->nfv) ? NULL : st_read(radr->t,s_des->nfv-1),
		 s_des->nv,s_des->nfv);
d685 2
d688 1
d716 16
d758 26
d835 3
a837 1
	
d845 9
a853 1
	
@


1.33
log
@problems with depending recursiv functions removed
@
text
@d186 1
d191 9
a199 3
ftd=searchftypes(fl->funtypes,
		 (0==des->nv ) ? NULL : st_read(w,des->nv-1),
		 (0==des->nfv) ? NULL : st_read(t,des->nfv-1),des->nv,des->nfv);
d677 42
d775 3
d1025 7
a1031 1
    SETSTELMDATA(help,stelmlist)=data;
d1534 40
a1573 1
    }    
@


1.32
log
@function dependency tree build
@
text
@d119 56
d793 1
d795 1
a795 1
void insert_functype(char*name,STACK *a,long n,STACK *t,long nt,STELM *res,
d826 1
d854 2
a855 1
    if (ft->result.type!=GETSTELMTYPE(res))	/* old restype != newrestype */
d859 2
d866 1
d868 2
d871 1
d873 2
d877 1
a877 1
DBUG_VOID_RETURN;
@


1.31
log
@args output bugfix
@
text
@d119 44
d580 1
d597 1
d599 9
d785 4
a788 1
  stelm_cpy(&ft->result,res,1);		/* store result */
d794 9
a802 1
  if (ft->result.type!=GETSTELMTYPE(res))	/* old restype != newrestype */
d804 4
a807 2
    ft->result.type=tp_none;
    ft->result.dat.desclist=GETSTELMDATA(res,desclist);
d948 1
@


1.30
log
@tp_cmplx added
@
text
@d128 1
a128 1
    switch (types[i] & EXT_MASK)
d137 14
@


1.29
log
@hashstring removed
@
text
@d16 2
a17 2
			  	NULL};
const char *s_prim_type_names[]={"?","i","r","d","b","s"};
@


1.28
log
@lists have changed, primitiv apply bugfixed
@
text
@d119 28
d346 1
a346 1
  if (GETDATAENTRY(data,address)==(int)adr)			/* dataadress found */
d413 1
a413 2
if ((hashargs==GETORDERENTRY(ord,command)) && (0==strncmp(GETORDERARGS(ord,hash_str),
						      "#args",5)))
a423 1
char d_str[MAX_LINE_LENGTH], *str;
a431 1
    strcpy(d_str,"#args");
a434 1
      {
d436 1
a436 8
      d_str[strlen(d_str)+1]=0;
      d_str[strlen(d_str)]=' ';
      strcpy(&d_str[strlen(d_str)],long_type_names(argtp[i]));
      }
    if (NULL==(str=malloc(strlen(d_str)+1)))
      yyfail("%s","no memory for argshash!");
    strcpy(str,d_str);
    o=new_order(hashargs,str,n,argtp);
a440 1
    strcpy(d_str,"#tildeargs");
a443 1
      {
d445 1
a445 8
      d_str[strlen(d_str)+1]=0;
      d_str[strlen(d_str)]=' ';
      strcpy(&d_str[strlen(d_str)],long_type_names(argtp[i]));
      }
    if (NULL==(str=malloc(strlen(d_str)+1)))
      yyfail("%s","no memory for tildeargshash!");
    strcpy(str,d_str);
    o=new_order(hashtildeargs,str,n,argtp);
a452 2
    free(GETORDERARGS(ord,hash_str));
    strcpy(d_str,"#args");
a459 3
      d_str[strlen(d_str)+1]=0;
      d_str[strlen(d_str)]=' ';
      strcpy(&d_str[strlen(d_str)],long_type_names(argtp[i]));
a461 3
    if (NULL==(str=malloc(strlen(d_str)+1)))
      yyfail("%s","no memory for argshash!");
    strcpy(str,d_str);
a462 1
    SETORDERARGS(ord,hash_str)=str;
a466 2
    free(GETORDERARGS(ord,hash_str));
    strcpy(d_str,"#tildeargs");
a473 3
      d_str[strlen(d_str)+1]=0;
      d_str[strlen(d_str)]=' ';
      strcpy(&d_str[strlen(d_str)],long_type_names(argtp[i]));
a475 3
    if (NULL==(str=malloc(strlen(d_str)+1)))
      yyfail("%s","no memory for tildeargshash!");
    strcpy(str,d_str);
a476 1
    SETORDERARGS(ord,hash_str)=str;
a487 1
char str[MAX_LINE_LENGTH], *ds;
a494 8
    sprintf(str,"#restype [%s]",
	(tp_none!=(GETSTELMLIST(res) & PRIM_MASK)) ? 
	prim_type_names[GETSTELMLIST(res)] :
	(tp_none!=(GETSTELMLIST(res) & EXT_MASK)) ?
	ext_type_names[(GETSTELMLIST(res)>>4)] :
	other_type_names[(GETSTELMLIST(res)>>5)]);
    if (NULL==(ds=malloc(strlen(str)+1)))		/* get memory for string */
      yyfail("%s","no memory for hash-string!");
d498 1
a498 2
    strcpy(ds,str);
    ord=new_order(hashrestype,ds,1,argtp);		/* create hash ORDER */
a502 4
    sprintf(str,"#restype %s",long_type_names(GETSTELMTYPE(res)));
    							/* build string */
    if (NULL==(ds=malloc(strlen(str)+1)))		/* get memory for string */
      yyfail("%s","no memory for hash-string!");
d506 1
a506 2
    strcpy(ds,str);
    ord=new_order(hashrestype,ds,1,argtp);		/* create hash ORDER */
a513 1
    {
a514 6
    free(GETORDERARGS(o,hash_str));
    if (NULL==(ds=malloc(strlen("#restype none" )+1)))	/* get memory for string */
      yyfail("%s","no memory for hash-string!");
    strcpy(ds,"#restype none");
    SETORDERARGS(o,hash_str)=ds;
    }
a718 1
  ft->knowledge=kn;
a725 1
    ft->knowledge=kn_sure;
a729 37

/************************************************************************/
/* checks for restype hash						*/
/* returns new_stelm of set restype or NULL				*/
/************************************************************************/
STELM *gethash_restype(ORDER *ord)
{
char *s;
int i;

DBUG_ENTER("gethash_restype");
if (hashrestype==GETORDERENTRY(ord,command))
  {
  i=0;
  while (NULL!=prim_type_names[i])			/* check prim types */
    {
    if (0==strcmp(s,prim_type_names[i]))
      DBUG_RETURN(new_stelm(i,NULL));
    i++;
    }
  i=0;
  while (NULL!=ext_type_names[i])			/* check ext type */
    {
    if (0==strcmp(s,ext_type_names[i]))
      DBUG_RETURN(new_stelm(DO_EXT(i),NULL));
    i++;
    }
  i=0;
  while (NULL!=other_type_names[i])			/* check other type */
     {
     if (0==strcmp(s,other_type_names[i]))
       DBUG_RETURN(new_stelm(i|OTHER_MASK,NULL));
     i++;
     }
  }
DBUG_RETURN((STELM *)NULL);
}  
@


1.27
log
@neg bugfixed, sin/cos implemented
@
text
@d84 1
a84 1
      printf(" (%s)",primf_tab[stelm[j].dat.prim]);
d628 1
a628 2
	printf("do be done");
	exit(0);
d632 4
d701 2
a702 1
void insert_functype(char*name,STACK *a,long n,STACK *t,long nt,STELM *res)
d751 1
d759 1
d1043 3
a1045 2
    for (i=0; i<clos->k; i++)
      stelm_free(&(clos->t[i]));
@


1.26
log
@lists have been changed, hash -> hashargs ...
@
text
@d1204 1
a1204 1
    if ((tp_int==GETSTELMTYPE(tp0)) && (tp_real==GETSTELMTYPE(tp0)))
d1206 24
@


1.25
log
@*** empty log message ***
@
text
@d105 3
a107 3
      printf(" [%s]",(tp_none!=stelm[j].dat.stelm->type & PRIM_MASK) ?
	     prim_type_names[stelm[j].dat.stelm->type & PRIM_MASK] :
	     ext_type_names[(stelm[j].dat.stelm->type & EXT_MASK)>>4]);
d385 1
a385 1
if ((hash==GETORDERENTRY(ord,command)) && (0==strncmp(GETORDERARGS(ord,hash_str),
d419 1
a419 1
    o=new_order(hash,str,n,argtp);
d426 1
a426 1
      yyfail("%s","no memory for argtypes of function!\n");
d437 1
a437 1
    o=new_order(hash,str,n,argtp);
d502 1
a502 1
if (hash!=GETORDERENTRY(GETORDERENTRY(o,prev),command))
d506 6
a511 2
    sprintf(str,"#restype [%s]",(tp_list==GETSTELMTYPE(GETSTELMDATA(res,stelm))) ?
	    			"[...]" : long_type_names(GETSTELMTYPE(GETSTELMDATA(res,stelm)) & PRIM_MASK));
d516 1
a516 1
    argtp[0]=GETSTELMTYPE(res) | GETSTELMTYPE(GETSTELMDATA(res,stelm));
d518 1
a518 1
    ord=new_order(hash,ds,1,argtp);		/* create hash ORDER */
d531 1
a531 1
    ord=new_order(hash,ds,1,argtp);		/* create hash ORDER */
d744 1
a744 3
  ft->result.type=GETSTELMTYPE(res);		/* store result */
  ft->result.dat.desclist=GETSTELMDATA(res,desclist);
						/* ft->des fehlt !!! */
a759 14
/* checks for string "#restype "					*/
/* returns adress of first char behind it or NULL			*/
/************************************************************************/
char *check_restype(char *s)
{
DBUG_ENTER("check_restype");
if (0==strncmp(s,"#restype ",9))		/* compare strings */
  s=&s[9];
else
  s=NULL;					/* does not match */
DBUG_RETURN(s);
}

/************************************************************************/
d769 1
a769 2
if ((hash==GETORDERENTRY(ord,command)) &&		/* checks for hash */ 
    (NULL!=(s=check_restype(GETORDERARGS(ord,hash_str))))) /* checks for restype */
d857 1
d875 1
d888 2
a889 7
    {
    SETSTELMDATA(help,stelm)=data;
    break;
    }
  case tp_empty:
    {
    SETSTELMDATA(help,stelm)=data;
d982 15
a996 3
      if (NULL==(stelm1[i].dat.stelm=malloc(sizeof(STELM))))
	yyfail("%s","no memory for list");
      stelm_cpy(stelm1[i].dat.stelm,stelm2[i].dat.stelm,1);
d1044 11
a1054 2
    stelm_free(GETSTELMDATA(stelm,stelm));
    free(GETSTELMDATA(stelm,stelm));
d1199 1
a1199 1
switch (primf)
@


1.24
log
@some types modified
@
text
@d105 3
a107 1
      printf(" [%s]",prim_type_names[stelm[j].type & PRIM_MASK]);
d932 2
a997 2
      STELM *st;
      
d1026 2
d1029 2
a1030 1
  case tp_empty:
d1032 1
d1196 23
@


1.23
log
@list and descriptor concept changed
@
text
@d505 1
a505 1
	    			"[]" : long_type_names(GETSTELMTYPE(res) & PRIM_MASK));
d994 2
d1190 23
@


1.22
log
@first try with lists
@
text
@d79 1
a79 1
      printf(" (%s)",GETDESCENTRY(stelm[j].dat.desc,label));
d102 6
d109 1
a109 5
      if (tp_list==(stelm[j].type & tp_list))
	printf(" [%s]",prim_type_names[stelm[j].type & PRIM_MASK]);
      else
        yyfail("%s","unknown type for stelm_output");
      break;
d198 1
d296 1
d303 7
a309 1
    res=new_stelm(tp_func,froot);		/* remember FUNDESC in STELM */
d331 1
a331 1
	size=GETDATAENTRY(data, u.v.size);
d352 1
a352 1
	res=new_stelm((tp_list | tp),NULL);
d502 1
a502 1
  if (tp_list==(GETSTELMTYPE(res) & tp_list))
d504 2
a505 1
    sprintf(str,"#restype [%s]",long_type_names(GETSTELMTYPE(res) & PRIM_MASK));
d510 1
a510 1
    argtp[0]=GETSTELMTYPE(res);
d571 75
d657 2
a658 2
  if (((0==n) || (0==memcmp(a,ft->params,n*sizeof(STELM)))) &&  /* NOCH NICHT FERTIG !!! */
       ((0==nt) || (0==memcmp(t,ft->tparams,nt*sizeof(STELM)))))
d739 1
a739 1
  ft->result.dat.desc=GETSTELMDATA(res,desc);
d749 1
a749 1
    ft->result.dat.desc=GETSTELMDATA(res,desc);
d872 1
a872 1
    SETSTELMDATA(help,desc)=data;			/* set FUNDESC of STELM */
d888 1
a888 1
    SETSTELMDATA(help,desc)=data;			/* set NULL */
d896 10
d908 1
a908 4
    if (tp_list==(tp & tp_list))
      SETSTELMDATA(help,ret)=data;
    else
      yyfail("%s","wrong type for stackelement");
a939 1
    case tp_func:
d942 1
d944 17
d975 2
a976 2
      clos->desc=stelm2[i].dat.clos->desc;
      if (NULL!=clos->desc)			/* clos->desc!=NULL => func */
d992 1
a992 1
    default:
d994 3
a996 2
      if (tp_list!=(stelm2[i].type & tp_list))
        yyfail("%s","no known STELM type");
d999 2
d1023 1
d1038 6
d1045 1
a1045 3
    if (tp_list!=(GETSTELMTYPE(stelm) & tp_list))
      yyfail("%s","illegal stackelement found");
    break;
d1194 1
a1194 1
    d_stelm.dat.desc=NULL;
d1227 1
a1227 1
    d_stelm.dat.desc=NULL;
d1262 1
a1262 1
    d_stelm.dat.desc=NULL;
d1290 1
a1290 1
    d_stelm.dat.desc=NULL;
@


1.21
log
@new macros inserted
@
text
@d15 2
a16 1
const char *prim_type_names[]={"none","int","real","digit","bool","string",NULL};
d103 5
a107 1
      yyfail("%s","unknown type for stelm_output");
d147 53
d316 27
d344 1
d387 1
d395 2
d399 1
d402 1
a402 1
      strcpy(&d_str[strlen(d_str)],long_type_names(GETSTELMTYPE(st_read(w,i))));
d407 1
a407 1
    o=new_order(hash,str);
d413 2
d417 1
d420 1
a420 1
      strcpy(&d_str[strlen(d_str)],long_type_names(GETSTELMTYPE(st_read(t,i))));
d425 1
a425 1
    o=new_order(hash,str);
d429 48
d487 1
d490 1
a490 1
if (hash!=GETORDERENTRY(GETORDERENTRY(o,prev),command)) /* already hashes there !!! */
d492 38
a529 10
  sprintf(str,"#restype %s",long_type_names(GETSTELMTYPE(res))); /* build string */
  if (NULL==(ds=malloc(strlen(str)+1)))		/* get memory for string */
    yyfail("%s","no memory for hash-string!");
  strcpy(ds,str);
  ord=new_order(hash,ds);			/* create hash ORDER */
  insert_order_list(ord,o);
  }
else
  {
  /* viel Arbeit !!! */
d571 1
a571 1
  if (((0==n) || (0==memcmp(a,ft->params,n*sizeof(STELM)))) &&  /* frames match ? */
d606 1
a606 2
void insert_functype(char *name, STACK *a, long n, STACK *t, long nt, 
		     STELM *res)
d662 2
a663 6
    if (tp_none!=ft->result.type)		/* noch viel zu tun !!! */
      {
      DBUG_PRINT("UNIFI",("stored functype changed!"));
      ft->result.type=GETSTELMTYPE(res);
      ft->result.dat.desc=GETSTELMDATA(res,desc);
      }
d799 1
d812 4
a815 1
    yyfail("%s","wrong type for stackelement");
d884 2
a885 1
      yyfail("%s","no known STELM type");
d899 1
a899 1
switch (stelm->type)
d925 3
a927 1
    yyfail("%s","illegal stackelement found");
d1077 3
a1079 1
    SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
d1081 9
d1110 3
a1112 1
    SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
d1114 9
d1145 13
a1157 2
    SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
					tp_none,tp_none); /* internal types */     
d1173 13
a1185 2
    SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tp0),GETSTELMTYPE(tp1),
					tp_none,tp_none); /* internal types */     
@


1.20
log
@mkclos bug removed
@
text
@d34 1
a34 1
    stelm_display(w->stack,w->topofstack);
d37 1
a37 1
    stelm_display(a->stack,a->topofstack);
d40 1
a40 1
    stelm_display(t->stack,t->topofstack);
d43 1
a43 1
    stelm_display(r->stack,r->topofstack);
d78 1
a78 1
      printf(" (%s)",stelm[j].dat.desc->label);
d121 1
a121 1
for (i=0; i<ret->topofstack; i++)
d123 1
a123 1
  if (ord==ret->stack[i].dat.ret->ord)
d128 1
a128 1
  for (i=ret->topofstack-1; i>=0; i--)
d130 1
a130 1
    if JCONDS(GETORDERENTRY(ret->stack[i].dat.ret->ord,command))
d132 2
a133 2
      if (1==GETORDERARGS(ret->stack[i].dat.ret->ord,k))
	DBUG_RETURN(ret->stack[i].dat.ret->ord);
d150 1
a150 1
for (i=ret->topofstack-1; i>=0; i--)
d152 2
a153 2
  if BETAFUNCS(GETORDERENTRY(ret->stack[i].dat.ret->ord,command))
    DBUG_RETURN(&(ret->stack[i]));
d155 1
a155 1
    if (ext==GETORDERENTRY(ret->stack[i].dat.ret->ord,command))	
d173 1
a173 1
while (elm->dat.ret->ord!=ord)
d175 4
a178 4
  st_free(elm->dat.ret->w);
  st_free(elm->dat.ret->a);
  st_free(elm->dat.ret->t);
  st_free(elm->dat.ret->r);
d287 2
a288 1
if ((hash==GETORDERENTRY(ord,command)) && (0==strncmp(GETORDERARGS(ord,hash_str),"#args",5)))
d312 1
a312 1
      strcpy(&d_str[strlen(d_str)],long_type_names(st_read(w,i)->type));
d327 1
a327 1
      strcpy(&d_str[strlen(d_str)],long_type_names(st_read(t,i)->type));
d348 1
a348 1
if (hash!=o->prev->command)			/* already hashes there !!! */
d350 1
a350 1
  sprintf(str,"#restype %s",long_type_names(res->type));/* build string */
d380 2
a381 2
		  (0==n) ? NULL : &(a->stack[a->topofstack-n]), 
		  (0==nt) ? NULL : &(t->stack[t->topofstack-nt]),n,nt);
d385 1
a385 1
DBUG_PRINT("FUNLIST",("<-Result: %d",(NULL==res) ? tp_illegal : res->type));
d444 1
a444 1
		      (NULL==res) ? tp_illegal :res->type));
d459 2
a460 2
ft=searchftypes(flp->funtypes, (NULL==a) ? NULL : &(a->stack[a->topofstack-n]),
		(NULL==t) ? NULL : &(t->stack[t->topofstack-nt]), n, nt);
d471 1
a471 1
    stelm_cpy(ft->params,&(a->stack[a->topofstack-n]),n); /* copy frame */
d479 1
a479 1
    stelm_cpy(ft->tparams,&(t->stack[t->topofstack-nt]),nt); /* copy frame */
d483 2
a484 2
  ft->result.type=res->type;			/* store result */
  ft->result.dat.desc=res->dat.desc;
d487 1
a487 1
			(NULL==res) ? tp_illegal : res->type));
d491 1
a491 1
  if (ft->result.type!=res->type)		/* old restype != newrestype */
d496 2
a497 2
      ft->result.type=res->type;
      ft->result.dat.desc=res->dat.desc;
d560 1
a560 1
ORDER *find_func(FUNCTION *fun, char *s)
d572 1
a572 1
FUNDESC *find_desc(FUNDESC *des, char *label)
d616 1
a616 1
help->type=tp;						/* set type of STELM */
d621 1
a621 1
    help->dat.desc=data;				/* set FUNDESC of STELM */
d626 1
a626 1
    help->dat.clos=data;				/* set CLOSURE of STELM */
d636 1
a636 1
    help->dat.desc=data;				/* set NULL */
d641 1
a641 1
    help->dat.ret=data;
d668 5
a672 5
      stelm1->dat.ret->w=stelm2->dat.ret->w;
      stelm1->dat.ret->a=stelm2->dat.ret->a;
      stelm1->dat.ret->r=stelm2->dat.ret->r;
      stelm1->dat.ret->t=stelm2->dat.ret->t;
      stelm1->dat.ret->ord=stelm2->dat.ret->ord;      
d770 1
a770 1
  for (i=0; i<st->topofstack; i++)
d796 1
a796 1
  if (NULL==(nst->stack=malloc(l*sizeof(STELM))))
d798 3
a800 3
  nst->length=l;					/* store size */
  nst->topofstack=n;
  stelm_cpy(nst->stack,&(st->stack[st->topofstack-n]),n); /* copy STELMs */
d812 2
a813 2
(st->topofstack)--;				/* decrement top of stack pointer */
DBUG_RETURN(&(st->stack[st->topofstack]));
d823 1
a823 1
DBUG_RETURN(&(st->stack[st->topofstack-i-1]));
d837 1
a837 1
  if (NULL==(st->stack=malloc(MIN_STACK_SIZE*sizeof(STELM))))
d839 2
a840 2
  st->length=MIN_STACK_SIZE;				/* set initial size */
  st->topofstack=0;
d844 1
a844 1
  if (st->length==st->topofstack)			/* modify stacklength */
d846 2
a847 1
    if (NULL==(st->stack=realloc(st->stack,4*st->length)))
d849 1
a849 1
    st->length*=4;
d852 3
a854 2
stelm_cpy(&(st->stack[st->topofstack]),vt,1);		/* write STELM to STACK */
st->topofstack++;				/* increment top of stack pointer */
d905 2
a906 1
    SETORDERENTRY(ord,types)=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none); /* internal types */
d918 5
a922 4
    if ((((tp0->type==tp1->type) && 			/* ii, rr, bb, ir ri */
	  (((tp_int==tp0->type) || (tp_real==tp0->type)) || (tp_bool==tp0->type))) ||
	((tp_int==tp0->type) && (tp_real==tp1->type))) ||
	((tp_real==tp0->type) && (tp_int==tp1->type)))
d927 2
a928 1
    SETORDERENTRY(ord,types)=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none); /* internal types */
d939 1
a939 1
    if ((tp_int==tp0->type) && (tp_int==tp1->type))		/* intint */
d943 3
a945 2
      if (((tp_int==tp0->type) || (tp_real==tp0->type)) &&   /* intreal, realint, */
	  ((tp_int==tp1->type) || (tp_real==tp1->type)))     /* realreal */
d951 2
a952 1
    SETORDERENTRY(ord,types)=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none); /* internal types */     
d961 3
a963 2
    if (((tp_int==tp0->type) || (tp_real==tp0->type)) &&   /* intint, realreal  */
	((tp_int==tp1->type) || (tp_real==tp1->type)))     /* intreal, realint, */
d968 2
a969 1
    SETORDERENTRY(ord,types)=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none); /* internal types */     
@


1.19
log
@now using macros
@
text
@d27 1
a27 1
void stack_display(STACK *w, STACK *a, STACK *t, STACK *r)
d41 1
d90 1
a90 1
        printf(" (closure[");
d92 2
@


1.18
log
@jcond2, rtm, mkcclos implemented
@
text
@d127 1
a127 1
    if JCONDS(ret->stack[i].dat.ret->ord->command)
d129 1
a129 1
      if (1==ret->stack[i].dat.ret->ord->args.k)
d149 1
a149 1
  if BETAFUNCS(ret->stack[i].dat.ret->ord->command)
d152 2
a153 2
    if (ext==ret->stack[i].dat.ret->ord->command)	/* end of dump execution */
      df=1;
d237 1
a237 1
  if (froot->address==(int)adr)			/* function found */
d240 1
a240 1
    froot=froot->next;
d242 1
a242 1
data=program_start->data;			/* first DATANODE */
d245 1
a245 1
  if (data->address==(int)adr)			/* dataadress found */
d247 1
a247 1
    switch (data->tag)
d272 1
a272 1
    data=data->next;
d277 4
d284 1
a284 1
if ((hash==ord->command) && (0==strncmp(ord->args.hash_str,"#args",5)))
d524 2
a525 2
if ((hash==ord->command) &&				/* checks for hash */ 
    (NULL!=(s=check_restype(ord->args.hash_str))))	/* checks for restype */
d559 3
a561 3
while ((NULL!=fun) && (0!=strcmp(s,fun->name)))
  fun=fun->next;
DBUG_RETURN(fun->order);
d575 1
a575 1
  if (0==strcmp(label, des->label))		/* function names match */
d578 1
a578 1
    des=des->next;
d594 1
a594 1
  if ((label==ord->command) && (0==strcmp(s,ord->args.label)))
d596 1
a596 1
  ord=ord->next;
d899 1
a899 1
    ord->types=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none); /* internal types */
d919 1
a919 1
    ord->types=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none); /* internal types */
d941 1
a941 1
    ord->types=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none); /* internal types */     
d956 1
a956 1
    ord->types=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none); /* internal types */     
@


1.17
log
@gammabeta corrected
@
text
@d127 1
a127 2
    if ((jcond==ret->stack[i].dat.ret->ord->command) ||
	(jfalse==ret->stack[i].dat.ret->ord->command))
d234 1
a234 1
froot=program_start->desc;			/* start with FUNDESCs */
@


1.16
log
@indefi. jcond recognition inserted, minor bug removed
@
text
@d692 9
a700 4
	if (NULL==(clos->t=malloc(stelm2[i].dat.clos->k*sizeof(STELM))))
	  yyfail("%s","no memory for new closure");
        stelm_cpy(clos->t,stelm2[i].dat.clos->t,
		  stelm2[i].dat.clos->k);	/* copy T frame */
@


1.15
log
@*** empty log message ***
@
text
@a131 2
      else
	ret->stack[i].dat.ret->ord->args.k=0;	
@


1.14
log
@minor change
@
text
@d15 6
a20 6
char *prim_type_names[]={"none","int","real","digit","bool","string",NULL};
char *s_prim_type_names[]={"?","i","r","d","b","s"};
char *ext_type_names[]={"scalar","list","vect","tvect","matrix",NULL};
char *s_ext_type_names[]={NULL,"l","v","t","m"};
char *other_type_names[]={"prim","clos","func",NULL};
char *s_other_type_names[]={"p","c","f"};
d24 2
a25 2
/* displays stacks							*/
/* (used by exe_func)							*/
d27 1
a27 1
void stack_display(STACK *w, STACK *a, STACK *t)
d30 1
a30 1
if (_db_keyword_("STACKS"))
d32 1
a32 1
  printf("w:\t");
d41 2
d49 2
a50 2
/* displays array of STELM						*/
/* (used by exe_func)							*/
d57 1
a57 1
for (j=0; j<i; j++)
a60 1
    case tp_badlocrec:
a61 1
    case tp_doagain:
a62 1
    case tp_data:
a81 1
      printf("*** %d ***\n",stelm[j].dat.prim);
d87 1
a87 1
      if (_db_keyword_("CLOSURE"))
d107 3
a109 2
/* returns pointer of short-type-string					*/
/* (used)								*/
d111 1
a111 1
char *short_type_names(TP_TYPES type)
d113 76
d190 1
a190 1
if ((0<=type) && (OTHER_MASK>type))
d197 2
a198 2
else
  if (0>type)
d200 1
a200 1
  else
d206 1
a206 2
/* returns pointer of type-string					*/
/* (used)								*/
d208 1
a208 1
char *long_type_names(TP_TYPES type)
d211 1
a211 1
if ((0<=type) && (OTHER_MASK>type))
d218 2
a219 2
else
  if (0>type)
d221 1
a221 1
  else
d228 1
a228 1
/* (used by exe_func)							*/
d237 1
a237 1
froot=program_start->desc;
d240 2
a241 2
  if (froot->address==(int)adr)
    res=new_stelm(tp_func,froot);
d245 1
a245 1
data=program_start->data;
d248 1
a248 1
  if (data->address==(int)adr)
a251 2
      case d_list:
	break;
d257 2
d280 54
a335 1
/* (used by exe_func)							*/
d343 1
a343 1
if (hash!=o->prev->command)
d345 2
a346 2
  sprintf(str,"#restype %s",long_type_names(res->type));
  if (NULL==(ds=malloc(strlen(str)+1)))
d349 1
a349 2
  DBUG_PRINT("ORDERS",("%s",ds));
  ord=new_order(hash,ds);
d360 2
a361 3
/* searches for functionresult in functionresultlist and returns type	*/
/* of function.								*/
/* (used by exe_func)							*/
d365 1
a365 1
STELM *res=NULL;
d372 1
a372 1
if (NULL!=flp)
d377 2
a378 2
  if (NULL!=ft)
    res=&(ft->result);
d385 2
a386 3
/* searches for function in functionlist and returns pointer of		*/
/* function.								*/
/* (used by exe_func)							*/
d396 1
a396 1
  if (((0==n) || (0==memcmp(a,ft->params,n*sizeof(STELM)))) && 
d407 2
a408 3
/* searches for function in functionlist and returns pointer of		*/
/* function.								*/
/* (used by exe_func)							*/
d419 1
a419 1
  if (0==strcmp(root->name,name))
d429 1
a429 2
/* checks and inserts new/old functiontype in FUNLIST			*/
/* (used by exe_func)							*/
d432 1
a432 1
		     STELM *res, char kn)
d440 2
a441 2
flp=searchfunlist(name);
if (NULL==flp)
d447 3
a449 3
  strcpy(flp->name,name);
  flp->a=n;
  flp->t=nt;
d452 1
a452 1
  flp->funtypes=NULL;
d456 1
a456 1
if (NULL==ft)
d460 1
a460 1
  ft->next=flp->funtypes;
d462 1
a462 1
  if (0<n)
d466 1
a466 1
    stelm_cpy(ft->params,&(a->stack[a->topofstack-n]),n);
d468 1
a468 1
  else
d470 1
a470 1
  if (0<nt)
d474 1
a474 1
    stelm_cpy(ft->tparams,&(t->stack[t->topofstack-nt]),nt);
d476 1
a476 1
  else
d478 1
a478 1
  ft->result.type=res->type;
d480 1
a480 1
  ft->knowledge=kn;
d484 1
a484 1
else						/* searchfuntype anpassen */
d486 1
a486 22
  if (ft->result.type==res->type)			/* reassign knowledge */
    {
    switch (kn)
      {
      case kn_sure:
	{
	ft->knowledge=kn_sure;
	break;
	}
      case kn_partial:
	{
	if (kn_preset==ft->knowledge)
	  ft->knowledge=kn_partial;
        break;
	}
      case kn_preset:
	{
	break;
	}
      }
    }
  else					/* old restype != newrestype */
d488 1
a488 1
    if (tp_none!=ft->result.type)
a492 1
      ft->knowledge=kn;
d500 2
a501 2
/* checks for "#restype " and return position behind it			*/
/* (used by gethash_restype)						*/
d506 1
a506 1
if (0==strncmp(s,"#restype ",9))
d509 1
a509 1
  s=NULL;
d514 2
a515 2
/* if exists returns restype of function drawn from hash		*/
/* (used by execution)							*/
d523 2
a524 1
if ((hash==ord->command) && (NULL!=(s=check_restype(ord->args.hash_str))))
d527 1
a527 1
  while (NULL!=prim_type_names[i])
d534 1
a534 1
  while (NULL!=ext_type_names[i])
d541 1
a541 1
  while (NULL!=other_type_names[i])
d552 2
a553 2
/* returns first order of function s					*/
/* (used by execution)							*/
d564 2
a565 3
/* searches for function in functiondescriptorlist and returns pointer	*/
/* functiondescriptor.							*/
/* (used by exe_func)							*/
d574 1
a574 1
  if (0==strcmp(label, des->label))
d583 2
a584 2
/* searches for functionlabel in given orderlist			*/
/* (used by exe_func)							*/
d602 1
a602 1
/* (used by exe_func)							*/
d609 1
a609 1
if (NULL==(help=malloc(sizeof(STELM))))
d611 1
a611 1
help->type=tp;
d616 1
a616 1
    help->dat.desc=data;
d621 1
a621 1
    help->dat.clos=data;
a623 1
  case tp_badlocrec:
a624 1
  case tp_doagain:
d631 1
a631 1
    help->dat.desc=data;
d634 1
a634 1
  case tp_data:
d636 1
a636 1
    help->dat.data=data;
a649 1
/* (used by st_make, exe_func)						*/
d661 10
a670 1
    case tp_none:
a675 1
    case tp_data:
d677 1
a677 1
    case tp_clos:
d683 1
a683 1
      stelm1[i].dat.clos=clos;
d686 2
a687 1
      stelm_cpy(clos->w,stelm2[i].dat.clos->w,stelm2[i].dat.clos->i);
d692 1
a692 1
      if (NULL!=clos->desc)
d696 2
a697 1
        stelm_cpy(clos->t,stelm2[i].dat.clos->t,stelm2[i].dat.clos->k);
d699 1
a699 1
      else
d714 1
a714 2
/* frees stackelements with all possible structures			*/
/* (used by exe_func)							*/
d721 1
a721 1
  case tp_none:
a726 1
  case tp_doagain:
a727 1
  case tp_badlocrec:
d729 1
d731 1
a731 1
  case tp_clos:
a744 1
    {
a745 2
    break;
    }
a751 1
/* (used by exe_func)							*/
d758 1
a758 1
if (NULL!=st)
d761 2
a762 2
    stelm_free(&(st->stack[i]));
  free(st->stack);
d770 2
a771 2
/* builds a stack with the first n elements of st copied into it	*/
/* (used by exe_func)							*/
d779 1
a779 1
if (0!=n)
d783 2
a784 2
  l=MIN_STACK_SIZE;
  while (l<=n)
d788 1
a788 1
  nst->length=l;
d790 1
a790 1
  stelm_cpy(nst->stack,&(st->stack[st->topofstack-n]),n);
d796 2
a797 2
/* pops type to elemet top of stack					*/
/* (used by exe_func)							*/
d802 1
a802 1
(st->topofstack)--;
d807 2
a808 2
/* reads type to stack element number i					*/
/* (used by exe_func)							*/
a812 1
DBUG_ASSERT(i>=0,"stackread assertion failed");
d817 2
a818 2
/* writes type to stack							*/
/* (used by exe_func)							*/
d823 1
a823 1
if (NULL==st)
d829 1
a829 1
  st->length=MIN_STACK_SIZE;
d832 1
a832 1
else
d834 1
a834 1
  if (st->length==st->topofstack)
d841 2
a842 2
stelm_cpy(&(st->stack[st->topofstack]),vt,1);
st->topofstack++;
d846 4
a849 4
/***********************************************************************/
/* converts hexadecimal number placed in a string into intege          */
/* (used by out_tree()).                                               */
/***********************************************************************/
d856 5
a860 4
while(*s) {
n = n*16 + (isdigit(*s) ? *s-'0' : toupper(*s)-'A'+10);
s++;
}
d864 4
a867 4
/***********************************************************************/
/* searches for underscore and returns string                          */
/* (used by out_tree()).                                               */
/***********************************************************************/
d878 1
a878 2
/* executes primitiv function                          			*/
/* (used by exe_func()).                                                */
d889 1
a889 1
    tp0=st_pop(w);
d891 1
a891 1
    d_stelm.type=tp_bool;
d893 3
a895 3
    ord->types=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none);
    w=st_push(w,&d_stelm);
    insert_restype(&d_stelm,ord);
d903 1
a903 1
    tp0=st_pop(w);
d913 3
a915 3
    ord->types=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none);
    w=st_push(w,&d_stelm);
    insert_restype(&d_stelm,ord);
d932 1
a932 1
        d_stelm.type=tp_none;				     /* for the rest */
d935 3
a937 3
    ord->types=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none);      
    w=st_push(w,&d_stelm);
    insert_restype(&d_stelm,ord);
d948 1
a948 1
      d_stelm.type=tp_none;				     /* for the rest */
d950 3
a952 3
    ord->types=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none);      
    w=st_push(w,&d_stelm);
    insert_restype(&d_stelm,ord);
@


1.13
log
@first changes for type conflicts
@
text
@d15 6
d840 15
@


1.12
log
@internal types changed
@
text
@d18 23
d65 1
d77 1
a92 1
    case tp_real:
a94 1
      {
a95 2
      break;
      }
d220 4
d266 2
a267 1
  if (((0==n) || (0==memcmp(a,ft->params,n))) && ((0==nt) || (0==memcmp(t,ft->tparams,nt))))
@


1.11
log
@types changed
@
text
@d353 1
a353 1
  else
d355 1
a355 5
    if (kn_preset!=ft->knowledge)    /* old restype != newrestype */
      {
      /* nach was zu tun !!! */
      }
    else
d357 4
a360 1
      fprintf(stderr,"warning: type conflict with preset type!\n");
a762 7
    if ((apply!=ord->command) && (apply_c!=ord->command))
      {
      if (p_eq==ord->args.primf)
        ord->command=eq;
      else
        ord->command=ne;
      }
d773 1
a773 1
    if ((((tp0->type==tp1->type) && 
a776 1
      {
a777 25
      d_stelm.dat.desc=NULL;
      ord->types=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none);
      w=st_push(w,&d_stelm);
      if ((apply!=ord->command) && (apply_c!=ord->command))
	{
	switch (ord->args.primf)
	  {
	  case p_ge:
	    ord->command=ge;
	    break;
	  case p_gt:
	    ord->command=gt;
	    break;
	  case p_le:
	    ord->command=le;
	    break;
	  case p_lt:
	    ord->command=lt;
	    break;
	  default:					/* not reachable */
	    break;
	  }
	}
      insert_restype(&d_stelm,ord);
      }
d779 5
a783 4
      {
      fprintf(stderr,"le//lt//ge//gt can't handle types of arguments\n");
      exit(0);
      }
d792 1
a792 2
    if ((tp_int==tp0->type) && (tp_int==tp1->type))
      {
a793 22
      d_stelm.dat.desc=NULL;
      ord->types=TYPES2LONG(tp0->type,tp1->type,tp_none,tp_none);      
      w=st_push(w,&d_stelm);
      if ((apply!=ord->command) && (apply_c!=ord->command))
	{
	switch (ord->args.primf)
	  {
	  case p_minus:
	    ord->command=minus;
	    break;
	  case p_plus:
	    ord->command=add;
	    break;
	  case p_mult:
	    ord->command=mult;
	    break;
	  default:
	    break;
	  }
	}
      insert_restype(&d_stelm,ord);
      }
d796 5
a800 2
      fprintf(stderr,"minus//add//mult can't handle type != int!\n");
      exit(0);
d802 4
d809 1
a809 4
    {
    fprintf(stderr,"unkown primitiv function!\n");
    exit(0);
    }
@


1.10
log
@plus_ii -> add_ii and working on real
@
text
@d43 1
a43 1
      printf(" (%s)",type_names[stelm[j].type]);
d82 44
a164 2
	{
        res=new_stelm(tp_string,NULL);
a165 1
	}
d191 1
a191 1
  sprintf(str,"#restype %s",type_names[res->type]);
d394 21
a414 3
  for (i=1; i<=tps_number; i++)
    if (0==strcmp(s, type_names[i]))
	DBUG_RETURN(new_stelm(i,NULL));
d751 1
a751 1
STELM d_stelm,*tp0,*tp1 /* ,*tp2,*tp3 */;
d755 19
a777 2
  case p_eq:
  case p_ne:
d788 1
d795 1
a795 1
	    ord->command=ge_ii;
d798 1
a798 1
	    ord->command=gt_ii;
d801 1
a801 1
	    ord->command=le_ii;
d804 1
a804 4
	    ord->command=lt_ii;
	    break;
	  case p_eq:
	    ord->command=eq_ii;
a805 3
	  case p_ne:
	    ord->command=ne_ii;
	    break;
d814 1
a814 1
      fprintf(stderr,"le//lt//ge//gt//ne//eq can't handle types of arguments\n");
a816 2
    stelm_free(tp0);
    stelm_free(tp1);
d829 1
d836 1
a836 1
	    ord->command=minus_ii;
d839 1
a839 1
	    ord->command=add_ii;
d842 1
a842 1
	    ord->command=mult_ii;
a854 2
    stelm_free(tp0);
    stelm_free(tp1);
d863 1
a863 1
}@


1.9
log
@minor bug removed
@
text
@d16 1
d79 1
d289 1
a289 1
else						/* searchfuntype anpassen !!! */
d439 1
d479 2
d534 1
d705 4
a708 1
    if ((tp_int==tp0->type) && (tp_int==tp1->type))
d743 1
a743 1
      fprintf(stderr,"le//lt//ge//gt//ne//eq can't handle type != int!\n");
d769 1
a769 1
	    ord->command=plus_ii;
d782 1
a782 1
      fprintf(stderr,"minus//plus//mult can't handle type != int!\n");
@


1.8
log
@stack handling with closures debugged
@
text
@d679 108
@


1.7
log
@*** empty log message ***
@
text
@d14 1
d17 63
d269 1
a269 1
    memcpy(ft->params,&(a->stack[a->topofstack-n]),n*sizeof(STELM));
d277 1
a277 1
    memcpy(ft->tparams,&(t->stack[t->topofstack-nt]),nt*sizeof(STELM));
d287 1
a287 1
else
d314 1
a314 1
      /* to be continued */
d458 95
d558 2
d563 2
d593 1
a593 1
  memcpy(nst->stack,&(st->stack[st->topofstack-n]),n*sizeof(STELM));
d616 1
a616 1
/* DBUG_ASSERT(i>=0,"stackread assertion failed"); */
d645 1
a645 1
memcpy(&(st->stack[st->topofstack]),vt,sizeof(STELM));
@


1.6
log
@minor change in st_free
@
text
@d404 1
@


1.5
log
@st_free added
@
text
@d400 5
a404 2
free(st->stack);
free(st);
@


1.4
log
@some functions moved from tis
@
text
@d394 12
@


1.3
log
@tp_data inserted
@
text
@d3 1
d7 1
d9 1
d13 281
d368 1
@


1.2
log
@minor bugs removed
@
text
@d94 5
d152 1
@


1.1
log
@Initial revision
@
text
@d64 1
a64 1
STELM *new_stelm(TP_TYPES tp, FUNDESC *fun)
d72 28
a99 1
help->desc=fun; 
@
