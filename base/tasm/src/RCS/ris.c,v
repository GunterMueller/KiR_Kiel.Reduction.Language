head	1.36;
access;
symbols;
locks; strict;
comment	@ * @;


1.36
date	96.02.23.14.10.32;	author rs;	state Exp;
branches;
next	1.35;

1.35
date	96.02.22.16.53.22;	author stt;	state Exp;
branches;
next	1.34;

1.34
date	96.02.21.15.48.44;	author car;	state Exp;
branches;
next	1.33;

1.33
date	96.02.13.16.25.00;	author stt;	state Exp;
branches;
next	1.32;

1.32
date	96.01.16.19.51.01;	author car;	state Exp;
branches;
next	1.31;

1.31
date	95.08.15.10.00.34;	author car;	state Exp;
branches;
next	1.30;

1.30
date	95.08.10.12.06.53;	author car;	state Exp;
branches;
next	1.29;

1.29
date	95.07.07.08.21.20;	author car;	state Exp;
branches;
next	1.28;

1.28
date	95.06.15.11.29.51;	author car;	state Exp;
branches;
next	1.27;

1.27
date	95.06.14.15.17.30;	author car;	state Exp;
branches;
next	1.26;

1.26
date	95.06.02.13.36.03;	author car;	state Exp;
branches;
next	1.25;

1.25
date	95.05.18.09.47.16;	author car;	state Exp;
branches;
next	1.24;

1.24
date	95.05.18.09.46.17;	author car;	state Exp;
branches;
next	1.23;

1.23
date	95.05.17.17.26.24;	author car;	state Exp;
branches;
next	1.22;

1.22
date	95.05.10.12.19.40;	author car;	state Exp;
branches;
next	1.21;

1.21
date	95.05.10.06.59.08;	author car;	state Exp;
branches;
next	1.20;

1.20
date	95.05.09.14.49.33;	author car;	state Exp;
branches;
next	1.19;

1.19
date	95.04.21.16.35.31;	author car;	state Exp;
branches;
next	1.18;

1.18
date	95.04.21.11.15.50;	author car;	state Exp;
branches;
next	1.17;

1.17
date	95.04.19.14.45.08;	author car;	state Exp;
branches;
next	1.16;

1.16
date	95.04.13.15.33.51;	author car;	state Exp;
branches;
next	1.15;

1.15
date	95.04.06.09.51.57;	author car;	state Exp;
branches;
next	1.14;

1.14
date	95.04.04.07.26.00;	author car;	state Exp;
branches;
next	1.13;

1.13
date	95.04.03.16.22.25;	author car;	state Exp;
branches;
next	1.12;

1.12
date	95.04.03.15.14.05;	author car;	state Exp;
branches;
next	1.11;

1.11
date	95.03.21.15.19.26;	author car;	state Exp;
branches;
next	1.10;

1.10
date	95.03.08.17.23.38;	author car;	state Exp;
branches;
next	1.9;

1.9
date	95.02.15.18.26.22;	author car;	state Exp;
branches;
next	1.8;

1.8
date	95.02.10.17.21.38;	author car;	state Exp;
branches;
next	1.7;

1.7
date	95.02.10.17.16.00;	author car;	state Exp;
branches;
next	1.6;

1.6
date	95.02.03.07.41.06;	author car;	state Exp;
branches;
next	1.5;

1.5
date	95.01.31.12.28.54;	author car;	state Exp;
branches;
next	1.4;

1.4
date	95.01.04.13.01.59;	author car;	state Exp;
branches;
next	1.3;

1.3
date	94.12.27.14.46.23;	author car;	state Exp;
branches;
next	1.2;

1.2
date	94.12.19.15.18.26;	author car;	state Exp;
branches;
next	1.1;

1.1
date	94.11.21.07.51.39;	author car;	state Exp;
branches;
next	;


desc
@initial incomplete version
@


1.36
log
@new (t)ASM commands: count(x), msdistend, msnodist
@
text
@#include <stdio.h>
#include <string.h>
#include "ris.h"
#include "main.h"
#include "mytypes.h"
#include "buildtree.h"
#include "support.h"
#include "tiny.h"
#include "heap.h"
#include "stack.h"
#include "error.h"
#include "dbug.h"

char * vris = VRIS;
static setrefmode refmode;
/* refinserted mechanism (only used for PM):
 *   after leaving the match code the reference counts of any
 *   freshly bound variables are NOT modified. The internal increment
 *   counter is set to 1 (unless shared). During execution of the
 *   guard increment instruction may be issued which also include
 *   the above modification. If the guard fails the modification
 *   has to be undone, because there is only _one_ destination
 *   for a failed clause.
 * The approach taken here is the following:
 *   if ref-count instructions are to be issued for guard code
 *   the modification is offset by 1 (for the bind).
 * refinserted is set to -1 if no PM is done (or the guard is surely left);
 *   0 if in PM code (perhaps in guard), and 1 if a instruction
 *   has already been issued in guard (this cause a complete syncronisation
 *   at the tguard instruction with the above offset)
 */
static int refinserted;

astack(W); astack(A); astack(R); astack(T); astack(H); astack(H1); astack (H2);

#ifndef DBUG_OFF

/* prstack: prints a stack in decoded form to stderr
 */

static void prstack(const char * str, argstack(S), const int m)
  {
  int i, j = 0;
  desc * p;

  fprintf(stderr, "%s: ", str);
  for(i = 0; peek(S, i) != BOTTOM; i++)
    if (m && (j == 0)) {
      j = peek(S, i);
      fprintf(stderr, "#%d ", j);
      }
    else if (peek(S, i) < lastcmd) {
      if (strcmp(str, "H") == 0)
        switch((doneid)peek(S, i)) {
          case FSYNC: fprintf(stderr, "FS "); break;
          case SYNC: fprintf(stderr, "S "); break;
          case SYNCMERGE: fprintf(stderr, "SM "); break;
          case FSYNCMERGE: fprintf(stderr, "FSM "); break;
          case NOOP: fprintf(stderr, "N "); break;
          case CSYNC: fprintf(stderr, "CS "); break;
          case CSYNCMERGE: fprintf(stderr, "CSM "); break;
          default: fprintf(stderr, "**%d** ", peek(S, i));
          }
      else
        fprintf(stderr, "%d ", peek(S, i));
      j--;
      }
    else {
      p = (desc *)peek(S, i);
      j--;
      fprintf(stderr, "%p(%c%c%d) ", p,
        (rnode(p,type) == TYshared ? 's' : '-'),
        (rnode(p,mode) == CLnoref ? 'n' : rnode(p,mode) == CLref ? 'r' : 't'),
        rnode(p, refcnt));
      }
  fprintf(stderr, "\n");
  }

#endif /* DBUG_OFF */

/* risk determines if a decrement operation may be moved over
 * the corresponding instruction
 * THIS IS A POSITIVE INDEX, OTHER ENTRIES ARE DANGEROUS!
 */
static int norisk[lastcmd];
static int isterm[lastcmd];

void initnorisk()
  {
  norisk[delta1] = 1; norisk[delta2] = 1; norisk[delta3] = 1; norisk[delta4] = 1;
  norisk[freea] = 1; norisk[freer] = 1; norisk[freeswt] = 1; norisk[freet] = 1;
  norisk[freew] = 1; norisk[label] = 1; norisk[mkap] = 1; norisk[mkbclos] = 1;
  norisk[mkcclos] = 1; norisk[mkdclos] = 1; norisk[mkgaclos] = 1; norisk[mkgclos] = 1;
  norisk[mkgsclos] = 1; norisk[mkilist] = 1; norisk[mklist] = 1; norisk[mksclos] = 1;
  norisk[mkiclos] = 1; norisk[intact] = 1;
  norisk[movear] = 1; norisk[moveaw] = 1; norisk[movetr] = 1; norisk[movetw] = 1;
  norisk[pushar] = 1; norisk[pushaw] = 1; norisk[pushr] = 1; norisk[pushr_p] = 1;
  norisk[pushtr] = 1; norisk[pushtw] = 1; norisk[pushw] = 1; norisk[pushcw_pf] = 1;
  norisk[pushw_p] = 1; norisk[pushcw_i] = 1; norisk[pushcw_b] = 1; norisk[pushcr_i] = 1;
  norisk[pushcr_b] = 1; norisk[pushcw_r] = 1; norisk[pushaux] = 1; norisk[pushh] = 1;
  norisk[pushret] = 1; norisk[incw] = 1; norisk[inca] = 1; norisk[incr] = 1;
  norisk[inct] = 1; norisk[tincw] = 1; norisk[tinca] = 1; norisk[tincr] = 1;
  norisk[tinct] = 1; norisk[decw] = 1; norisk[deca] = 1; norisk[decr] = 1;
  norisk[dect] = 1; norisk[tdecw] = 1; norisk[tdeca] = 1; norisk[tdecr] = 1;
  norisk[tdect] = 1; norisk[killw] = 1; norisk[killa] = 1; norisk[killr] = 1;
  norisk[killt] = 1; norisk[tkillw] = 1; norisk[tkilla] = 1; norisk[tkillr] = 1;
  norisk[tkillt] = 1; norisk[hashargs] = 1; norisk[hashtildeargs] = 1;
  norisk[hashrestype] = 1; norisk[hashsetref] = 1; norisk[advance] = 1;
  norisk[bind] = 1; norisk[binds] = 1; norisk[bindsubl] = 1; norisk[dereference] = 1;
  norisk[drop] = 1; norisk[endlist] = 1; norisk[endsubl] = 1; norisk[fetch] = 1;
  norisk[initbt] = 1; norisk[mkcase] = 1; norisk[mkwframe] = 1;
  norisk[nestlist] = 1; norisk[pick] = 1; norisk[restorebt] = 1; norisk[restoreptr] = 1;
  norisk[rmbtframe] = 1; norisk[rmwframe] = 1; norisk[savebt] = 1;
  norisk[saveptr] = 1; norisk[startsubl] = 1;

  isterm[rtc] = 1; isterm[rtc_b] = 1; isterm[rtc_i] = 1; isterm[rtc_pf] = 1;
  isterm[i_rtc_b] = 1; isterm[i_rtc_i] = 1; isterm[i_rtf] = 1; isterm[i_rtt] = 1;
  isterm[i_rtp] = 1; isterm[i_rtm] = 1; isterm[i_rtm] = 1; isterm[i_rtc_pf] = 1;
  isterm[rtf] = 1; isterm[rtm] = 1; isterm[rtm_t] = 1; isterm[rtp] = 1;
  isterm[rtt] = 1; isterm[end] = 1; isterm[tguard] = 1;
  }

/* test if instruction is in guard of PM
 * e.g. is followed by a tguard instruction instead of an rtf or end
 */

static int testguard(ORDER * cmd)
  {
  while(isterm[GETORDERENTRY(cmd, command)] == 0)
    cmd = GETNEXTORDER(cmd);
  return GETORDERENTRY(cmd, command) == tguard;
  }
    
/* insert an increment refcount instruction before intruction p,
 * stack may be defined on invocation
 */
static void mkinc(ORDER * cmd, desc * p, const stackid stid, const int off)
  {
  int i;
  COMMAND cmdid;

  DBUG_ENTER("mkinc");
  if ((int)p < lastcmd)
    DBUG_VOID_RETURN;
  DBUG_PRINT("REF", ("INC: refcnt=%d", rnode(p, refcnt)));
  /* test if ref-count operation is done in guard of PM
   */
  if ((refinserted == 1) || ((refinserted == 0) && testguard(cmd))) {
    for(i = 0; i < top(A); i++)
      if (peek(A, i+1) > lastcmd)
        lnode((desc *)peek(A, i+1), refcnt)--;
    refinserted = 1;
    DBUG_PRINT("RIS", ("trying reduced INC*"));
    }
  if ((rnode(p, refcnt) > 0) && (rnode(p, mode) != CLnoref)) {
    DBUG_PRINT("REF", ("INC: refcnt=%d", rnode(p, refcnt)));
    if (rnode(p, prev))
      /* update previous increment operation */
      GETORDERARGS(rnode(p, prev),m) += rnode(p, refcnt);
    else {
      switch(stid) {
        case ST_A: if (rnode(p, mode) == CLref) cmdid = inca; else cmdid = tinca;
          break;
        case ST_R: if (rnode(p, mode) == CLref) cmdid = incr; else cmdid = tincr;
          break;
        case ST_T: if (rnode(p, mode) == CLref) cmdid = inct; else cmdid = tinct;
          break;
        case ST_W: if (rnode(p, mode) == CLref) cmdid = incw; else cmdid = tincw;
          break;
        default:
          yyfail("internal error: illegal stack");
        }
      insert_order_list(rnode(p, prev) = new_order(cmdid, off, rnode(p, refcnt)), cmd);
      DBUG_PRINT("RIS", ("INC* inserted"));
      }
    lnode(p, type) = TYshared;
    lnode(p, refcnt) = 0;
    if (refinserted == 1)
      for(i = 0; i < top(A); i++)
        if (peek(A, i+1) > lastcmd)
          lnode((desc *)peek(A, i+1), refcnt)++;
    }
  else
    lnode(p, refcnt) = 0;
  DBUG_VOID_RETURN;
  }

/* insert an decrement refcount instruction before intruction p,
 * stack may be defined on invocation
 */
static void mkdec(ORDER * cmd, desc * p, const stackid stid, const int off)
  {
  int f = 0;
  ORDER * pc;
  COMMAND cmdid;

  DBUG_ENTER("mkdec");
  if ((int)p < lastcmd)
    DBUG_VOID_RETURN;
  DBUG_PRINT("REF", ("DEC: refcnt=%d", rnode(p, refcnt)));
  if ((rnode(p, refcnt) == 0) && (rnode(p, mode) != CLnoref))
    { 
    if (rnode(p, prev))
      for(pc = cmd, f = 1; pc && (pc != rnode(p, prev)); pc = GETPREVORDER(pc))
        f &= norisk[GETORDERENTRY(pc, command)];
    if (f && (GETORDERARGS(rnode(p, prev),m) > 1))
      GETORDERARGS(rnode(p, prev),m)--;
    else {
      switch(stid) {
        case ST_A: if (rnode(p, mode) == CLref) cmdid = deca; else cmdid = tdeca;
          break;
        case ST_R: if (rnode(p, mode) == CLref) cmdid = decr; else cmdid = tdecr;
          break;
        case ST_T: if (rnode(p, mode) == CLref) cmdid = dect; else cmdid = tdect;
          break;
        case ST_W: if (rnode(p, mode) == CLref) cmdid = decw; else cmdid = tdecw;
          break;
        default:
          yyfail("internal error: illegal stack");
        }
      insert_order_list(new_order(cmdid, off), cmd);
      lnode(p, refcnt) = 0;
      DBUG_PRINT("RIS", ("DEC* inserted"));
      }
    }
  else
    rnode(p, refcnt) -= 1;
  DBUG_PRINT("REF", ("DEC: refcnt=%d", rnode(p, refcnt)));
  DBUG_VOID_RETURN;
  }

/* converts an external type into CLref/CLnoref/CLtest
 */

static typeclass convtype(const TP_TYPES t)
  {
  switch(t & EXT_MASK) {
    case 0: switch(t & PRIM_MASK) {
      case tp_int:
      case tp_bool: return CLnoref;
      case tp_real:
      case tp_digit:
      case tp_string: return CLref;
      }
      break;
    case tp_list:
    case tp_vect:
    case tp_tvect:
    case tp_matrix: return CLref;
    }
  return CLtest;
  }

/* copy argument frame 
 * mode :
 *   if 0 then top of stack is frame size, and top element is just duplicated
 *   otherwise size is determined by (null) or (bottom) element in stack
 * make copies of all members in frame
 * if mode==0 then copy all references afterwards
 */
static stack * cpframe(argstack(S), int m)
  {
  int i, j, n, h = 0;
  desc * p, * q;

  DBUG_ENTER("cpframe");
  if (m == 0)
    n = top(S);
  else {
    push(S, (stack)NULL);
    for(n = 1; ((peek(S, n) != BOTTOM) && (peek(S, n) != 0)); n++);
    n--;
    }
  DBUG_PRINT("RISAUX", ("cpframe size %d", n));
  for(i = 0; i < n;  i++) {
    p = (desc *)peek(S, n); q = NULL;
    if ((int)p < lastcmd)
      push(S, (stack)p);
    else {
      for(j = 0; peek(H1, j) != BOTTOM; j++)
        if ((desc *)peek(H1, j) == p)
          q = (desc *)peek(H2, j);
      if (q)
        push(S, (stack)q);
      else {
        push(S, (stack)ndesc(rnode(p, type), rnode(p, refcnt), rnode(p, mode)));
        push(H1, (stack)p); push(H2, top(S)); h++;
        lnode(p, prev) = NULL;
        }
      }
    }
  push(S, (m ? 0 : n));
  for(i = 0; i < n;  i++) {
    p = (desc *)peek(S, 2*n+1);
    push(S, (stack)p);
    }
  if (m == 0)
    push(S, n);
  drop(H1, h), drop(H2, h);
  DBUG_RETURN(getstack(S));
  }

/* restore argument frame from copy after completing
 * one alternative of conditional
 */
static stack * restoreframe(argstack(S), int m)
  {
  int i, n;
  desc * p, * q;

  DBUG_ENTER("restoreframe");
  if (m)
    for(n = 0; peek(S, n) != 0; n++) ;
  else
    n = pop(S);
  for(i = 0; i < n;  i++) {
    p = (desc *)pop(S);
    q = (desc *)peek(S, n);
    DBUG_PRINT("RISAUX", ("%d/%d p=%p, q=%p", i, n, p, q));
    if (((int)p > lastcmd) && ((int)q > lastcmd)) {
      lnode(q, type) = rnode(p, type);
      lnode(q, refcnt) = rnode(p, refcnt);
      lnode(q, mode) = rnode(p, mode);
      lnode(q, prev) = NULL;
      }
    }
  if (m)
    drop(S, 1);
  DBUG_RETURN(getstack(S));
  }

/* cmpres: compares the types of the both topmost
 * stack entries and replaces them by a element
 * created with the least specific entries.
 */
static stack * cmpres(argstack(S))
  {
  desc * p, * q;

  DBUG_ENTER("cmpres");
  p = (desc *)pop(S); q = (desc *)pop(S);
  if (rnode(p, refcnt) && rnode(q, refcnt))
    yywarn("INTERNAL ERROR: reference count not zero");
  push(S, (stack)ndesc(
      ((rnode(p, type) == TYdetructive) && (rnode(q, type) == TYdetructive) ?
          TYdetructive : TYshared),
      0,
      ((rnode(p, mode) == CLref) && (rnode(q, mode) == CLref) ? CLref :
          ((rnode(p, mode) == CLnoref) && (rnode(q, mode) == CLnoref) ?
              CLnoref : CLtest))
      ));
  DBUG_RETURN(getstack(S));
  }

/* performs all clean up on the 5 stacks
 * synchronisation of reference count has been done
 * outside of cleanstacks
 * called for rtf/jump/label
 */
static void cleanstacks(ORDER * order, COMMAND cmd)
  {
  int i;

  DBUG_ENTER("cleanstacks");
  /* always clear 'previous' refences on stack T
   */
  for(i = 0; i < top(T); i++)
    lnode((desc *)peek(T, i+1), prev) = NULL;
  switch((doneid)top(H)) {
    case FSYNC:
      /* clear all stacks
       *   remove argument frame, remove result
       */
      mkinc(order, (desc *)peek(W, 0), ST_W, 0);
      drop(W, 1);
      freeframe(A, order);
      break;
    case FSYNCMERGE:
      /* clear all stacks
       *   remove argument frame, remove results of two branches
       *   (correct refcount only for first one)
       */
      mkinc(order, (desc *)peek(W, 0), ST_W, 0);
      freeframe(A, order);
      while((doneid)top(H) == FSYNCMERGE) {
        drop(W, 1);
        drop(H, 1);
        }
      drop(W, 1);
      push(H, FSYNC);
      break;
    case CSYNC:
    case CSYNCMERGE:
      /* if CSYNC(MERGE) is carried out the stacks are like:
       *   W the result entry
       *   A a removed frame (should be empty!)
       *   R removed frame (means a seperator)
       */
      mkinc(order, (desc *)peek(W, 0), ST_W, 0);
      while(top(W)) drop(W, 1); drop(W, 1);
      while(top(R)) drop(R, 1); drop(R, 1);
      drop(A, top(A)+1);
      getstack(W) = restoreframe(getstack(W), 1);
      getstack(R) = restoreframe(getstack(R), 1);
      getstack(A) = restoreframe(getstack(A), 0);
      drop(H, 1);
      if (cmd == label) {
        drop(H, 1);
        }
      break;
    case SYNC:
      /* does reference counting operations on top of stack W;
       * then removes top frame from stack A and rebuilds next frame
       */
      drop(H, 1);
      mkinc(order, (desc *)peek(W, 0), ST_W, 0);
      freeframe(A, order);
      getstack(A) = restoreframe(getstack(A), 0);
      break;
    case SYNCMERGE:
      /* does reference counting operations on top of stack W,
       * compares to both top most entries on stack W; 
       *   and leaves a merged entry 
       * then removes top frame from stack A and rebuilds next frame
       */
      mkinc(order, (desc *)peek(W, 0), ST_W, 0);
      freeframe(A, order);
      getstack(A) = restoreframe(getstack(A), 0);
      if ((doneid)top(H) == SYNCMERGE)
        while((doneid)top(H) == SYNCMERGE) {
          getstack(W) = cmpres(getstack(W));
          drop(H, 1);
          }
      else
        drop(H, 1);
      /* if not rtf followed by cont_* label (cr style ASM code)
       * remove next marker from stack H
       * due to the carried out synchronisation within the
       * branches all reference count are set to zero
       */
      if ((cmd == label) && (GETORDERARGS(order, n) == LABcont)) {
        for(i = 1; i <= top(A); i++)
          lnode((desc *)peek(A, i), refcnt) = 0;
        drop(H, 1);
        }
      break;
    case NOOP:
      /* do nothing */
      drop(H, 1);
      break;
    default:
      yyfail("INTERNAL ERROR: unknown control symbol on control stack");
    }
  DBUG_VOID_RETURN;
  }

/* ris: inserts explicit reference counting instructions
 *      that replace the implicitoperations
 */

int ris()
  {
  int i, n, restypecnt;
  char * str;
  stack el;
  FUNCTION * fun;
  ORDER * cmd, * actcmd, * restype;
  FUNDESC * f;

  DBUG_ENTER("ris");
  initstack(W, stacksize);
  initstack(A, stacksize);
  initstack(R, stacksize);
  initstack(T, stacksize);
  initstack(H, stacksize);
  initstack(H1, stacksize);
  initstack(H2, stacksize);
  initheap(heapsize);
  initnorisk();
  for(fun = GETFIRSTFUNCTION(program_start); fun; fun = GETNEXTFUNCTION(fun)) {
    refmode = SREFnone;
    insert_order_list(new_order(hashsetref, SREFimplicit), GETFIRSTORDER(fun));
    /* install argument frame for function
     */
    DBUG_EXECUTE("STACKINI",
      prstack("W", getstack(W), 0);
      prstack("A", getstack(A), 1);
      prstack("R", getstack(R), 0);
      prstack("T", getstack(T), 1);
      prstack("H", getstack(H), 0);
      fprintf(stderr, "---------------------------\n");
      )
    DBUG_PRINT("RIS", ("  installing argument frame for %s: %d arg(s), %d tilde arg(s)",
        GETDESCENTRY(GETDESC(fun), label),
        GETDESCENTRY(GETDESC(fun), nv), GETDESCENTRY(GETDESC(fun), nfv)));
    if (GETDESCENTRY(GETDESC(fun), tag) == DT_CASE) {
      /* PM abstractions expect arguments on stack W! */
      for(i = 0; i < GETDESCENTRY(GETDESC(fun), nv); i++)
        push(W, (stack)ndesc(TYshared, 0, CLtest));
      push(A, 0);
      refinserted = 0;
      }
    else {
        /* all other abstractions (combinators) expects arguments on stack A */
      for(i = 0; i < GETDESCENTRY(GETDESC(fun), nv); i++)
        push(A, (stack)ndesc(TYshared, 0, CLtest));
      push(A, GETDESCENTRY(GETDESC(fun), nv));
      refinserted = -1;
      }
    /* install tilde argument frame for function
     */
    for(i = 0; i < GETDESCENTRY(GETDESC(fun), nfv); i++)
      push(T, (stack)ndesc(TYshared, 0, CLtest));
    push(T, GETDESCENTRY(GETDESC(fun), nfv));
    push(H, FSYNC);
    restypecnt = 0; restype = NULL;
    for(cmd = GETFIRSTORDER(fun); cmd; ) {
      DBUG_EXECUTE("STACK",
        prstack("W", getstack(W), 0);
        prstack("A", getstack(A), 1);
        prstack("R", getstack(R), 0);
        prstack("T", getstack(T), 1);
        prstack("H", getstack(H), 0);
        fprintf(stderr, "---------------------------\n");
        )
      actcmd = cmd;
      cmd = GETNEXTORDER(cmd);
      switch(GETORDERENTRY(actcmd, command)) {
        case pushcw_b:
        case pushcw_i:
        case pushcw_pf: 
          /* unboxed object; needs no reference counting */
          DBUG_PRINT("RIS", ("PUSHCW_B/PUSHCW_I/PUSHCW_PF"));
            push(W, (stack)ndesc(TYshared, 1, CLnoref));
          break;
        case pushw_p:
          /* boxed object; needs reference counting */
          DBUG_PRINT("RIS", ("PUSHW_P"));
            push(W, (stack)ndesc(TYshared, 1, CLref));
          break;
        case pushr:
          /* increment reference count */
          DBUG_PRINT("RIS", ("PUSH_R"));
            push(R, (stack)ndesc(TYshared, 1, CLref));
          break;
        case pushr_p:
          /* boxed object; needs reference counting */
          DBUG_PRINT("RIS", ("PUSHR_P"));
            push(R, (stack)ndesc(TYshared, 1, CLref));
          break;
        case pushar:
          /* increment reference count */
          DBUG_PRINT("RIS", ("PUSH_AR"));
          push(R, peek(A, GETORDERARGS(actcmd, n)+1));
            lnode((desc *)top(R), refcnt) += 1;
          break;
        case pushaw:
          /* increment reference count */
          DBUG_PRINT("RIS", ("PUSH_AW"));
          push(W, peek(A, GETORDERARGS(actcmd, n)+1));
            lnode((desc *)top(W), refcnt) += 1;
          break;
        case pushtr:
          /* increment reference count */
          DBUG_PRINT("RIS", ("PUSH_TR"));
          push(R, peek(T, GETORDERARGS(actcmd, n)+1));
            lnode((desc *)top(R), refcnt) += 1;
          break;
        case pushtw:
          /* increment reference count */
          DBUG_PRINT("RIS", ("PUSH_TW"));
          push(W, peek(T, GETORDERARGS(actcmd, n)+1));
            lnode((desc *)top(W), refcnt) += 1;
          break;
        case movear:
          /* move top-element from A to R, do not increment any ref-counts,
             adjust frame size on A
           */
          DBUG_PRINT("RIS", ("MOVEAR"));
          i = (int)pop(A)-1; push(R, pop(A)); push(A, (stack)i);
          break;
        case moveaw:
          /* move top-element from A to W, do not increment any ref-counts,
             adjust frame size on A
           */
          DBUG_PRINT("RIS", ("MOVEAW"));
          i = (int)pop(A)-1; push(W, pop(A)); push(A, (stack)i);
          break;
        case movetr:
          /* move top-element from T to R, do not increment any ref-counts,
             adjust frame size on T
           */
          DBUG_PRINT("RIS", ("MOVETR"));
          i = (int)pop(T)-1; push(R, pop(T)); push(T, (stack)i);
          break;
        case movetw:
          /* move top-element from T to W, do not increment any ref-counts,
           * adjust frame size on T
           */
          DBUG_PRINT("RIS", ("MOVETW"));
          i = (int)pop(T)-1; push(W, pop(T)); push(T, (stack)i);
          break;
        case tdeca:
        case deca:
          /* increment reference count */
          DBUG_PRINT("RIS", ("(T)DECA"));
          lnode((desc *)peek(A, GETORDERARGS(actcmd, n)+1), refcnt) -= 1;
          break;
        case tdecr:
        case decr:
          /* increment reference count */
          DBUG_PRINT("RIS", ("(T)DECR"));
          lnode((desc *)peek(R, GETORDERARGS(actcmd, n)), refcnt) -= 1;
          break;
        case tdect:
        case dect:
          /* increment reference count */
          DBUG_PRINT("RIS", ("(T)DECT"));
          lnode((desc *)peek(T, GETORDERARGS(actcmd, n)+1), refcnt) -= 1;
          break;
        case tdecw:
        case decw:
          /* increment reference count */
          DBUG_PRINT("RIS", ("(T)DECW"));
          lnode((desc *)peek(W, GETORDERARGS(actcmd, n)), refcnt) -= 1;
          break;
        case tinca:
        case inca:
          /* increment reference count */
          DBUG_PRINT("RIS", ("(T)INCA"));
          lnode((desc *)peek(A, GETORDERARGS(actcmd, n)+1), refcnt)
              += peek(A, GETORDERARGS(actcmd, m)+1);
          break;
        case tincr:
        case incr:
          /* increment reference count */
          DBUG_PRINT("RIS", ("(T)INCR"));
          lnode((desc *)peek(R, GETORDERARGS(actcmd, n)), refcnt)
              += peek(R, GETORDERARGS(actcmd, m)+1);
          break;
        case tinct:
        case inct:
          /* increment reference count */
          DBUG_PRINT("RIS", ("(T)INCT"));
          lnode((desc *)peek(T, GETORDERARGS(actcmd, n)+1), refcnt)
              += peek(T, GETORDERARGS(actcmd, m)+1);
          break;
        case tincw:
        case incw:
          /* increment reference count */
          DBUG_PRINT("RIS", ("(T)INCW"));
          lnode((desc *)peek(W, GETORDERARGS(actcmd, n)), refcnt)
              += peek(W, GETORDERARGS(actcmd, m)+1);
          break;
        case pushaux:
          /* push primitiv function result */
          DBUG_PRINT("RIS", ("PUSHAUX"));
          push(W, (stack)ndesc(TYdetructive, 0,
               (restype ? convtype(GETORDERARGS(restype, argtp)[0]) : CLtest)));
          break;
        case freea:
          /* drop arguments from stack A, therefore decrement reference counts
           * by 1
           */
          DBUG_PRINT("RIS", ("FREEA"));
          for(i = 0; i < GETORDERARGS(actcmd, n); i++)
            mkdec(actcmd, (desc *)peek(A, i+1), ST_A, i);
          n = pop(A);
          drop(A, GETORDERARGS(actcmd, n));
          push(A, n-GETORDERARGS(actcmd, n));
          break;
        case freeswt:
          /* drop arguments from stack T
           * because gammabeta does not exchange stack R and T the
           * entries are popped off stack R (instaed of T)
           * reference counts are adjusted accordingly
           */
          DBUG_PRINT("RIS", ("FREESW_T"));
          if (refmode != SREFisexplicit)
            for(i = 0; i < GETORDERARGS(actcmd, n); i++)
              mkdec(actcmd, (desc *)peek(R, i), ST_T, i);
          drop(R, GETORDERARGS(actcmd, n));
          break;
        case freer:
          /* drop arguments from stack R, therefore decrement reference counts
           * by 1
           * freeswt does not exchange stacks R and T (see gammabeta)
           */
          DBUG_PRINT("RIS", ("FREER"));
          if (refmode != SREFisexplicit)
            for(i = 0; i < GETORDERARGS(actcmd, n); i++)
              mkdec(actcmd, (desc *)peek(R, i), ST_R, i);
          drop(R, GETORDERARGS(actcmd, n));
          break;
        case freew:
          /* drop arguments from stack W, therefore decrement reference counts by 1
           */
          DBUG_PRINT("RIS", ("FREEW"));
          if (refmode != SREFisexplicit) {
            /* should not occur */
            yywarn("freew inside (keep)implicit environment");
            for(i = 0; i < GETORDERARGS(actcmd, n); i++)
              mkdec(actcmd, (desc *)peek(W, i), ST_W, i);
            }
          drop(W, GETORDERARGS(actcmd, n));
          break;
        case ext:
          DBUG_PRINT("RIS", ("EXT"));
          cleanstacks(actcmd, rtf);
          break;
        case end:
          /* release argument frame on stack T
           * frame on A is released by ext or return instruction
           */
          DBUG_PRINT("RIS", ("END"));
          freeframe(T, actcmd);
          if ((doneid)top(H) == FSYNC)
            drop(H, 1);
          else
            yywarn("INTERNAL ERROR: control stack messed up");
          if (top(W) != BOTTOM) yywarn("INTERNAL ERROR: stack W messed up");
          if (top(A) != BOTTOM) yywarn("INTERNAL ERROR: stack A messed up");
          if (top(R) != BOTTOM) yywarn("INTERNAL ERROR: stack R messed up");
          if (top(T) != BOTTOM) yywarn("INTERNAL ERROR: stack T messed up");
          break;
        case delta1:
        case delta2:
        case delta3:
        case delta4:
          /* decrement reference count for arguments only if argument
           * is freed, if destructable object emit *kill* instruction
           * otherwise emit *dec*,
           * and create updateable entry  for result with inferred
           * <restype> (found on previous line)
           */
          switch(GETORDERENTRY(actcmd, command)) {
            case delta1: n = 1; break;
            case delta2: n = 2; break;
            case delta3: n = 3; break;
            case delta4: n = 4; break;
            default:
            }
          /* build up the following structure:
           *   DELTA<n>  which creates a result with adequate reference count
           *             arguments are kept on stack and are not ref. counted
           *   optional DEC/KILL instruction for the arguments
           *   FREE_W<n> to remove the Arguments from stack
           *   PUSHAUX   to place the result on top of stack W
           */
          DBUG_PRINT("RIS", ("DELTA%d", n));
          if (refmode != SREFisexplicit)
            for(i = 0; i < n; i++)
              mkdec(cmd, (desc *)peek(W, i), ST_W, i);
          if (refmode == SREFexplicit) {
            insert_order_list(new_order(freew, n), cmd);
            insert_order_list(new_order(pushaux), cmd);
            drop(W, n);
            push(W, (stack)ndesc(TYdetructive, 0,
                 (restype ? convtype(GETORDERARGS(restype, argtp)[0]) : CLtest)));
            }
          break;
        case jcond:
        case jtrue:
        case jfalse:
          /* encountered conditional which makes up the complete
           * body of a function
           */
          DBUG_PRINT("RIS", ("JCOND/JTRUE/JFALSE"));
          /* make two (four) copies the actual argument frame,
           * the upper one is the original one, the lower one
           * consists of newly allocated nodes so all modifications
           * on stack objects from the first alternative can be undone
           * this has to be done twice
           */
          lnode((desc *)top(W), refcnt)--;
          getstack(A) = cpframe(getstack(A), 0);
          /* 2nd exit from conditional */
          switch((doneid)(el = top(H))) {
            case SYNC: set(H, 0, (stack)SYNCMERGE); break;
            case SYNCMERGE: push(H, (stack)SYNCMERGE); break;
            case FSYNC: set(H, 0, (stack)FSYNCMERGE); break;
            case FSYNCMERGE: push(H, (stack)FSYNCMERGE); break;
            case CSYNC: set(H, 0, (stack)CSYNCMERGE); break;
            case CSYNCMERGE: push(H, (stack)CSYNCMERGE); break;
            default:
              yywarn("illegal situation for conditional encoutered");
            }
          push(H, (stack)NOOP); /* cond_* label */
          push(H, (stack)SYNC); /* 1st exit from conditional */
          /* no reference count corrections required this is implicitly
           * done by cond or not necessary in case of typed conditional
           */
          drop(W, 1);
          break;
        case jcond2:
        case jtrue2:
        case jfalse2: {
          /* encountered embedded conditional
           */
          DBUG_PRINT("RIS", ("JCOND2/JTRUE2/JFALSE2"));
          /* make up to two copies the actual argument frame
           * (each requires a backup copy),
           * the upper one is the original one, the lower one
           * consists of newly allocated nodes so all modifications
           * on stack objects from the first alternative can be undone
           * the second copy is only made if the keep flag is set or
           * it's a return turn conditional (cr code)!
           */
          lnode((desc *)top(W), refcnt)--;
          getstack(A) = cpframe(getstack(A), 0);
          getstack(A) = cpframe(getstack(A), 0);
          push(H, (stack)NOOP); /* cont_* label or removed by SYNCMERGE */
          push(H, (stack)SYNCMERGE); /* either rtf or cont_* label */
          push(H, (stack)NOOP); /* cond_* label */
          push(H, (stack)SYNC); /* either rtf or jump */
          /* no reference count corrections required this is implicitly
           * done by cond or not necessary in case of typed conditional
           */
          drop(W, 1);
          break;
          }
        case Gamma:
        case gammanear:
        case gammafar:
          /* do not increment reference count for tilde arguments (done
           * by following freer);
           * create non updateable entry  for result with inferred
           * <restype> (found on previous line)
           */
          DBUG_PRINT("RIS", ("GAMMA"));
          if ((f = find_desc(GETFIRSTDESC(program_start), GETORDERARGS(actcmd, label)))) {
            push(W, (stack)ndesc(TYshared, 0,
                (restype ? convtype(GETORDERARGS(restype, argtp)[0]) : CLtest)));
            }
          else
            yyerror("illegal function identifier %s.", GETORDERARGS(actcmd, label));
          break;
        case gammabeta:
          /* increment reference count for combinator but not for tilde arguments
           * (this is done by following freeswt) and create non updateable
           * entry  for result with inferred <restype> (found on previous line)
           * gammabeta does NOT exchange the stacks R and T
           */
          DBUG_PRINT("RIS", ("GAMMABETA"));
          if ((f = find_desc(GETFIRSTDESC(program_start), GETORDERARGS(actcmd, label)))) {
            if (refmode != SREFisexplicit)
              for(i = 0; i < GETDESCENTRY(f,nv); i++)
                mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
            drop(W, GETDESCENTRY(f, nv));
            push(W, (stack)ndesc(TYshared, 0,
                (restype ? convtype(GETORDERARGS(restype, argtp)[0]) : CLtest)));
            }
          else
            yyerror("illegal function identifier %s.", GETORDERARGS(actcmd, label));
          break;
        case beta:
        case tail:
          /* increment reference count for all arguments (if necessary)
           * and create non updateable entry  for result with inferred
           * <restype> (found on previous line)
           */
          DBUG_PRINT("RIS", ("BETA"));
          if ((f = find_desc(GETFIRSTDESC(program_start), GETORDERARGS(actcmd, label)))) {
            if (refmode != SREFisexplicit)
              for(i = 0; i < GETDESCENTRY(f,nv); i++)
                mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
            drop(W, GETDESCENTRY(f, nv));
            push(W, (stack)ndesc(TYshared, 0,
                (restype ? convtype(GETORDERARGS(restype, argtp)[0]) : CLtest)));
            }
          else
            yyerror("illegal function identifier %s.", GETORDERARGS(actcmd, label));
          break;
        case intact:
          /* increment reference count for all arguments (if necessary)
           * and create non updateable entry  for result with inferred
           * <restype> (found on previous line)
           */
          DBUG_PRINT("RIS", ("INTACT"));
          n = get_ia_arity(GETIA(GETORDERARGS(actcmd, primf)));
          if (refmode != SREFisexplicit)
            for(i = 0; i < n; i++)
              mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
          drop(W, n);
          push(W, (stack)ndesc(TYshared, 0, CLref));
          break;
        case mkbclos:
        case mkcclos:
        case mksclos:
          /* increment reference count for all given arguments (if necessary)
           * and create updateable entry for closure
           */
          DBUG_PRINT("RIS", ("MKBCLOS/MKCCLOS/MKSCLOS"));
          if (refmode != SREFisexplicit)
            for(i = 0; i < GETORDERARGS(actcmd, n)+1; i++)
              mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
          if (ISASM_TILDE()) {
            if (refmode != SREFisexplicit)
              for(i = 0; i < GETORDERARGS(actcmd, k); i++)
                mkinc(actcmd, (desc *)peek(T, i+1), ST_T, i);
            }
          drop(W, GETORDERARGS(actcmd, n)+1);
          push(W, (stack)ndesc(TYdetructive, 0, CLref));
          break;
        case mkgaclos:
          /* increment reference count for all given arguments (if necessary)
           * and create updateable entry for closure
           * function is found on top of R
           */
          DBUG_PRINT("RIS", ("MKGACLOS"));
          if (refmode != SREFisexplicit)
            for(i = 0; i < GETORDERARGS(actcmd, n); i++)
              mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
          if (ISASM_TILDE()) {
            if (refmode != SREFisexplicit)
              for(i = 0; i < GETORDERARGS(actcmd, k)+1; i++)
                mkinc(actcmd, (desc *)peek(R, i), ST_R, i);
            }
          drop(W, GETORDERARGS(actcmd, n));
          drop(R, GETORDERARGS(actcmd, k)+1);
          push(W, (stack)ndesc(TYdetructive, 0, CLref));
          break;
        case apply:
        case mkap:
        case mkdclos:
        case mkiclos:
          /* increment reference count for all given arguments (if necessary)
           * and create updateable entry for closure
           */
          DBUG_PRINT("RIS", ("APPLY/MKAP/MKDCLOS/MKICLOS"));
          if (refmode != SREFisexplicit)
            for(i = 0; i < GETORDERARGS(actcmd, n)+1; i++)
              mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
          drop(W, GETORDERARGS(actcmd, n)+1);
          if (GETORDERENTRY(actcmd, command) == apply)
            push(W, (stack)ndesc(TYdetructive, 0,
                (restype ? convtype(GETORDERARGS(restype, argtp)[0]) : CLtest)));
          else
            push(W, (stack)ndesc(TYdetructive, 0, CLref));
          break;
        case mklist:
        case mkilist:
        case mkframe:
          /* carry out increments of list/frame elements
           * create list/frame descriptor with ref-count 0
           */
          DBUG_PRINT("RIS", ("MKLIST/MKFRAME"));
          if (refmode != SREFisexplicit)
            for(i = 0; i < GETORDERARGS(actcmd, n); i++)
              mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
          drop(W, GETORDERARGS(actcmd, n));
          push(W, (stack)ndesc(TYshared, 0, CLref));
          break;
        case mkslot:
          /* carry out increments of 2 stack items
           * create slto descriptor with ref-count 0
           */
          DBUG_PRINT("RIS", ("MKSLOT"));
          if (refmode != SREFisexplicit)
            for(i = 0; i < 2; i++)
              mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
          drop(W, 2);
          push(W, (stack)ndesc(TYshared, 0, CLref));
          break;
        case jump:
          /* handled similarily to return instruction
           * if terminal instruction of conditional part
           */
          DBUG_PRINT("RIS", ("JUMP"));
          cleanstacks(actcmd, jump);
          break;
        case rtc:
        case rtc_i:
        case rtc_b:
        case rtc_pf:
        case rtf:
        case rtm:
        case rtp:
          /* always free the active argument frame on A stack
           * leave return value on W stack if return from inner
           * conditional, otherwise delete it
           * always increment ref-counts (W and A stack) if necessary
           */
          switch(GETORDERENTRY(actcmd, command)) {
            case rtf:
              DBUG_PRINT("RIS", ("RTF"));
              if (refmode != SREFisexplicit)
                mkinc(actcmd, (desc *)peek(W, 0), ST_W, 0);
              break;
            case rtm:
              DBUG_PRINT("RIS", ("RTM"));
              if (refmode != SREFisexplicit)
                mkinc(actcmd, (desc *)peek(A, 1), ST_A, 0);
              i = (int)pop(A)-1; push(W, pop(A)); push(A, (stack)i);
              break;
            default:
              DBUG_PRINT("RIS", ("RTC/RTP"));
              push(W, (stack)ndesc(TYshared, 0,
                  (GETORDERENTRY(actcmd, command) == rtp ? CLref : CLnoref)));
            }
          /* do all the clean up operations on the various stacks */
          cleanstacks(actcmd, rtf);
          break;
        case rtt:
          DBUG_PRINT("RIS", ("RTF"));
          if (refmode != SREFisexplicit)
            mkinc(actcmd, (desc *)peek(W, 0), ST_W, 0);
          break;
        case hashargs:
          /* replace argument frame on argument stack A/W */
          DBUG_PRINT("RIS", ("%s", GETORDERARGS(actcmd, hash_str)));
          str = GETORDERARGS(actcmd, hash_str);
          DBUG_PRINT("RIS", ("  replace argument frame on argument stack A/W"));
          if (GETDESCENTRY(GETDESC(fun), tag) == DT_CASE)
            for(i = 0; i < GETORDERARGS(actcmd, n); i++) {
              DBUG_PRINT("RIS", ("  type %d->%d",
                  GETORDERARGS(actcmd, argtp)[i],
                  convtype(GETORDERARGS(actcmd, argtp)[i])));
              lnode((desc *)peek(W, i), mode) =
                  convtype(GETORDERARGS(actcmd, argtp)[i]);
              }
          else
            if (GETORDERARGS(actcmd, n) == top(A))
              for(i = 0; i < GETORDERARGS(actcmd, n); i++) {
                DBUG_PRINT("RIS", ("  type %d->%d",
                    GETORDERARGS(actcmd, argtp)[i],
                    convtype(GETORDERARGS(actcmd, argtp)[i])));
                lnode((desc *)peek(A, i+1), mode) =
                    convtype(GETORDERARGS(actcmd, argtp)[i]);
                }
          else
            yyerror("illegal number of arguments on stack A/W (is %d should be %d)",
              top(A), GETORDERARGS(actcmd, n));
          break;
        case hashtildeargs:
          /* replace argument frame on argument stack T */
          DBUG_PRINT("RIS", ("%s", GETORDERARGS(actcmd, hash_str)));
          str = GETORDERARGS(actcmd, hash_str);
          DBUG_PRINT("RIS", ("  replace argument frame on argument stack T"));
          if (GETORDERARGS(actcmd, n) == top(T))
            for(i = 0; i < GETORDERARGS(actcmd, n); i++) {
              DBUG_PRINT("RIS", ("  type %d->%d",
                  GETORDERARGS(actcmd, argtp)[i],
                  convtype(GETORDERARGS(actcmd, argtp)[i])));
              lnode((desc *)peek(T, i+1), mode) =
                  convtype(GETORDERARGS(actcmd, argtp)[i]);
              }
          else
            yyerror("illegal number of arguments on stack T (is %d should be %d)",
              top(T), GETORDERARGS(actcmd, n));
          break;
        case hashrestype:
          /* store type for later use */
          DBUG_PRINT("RIS", ("%s", GETORDERARGS(actcmd, hash_str)));
          DBUG_PRINT("RIS", ("  got return type %d", GETORDERARGS(actcmd, argtp)[0]));
          restype = actcmd; restypecnt = 1;
          break;
        case hashsetref:
          /* switch mode, synchronisation may be necessary */
          DBUG_PRINT("RIS", ("#setref %d", GETORDERARGS(actcmd, n)));
          switch(refmode) {
            case SREFnone:
              /* This mode may only occur at start of function
               */
              switch(GETORDERARGS(actcmd, n)) {
                case SREFimplicit:
                  insert_order_list(new_order(hashsetref, SREFexplicit), actcmd);
                  delete_order(actcmd);
                  refmode = SREFexplicit;
                  break;
                case SREFexplicit:
                  refmode = SREFisexplicit;
                  break;
                case SREFkeepimpl:
                  refmode = SREFkeepimpl;
                  break;
                default: yywarn("RIS: unknown mode found");
                }
              break;
            case SREFexplicit:
              switch(GETORDERARGS(actcmd, n)) {
                case SREFexplicit:
                  refmode = SREFisexplicit;
                case SREFimplicit:
                  delete_order(actcmd);
                  break;
                case SREFkeepimpl:
                  for(i = 0; peek(W, i) && (peek(W, i) != BOTTOM); i++)
                    mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
                  for(i = 0; i < top(A); i++)
                    mkinc(actcmd, (desc *)peek(A, i+1), ST_A, i);
                  refmode = SREFkeepimpl;
                  break;
                default: yywarn("RIS: unknown mode found");
                }
              break;
            case SREFkeepimpl:
              switch(GETORDERARGS(actcmd, n)) {
                case SREFimplicit:
                  insert_order_list(new_order(hashsetref, SREFexplicit), cmd);
                  delete_order(actcmd);
                  refmode = SREFexplicit;
                  break;
                case SREFexplicit:
                  refmode = SREFisexplicit;
                  break;
                case SREFkeepimpl:
                  break;
                default: yywarn("RIS: unknown mode found");
                }
              break;
            default:
              yyfail("reference count inference system looses state");
            }
          break;
        case label:
          DBUG_PRINT("RIS",("LABEL %s:", GETORDERARGS(actcmd, label)));
          if ((GETORDERARGS(actcmd, n) == LABcond) ||
              (GETORDERARGS(actcmd, n) == LABcont) ||
              (GETORDERARGS(actcmd, n) == LABfail) ||
              (GETORDERARGS(actcmd, n) == LABundecided))
            cleanstacks(actcmd, label);
          if (GETORDERARGS(actcmd, n) == LABfail)
            refinserted = 0;
          break;
        /*
         * PM instructions
         */
        case advance:
          DBUG_PRINT("RIS", ("ADVANCE")); break;
        case bind:
          /* copy top element of W to the addressed position on stack A,
           * reference count of overwritten object has to be decremented
           */
          DBUG_PRINT("RIS", ("BIND"));
          mkdec(actcmd, (desc *)peek(A, GETORDERARGS(actcmd, n)+1),
              ST_A, GETORDERARGS(actcmd, n));
          set(A, GETORDERARGS(actcmd, n)+1, top(W));
          lnode((desc *)top(W), refcnt) += 1;
          break;
        case binds:
          /* write new string descriptor to l-th stack position of A
           */
          DBUG_PRINT("RIS", ("BINDS"));
          mkdec(actcmd, (desc *)peek(A, GETORDERARGS(actcmd, n)+1),
              ST_A, GETORDERARGS(actcmd, n));
          set(A, GETORDERARGS(actcmd, n)+1, (stack)ndesc(TYdetructive, 0, CLref));
          break;
        case bindsubl:
          /* write new list descriptor to l-th stack position of A
           */
          DBUG_PRINT("RIS", ("BINDSUBL"));
          set(A, GETORDERARGS(actcmd, l)+1, (stack)ndesc(TYdetructive, 0, CLref));
          break;
        case Case:
          /* call PM abstraction */
          DBUG_PRINT("RIS", ("CASE"));
          if ((f = find_desc(GETFIRSTDESC(program_start), GETORDERARGS(actcmd, label)))) {
            for(i = 0; i < GETDESCENTRY(f,nv); i++)
              mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
            drop(W, GETDESCENTRY(f, nv));
            push(W, (stack)ndesc(TYshared, 0,
                (restype ? convtype(GETORDERARGS(restype, argtp)[0]) : CLtest)));
            }
          else
            yyerror("illegal function identifier %s.", GETORDERARGS(actcmd, label));
          break;
        case dereference:
          /* replace top most entry on stack W by dereferenced value */
          DBUG_PRINT("RIS", ("DEREFERENCE"));
          set(W, 0, (stack)ndesc(TYshared, 0,
              (restype ? convtype(GETORDERARGS(restype, argtp)[0]) : CLtest)));
          break;
        case drop: {
          /* drop the top most element of stack W */
          int j;
          DBUG_PRINT("RIS", ("DROP"));
          /* increment reference counts for all bound variables
           */
          for(i = j = 0; i < top(A); i++) {
            if ((desc *)peek(A, i+1) == (desc *)top(W))
              j = 1;
            else
              mkinc(actcmd, (desc *)peek(A, i+1), ST_A, i);
            }
          if (j == 0)
            mkdec(actcmd, (desc *)pop(W), ST_W, 0);
          else {
            /* dropped entry also on stack A
             * refcount > 0
             */
            lnode((desc *)top(W), refcnt)--;
            drop(W, 1);
            }
          break;
          }
        case endlist:
        case endsubl:
          DBUG_PRINT("RIS", ("ENDLIST/ENDSUBL"));
          break;
        case fetch:
          /* replace top of W 
           * top of W was pointer to heap element, therefore
           * refcounting is not necessary
           */
          DBUG_PRINT("RIS", ("FETCH"));
          set(W, 0, (stack)ndesc(TYshared, 1,
              (restype ? convtype(GETORDERARGS(restype, argtp)[0]) : CLtest)));
          break;
        case gammacase:
          /* increment reference count for combinator but not for tilde arguments
           * (this is done by following freeswt) and create non updateable
           * entry  for result with inferred <restype> (found on previous line)
           * gammacase does NOT exchange the stacks R and T
           */
          DBUG_PRINT("RIS", ("GAMMACASE"));
          if ((f = find_desc(GETFIRSTDESC(program_start), GETORDERARGS(actcmd, label)))) {
            if (refmode != SREFisexplicit)
              for(i = 0; i < GETDESCENTRY(f,nv); i++)
                mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
            drop(W, GETDESCENTRY(f, nv));
            push(W, (stack)ndesc(TYshared, 0,
                (restype ? convtype(GETORDERARGS(restype, argtp)[0]) : CLtest)));
            }
          else
            yyerror("illegal function identifier %s.", GETORDERARGS(actcmd, label));
          break;
        case initbt:
          /* install a 4 entries large back-tracking frame with will not
           * be refcounted
           */
          DBUG_PRINT("RIS", ("INITBT"));
          set(R, 0, (stack)1);
          set(R, 1, (stack)1);
          set(R, 2, top(W));
          set(R, 3, (stack)1);
          break;
        case matcharb:
        case matcharbs:
        case matchbool:
        case matchin:
        case matchint:
        case matchlist:
        case matchprim:
        case matchstr: {
          /* prepare two copies of the actual argument frame
           * (each requires a backup copy),
           * the upper one is the original one, the lower one
           * consists of newly allocated nodes so all modifications
           * on stack objects from the first alternative can be undone
           */
          stack el;
          DBUG_PRINT("RIS", ("MATCH*"));
          n = top(A);
          getstack(A) = cpframe(getstack(A), 0);
          for(i = 2*n+1; i >= 0; i--) {
            el = peek(A, 2*n+1); push(A, el);
            }
          /* also prepare two copies of the _complete_ workspace frame
           */
          getstack(W) = cpframe(getstack(W), 1);
          getstack(W) = cpframe(getstack(W), 1);
          /* as well as the R stack frame
           */
          getstack(R) = cpframe(getstack(R), 1);
          getstack(R) = cpframe(getstack(R), 1);
          push(H, (stack)NOOP);
          push(H, (stack)CSYNC);
          push(H, (stack)NOOP);
          push(H, (stack)CSYNC);
          break;
          }
        case mkaframe:
          /* allocate a new Frame on stack A and fill it with dummy values */
          DBUG_PRINT("RIS", ("MKAFRAME"));
          n = pop(A);
          for(i = 0; i < GETORDERARGS(actcmd, n); i++)
            push(A, (stack)1);
          push(A, GETORDERARGS(actcmd, n)+n);
          break;
        case mkbtframe:
          /* allocate a new Frame on stack R and fill it with dummy values */
          DBUG_PRINT("RIS", ("MKBTFRAME"));
          for(i = 0; i < GETORDERARGS(actcmd, n); i++)
            push(R, (stack)1);
          break;
        case mkcase:
          DBUG_PRINT("RIS", ("MKCASE"));
          drop(W, 1);
          push(W, (stack)ndesc(TYshared, 0, CLref));
          break;
        case mkwframe: {
          /* allocate a frame on stack W and copy to actual
           * match pointer on top
           */
          stack el;
          DBUG_PRINT("RIS", ("MKWFRAME"));
          for(i = 0; i < GETORDERARGS(actcmd, n); i++)
            push(W, 1);
          el =  peek(W, GETORDERARGS(actcmd, n)); push(W, el);
          break;
          }
        case nestlist:
          DBUG_PRINT("RIS", ("NESTLIST"));
          break;
        case pick: {
          /* copies the n-th element of stack W to top
           */
          stack el;
          DBUG_PRINT("RIS", ("PICK"));
          el =  peek(W, GETORDERARGS(actcmd, n));
          set(W, 0, el);
          break;
          }
        case restorebt:
        case restoreptr:
          DBUG_PRINT("RIS", ("RESTORE[BT/PTR]")); break;
        case rmbtframe:
          /* remove frame from stack R
           */
          DBUG_PRINT("RIS", ("RMBTFRAME"));
          drop(R, GETORDERARGS(actcmd, n));
          break;
        case rmwframe:
          /* remove frame from stack W
           */
          DBUG_PRINT("RIS", ("RMWFRAME"));
          drop(W, GETORDERARGS(actcmd, n));
          break;
        case savebt:
        case startsubl:
          DBUG_PRINT("RIS", ("SAVEBT/STARTSUBL"));
          break;
        case tguard:
          /* prepare a copy of the actual argument frame
           * (which requires a backup copy),
           * the upper one is the original one, the lower one
           * consists of newly allocated nodes so all modifications
           * on stack objects from the first alternative can be undone
           */
          /* first the tested argument is removed (ref-counting done
           * by instruction)
           */
          rnode((desc *)top(W), refcnt)--;
          if (refinserted == 1) {
            refinserted = -1;
            for(i = 0; i < top(A); i++)
              lnode((desc *)peek(A, i+1), refcnt)--;
            for(i = 0; i < top(A); i++)
              mkinc(actcmd, (desc *)peek(A, i+1), ST_A, i);
            for(i = 0; i < top(A); i++)
              lnode((desc *)peek(A, i+1), refcnt)++;
            }
          else
            refinserted = -1;
          drop(W, 1);
        case atend:
        case atstart:
          /* do the same stuff as for tguard, except don't remove
           * guard from stack W
           */
          DBUG_PRINT("RIS", ("TGUARD/ATEND/ATSTART"));
          /* make a full synchronisation of new argument frame
           * only if any reference count instructions are
           * inserted above
           */
          getstack(A) = cpframe(getstack(A), 0);
          /* also prepare a copies of the _complete_ workspace frame
           */
          getstack(W) = cpframe(getstack(W), 1);
          /* as well as the R stack frame
           */
          getstack(R) = cpframe(getstack(R), 1);
          push(H, (stack)NOOP);
          push(H, (stack)CSYNC);
          break;
        case saveptr:
          DBUG_PRINT("RIS", ("SAVEPTR"));
          break;
        case pushh:
        case poph:
        case wait:
	case count:
	case msnodist:
	case msdistend:
          break;
        case dist:
          /* force synchronisation
           */
          for(i = 0; i < GETORDERARGS(actcmd, n); i++)
            mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
          break;
        case distb:
          /* force synchronisation
           */
          for(i = 0, n = GETORDERARGS(actcmd, n); n; i++, n /= 2)
            if (n%1)
              mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
          break;
        case distend:
          /* force synchronisation
           */
          if (refmode != SREFisexplicit)
            mkinc(actcmd, (desc *)peek(W, 0), ST_W, 0);
          break;
        default: yyfail("ris: illegal order received");
        }
        if (restypecnt) restypecnt--; else restype = NULL;
      }
    }
  freestack(W);
  freestack(A);
  freestack(R);
  freestack(T);
  freestack(H);
  freestack(H1);
  freestack(H2);
  freeheap();
  DBUG_RETURN(0);
  }
@


1.35
log
@mkiclos fixed
@
text
@d1383 3
@


1.34
log
@mkgaclos fixed
@
text
@a888 1
        case mkiclos:
d893 1
a893 1
          DBUG_PRINT("RIS", ("MKBCLOS/MKDCLOS/MKICLOS/MKSCLOS"));
d926 1
d930 1
a930 1
          DBUG_PRINT("RIS", ("APPLY/MKAP/MKDCLOS"));
@


1.33
log
@cases for mkiclos and intact added.
@
text
@a889 1
        case mkgaclos:
d894 1
a894 1
          DBUG_PRINT("RIS", ("MKBCLOS/MKDCLOS/MKGACLOS/MKSCLOS"));
d904 18
@


1.32
log
@rtt was missing
@
text
@d7 1
d95 1
d874 13
d889 1
a898 1
          /*
a899 1
            yywarn("may be wrong!");
a903 1
          */
@


1.31
log
@A/W argument stack for case
@
text
@d974 5
@


1.30
log
@arg replacement for case functions
@
text
@d905 5
a909 1
          push(W, (stack)ndesc(TYdetructive, 0, CLref));
@


1.29
log
@DIST implemented
@
text
@d971 1
a971 1
          /* replace argument frame on argument stack A */
d974 2
a975 2
          DBUG_PRINT("RIS", ("  replace argument frame on argument stack A"));
          if (GETORDERARGS(actcmd, n) == top(A))
d980 1
a980 1
              lnode((desc *)peek(A, i+1), mode) =
d984 10
a993 1
            yyerror("illegal number of arguments on stack A (is %d should be %d)",
@


1.28
log
@multi increment fixed
@
text
@d15 17
d80 52
d137 1
d144 11
a154 2
  if ((rnode(p, refcnt) > 0) && (rnode(p, mode) != CLnoref))
    {
d175 5
d181 2
a182 2
  lnode(p, refcnt) = 0;
  DBUG_PRINT("REF", ("INC: refcnt=%d", rnode(p, refcnt)));
d191 2
d200 1
a200 1
    {
d202 20
a221 12
      lnode(p, prev) = NULL;
    switch(stid) {
      case ST_A: if (rnode(p, mode) == CLref) cmdid = deca; else cmdid = tdeca;
        break;
      case ST_R: if (rnode(p, mode) == CLref) cmdid = decr; else cmdid = tdecr;
        break;
      case ST_T: if (rnode(p, mode) == CLref) cmdid = dect; else cmdid = tdect;
        break;
      case ST_W: if (rnode(p, mode) == CLref) cmdid = decw; else cmdid = tdecw;
        break;
      default:
        yyfail("internal error: illegal stack");
a222 3
    insert_order_list(new_order(cmdid, off), cmd);
    lnode(p, refcnt) = 0;
    DBUG_PRINT("RIS", ("DEC* inserted"));
d363 4
d477 1
d491 2
a492 1
    DBUG_PRINT("RIS", ("  installing argument frame: %d arg(s), %d tilde arg(s)",
d499 1
d506 1
d605 1
a605 1
          lnode((desc *)peek(A, GETORDERARGS(actcmd, n)), refcnt) -= 1;
d617 1
a617 1
          lnode((desc *)peek(T, GETORDERARGS(actcmd, n)), refcnt) -= 1;
d629 2
a630 1
          lnode((desc *)peek(A, GETORDERARGS(actcmd, n)), refcnt) += peek(A, GETORDERARGS(actcmd, m)+1);
d636 2
a637 1
          lnode((desc *)peek(R, GETORDERARGS(actcmd, n)), refcnt) += peek(R, GETORDERARGS(actcmd, m)+1);
d643 2
a644 1
          lnode((desc *)peek(T, GETORDERARGS(actcmd, n)), refcnt) += peek(T, GETORDERARGS(actcmd, m)+1);
d650 2
a651 1
          lnode((desc *)peek(W, GETORDERARGS(actcmd, n)), refcnt) += peek(W, GETORDERARGS(actcmd, m)+1);
d665 1
a665 2
            if ((desc *)peek(A, i+1))
              mkdec(actcmd, (desc *)peek(A, i+1), ST_A, i);
d679 1
a679 2
              if ((desc *)peek(R, i))
                mkdec(actcmd, (desc *)peek(R, i), ST_T, i);
d690 1
a690 2
              if ((desc *)peek(R, i))
                mkdec(actcmd, (desc *)peek(R, i), ST_R, i);
d701 1
a701 2
              if ((desc *)peek(W, i))
                mkdec(actcmd, (desc *)peek(W, i), ST_W, i);
a836 2
        case gammabetanear:
        case gammabetafar:
d879 1
a879 1
          DBUG_PRINT("RIS", ("MKBCLOS/MKDCLOS/MKGACLOS"));
d1075 2
a1240 1
          mkdec(actcmd, (desc *)peek(W, 0), ST_W, 0);
d1293 16
a1308 1
          mkdec(actcmd, (desc *)pop(W), ST_W, 0);
d1315 4
d1331 23
@


1.27
log
@new conditional handling
restructured control stack
@
text
@d76 1
a76 1
    if (rnode(p, prev)) {
d78 1
a78 3
      GETORDERARGS(rnode(p, prev),n) += rnode(p, refcnt);
      yymessage("multi increment carried out");
      }
@


1.26
log
@mkilist added
@
text
@d14 1
d23 1
a23 1
static void prstack(const char * str, const stack * s, const int m)
a26 1
  const astack(S);
a27 1
  setstack(S) = s;
d37 7
a43 6
          case null:      fprintf(stderr, "(null) "); break;
          case cond_done: fprintf(stderr, "cond "); break;
          case then_done: fprintf(stderr, "then "); break;
          case else_done: fprintf(stderr, "else "); break;
          case func_done: fprintf(stderr, "func "); break;
          case case_done: fprintf(stderr, "case "); break;
d70 3
a73 2
  if ((int)p < lastcmd)
    yyfail("illegal pointer for increment instruction received");
d101 1
d111 3
a114 2
  if ((int)p < lastcmd)
    yyfail("illegal pointer for decrement instruction received");
d138 1
d170 1
a170 1
static stack * cpframe(stack * s, int m)
a173 1
  astack(S);
a175 1
  setstack(S) = s;
d177 1
a177 1
    n = peek(S, 0);
d183 1
d215 1
a215 1
static stack * restoreframe(stack * s, int m)
a218 1
  astack(S);
a220 1
  setstack(S) = s;
d228 1
a228 1
    DBUG_PRINT("RIS", ("%d/%d p=%p, q=%p", i, n, p, q));
d245 1
a245 1
static stack * cmpres(stack * s)
a247 1
  astack(S);
a249 1
  setstack(S) = s;
d264 4
a267 3
/* search the adjacent conditional descriptor
 * parameter is label 'cond' which will match desc entry 'jcond'
 * with same address
d269 1
a269 1
static FUNDESC * searchcond(char * label)
d271 1
a271 1
  FUNDESC * p = GETFIRSTDESC(program_start);
d273 87
a359 5
  DBUG_ENTER("search_desc");
  for(p = GETFIRSTDESC(program_start);
      p && strcmp(&GETDESCENTRY(p, label)[1], label);
      p = GETNEXTDESC(p));
  DBUG_RETURN(p);
d361 1
a361 15
      
/* search a jump instruction with appropriate label
 * parameter is label 'cond' which will match desc entry 'jcond'
 * with same address
 */
static ORDER * searchjump(ORDER * p, char * label)
  {
  DBUG_ENTER("search_jump");
  for(;
      p && (GETORDERENTRY(p, command) == jump)
          && strcmp(GETORDERARGS(p, label), label);
      p = GETNEXTORDER(p));
  DBUG_RETURN(p);
  }
      
a368 1
  setrefmode refmode;
d370 1
d389 8
d416 2
a417 2
    push(H, func_done);
    restype = NULL;
d610 1
a610 2
          freeframe(A, actcmd);
          drop(W, 1);
d618 1
a618 1
          if ((doneid)top(H) == func_done)
d621 5
a625 1
            yywarn("INTERNAL ERROR: return stack messed up");
d670 1
a670 1
          /* make two copies the actual argument frame,
d674 1
d677 14
a690 2
          setstack(A) = cpframe(getstack(A), 0);
          push(H, (stack)then_done);
a698 2
          FUNDESC * fd;
          stack el;
d711 6
a716 17
          n = top(A);
          setstack(A) = cpframe(getstack(A), 0);
          if (((fd = searchcond(GETORDERARGS(actcmd, label))) &&
                (GETDESCENTRY(fd, nfv)&0x1))
              || (searchjump(actcmd, GETORDERARGS(actcmd, ret)) != NULL)) {
            /* if keep flag set */
            for(i = 2*n+1; i >= 0; i--) {
              el = peek(A, 2*n+1); push(A, el);
              }
            /* prepare a second cleanup operation
             */
            if (fd && (GETDESCENTRY(fd, nfv)&0x1))
              push(H, (stack)else_done);
            else
              push(H, (stack)then_done);
            }
          push(H, (stack)then_done);
d780 1
d786 1
a786 1
            for(i = 0; i < GETORDERARGS(actcmd, n); i++)
d788 1
d790 1
a790 1
            yyerror("may be wrong!");
d793 1
a793 1
                mkinc(actcmd, (desc *)peek(T, i), ST_T, i);
d795 2
a796 1
          drop(W, GETORDERARGS(actcmd, n));
d807 1
a807 1
            for(i = 0; i < GETORDERARGS(actcmd, n); i++)
d809 1
a809 1
          drop(W, GETORDERARGS(actcmd, n));
d841 1
a841 7
          if (GETORDERARGS(actcmd, n) == LABcont) {
            if (refmode != SREFisexplicit)
              mkinc(actcmd, (desc *)peek(W, 0), ST_W, 0);
            freeframe(A, actcmd);
            setstack(A) = restoreframe(getstack(A), 0);
            drop(H, 1);
            }
d843 5
d849 1
a849 3
          DBUG_PRINT("RIS", ("RTM + "));
          push(W, peek(A, 1));
        case rtf:
d855 5
a859 40
          DBUG_PRINT("RIS", ("RTF"));
          if (refmode != SREFisexplicit)
            mkinc(actcmd, (desc *)peek(W, 0), ST_W, 0);
          freeframe(A, actcmd);
          switch((doneid)top(H)) {
            case null:
            case else_done:
              drop(A, (int)top(A)+1);
              setstack(W) = cmpres(getstack(W)); drop(H, 1);
              break;
            case case_done:
              /* operations done by label */
              drop(W, 2);
              break;
            case then_done:
              setstack(A) = restoreframe(getstack(A), 0); drop(H, 1); break;
            case cond_done:
              setstack(W) = cmpres(getstack(W)); drop(H, 1); break;
            case func_done: 
              break;
            default:
              yyfail("INTERNAL ERROR: illegal object found on return stack");
            }
          break;
        case rtc:
        case rtc_i:
        case rtc_b:
        case rtp:
          DBUG_PRINT("RIS", ("RTC/RTP"));
          push(W, (stack)ndesc(TYshared, 0,
                          (GETORDERENTRY(actcmd, command) == rtp ? CLref : CLnoref)));
          freeframe(A, actcmd);
          switch((doneid)top(H)) {
            case else_done:
              drop(A, (int)top(A)+1);
              setstack(W) = cmpres(getstack(W)); drop(H, 1);
              break;
            case case_done:
              /* operations done by label */
              drop(W, 2);
d861 5
a865 5
            case then_done:
              setstack(A) = restoreframe(getstack(A), 0); drop(H, 1); break;
            case cond_done:
              setstack(W) = cmpres(getstack(W)); drop(H, 1); break;
            case func_done: 
d868 3
a870 1
              yyfail("INTERNAL ERROR: illegal object found on return stack");
d872 2
d975 5
a979 15
          if ((top(H) == (doneid)else_done)
              && (GETORDERARGS(actcmd, n) == LABcont)) {
            mkinc(actcmd, (desc *)peek(W, 0), ST_W, 0);
            drop(A, (int)top(A)+1); freeframe(A, actcmd);
            setstack(W) = cmpres(getstack(W));
            drop(H, 1);
            }
          else if ((top(H) == (doneid)case_done)
              && ((GETORDERARGS(actcmd, n) == LABundecided)
                 || (GETORDERARGS(actcmd, n) == LABfail))) {
            setstack(W) = restoreframe(getstack(W), 1);
            setstack(R) = restoreframe(getstack(R), 1);
            setstack(A) = restoreframe(getstack(A), 0);
            drop(H, 1);
            }
d991 2
a992 3
          if (peek(A, GETORDERARGS(actcmd, n)+1))
            mkdec(actcmd, (desc *)peek(A, GETORDERARGS(actcmd, n)+1),
                ST_A, GETORDERARGS(actcmd, n));
d1000 2
a1001 3
          if (peek(A, GETORDERARGS(actcmd, n)+1))
            mkdec(actcmd, (desc *)peek(A, GETORDERARGS(actcmd, n)+1),
                ST_A, GETORDERARGS(actcmd, n));
a1007 3
          if (peek(A, GETORDERARGS(actcmd, l)+1))
            mkdec(actcmd, (desc *)peek(A, GETORDERARGS(actcmd, l)+1),
                ST_A, GETORDERARGS(actcmd, l));
d1026 1
a1026 2
          mkdec(actcmd, (desc *)pop(W), ST_W, 0);
          push(W, (stack)ndesc(TYshared, 1,
d1036 1
a1036 2
            if ((desc *)peek(A, i+1) == (desc *)top(W)) {
              lnode((desc *)top(W), refcnt)--;
d1038 1
a1038 2
              }
            if (peek(A, i+1))
d1043 5
a1047 1
          else
d1049 1
d1057 6
a1062 4
          DBUG_PRINT("RIS", ("ENDLIST/ENDSUBL"));
          if (lnode(((desc *)top(W)), refcnt))
            yywarn("illegal reference counting for heap pointer required");
          push(W, (stack)ndesc(TYshared, 1,
d1071 1
a1071 1
          DBUG_PRINT("RIS", ("GAMMA"));
d1076 1
a1076 1
            drop(W, GETDESCENTRY(f, nfv));
d1088 4
a1091 2
          for(i = 0; i < 4; i++)
            push(R, (stack)NULL);
d1110 1
a1110 1
          setstack(A) = cpframe(getstack(A), 0);
a1114 1
           * as well as the R stack frame
d1116 10
a1125 6
          setstack(W) = cpframe(getstack(W), 1);
          setstack(W) = cpframe(getstack(W), 1);
          setstack(R) = cpframe(getstack(R), 1);
          setstack(R) = cpframe(getstack(R), 1);
          push(H, (stack)case_done);
          push(H, (stack)case_done);
d1133 1
a1133 1
            push(A, (stack)NULL);
d1138 1
a1138 1
          DBUG_PRINT("RIS", ("MKRFRAME"));
a1156 1
          lnode((desc *)el, refcnt) += 1;
d1160 2
a1161 1
          DBUG_PRINT("RIS", ("NESTLIST")); break;
d1168 1
a1168 3
          mkdec(actcmd, (desc *)pop(W), ST_W, 0);
          push(W, el);
          lnode((desc *)el, refcnt) += 1;
d1175 1
a1175 2
          /* remove frame from stack R, decrement refenrece count
           * of all non-dummy entries
a1177 3
          for(i = 0; i < GETORDERARGS(actcmd, n); i++)
            if (peek(R, i) > lastcmd)
              mkdec(actcmd, (desc *)peek(R, i), ST_R, i);
d1181 1
a1181 2
          /* remove frame from stack W, decrement refenrece count
           * of all non-dummy entries
a1183 3
          for(i = 0; i < GETORDERARGS(actcmd, n); i++)
            if (peek(W, i) > lastcmd)
              mkdec(actcmd, (desc *)peek(W, i), ST_W, i);
a1186 1
          DBUG_PRINT("RIS", ("SAVEBT/STARTSUBL")); break;
d1188 2
a1189 1
          DBUG_PRINT("RIS", ("SAVEBT/STARTSUBL")); break;
d1197 1
d1203 2
a1204 9
          if (GETORDERENTRY(actcmd, command) == tguard) {
            DBUG_PRINT("RIS", ("TGUARD"));
            if ((desc *)top(W))
              mkdec(actcmd, (desc *)pop(W), ST_W, i);
            }
          else
            DBUG_PRINT("RIS", ("ATEND/ATSTART"));
          n = top(A);
          setstack(A) = cpframe(getstack(A), 0);
d1207 6
a1212 2
          setstack(W) = cpframe(getstack(W), 1);
          push(H, (stack)case_done);
d1215 2
a1216 1
          DBUG_PRINT("RIS", ("SAVEPTR")); break;
d1219 1
a1219 4
        if (restypecnt)
          restypecnt--;
        else
          restype = NULL;
d1222 8
@


1.25
log
@fetch fixed
@
text
@d731 1
@


1.24
log
@gamma fixed
some more PM instructions
@
text
@d1024 1
a1024 1
          push(W, (stack)ndesc(TYshared, 0,
@


1.23
log
@bug fix in jcond2
@
text
@d668 1
a668 1
          DBUG_PRINT("RIS", ("GAMMA"));
d673 1
a673 1
            drop(W, GETDESCENTRY(f, nfv));
a787 1
              drop(R, 1);
d1021 6
d1028 17
d1046 7
a1052 1
          yyfail("not implemented yet");
@


1.22
log
@bug fix in freeswt
@
text
@d265 1
a265 1
/* search the addjacent conditional descriptor
d280 14
d617 2
a618 1
           * the second copy is only made if the keep flag is set!
d623 3
a625 2
          if ((fd = searchcond(GETORDERARGS(actcmd, label))) &&
              (GETDESCENTRY(fd, nfv)&0x1)) {
d632 4
a635 1
            push(H, (stack)else_done);
d731 3
a733 2
          /* carry out increments of list elements
           * create list descriptor with ref-count 0
d735 1
a735 1
          DBUG_PRINT("RIS", ("MKLIST"));
d740 11
@


1.21
log
@bug fix for closures
@
text
@d481 12
d498 1
a498 1
          DBUG_PRINT("RIS", ("FREESW_T/FREER"));
@


1.20
log
@mkbclos bug (tilde stack) fixed
@
text
@d683 1
a683 1
          drop(W, GETDESCENTRY(f, nv));
d696 1
a696 1
          drop(W, GETDESCENTRY(f, nv));
@


1.19
log
@1st keepimplicit & isexplicit phase
@
text
@d681 1
a681 1
                mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
@


1.18
log
@insert setref instr & mode handling
@
text
@d287 1
a287 1
  setrefmode refmode = SREFimplicit;
d303 2
a304 2
    refmode = SREFimplicit;
    insert_order_list(new_order(hashsetref, SREFexplicit), GETFIRSTORDER(fun));
d345 1
a345 1
          push(W, (stack)ndesc(TYshared, 1, CLnoref));
d350 1
a350 1
          push(W, (stack)ndesc(TYshared, 1, CLref));
d355 1
a355 1
          push(R, (stack)ndesc(TYshared, 1, CLref));
d360 1
a360 1
          push(R, (stack)ndesc(TYshared, 1, CLref));
d365 2
a366 1
          push(R, peek(A, GETORDERARGS(actcmd, n)+1)); lnode((desc *)top(R), refcnt) += 1;
d371 2
a372 1
          push(W, peek(A, GETORDERARGS(actcmd, n)+1)); lnode((desc *)top(W), refcnt) += 1;
d377 2
a378 1
          push(R, peek(T, GETORDERARGS(actcmd, n)+1)); lnode((desc *)top(R), refcnt) += 1;
d383 2
a384 1
          push(W, peek(T, GETORDERARGS(actcmd, n)+1)); lnode((desc *)top(W), refcnt) += 1;
d414 54
d487 4
a490 3
          for(i = 0; i < GETORDERARGS(actcmd, n); i++)
            if ((desc *)peek(R, i))
              mkdec(actcmd, (desc *)peek(R, i), ST_R, i);
d493 13
d547 10
a556 7
          for(i = 0; i < n; i++)
            mkdec(cmd, (desc *)peek(W, i), ST_W, i);
          insert_order_list(new_order(freew, n), cmd);
          insert_order_list(new_order(pushaux), cmd);
          drop(W, n);
          push(W, (stack)ndesc(TYdetructive, 0,
               (restype ? convtype(GETORDERARGS(restype, argtp)[0]) : CLtest)));
d639 3
a641 2
            for(i = 0; i < GETDESCENTRY(f,nv); i++)
              mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
d657 3
a659 2
            for(i = 0; i < GETDESCENTRY(f,nv); i++)
              mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
d674 3
a676 2
          for(i = 0; i < GETORDERARGS(actcmd, n); i++)
            mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
d679 3
a681 2
            for(i = 0; i < GETORDERARGS(actcmd, k); i++)
              mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
d693 3
a695 2
          for(i = 0; i < GETORDERARGS(actcmd, n); i++)
            mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
d704 3
a706 2
          for(i = 0; i < GETORDERARGS(actcmd, n); i++)
            mkinc(actcmd, (desc *)peek(W, i), ST_W, i);
a714 1
          mkinc(actcmd, (desc *)peek(W, 0), ST_W, 0);
d716 2
d733 2
a734 1
          mkinc(actcmd, (desc *)peek(W, 0), ST_W, 0);
d828 18
d848 2
a850 1
                case SREFexplicit:
d854 4
a857 1
                  yywarn("missing: full synchronisation");
d860 1
a860 2
                default:
                  yywarn("RIS: unknown mode found");
d866 1
d868 2
a869 1
                  insert_order_list(new_order(hashsetref, SREFexplicit), cmd);
d871 1
a871 1
                  refmode = SREFexplicit;
d875 1
a875 2
                default:
                  yywarn("RIS: unknown mode found");
a877 2
            case SREFimplicit:
              break;
a880 4
              


          refmode = GETORDERARGS(actcmd, n);
@


1.17
log
@improved multi thread conditional return
@
text
@d287 1
d303 2
a306 3
/* !!!
    insert_order_list(new_order(hashsetref, 1), cmd);
*/
d740 42
@


1.16
log
@label ID integration
@
text
@d511 2
a512 2
          /* make two copies the actual argument frame
           * (each requires a baackup copy),
d516 1
d523 1
d527 1
a527 1
            /* merge three results to one
d656 1
a656 1
              drop(A, (int)top(A)+1); freeframe(A, actcmd);
d684 1
a684 1
              drop(A, (int)top(A)+1); freeframe(A, actcmd);
@


1.15
log
@keep flag for jcond2 inspected
@
text
@d633 1
a633 1
          if (strncmp(GETORDERARGS(actcmd, label), "cont_", 5) == 0) {
d742 1
a742 1
              && (strncmp(GETORDERARGS(actcmd, label), "cont_", 5) == 0)) {
d749 2
a750 2
              && ((strncmp(GETORDERARGS(actcmd, label), "undecided_", 10) == 0)
                 || (strncmp(GETORDERARGS(actcmd, label), "fail_", 5) == 0))) {
@


1.14
log
@multi increment & multiple freeframe -> drop + freeframe
@
text
@d265 15
d304 3
d495 1
d506 1
d517 1
d520 8
a527 2
          for(i = 2*n+1; i >= 0; i--) {
            el = peek(A, 2*n+1); push(A, el);
a528 3
          /* merge three results to one
           */
          push(H, (stack)else_done);
@


1.13
log
@pushr, bug in cmpres & jcond
@
text
@d77 2
a78 1
      yyfail("multi increment not implemented yet");
d232 1
d630 1
a630 1
              freeframe(A, actcmd); freeframe(A, actcmd);
d658 1
a658 1
              freeframe(A, actcmd); freeframe(A, actcmd);
d720 1
a720 2
/* ???? */
            freeframe(A, actcmd); freeframe(A, actcmd);
@


1.12
log
@tail same as beta
@
text
@a259 1
  drop(S, 1);
d328 1
a328 1
          /* boced object; needs reference counting */
d333 1
a333 1
          /* boced object; needs reference counting */
d337 5
a475 1
          push(H, (stack)cond_done);
d718 1
@


1.11
log
@PM
additional help stack
@
text
@d543 1
@


1.10
log
@cond-jump construct integrated
@
text
@d15 1
a15 1
astack(W); astack(A); astack(R); astack(T);
d36 12
a47 8
      switch((doneid)peek(S, i)) {
        case null:      fprintf(stderr, "(null) "); break;
        case cond_done: fprintf(stderr, "cond_done "); break;
        case then_done: fprintf(stderr, "then_done "); break;
        case else_done: fprintf(stderr, "else_done "); break;
        case func_done: fprintf(stderr, "func_done "); break;
        default: fprintf(stderr, "**%d** ", peek(S, i));
        }
d53 4
a56 4
      fprintf(stderr, "%p(%c%d%c) ", p,
        (rnode(p,type) == TYshared ? '-' : '+'),
        rnode(p, refcnt),
        (rnode(p,mode) == CLnoref ? 'n' : rnode(p,mode) == CLref ? 'r' : 't'));
d70 3
d93 1
d98 1
d108 3
d129 1
d133 1
d159 3
a161 1
 * size of frame is found as top element of stack
d163 1
a163 1
 * afterwards copy all references 
d165 1
a165 1
static stack * cpframe(stack * s)
d167 2
a168 2
  int i, n;
  desc * p;
d173 7
a179 1
  n = peek(S, 0);
d181 15
a195 3
    p = (desc *)peek(S, n);
    push(S, (stack)ndesc(rnode(p, type), rnode(p, refcnt), rnode(p, mode)));
    lnode(p, prev) = NULL;
d197 1
a197 1
  push(S, n);
d202 3
a204 1
  push(S, n);
d211 1
a211 1
static stack * restoreframe(stack * s)
d219 4
a222 1
  n = peek(S, 0);
d224 8
a231 26
    p = (desc *)peek(S, n);
    q = (desc *)peek(S, 2*n+1);
    lnode(q, type) = rnode(p, type);
    lnode(q, refcnt) = rnode(p, refcnt);
    lnode(q, mode) = rnode(p, mode);
    }
  drop(S, n+1);
  push(S, 0);
  DBUG_RETURN(getstack(S));
  }

/* restore argument frame from copy after completing
 * second alternative of conditional
 * (only if frame is used for further instructions!)
 */
static stack * clearframe(stack * s)
  {
  int i, n;
  astack(S);

  DBUG_ENTER("clearframe");
  setstack(S) = s;
  n = peek(S, 0);
  for(i = 0; i < n;  i++) {
    lnode((desc *)peek(S, 2*n+1), type) = TYshared;
    /* lnode(q, refcnt), lnode(q, mode) is not changed */ 
d233 2
a234 2
  drop(S, n+1);
  push(S, 0);
d249 1
a249 1
  p = (desc *)pop(W); q = (desc *)pop(W);
d252 1
a252 1
  push(W, (stack)ndesc(
d281 3
d288 1
a288 1
    DBUG_PRINT("RIS", ("installing argument frame: %d arg(s), %d tilde arg(s)",
d290 3
a292 3
    for(i = 0; i < GETDESCENTRY(GETDESC(fun), nv); i++)
      if (GETDESCENTRY(GETDESC(fun), tag) == DT_CASE)
        /* PM abstractions expect arguments on stack W! */
d294 3
a296 1
      else
d298 1
d300 2
a301 1
    push(A, GETDESCENTRY(GETDESC(fun), nv));
d307 1
a307 1
    push(R, func_done);
d315 1
d325 1
a325 1
          DBUG_PRINT("RIS", ("  PUSHCW_B/PUSHCW_I/PUSHCW_PF"));
d330 1
a330 1
          DBUG_PRINT("RIS", ("  PUSHW_P"));
d335 1
a335 1
          DBUG_PRINT("RIS", ("  PUSH_R"));
d340 2
a341 2
          DBUG_PRINT("RIS", ("  PUSH_AR"));
          push(R, peek(A, GETORDERARGS(actcmd, n)+1)); lnode((desc *)top(R), refcnt)++;
d345 2
a346 2
          DBUG_PRINT("RIS", ("  PUSH_AW"));
          push(W, peek(A, GETORDERARGS(actcmd, n)+1)); lnode((desc *)top(W), refcnt)++;
d350 2
a351 2
          DBUG_PRINT("RIS", ("  PUSH_TR"));
          push(R, peek(T, GETORDERARGS(actcmd, n)+1)); lnode((desc *)top(R), refcnt)++;
d355 2
a356 2
          DBUG_PRINT("RIS", ("  PUSH_TW"));
          push(W, peek(T, GETORDERARGS(actcmd, n)+1)); lnode((desc *)top(W), refcnt)++;
d362 1
a362 1
          DBUG_PRINT("RIS", ("  MOVEAR"));
d369 1
a369 1
          DBUG_PRINT("RIS", ("  MOVEAW"));
d376 1
a376 1
          DBUG_PRINT("RIS", ("  MOVETR"));
d383 1
a383 1
          DBUG_PRINT("RIS", ("  MOVETW"));
d390 1
a390 1
          DBUG_PRINT("RIS", ("  FREEA"));
d392 2
a393 1
            mkdec(actcmd, (desc *)peek(A, i+1), ST_A, i);
d404 1
a404 1
          DBUG_PRINT("RIS", ("  FREESW_T/FREER"));
d406 2
a407 1
            mkdec(actcmd, (desc *)peek(R, i), ST_R, i);
d411 1
a411 1
          DBUG_PRINT("RIS", ("  EXT"));
d419 1
a419 1
          DBUG_PRINT("RIS", ("  END"));
d421 2
a422 2
          if ((doneid)top(R) == func_done)
            drop(R, 1);
d450 1
a450 1
          DBUG_PRINT("RIS", ("  DELTA%d", n));
d465 1
a465 1
          DBUG_PRINT("RIS", ("  JCOND/JTRUE/JFALSE"));
d471 3
a473 3
          setstack(A) = cpframe(getstack(A));
          push(R, (stack)cond_done);
          push(R, (stack)then_done);
d485 3
a487 2
          DBUG_PRINT("RIS", ("  JCOND2/JTRUE2/JFALSE2"));
          /* make three copies the actual argument frame,
d493 1
a493 1
          setstack(A) = cpframe(getstack(A));
d499 2
a500 2
          push(R, (stack)else_done);
          push(R, (stack)then_done);
d515 1
a515 1
          DBUG_PRINT("RIS", ("  GAMMA"));
d531 1
a531 1
          DBUG_PRINT("RIS", ("  GAMMA"));
d547 1
a547 1
          DBUG_PRINT("RIS", ("  BETA"));
d564 1
a564 1
          DBUG_PRINT("RIS", ("  MKBCLOS/MKDCLOS/MKGACLOS"));
d567 2
a568 1
          if (ISASM_TILDE())
d571 1
d581 1
a581 1
          DBUG_PRINT("RIS", ("  APPLY/MKAP/MKDCLOS"));
d591 1
a591 1
          DBUG_PRINT("RIS", ("  MKLIST"));
d601 1
a601 1
          DBUG_PRINT("RIS", ("  JUMP"));
d605 2
a606 3
            setstack(A) = restoreframe(getstack(A));
            drop(A, 1);
            drop(R, 1);
d610 1
a610 1
          DBUG_PRINT("RIS", ("  RTM + "));
d618 1
a618 1
          DBUG_PRINT("RIS", ("  RTF"));
d621 1
a621 1
          switch((doneid)top(R)) {
d625 6
a630 1
              setstack(W) = cmpres(getstack(W)); drop(R, 1);
d633 1
a633 1
              setstack(A) = restoreframe(getstack(A)); drop(A, 1); drop(R, 1); break;
d635 1
a635 1
              setstack(W) = cmpres(getstack(W)); drop(R, 1); break;
d646 1
a646 1
          DBUG_PRINT("RIS", ("  RTC/RTP"));
d650 1
a650 1
          switch((doneid)top(R)) {
d653 1
a653 1
              setstack(W) = cmpres(getstack(W)); drop(R, 1);
d655 4
d660 1
a660 1
              setstack(A) = restoreframe(getstack(A)); drop(A, 1); drop(R, 1); break;
d662 1
a662 1
              setstack(W) = cmpres(getstack(W)); drop(R, 1); break;
d671 1
a671 1
          DBUG_PRINT("RIS", ("  %s", GETORDERARGS(actcmd, hash_str)));
d673 1
a673 1
          DBUG_PRINT("RIS", ("replace argument frame on argument stack A"));
d688 1
a688 1
          DBUG_PRINT("RIS", ("  %s", GETORDERARGS(actcmd, hash_str)));
d690 1
a690 1
          DBUG_PRINT("RIS", ("replace argument frame on argument stack T"));
d705 2
a706 2
          DBUG_PRINT("RIS", ("  %s", GETORDERARGS(actcmd, hash_str)));
          DBUG_PRINT("RIS", ("got return type %d", GETORDERARGS(actcmd, argtp)[0]));
d710 2
a711 3
          DBUG_PRINT("RIS",("%s:", GETORDERARGS(actcmd, label)));
          mkinc(actcmd, (desc *)peek(W, 0), ST_W, 0);
          if ((top(R) == (doneid)else_done)
d713 1
d716 9
a724 1
            drop(R, 1);
d731 1
a731 7
          DBUG_PRINT("RIS", ("  ADVANCE"));
          break;
        case atend:
        case atstart:
          DBUG_PRINT("RIS", ("  ATEND/ATSTART"));
          yyfail("not implemented yet");
          break;
d736 4
a739 3
          DBUG_PRINT("RIS", ("  BIND"));
          mkdec(actcmd, (desc *)peek(W, GETORDERARGS(actcmd, n)+1),
              ST_W, GETORDERARGS(actcmd, n));
d741 1
a741 1
          lnode((desc *)top(W), refcnt)++;
d744 8
d753 8
d763 1
a763 1
          DBUG_PRINT("RIS", ("  CASE"));
d775 7
a781 1
        case drop:
d783 16
a798 2
          DBUG_PRINT("RIS", ("  DROP"));
          mkdec(actcmd, (desc *)pop(W), ST_W, 0);
d800 1
d803 2
d808 1
d817 6
d824 5
a828 9
          /* encountered embedded conditional
           */
          DBUG_PRINT("RIS", ("  MATCH*"));
          /* copy the actual argument frame. upon leaving one alternative
           * all modifications on stack objects can be undone
           */
          setstack(A) = cpframe(getstack(A));
          for(i = 0; i < 2*n+2; i++) {
            el = peek(A, 2*n+2); push(A, el);
d830 2
a831 8
          /* merge three results to one
           */
          push(R, (stack)cond_done);
          push(R, (stack)cond_done);
          push(R, (stack)else_done);
          push(R, (stack)then_done);
          /* no reference count corrections required this is implicitly
           * done by cond or not necessary in case of typed conditional
d833 6
a838 1
          drop(W, 1);
d842 3
a844 2
          /* allocate a new Frame on stack A and fill it with dumm values */
          DBUG_PRINT("RIS", ("  MKAFRAME"));
d847 1
a847 1
          push(A, GETORDERARGS(actcmd, n));
d850 5
d856 17
a872 2
        case mkwframe:
          yyerror("mkwframe ignored");
d874 12
a885 1
        case pick:
d888 1
d890 9
d900 9
d910 1
a910 1
        case saveptr:
d912 1
d914 27
@


1.9
log
@mk*clos etc integrated
@
text
@d37 1
a87 1
    lnode(p, refcnt) = 0;
d89 1
d196 21
d267 6
a272 1
      push(A, (stack)ndesc(TYshared, 0, CLtest));
d424 1
a426 1
          drop(W, n);
d435 4
a438 2
          /* copy the actual argument frame. upon leaving one alternative
           * all modifications on stack objects can be undone
d455 4
a458 2
          /* copy the actual argument frame. upon leaving one alternative
           * all modifications on stack objects can be undone
d460 1
d462 2
a463 2
          for(i = 0; i < 2*n+2; i++) {
            el = peek(A, 2*n+2); push(A, el);
a466 2
          push(R, (stack)cond_done);
          push(R, (stack)cond_done);
d564 1
a564 1
          /* handled similarily to reurn instruction
d567 9
a575 3
          DBUG_PRINT("RIS", ("  GOTO"));
          if (strncmp(GETORDERARGS(actcmd, label), "cont_", 5))
            break;
d577 1
a577 1
          DBUG_PRINT("RIS", ("  RTM"));
d585 1
a585 2
          DBUG_PRINT("RIS", ("  + RTF"));
          mkinc(actcmd, (desc *)peek(W, 0), ST_W, 0);
d589 1
d591 3
d599 3
d608 1
a608 1
          DBUG_PRINT("RIS", ("  + RTC/RTP"));
d614 3
d622 3
d669 92
d762 14
@


1.8
log
@bug fix
@
text
@d425 1
a425 1
          DBUG_PRINT("RIS", ("  JCOND/JTRUE/JFALSE"));
d495 27
@


1.7
log
@conditionals integrated
@
text
@d433 3
@


1.6
log
@delta, gamma(beta), hash*
@
text
@d15 2
d23 32
a54 22
 {
 int i, j = 0;
 desc * p;
 const astack(S);

 setstack(S) = s;
 fprintf(stderr, "%s: ", str);
 for(i = 0; peek(S, i) != BOTTOM; i++)
   if (m && (j == 0)) {
     j = peek(S, i);
     fprintf(stderr, "#%d ", j);
     }
   else {
     p = (desc *)peek(S, i);
     j--;
     fprintf(stderr, "%p(%c%d%c) ", p,
       (rnode(p,type) == TYshared ? '-' : '+'),
       rnode(p, refcnt),
       (rnode(p,mode) == CLnoref ? 'n' : rnode(p,mode) == CLref ? 'r' : 't'));
     }
 fprintf(stderr, "\n");
 }
d143 78
a231 1
  astack(W); astack(A); astack(R); astack(T);
d252 1
d363 4
d408 10
a417 1
          yyfail("still missing jcond/jtrue/jfalse");
d421 2
a422 1
        case jfalse2:
d425 15
a439 2
          DBUG_PRINT("RIS", ("  JCOND2/JTRUE2/JFALSE2"));
          yyfail("still missing jcond2/jtrue2/jfalse2");
d441 1
d503 10
d519 2
a520 1
          DBUG_PRINT("RIS", ("  RTF"));
d523 8
a534 3
          DBUG_PRINT("RIS", ("  RTC"));
          freeframe(A, actcmd);
          break;
d536 3
a538 1
          DBUG_PRINT("RIS", ("  RTP"));
d540 8
a548 5
        case rtm:
          DBUG_PRINT("RIS", ("  RTM"));
          mkinc(actcmd, (desc *)peek(A, 1), ST_A, 0);
          freeframe(A, actcmd);
          break;
d588 3
@


1.5
log
@types, gamma, delta
@
text
@d86 1
a86 1
  if ((rnode(p, refcnt) > 0) && (rnode(p, mode) != CLnoref))
d102 1
a102 1
    insert_order_list(new_order(cmdid, off, rnode(p, refcnt)), cmd);
d105 2
d195 1
a195 1
          push(R, peek(A, GETORDERARGS(actcmd, n+1))); lnode((desc *)top(R), refcnt)++;
d200 1
a200 1
          push(W, peek(A, GETORDERARGS(actcmd, n+1))); lnode((desc *)top(W), refcnt)++;
d205 1
a205 1
          push(R, peek(T, GETORDERARGS(actcmd, n+1))); lnode((desc *)top(R), refcnt)++;
d210 1
a210 1
          push(W, peek(T, GETORDERARGS(actcmd, n+1))); lnode((desc *)top(W), refcnt)++;
d240 22
d298 1
d305 18
d324 1
d327 3
a329 2
          /* increment reference count for all tilde arguments (if necessary)
           * and create non updateable entry  for result with inferred
d334 18
a351 2
            for(i = GETDESCENTRY(f,nfv)-1; i >= 0; i--)
              mkinc(actcmd, (desc *)peek(R, i), ST_R, i);
d366 1
a366 1
            for(i = GETDESCENTRY(f,nv)-1; i >= 0; i--)
d396 2
d410 19
a428 1
        case hash:
d431 18
a448 20
          if (strncmp(str, "#args", 5) == 0) {
            /* replace argument frame on argument stack A */
            DBUG_PRINT("RIS", ("replace argument frame on argument stack A"));
            if (GETORDERARGS(actcmd, n) == top(A))
              for(i = 0; i < GETORDERARGS(actcmd, n); i++) {
                DBUG_PRINT("RIS", ("  type %d->%d",
                    GETORDERARGS(actcmd, argtp)[i],
                    convtype(GETORDERARGS(actcmd, argtp)[i])));
                lnode((desc *)peek(A, i+1), mode) =
                    convtype(GETORDERARGS(actcmd, argtp)[i]);
                }
            else
              yyerror("illegal number of arguments on stack A (%d should be %d)",
                top(A), GETORDERARGS(actcmd, n));
            }
          else if (strncmp(str, "#restype", 8) == 0) {
            /* store type for later use */
            DBUG_PRINT("RIS", ("got return type %d", GETORDERARGS(actcmd, argtp)[0]));
            restype = actcmd; restypecnt = 1;
            }
@


1.4
log
@mklist
@
text
@d20 1
a20 1
static void prstack(char * str, stack * s, int m)
d24 1
a24 1
 astack(S);
d49 1
a49 1
void mkinc(ORDER * cmd, desc * p, const stackid stid, const int off)
d61 1
a61 15
        case ST_A:
          if (rnode(p, mode) == CLref)
            cmdid = inca; else cmdid = tinca;
          break;
        case ST_R:
          if (rnode(p, mode) == CLref)
            cmdid = incr; else cmdid = tincr;
          break;
        case ST_T:
          if (rnode(p, mode) == CLref)
            cmdid = inct; else cmdid = tinct;
          break;
        case ST_W:
          if (rnode(p, mode) == CLref)
            cmdid = incw; else cmdid = tincw;
d63 6
d79 29
a107 2
/* return the type class CLref/CLnoref/CLtest
 * of an function call
d110 1
a110 1
typeclass getresclass(ORDER * cmd)
d112 15
a126 2
  cmd = GETPREVORDER(cmd);
  return(CLtest);
d135 2
a136 1
  int i;
d138 1
a138 1
  ORDER * cmd, * actcmd;
d161 1
d177 1
a177 1
          DBUG_PRINT("RIS", ("PUSHCW_B/PUSHCW_I/PUSHCW_PF"));
d182 1
a182 1
          DBUG_PRINT("RIS", ("PUSHW_P"));
d187 1
a187 1
          DBUG_PRINT("RIS", ("PUSH_R"));
d193 1
a193 1
          push(R, peek(A, actcmd->args.n+1)); lnode((desc *)top(R), refcnt)++;
d198 1
a198 1
          push(W, peek(A, actcmd->args.n+1)); lnode((desc *)top(W), refcnt)++;
d203 1
a203 1
          push(R, peek(T, actcmd->args.n+1)); lnode((desc *)top(R), refcnt)++;
d208 1
a208 1
          push(W, peek(T, actcmd->args.n+1)); lnode((desc *)top(W), refcnt)++;
d214 1
a214 1
          DBUG_PRINT("RIS", ("MOVEAR"));
d221 1
a221 1
          DBUG_PRINT("RIS", ("MOVEAW"));
d228 1
a228 1
          DBUG_PRINT("RIS", ("MOVETR"));
d235 1
a235 1
          DBUG_PRINT("RIS", ("MOVETW"));
d239 1
a239 1
          DBUG_PRINT("RIS", ("EXT"));
d244 2
a245 1
          /* release argument frame on stack A and T
d247 1
a247 1
          DBUG_PRINT("RIS", ("END"));
d250 48
d300 1
a300 1
           * and create non updateable entry  for result with infered
d303 1
a303 1
          DBUG_PRINT("RIS", ("BETA"));
d307 3
a309 2
            drop(W, f->nv);
            push(W, (stack)ndesc(TYshared, 0, getresclass(actcmd)));
d318 2
a319 2
          DBUG_PRINT("RIS", ("MKLIST"));
          for(i = 0; i < actcmd->args.n; i++)
d321 1
a321 1
          drop(W, actcmd->args.n);
d330 2
a331 2
          DBUG_PRINT("RIS", ("RTF"));
          mkinc(cmd, (desc *)peek(W, 0), ST_W, 0);
d335 1
a335 1
          DBUG_PRINT("RIS", ("RTC"));
d339 1
a339 1
          DBUG_PRINT("RIS", ("RTP"));
d343 1
a343 1
          DBUG_PRINT("RIS", ("RTM"));
d347 24
d373 4
@


1.3
log
@simple instructions (incl. beta) work
@
text
@d230 10
d247 3
a249 1
          mkinc(cmd, (desc *)peek(A, 1), ST_W, 0);
d251 3
a253 2
          if (GETORDERENTRY(actcmd, command) == rtc)
            DBUG_PRINT("RIS", ("RTC"));
d255 3
a257 2
          if (GETORDERENTRY(actcmd, command) == rtp)
            DBUG_PRINT("RIS", ("RTP"));
d259 2
a260 4
          if (GETORDERENTRY(actcmd, command) == rtm) {
            DBUG_PRINT("RIS", ("RTM"));
            mkinc(actcmd, (desc *)peek(A, 1), ST_A, 0);
            }
@


1.2
log
@*** empty log message ***
@
text
@d2 1
d7 1
d15 82
d103 1
d105 2
a106 1
  ORDER * cmd, * p;
d110 5
a114 5
  initstack(W, STACKSIZE);
  initstack(A, STACKSIZE);
  initstack(R, STACKSIZE);
  initstack(T, STACKSIZE);
  push(A, (stack)0);
d116 12
d129 8
a136 1
      p = cmd;
d138 1
a138 1
      switch(p->command) {
d142 1
d144 1
a144 1
          push(W, (stack)ndesc(TYnoupdate, 1, CLnoref));
a145 1
        case pushw:
d147 23
a169 2
          DBUG_PRINT("RIS", ("PUSHW/PUSHW_P"));
          push(W, (stack)ndesc(TYnoupdate, 1, CLref));
d171 33
d206 1
d210 40
d251 1
a251 1
        default: yyfail("internal error: illegal order received");
@


1.1
log
@Initial revision
@
text
@d1 2
d4 6
d13 4
d19 37
a55 1
  return 0;
@
