head	1.72;
access;
symbols;
locks; strict;
comment	@ * @;


1.72
date	97.02.18.14.46.39;	author stt;	state Exp;
branches;
next	1.71;

1.71
date	96.05.09.12.41.00;	author stt;	state Exp;
branches;
next	1.70;

1.70
date	96.05.08.16.51.58;	author cr;	state Exp;
branches;
next	1.69;

1.69
date	96.04.11.13.07.16;	author cr;	state Exp;
branches;
next	1.68;

1.68
date	96.02.28.08.07.54;	author um;	state Exp;
branches;
next	1.67;

1.67
date	96.02.23.14.10.32;	author rs;	state Exp;
branches;
next	1.66;

1.66
date	96.02.21.15.49.42;	author car;	state Exp;
branches;
next	1.65;

1.65
date	96.02.21.14.44.17;	author car;	state Exp;
branches;
next	1.64;

1.64
date	96.02.20.15.45.10;	author stt;	state Exp;
branches;
next	1.63;

1.63
date	96.02.20.12.55.56;	author cr;	state Exp;
branches;
next	1.62;

1.62
date	96.02.15.16.52.23;	author cr;	state Exp;
branches;
next	1.61;

1.61
date	96.02.15.16.31.13;	author car;	state Exp;
branches;
next	1.60;

1.60
date	96.02.13.17.26.35;	author stt;	state Exp;
branches;
next	1.59;

1.59
date	96.02.13.15.39.08;	author stt;	state Exp;
branches;
next	1.58;

1.58
date	96.02.07.17.52.10;	author rs;	state Exp;
branches;
next	1.57;

1.57
date	95.08.02.09.48.28;	author sf;	state Exp;
branches;
next	1.56;

1.56
date	95.07.26.14.34.37;	author sf;	state Exp;
branches;
next	1.55;

1.55
date	95.07.11.15.07.35;	author sf;	state Exp;
branches;
next	1.54;

1.54
date	95.07.11.14.43.12;	author sf;	state Exp;
branches;
next	1.53;

1.53
date	95.07.10.15.54.29;	author sf;	state Exp;
branches;
next	1.52;

1.52
date	95.07.07.08.21.20;	author car;	state Exp;
branches;
next	1.51;

1.51
date	95.07.04.14.41.48;	author sf;	state Exp;
branches;
next	1.50;

1.50
date	95.07.04.11.45.06;	author sf;	state Exp;
branches;
next	1.49;

1.49
date	95.06.07.07.50.18;	author um;	state Exp;
branches;
next	1.48;

1.48
date	95.06.02.12.00.15;	author sf;	state Exp;
branches;
next	1.47;

1.47
date	95.05.31.12.57.54;	author sf;	state Exp;
branches;
next	1.46;

1.46
date	95.05.12.11.52.54;	author sf;	state Exp;
branches;
next	1.45;

1.45
date	95.05.12.09.39.44;	author sf;	state Exp;
branches;
next	1.44;

1.44
date	95.05.03.12.40.02;	author sf;	state Exp;
branches;
next	1.43;

1.43
date	95.05.02.11.42.59;	author cr;	state Exp;
branches;
next	1.42;

1.42
date	95.04.26.07.10.34;	author sf;	state Exp;
branches;
next	1.41;

1.41
date	95.04.24.06.48.20;	author car;	state Exp;
branches;
next	1.40;

1.40
date	95.04.21.08.29.56;	author car;	state Exp;
branches;
next	1.39;

1.39
date	95.04.20.09.58.53;	author car;	state Exp;
branches;
next	1.38;

1.38
date	95.04.12.13.30.07;	author sf;	state Exp;
branches;
next	1.37;

1.37
date	95.04.12.06.51.37;	author sf;	state Exp;
branches;
next	1.36;

1.36
date	95.04.06.16.10.10;	author car;	state Exp;
branches;
next	1.35;

1.35
date	95.04.05.15.48.59;	author sf;	state Exp;
branches;
next	1.34;

1.34
date	95.04.05.15.46.19;	author sf;	state Exp;
branches;
next	1.33;

1.33
date	95.04.03.13.26.01;	author sf;	state Exp;
branches;
next	1.32;

1.32
date	95.03.29.16.13.01;	author cr;	state Exp;
branches;
next	1.31;

1.31
date	95.03.27.11.45.05;	author car;	state Exp;
branches;
next	1.30;

1.30
date	95.03.27.09.02.14;	author car;	state Exp;
branches;
next	1.29;

1.29
date	95.03.24.11.01.31;	author car;	state Exp;
branches;
next	1.28;

1.28
date	95.03.23.15.08.11;	author car;	state Exp;
branches;
next	1.27;

1.27
date	95.03.23.14.08.56;	author car;	state Exp;
branches;
next	1.26;

1.26
date	95.03.22.17.48.27;	author cr;	state Exp;
branches;
next	1.25;

1.25
date	95.03.22.15.38.21;	author car;	state Exp;
branches;
next	1.24;

1.24
date	95.03.14.12.31.54;	author car;	state Exp;
branches;
next	1.23;

1.23
date	95.03.13.14.43.07;	author sf;	state Exp;
branches;
next	1.22;

1.22
date	95.03.08.13.16.41;	author sf;	state Exp;
branches;
next	1.21;

1.21
date	95.03.03.17.51.47;	author car;	state Exp;
branches;
next	1.20;

1.20
date	95.02.14.09.53.40;	author car;	state Exp;
branches;
next	1.19;

1.19
date	95.02.13.16.28.27;	author car;	state Exp;
branches;
next	1.18;

1.18
date	95.02.03.12.03.04;	author car;	state Exp;
branches;
next	1.17;

1.17
date	95.02.03.07.41.06;	author car;	state Exp;
branches;
next	1.16;

1.16
date	95.01.31.12.29.56;	author car;	state Exp;
branches;
next	1.15;

1.15
date	95.01.05.17.23.40;	author car;	state Exp;
branches;
next	1.14;

1.14
date	94.12.27.14.46.23;	author car;	state Exp;
branches;
next	1.13;

1.13
date	94.12.08.15.43.28;	author sf;	state Exp;
branches;
next	1.12;

1.12
date	94.12.08.15.14.42;	author um;	state Exp;
branches;
next	1.11;

1.11
date	94.12.08.09.32.28;	author car;	state Exp;
branches;
next	1.10;

1.10
date	94.12.01.10.56.38;	author car;	state Exp;
branches;
next	1.9;

1.9
date	94.11.28.12.53.53;	author car;	state Exp;
branches;
next	1.8;

1.8
date	94.11.28.11.20.26;	author sf;	state Exp;
branches;
next	1.7;

1.7
date	94.11.25.17.29.18;	author car;	state Exp;
branches;
next	1.6;

1.6
date	94.11.24.14.48.34;	author car;	state Exp;
branches;
next	1.5;

1.5
date	94.11.23.15.53.44;	author car;	state Exp;
branches;
next	1.4;

1.4
date	94.11.23.07.35.18;	author car;	state Exp;
branches;
next	1.3;

1.3
date	94.11.22.10.50.37;	author car;	state Exp;
branches;
next	1.2;

1.2
date	94.11.21.16.15.26;	author car;	state Exp;
branches;
next	1.1;

1.1
date	94.11.21.07.51.39;	author car;	state Exp;
branches;
next	;


desc
@initial incomplete version
@


1.72
log
@item ia_fscanf replaced by item ia_fredirect
@
text
@%{
extern int lineno;              /* aus tasmt2c.y */
#include <math.h>               /* fuer den atof()-Call */
#include <string.h>
#include <ctype.h>
#include "mytypes.h"
#include "tasm2c.tab.h"
#include "error.h"
int isatty();
static int atox(const char *);
static int str2type(char *);
%}

DIGIT    [0-9]
SIGN     [-+]
HASHME   [A-Z a-z0-9]*
ID       [A-Za-z][A-Za-z0-9]*
LABELC   [A-Za-z0-9][_A-Za-z0-9]+
OPTTYPES (\.[?a-z$]*)?
HEXA     [a-fA-F0-9]*
OCTAL    \\[0-7][0-7][0-7]
MODULE   (M[A-Za-z0-9]+_)


%%
-?{DIGIT}+                      {yylval.intv=atoi(yytext); return(INTV);}
{SIGN}{DIGIT}+"."{DIGIT}*       {yylval.realv=atof(yytext); return(REALV);}
{SIGN}{DIGIT}+"."{DIGIT}+"e"{SIGN}{DIGIT}+ {yylval.realv=atof(yytext); return(REALV);}
{SIGN}{DIGIT}+"e"{SIGN}{DIGIT}+ {yylval.realv=atof(yytext); return(REALV);}
"'"."'"                         {yylval.intv=yytext[1]; return SELEM;}
"'"\\n"'"                       {yylval.intv=(int)'\n'; return SELEM;}
"'"\\t"'"                       {yylval.intv=(int)'\t'; return SELEM;}
"'"{OCTAL}"'"                   {yylval.intv=(int)strtol(yytext+2,NULL,8);
                                 return SELEM;}
\"[^"]*\"                       {yylval.helpstring=malloc(strlen(yytext)-1);
                                 if (NULL==yylval.helpstring)
                                   yyfail("%s","Couldn't allocate memory !");
                                 strncpy(yylval.helpstring,&yytext[1],strlen(yytext)-2);
				 yylval.helpstring[strlen(yytext)-2] = '\0';
                                 return CLIST;
                                }
[pP]ush_w                         {return PUSHW;}
[pP]ushc_w                        {return PUSHCW;}
[pP]ush_aw                        {return PUSHAW;}
[pP]ush_aw0                       {return PUSHAW0;}
[pP]ush_tw                        {return PUSHTW;}
[pP]ush_tw0                       {return PUSHTW0;}
[pP]ush_r                         {return PUSHR;}
[pP]ush_ar                        {return PUSHAR;}
[pP]ush_ar0                       {return PUSHAR0;}
[pP]ush_tr                        {return PUSHTR;}
[pP]ush_tr0                       {return PUSHTR0;}
[pP]ushret                        {return PUSHRET;}
[pP]ushaux                        {return PUSHAUX;}

[mM]ove_aw                        {return MOVEAW;}
[mM]ove_ar                        {return MOVEAR;}
[mM]ove_tw                        {return MOVETW;}
[mM]ove_tr                        {return MOVETR;}

[jJ]false2{OPTTYPES}              {yylval.primf.types=str2type(yytext); return JFALSE2;}
[jJ]true2{OPTTYPES}               {yylval.primf.types=str2type(yytext); return JTRUE2;}
[jJ]cond2{OPTTYPES}               {yylval.primf.types=str2type(yytext); return JCOND2;}
[jJ]false{OPTTYPES}               {yylval.primf.types=str2type(yytext); return JFALSE;}
[jJ]true{OPTTYPES}                {yylval.primf.types=str2type(yytext); return JTRUE;}
[jJ]cond{OPTTYPES}                {yylval.primf.types=str2type(yytext); return JCOND;}
[jJ]ump                           {yylval.primf.types=str2type(yytext); return JUMP;}

[fF]ree_r                         {return FREER;}
[fF]ree1_r                        {return FREE1R;}
[fF]ree_a                         {return FREEA;}
[fF]ree1_a                        {return FREE1A;}
[fF]ree_t                         {return FREET;}
[fF]ree_w                         {return FREEW;}
[fF]reesw_t                       {return FREESWT;}
[fF]ree1sw_t                      {return FREE1SWT;}

[rR]tt                            {return RTT;}
[tT]ail                           {return TAIL;}
[rR]tf                            {return RTF;}
[rR]tm                            {return RTM;}
[rR]tc                            {return RTC;}
[rR]tp                            {return RTP;}
[aA]pply                          {return APPLY;}
[mM]kap                           {return MKAP;}
[mM]klist                         {return MKLIST;}
[mM]kilist                        {return MKILIST;}
[mM]kdclos                        {return MKDCLOS;}
[mM]kiclos                        {return MKICLOS;}
[mM]kcclos                        {return MKCCLOS;}
[mM]kbclos                        {return MKBCLOS;}
[mM]ksclos                        {return MKSCLOS;}
[mM]kgaclos                       {return MKGACLOS;}
[mM]kgsclos                       {return MKGSCLOS;}
[dD]elta1                         {return DELTA1;}
[dD]elta2                         {return DELTA2;}
[dD]elta3                         {return DELTA3;}
[dD]elta4                         {return DELTA4;}
[iI]ntact                         {return INTACT;}
[bB]eta                           {return BETA;}
[bB]etaq                          {return BETA;}
[bB]etaq0                         {return BETA;}
[bB]etaq1                         {return BETA;}
[uU]pdate                         {return BETA0UPDATE;}
[tT]ailq                          {return TAIL;}
[tT]ailq0                         {return TAIL;}
[tT]ailq1                         {return TAIL;}
[gG]amma                          {return GAMMA;}
[gG]ammabeta                      {return GAMMABETA;}

[iI]nca                           {return INCA;}
[iI]ncr                           {return INCR;}
[iI]nct                           {return INCT;}
[iI]ncw                           {return INCW;}
[tT]inca                          {return TINCA;}
[tT]incr                          {return TINCR;}
[tT]inct                          {return TINCT;}
[tT]incw                          {return TINCW;}
[dD]eca                           {return DECA;}
[dD]ecr                           {return DECR;}
[dD]ect                           {return DECT;}
[dD]ecw                           {return DECW;}
[tT]deca                          {return TDECA;}
[tT]decr                          {return TDECR;}
[tT]dect                          {return TDECT;}
[tT]decw                          {return TDECW;}
[kK]illa                          {return KILLA;}
[kK]illr                          {return KILLR;}
[kK]illt                          {return KILLT;}
[kK]illw                          {return KILLW;}
[tT]killa                         {return TKILLA;}
[tT]killr                         {return TKILLR;}
[tT]killt                         {return TKILLT;}
[tT]killw                         {return TKILLW;}

[eE]xt                            {return EXIT;}
[eE]nd                            {return END;}

[aA]dvance                        {return ADVANCE;}
[aA]tend                          {return ATEND;}
[aA]tstart                        {return ATSTART;}
[bB]ackup                         {return BACKUP;}
[bB]ind                           {return BIND;}
[bB]inds                          {return BINDS;}
[bB]indsubl                       {return BINDSUBL;}
[cC]ase                           {return CASE;}
[gG]ammacase                      {return GAMMACASE;}
[dD]ereference                    {return DEREFERENCE;}
[dD]rop                           {return DROP;}
[eE]ndlist                        {return ENDLIST;}
[eE]ndsubl                        {return ENDSUBL;}
[fF]etch                          {return FETCH;}
[iI]nitbt                         {return INITBT;}
[mM]atcharb{OPTTYPES}             {yylval.types=str2type(yytext); return MATCHARB;}
[mM]atcharbs{OPTTYPES}            {yylval.types=str2type(yytext); return MATCHARBS;}
[mM]atchbool{OPTTYPES}            {yylval.types=str2type(yytext); return MATCHBOOL;}
[mM]atchc{OPTTYPES}               {yylval.types=str2type(yytext); return MATCHC;}
[mM]atchfalse{OPTTYPES}           {yylval.types=str2type(yytext); return MATCHFALSE;}
[mM]atchin{OPTTYPES}              {yylval.types=str2type(yytext); return MATCHIN;}
[mM]atchint{OPTTYPES}             {yylval.types=str2type(yytext); return MATCHINT;}
[mM]atchlist{OPTTYPES}            {yylval.types=str2type(yytext); return MATCHLIST;}
[mM]atchnil{OPTTYPES}             {yylval.types=str2type(yytext); return MATCHNIL;}
[mM]atchnils{OPTTYPES}            {yylval.types=str2type(yytext); return MATCHNILS;}
[mM]atchprim{OPTTYPES}            {yylval.types=str2type(yytext); return MATCHPRIM;}
[mM]atchstr{OPTTYPES}             {yylval.types=str2type(yytext); return MATCHSTR;}
[mM]atchtrue{OPTTYPES}            {yylval.types=str2type(yytext); return MATCHTRUE;}
[mM]kaframe                       {return MKAFRAME;}
[mM]kbtframe                      {return MKBTFRAME;}
[mM]kcase                         {return MKCASE;}
[mM]kwframe                       {return MKWFRAME;}
[nN]estlist                       {return NESTLIST;}
[pP]ick                           {return PICK;}
[rR]estorebt                      {return RESTOREBT;}
[rR]estoreptr                     {return RESTOREPTR;}
[rR]mbtframe                      {return RMBTFRAME;}
[rR]mwframe                       {return RMWFRAME;}
[sS]avebt                         {return SAVEBT;}
[sS]aveptr                        {return SAVEPTR;}
[sS]tartsubl                      {return STARTSUBL;}
[tT]guard                         {return TGUARD;}
[mM]kframe                        {return MKFRAME;}
[mM]kslot                         {return MKSLOT;}
[iI]nter                          {return INTER;}
[pP]ushh                          {return PUSHH;}
[cC]ount                          {return COUNT;}
[dD]ist                           {return DIST;}
[dD]istb                          {return DISTB;}
[dD]ist_end                       {return DISTEND;}
[wW]ait                           {return WAIT;}
[pP]oph                           {return POPH;}
[mM]sdistend                      {return MSDISTEND;}
[mM]snodist                       {return MSNODIST;}

real                              {return REAL;}
int                               {return INT;}
char                              {return CHAR;}
digit                             {return DIGIT;}
bool                              {return BOOL;}
string                            {return STRING;}
none                              {return NONE;}

_desc                             {return FUN_DESC;}
0x{HEXA}                          {yylval.intv = atox(yytext);
                                   return HEX_NUM;}
start{DIGIT}*_{LABELC}             {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return GOAL_LABEL;}
{MODULE}start{DIGIT}*_{LABELC}     {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return FUNC_LABEL;}
{MODULE}?func{DIGIT}*_{LABELC}     {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return FUNC_LABEL;}
{MODULE}?jcond{DIGIT}*_{LABELC}    {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return JCOND_LABEL;}
{MODULE}?cond{DIGIT}*_{LABELC}     {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return COND_LABEL;}
{MODULE}?cont{DIGIT}*_{LABELC}     {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return CONT_LABEL;}
{MODULE}?case{DIGIT}*_{LABELC}     {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return CASE_LABEL;}
{MODULE}?when{DIGIT}*_{LABELC}     {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return CASE_LABEL;}
{MODULE}?fail{DIGIT}*_{LABELC}     {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return FAIL_LABEL;}
{MODULE}?undecided{DIGIT}*_{LABELC} {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return UND_LABEL;}
{MODULE}?bt{DIGIT}*_{LABELC}       {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return BT_LABEL;}
{MODULE}?inloop{DIGIT}*_{LABELC}   {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return INLOOP_LABEL;}
{MODULE}?distarg{DIGIT}*_{LABELC}   {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return DISTARG_LABEL;}
{MODULE}?distend{DIGIT}*_{LABELC}   {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
                                   strcpy(yylval.func_lab,yytext);
                                   return DISTEND_LABEL;}
ptd                               {return PTD;}
_real                             {return D_REAL;}
_vect                             {return D_VECT;}
_tvect                            {return D_TVECT;}
_mat                              {return D_MAT;}
_list                             {return D_LIST;}
_str                              {return D_STRING;}
_name                             {return D_NAME;}
TY_INTEGER                        {return TY_INT;}
TY_BOOL                           {return TY_BO;}
TY_REAL                           {return TY_RE;}
TY_UNDEF                          {return TY_UN;}
FUNC                              {return D_FUNC;}
COMB                              {return D_COMB;}
CONDI                             {return D_CONDI;}
CASE                              {return D_CASE;}

true                              {yylval.intv = 1; return TRUE_Y;}
false                             {yylval.intv = 0; return FALSE_Y;}

abs{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return ABS;}
neg{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return NEG;}
not{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return NOT;}
exp{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return EXP;}
ln{OPTTYPES}                      {yylval.primf.types=str2type(yytext); return LN;}
sin{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return SIN;}
cos{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return COS;}
tan{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return TAN;}
floor{OPTTYPES}                   {yylval.primf.types=str2type(yytext); return FLOOR;}
ceil{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return CEIL;}
frac{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return FRAC;}
trunc{OPTTYPES}                   {yylval.primf.types=str2type(yytext); return TRUNC;}
vc_plus{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return VC_PLUS;}
vc_minus{OPTTYPES}                {yylval.primf.types=str2type(yytext); return VC_MINUS;}
vc_mult{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return VC_MULT;}
vc_div{OPTTYPES}                  {yylval.primf.types=str2type(yytext); return VC_DIV;}
vc_min{OPTTYPES}                  {yylval.primf.types=str2type(yytext); return VC_MIN;}
vc_max{OPTTYPES}                  {yylval.primf.types=str2type(yytext); return VC_MAX;}
ldim{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return LDIM;}
vdim{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return VDIM;}
mdim{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return MDIM;}
mdimension{OPTTYPES}              {yylval.primf.types=str2type(yytext); return MDIM;}
class{OPTTYPES}                   {yylval.primf.types=str2type(yytext); return CLASS;}
type{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return TYPE;}
empty{OPTTYPES}                   {yylval.primf.types=str2type(yytext); return EMPTY;}
transpose{OPTTYPES}               {yylval.primf.types=str2type(yytext); return TRANSPOSE;}
reverse{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return REVERSE;}
to_list{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return TO_LIST;}
to_scal{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return TO_SCAL;}
to_vect{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return TO_VECT;}
to_tvect{OPTTYPES}                {yylval.primf.types=str2type(yytext); return TO_TVECT;}
to_mat{OPTTYPES}                  {yylval.primf.types=str2type(yytext); return TO_MAT;}
c_plus{OPTTYPES}                  {yylval.primf.types=str2type(yytext); return C_PLUS;}
c_minus{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return C_MINUS;}
c_mult{OPTTYPES}                  {yylval.primf.types=str2type(yytext); return C_MULT;}
c_div{OPTTYPES}                   {yylval.primf.types=str2type(yytext); return C_DIV;}
c_max{OPTTYPES}                   {yylval.primf.types=str2type(yytext); return C_MAX;}
c_min{OPTTYPES}                   {yylval.primf.types=str2type(yytext); return C_MIN;}
plus{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return PLUS;}
minus{OPTTYPES}                   {yylval.primf.types=str2type(yytext); return MINUS;}
mult{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return MULT;}
div{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return DIV;}
quot{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return QUOT;}
mod{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return MOD;}
ip{OPTTYPES}                      {yylval.primf.types=str2type(yytext); return IP;}
max{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return MAX;}
min{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return MIN;}
and{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return AND;}
or{OPTTYPES}                      {yylval.primf.types=str2type(yytext); return OR;}
xor{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return XOR;}
eq{OPTTYPES}                      {yylval.primf.types=str2type(yytext); return EQ;}
neq{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return NE;}
f_eq{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return F_EQ;}
f_ne{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return F_NE;}
geq{OPTTYPES}                     {yylval.primf.types=str2type(yytext); return GE;}
gt{OPTTYPES}                      {yylval.primf.types=str2type(yytext); return GT;}
le{OPTTYPES}                      {yylval.primf.types=str2type(yytext); return LE;}
lt{OPTTYPES}                      {yylval.primf.types=str2type(yytext); return LT;}
lselect{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return LSELECT;}
lcut{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return LCUT;}
lrotate{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return LROTATE;}
lunite{OPTTYPES}                  {yylval.primf.types=str2type(yytext); return LUNITE;}
vselect{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return VSELECT;}
vcut{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return VCUT;}
vrotate{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return VROTATE;}
vunite{OPTTYPES}                  {yylval.primf.types=str2type(yytext); return VUNITE;}
lreplace{OPTTYPES}                {yylval.primf.types=str2type(yytext); return LREPLACE;}
mselect{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return MSELECT;}
mcut{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return MCUT;}
mrotate{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return MROTATE;}
munite{OPTTYPES}                  {yylval.primf.types=str2type(yytext); return MUNITE;}
mre_r{OPTTYPES}                   {yylval.primf.types=str2type(yytext); return MRE_R;}
mre_c{OPTTYPES}                   {yylval.primf.types=str2type(yytext); return MRE_C;}
mreplace_r{OPTTYPES}              {yylval.primf.types=str2type(yytext); return MRE_R;}
mreplace_c{OPTTYPES}              {yylval.primf.types=str2type(yytext); return MRE_C;}
ltransform{OPTTYPES}              {yylval.primf.types=str2type(yytext); return LTRANSFORM;}
transform{OPTTYPES}               {yylval.primf.types=str2type(yytext); return TRANSFORM;}
mreplace{OPTTYPES}                {yylval.primf.types=str2type(yytext); return MREPLACE;}
vreplace{OPTTYPES}                {yylval.primf.types=str2type(yytext); return VREPLACE;}
repstr{OPTTYPES}                  {yylval.primf.types=str2type(yytext); return REPSTR;}

    /* cr 22/03/95, kir(ff), START */
fselect{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return FSELECT;}
fupdate{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return UPDATE;}
ftest{OPTTYPES}                   {yylval.primf.types=str2type(yytext); return TEST;}
fslots{OPTTYPES}                  {yylval.primf.types=str2type(yytext); return SLOTS;}
fdelete{OPTTYPES}                 {yylval.primf.types=str2type(yytext); return DELETE;}

    /* cr 22/03/95, kir(ff), END */

    /* stt, 09.05.96 */
sprintf{OPTTYPES}      {yylval.primf.types=str2type(yytext); return SPRINTF;}
sscanf{OPTTYPES}       {yylval.primf.types=str2type(yytext); return SSCANF;}
to_char{OPTTYPES}      {yylval.primf.types=str2type(yytext); return TO_CHAR;}
to_ord{OPTTYPES}       {yylval.primf.types=str2type(yytext); return TO_ORD;}

done                              {return DONE;}
get                               {return GET;}
put                               {return PUT;}

    /* stt, 13.02.96 */
ia_fopen{OPTTYPES}     {yylval.primf.types=str2type(yytext); return IA_FOPEN;}
ia_fclose{OPTTYPES}    {yylval.primf.types=str2type(yytext); return IA_FCLOSE;}
ia_fgetc{OPTTYPES}     {yylval.primf.types=str2type(yytext); return IA_FGETC;}
ia_fputc{OPTTYPES}     {yylval.primf.types=str2type(yytext); return IA_FPUTC;}
ia_ungetc{OPTTYPES}    {yylval.primf.types=str2type(yytext); return IA_UNGETC;}
ia_fgets{OPTTYPES}     {yylval.primf.types=str2type(yytext); return IA_FGETS;}
ia_read{OPTTYPES}      {yylval.primf.types=str2type(yytext); return IA_READ;}
ia_fputs{OPTTYPES}     {yylval.primf.types=str2type(yytext); return IA_FPUTS;}
ia_fprintf{OPTTYPES}   {yylval.primf.types=str2type(yytext); return IA_FPRINTF;}
ia_fredirect{OPTTYPES} {yylval.primf.types=str2type(yytext); return IA_FREDIRECT;}
ia_fseek{OPTTYPES}     {yylval.primf.types=str2type(yytext); return IA_FSEEK;}
ia_ftell{OPTTYPES}     {yylval.primf.types=str2type(yytext); return IA_FTELL;}
ia_exit{OPTTYPES}      {yylval.primf.types=str2type(yytext); return IA_EXIT;}
ia_eof{OPTTYPES}       {yylval.primf.types=str2type(yytext); return IA_EOF;}
ia_bind{OPTTYPES}      {yylval.primf.types=str2type(yytext); return IA_BIND;}
ia_unit{OPTTYPES}      {yylval.primf.types=str2type(yytext); return IA_UNIT;}
ia_finfo{OPTTYPES}     {yylval.primf.types=str2type(yytext); return IA_FINFO;}
ia_status{OPTTYPES}    {yylval.primf.types=str2type(yytext); return IA_STATUS;}
ia_remove{OPTTYPES}    {yylval.primf.types=str2type(yytext); return IA_REMOVE;}
ia_rename{OPTTYPES}    {yylval.primf.types=str2type(yytext); return IA_RENAME;}
ia_copy{OPTTYPES}      {yylval.primf.types=str2type(yytext); return IA_COPY;}
ia_mkdir{OPTTYPES}     {yylval.primf.types=str2type(yytext); return IA_MKDIR;}
ia_rmdir{OPTTYPES}     {yylval.primf.types=str2type(yytext); return IA_RMDIR;}
ia_chdir{OPTTYPES}     {yylval.primf.types=str2type(yytext); return IA_CHDIR;}
ia_getwd{OPTTYPES}     {yylval.primf.types=str2type(yytext); return IA_GETWD;}
ia_dir{OPTTYPES}       {yylval.primf.types=str2type(yytext); return IA_DIR;}
ia_get{OPTTYPES}       {yylval.primf.types=str2type(yytext); return IA_GET;}
ia_put{OPTTYPES}       {yylval.primf.types=str2type(yytext); return IA_PUT;}


"#"[ \t]*args                     {return HASHARGS;}
"#"[ \t]*tildeargs                {return HASHTILDEARGS;}
"#"[ \t]*restype                  {return HASHRESTYPE;}
"#"[ \t]*setref                   {return HASHSETREF;}
"#"[ \t]*addr                     {return HASHLOCATION;}
"#"[ \t]*update                   {return HASHUPDATE;}
implicit                          {return IMPLICIT;}
explicit                          {return EXPLICIT;}
keepimplicit                      {return KEEPIMPL;}
{ID}                              {printf( "unknown identifier: %s\n", yytext );}
"/*"[^\n]*"*/"                    /* Kommentare fressen */
[ \t]+                            /* Leerzeichen fressen */
\n                                lineno++;

"("                               {return LBRACKET;}
")"                               {return RBRACKET;}
"<"                               {return C_LBRACK;}
">"                               {return C_RBRACK;}
"["                               {return LBRACK;}
"]"                               {return RBRACK;}
"'"                               {return LQUOTE;}
"`"                               {return RQUOTE;}
";"                               {return SEMICOLON;}
","                               {return ',';}
":"                               {return COLON;}
.                                 {printf( "Ungueltiges Zeichen: %s\n", yytext );}
%%

#ifdef FLEX_SCANNER
static void yy_flex_strcpy( char * a, const char * b)
  {
  }
void dummy()
  {
  yyunput(0, NULL);
  yy_push_state(0);
  yy_pop_state();
  yy_top_state();
  yy_flex_strcpy(NULL, NULL);
  }
#endif /* FLEX_SCANNER */

static int getatomtype(char t)
  {
  switch(t) {
    case 'b': return tp_bool;
    case 'i': return tp_int;
    case 'r': return tp_real;
    case 's': return tp_string;
    case 'd': return tp_digit;
    case 'e': return tp_empty;
    case '?': return tp_none;
    }
  yywarn("illegal type specifier '%c' encountered", t);
  return tp_none;
  }

/* convert short ascii notation of operand types
 * for primitive functions into internal integer
 * coded notation
 */
static int str2type(char * str)
  {
  int i, exttype, types = TYPES2LONG(tp_none, tp_none, tp_none, tp_none);

  /* first: skip the command itself (means all stuff until '_')
   */
  str = strchr(str, '.');
  if (str) str++;
  for(i = 0; str && *str && (i < MAXDELTAARGS); i++, str++) {
    switch(*str) {
        case 'l': exttype = tp_list; break;
        case 'v': exttype = tp_vect; str++; break;
        case 't': exttype = tp_tvect; str++; break;
        case 'm': exttype = tp_matrix; str++; break;
        default:  exttype = tp_none;
        }
    types = MERGETYPE(DELTYPE(i, types), SETTYPE(i, MAKETYPE(exttype,
                          (exttype == tp_list ? tp_none : getatomtype(*str)))));
    }
  if (str && *str)
    yywarn("too many type for primitive function");
  return types;
  }

static int atox(const char * s)
  {
  int n = 0;
  extern int toupper();

  while(*s) {
    n = n*16 + (isdigit(*s) ? *s-'0' : toupper(*s)-'A'+10);
    s++;
    }
  return n;
  }

@


1.71
log
@addendum ord, char, sprintf, sscanf
@
text
@d377 1
a377 1
ia_fscanf{OPTTYPES}    {yylval.primf.types=str2type(yytext); return IA_FSCANF;}
@


1.70
log
@new interactions: IA_GET, IA_PUT
@
text
@d357 6
@


1.69
log
@ignore UPDATE instruction for tasm (cf. CAF_UPDATE in rear.c rinter.c)
@
text
@d388 2
@


1.68
log
@real-input fixed
@
text
@d104 1
@


1.67
log
@new (t)ASM commands: count(x), msdistend, msnodist
@
text
@d15 1
d27 3
a29 1
{DIGIT}+"."{DIGIT}*             {yylval.realv=atof(yytext); return(REALV);}
@


1.66
log
@betaq0/1 tailq0/1
@
text
@d181 1
d187 2
@


1.65
log
@tailq inserted
@
text
@d99 2
d102 2
@


1.64
log
@scanning of octal represented characters.
@
text
@d99 1
@


1.63
log
@update, test, slots, delete -> fupdate, ftest, fslots, fdelete
@
text
@d20 1
d27 12
a38 10
"'"."'"                           {yylval.intv=yytext[1]; return SELEM;}
"'"\\n"'"                         {yylval.intv=(int)'\n'; return SELEM;}
"'"\\t"'"                         {yylval.intv=(int)'\t'; return SELEM;}
\"[^"]*\"                          {yylval.helpstring=malloc(strlen(yytext)-1);
                                   if (NULL==yylval.helpstring)
                                     yyfail("%s","Couldn't allocate memory !");
                                   strncpy(yylval.helpstring,&yytext[1],strlen(yytext)-2);
				   yylval.helpstring[strlen(yytext)-2] = '\0';
                                   return CLIST;
                                  }
@


1.62
log
@added FR_DELETE, FR_SLOTS
@
text
@d335 4
a338 4
update{OPTTYPES}                  {yylval.primf.types=str2type(yytext); return UPDATE;}
test{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return TEST;}
slots{OPTTYPES}                   {yylval.primf.types=str2type(yytext); return SLOTS;}
delete{OPTTYPES}                  {yylval.primf.types=str2type(yytext); return DELETE;}
@


1.61
log
@betaq mapped to beta
@
text
@d337 3
@


1.60
log
@comment indent error fixed.
@
text
@d95 1
@


1.59
log
@Interactions, mkiclos and intact added.
@
text
@d342 1
a342 1
/* stt, 13.02.96 */
@


1.58
log
@strings...
@
text
@d83 1
d93 1
d342 27
@


1.57
log
@FREER, FREE1R
@
text
@d33 1
@


1.56
log
@in str2type: tp_empty added
@
text
@d62 2
@


1.55
log
@*** empty log message ***
@
text
@d389 1
@


1.54
log
@mdim -> mdimension
@
text
@d266 1
d319 2
@


1.53
log
@transform
@
text
@d266 1
a266 1
mdim{OPTTYPES}                    {yylval.primf.types=str2type(yytext); return MDIM;}
@


1.52
log
@DIST implemented
@
text
@d319 1
@


1.51
log
@to_list implemented
@
text
@d166 6
d220 6
d320 1
d333 2
d339 2
@


1.50
log
@new separator for typ information: '.' instead of '_'
@
text
@d260 1
@


1.49
log
@vect, tvect & matrix implemented
@
text
@d18 1
a18 1
OPTTYPES (_[?a-z$]*)?
d383 1
a383 1
  str = strchr(str, '_');
@


1.48
log
@empty mat/vect/tvect
@
text
@d333 2
@


1.47
log
@mat, vect, tvect implemented
@
text
@d225 1
@


1.46
log
@primfunc : NOT
@
text
@d222 3
d230 2
a231 2
true                              {return TRUE_Y;}
false                             {return FALSE_Y;}
@


1.45
log
@mkilist
@
text
@d82 1
d232 1
@


1.44
log
@primitive function implemented: quot
@
text
@d78 1
@


1.43
log
@Module prefix for labels
@
text
@d267 1
@


1.42
log
@ge -> geq
@
text
@d20 1
d22 1
d179 4
a182 1
func{DIGIT}*_{LABELC}              {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d185 1
a185 1
jcond{DIGIT}*_{LABELC}             {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d188 1
a188 1
cond{DIGIT}*_{LABELC}              {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d191 1
a191 1
cont{DIGIT}*_{LABELC}              {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d194 1
a194 1
case{DIGIT}*_{LABELC}              {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d197 1
a197 1
when{DIGIT}*_{LABELC}              {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d200 1
a200 1
fail{DIGIT}*_{LABELC}              {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d203 1
a203 1
undecided{DIGIT}*_{LABELC}         {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d206 1
a206 1
bt{DIGIT}*_{LABELC}                {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d209 1
a209 1
inloop{DIGIT}*_{LABELC}            {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
@


1.41
log
@keepimpl integrated
@
text
@d273 1
a273 1
ge{OPTTYPES}                      {yylval.primf.types=str2type(yytext); return GE;}
@


1.40
log
@dup labels allowed
@
text
@d310 3
a312 3
implicit                          {return SREFimplicit;}
explicit                          {return SREFexplicit;}
keepimplicit                      {return SREFkeepimpl;}
@


1.39
log
@allocation of labels
@
text
@d174 1
a174 1
start_{LABELC}                    {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d177 1
a177 1
func_{LABELC}                     {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d180 1
a180 1
jcond_{LABELC}                    {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d183 1
a183 1
cond_{LABELC}                     {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d186 1
a186 1
cont_{LABELC}                     {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d189 1
a189 1
case_{LABELC}                     {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d192 1
a192 1
when_{LABELC}                     {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d195 1
a195 1
fail_{LABELC}                     {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d198 1
a198 1
undecided_{LABELC}                {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d201 1
a201 1
bt_{LABELC}                       {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d204 1
a204 1
inloop_{LABELC}                   {yylval.func_lab = (char*)malloc(strlen(yytext)+1);
d310 3
a312 2
implicit                          {return IMPLICIT;}
explicit                          {return EXPLICIT;}
@


1.38
log
@*** empty log message ***
@
text
@d174 5
a178 2
start_{LABELC}                    {return GOAL_LABEL;}
func_{LABELC}                     {strcpy(yylval.func_lab,yytext);
d180 2
a181 1
jcond_{LABELC}                    {strcpy(yylval.func_lab,yytext);
d183 2
a184 1
cond_{LABELC}                     {strcpy(yylval.func_lab,yytext);
d186 2
a187 1
cont_{LABELC}                     {strcpy(yylval.func_lab,yytext);
d189 2
a190 1
case_{LABELC}                     {strcpy(yylval.func_lab,yytext);
d192 2
a193 1
when_{LABELC}                     {strcpy(yylval.func_lab,yytext);
d195 2
a196 1
fail_{LABELC}                     {strcpy(yylval.func_lab,yytext);
d198 2
a199 1
undecided_{LABELC}                {strcpy(yylval.func_lab,yytext);
d201 2
a202 1
bt_{LABELC}                       {strcpy(yylval.func_lab,yytext);
d204 2
a205 1
inloop_{LABELC}                   {strcpy(yylval.func_lab,yytext);
@


1.37
log
@try to optimize via parser
@
text
@a2 1
extern int compile_mode;        /* from main.c */
a32 2
"/* code processed by".*"*/"\n   { if (1 == compile_mode) return OPT_TOKEN;
                                    else return COMP_TOKEN; }
@


1.36
log
@hashsetref
@
text
@d3 1
d34 2
@


1.35
log
@mkgsclos
@
text
@d297 3
a299 12
"##"{HASHME}+             {yylval.helpstring=(char *)malloc(strlen(yytext)+1);
                                   if (NULL==yylval.helpstring)
                                     yyfail("%s","Couldn't allocate memory !");
                                   strcpy(yylval.helpstring,yytext);
                                   lineno++;
                                   if (strncmp(&yytext[1], "args", 4) == 0)
                                     return HASHARGS;
                                   else if (strncmp(&yytext[1], "tildeargs", 9) == 0)
                                     return HASHTILDEARGS;
                                   else if (strncmp(&yytext[1], "restype", 7) == 0)
                                     return HASHRESTYPE;
                                   return HASH;}
@


1.34
log
@*** empty log message ***
@
text
@d80 1
@


1.33
log
@reading "inloop_xxx"
@
text
@d308 1
a308 1
{ID}                              {printf( "An identifier: %s\n", yytext );}
@


1.32
log
@allow escaped characters (\n,\t)
@
text
@d192 2
@


1.31
log
@strings fixed
@
text
@d25 2
@


1.30
log
@strings type reorganized
@
text
@d22 1
a22 1
-?{DIGIT}+                        {yylval.intv=atoi(yytext); return(INTV);}
d162 1
a162 1
char                              {return BOOL;}
d313 2
@


1.29
log
@giammacase -> gammacase
@
text
@d18 1
a18 1
OPTTYPES (_[?a-z]*)?
d162 1
@


1.28
log
@str2type changed (l* -> l)
@
text
@d122 1
a122 1
[gG]iammacase                     {return GAMMACASE;}
@


1.27
log
@type PM instructions
@
text
@d360 1
a360 1
        case 'l': exttype = tp_list; str++; break;
d366 2
a367 2
    types = MERGETYPE(DELTYPE(i, types),
                      SETTYPE(i, MAKETYPE(exttype, getatomtype(*str))));
@


1.26
log
@added fselect,update,test
@
text
@d129 13
a141 13
[mM]atcharb                       {return MATCHARB;}
[mM]atcharbs                      {return MATCHARBS;}
[mM]atchbool                      {return MATCHBOOL;}
[mM]atchc                         {return MATCHC;}
[mM]atchfalse                     {return MATCHFALSE;}
[mM]atchin                        {return MATCHIN;}
[mM]atchint                       {return MATCHINT;}
[mM]atchlist                      {return MATCHLIST;}
[mM]atchnil                       {return MATCHNIL;}
[mM]atchnils                      {return MATCHNILS;}
[mM]atchprim                      {return MATCHPRIM;}
[mM]atchstr                       {return MATCHSTR;}
[mM]atchtrue                      {return MATCHTRUE;}
@


1.25
log
@strings & free variables
@
text
@d278 6
@


1.24
log
@BT label
@
text
@d24 7
a30 1

d195 2
@


1.23
log
@negative numbers
@
text
@d18 1
a18 1
OPTTYPES _?[?a-z]*
d150 3
d181 2
d269 4
@


1.22
log
@mkap implemented
@
text
@d22 1
a22 1
{DIGIT}+                        {yylval.intv=atoi(yytext); return(INTV);}
@


1.21
log
@PM added
@
text
@d66 1
@


1.20
log
@typed conditional jump
@
text
@d107 43
d169 8
d183 4
a186 3
FUNC                              {return FUNC;}
COMB                              {return COMB;}
CONDI                             {return CONDI;}
@


1.19
log
@scan/parse of type annotations
@
text
@d17 1
a17 1
LABELC   [_A-Za-z0-9]*
d44 7
a50 7
[jJ]false2                        {return JFALSE2;}
[jJ]true2                         {return JTRUE2;}
[jJ]cond2                         {return JCOND2;}
[jJ]false                         {return JFALSE;}
[jJ]true                          {return JTRUE;}
[jJ]cond                          {return JCOND;}
[jJ]ump                           {return JUMP;}
@


1.18
log
@strncasecmp -> strncmp
@
text
@d211 5
a215 2
								
"#"{HASHME}+             {yylval.helpstring=(char *)malloc(strlen(yytext)+1);
@


1.17
log
@hash instruction extended
@
text
@d217 1
a217 1
                                   if (strncasecmp(&yytext[1], "args", 4) == 0)
d219 1
a219 1
                                   else if (strncasecmp(&yytext[1], "tildeargs", 9) == 0)
d221 1
a221 1
                                   else if (strncasecmp(&yytext[1], "restype", 7) == 0)
@


1.16
log
@kill's pushaux freew
@
text
@d109 1
d111 2
d217 6
d229 1
d231 2
a232 1
"("                               {return LBRACKET;}
@


1.15
log
@label names changed
@
text
@d37 1
d55 1
d95 8
@


1.14
log
@ref-counting instructions readable
@
text
@d17 1
d104 2
a105 2
start_{HEXA}                      {return GOAL_LABEL;}
func_{HEXA}                       {strcpy(yylval.func_lab,yytext);
d107 1
a107 1
jcond_{HEXA}                      {strcpy(yylval.func_lab,yytext);
d109 1
a109 1
cond_{HEXA}                       {strcpy(yylval.func_lab,yytext);
d111 1
a111 1
cont_{HEXA}                       {strcpy(yylval.func_lab,yytext);
@


1.13
log
@*** empty log message ***
@
text
@d76 17
@


1.12
log
@OPTTYPES more general (like -i?i)
@
text
@d17 1
a17 1
OPTTYPES _[?a-z]*
@


1.11
log
@*** empty log message ***
@
text
@d17 1
a17 1
OPTTYPES _?[a-z]*
@


1.10
log
@jump implemented
@
text
@d7 2
a8 1
#include "tasm2c.tab.h" 
a9 1
int yyfail();
d11 1
d17 1
d19 1
a23 1

a41 6
[jJ]false2_b                      {return JFALSE2_B;}
[jJ]true2_b                       {return JTRUE2_B;}
[jJ]cond2_b                       {return JCOND2_B;}
[jJ]false_b                       {return JFALSE_B;}
[jJ]true_b                        {return JTRUE_B;}
[jJ]cond_b                        {return JCOND_B;}
a49 7
[Ll]e_ii                          {return LE_II;}
[eE]q_ii                          {return EQ_II;}
[Nn]e_ii                          {return NE_II;}
[pP]lus_ii                        {return PLUS_II;}
[Mm]inus_ii                       {return MINUS_II;}
[Mm]ult_ii                        {return MULT_II;}

d58 2
a59 2
[rR]tf                            {return RTF;}         
[rR]tm                            {return RTM;}         
d88 1
a88 1
                                   return FUNC_LABEL;} 
d90 1
a90 1
                                   return JCOND_LABEL;} 
d92 1
a92 1
                                   return COND_LABEL;} 
d94 1
a94 1
                                   return CONT_LABEL;} 
d107 74
a180 76
abs                               {return ABS;}       
neg                               {return NEG;}
exp                               {return EXP;}       
ln                                {return LN;}        
sin                               {return SIN;}       
cos                               {return COS;}       
tan                               {return TAN;}       
floor                             {return FLOOR;}     
ceil                              {return CEIL;}      
frac                              {return FRAC;}      
trunc                             {return TRUNC;}     
vc_plus                           {return VC_PLUS;}   
vc_minus                          {return VC_MINUS;}  
vc_mult                           {return VC_MULT;}   
vc_div                            {return VC_DIV;}    
vc_min                            {return VC_MIN;}    
vc_max                            {return VC_MAX;}    
ldim                              {return LDIM;}      
vdim                              {return VDIM;}      
mdim                              {return MDIM;}      
class                             {return CLASS;}     
type                              {return TYPE;}      
empty                             {return EMPTY;}     
transpose                         {return TRANSPOSE;} 
reverse                           {return REVERSE;}   
to_scal                           {return TO_SCAL;} 
to_vect                           {return TO_VECT;} 
to_tvect                          {return TO_TVECT;}
to_mat                            {return TO_MAT;} 
								     
c_plus                            {return C_PLUS;}      
c_minus                           {return C_MINUS;}     
c_mult                            {return C_MULT;}      
c_div                             {return C_DIV;}       
c_max                             {return C_MAX;}       
c_min                             {return C_MIN;}       
plus                              {return PLUS;}      
minus                             {return MINUS;}     
mult                              {return MULT;}      
div                               {return DIV;}       
mod                               {return MOD;}       
ip                                {return IP;}        
max                               {return MAX;}       
min                               {return MIN;}       
and                               {return AND;}       
or                                {return OR;}        
xor                               {return XOR;}       
eq                                {return EQ;}        
neq                               {return NE;}        
f_eq                              {return F_EQ;}      
f_ne                              {return F_NE;}      
ge                                {return GE;}        
gt                                {return GT;}        
le                                {return LE;}        
lt                                {return LT;}        
lselect                           {return LSELECT;}   
lcut                              {return LCUT;}      
lrotate                           {return LROTATE;}   
lunite                            {return LUNITE;}    
vselect                           {return VSELECT;}   
vcut                              {return VCUT;}      
vrotate                           {return VROTATE;}   
vunite                            {return VUNITE;}    
				
lreplace                          {return LREPLACE;}  
mselect                           {return MSELECT;}   
mcut                              {return MCUT;}      
mrotate                           {return MROTATE;}   
munite                            {return MUNITE;}    
mre_r                             {return MRE_R;}
mre_c                             {return MRE_C;}
ltransform                        {return LTRANSFORM;}
				
mreplace                          {return MREPLACE;}  
repstr                            {return REPSTR;}   
								   
d182 1
a182 1
                                   if (NULL==yylval.helpstring) 
d198 1
a198 1
%%                                                                
d213 42
@


1.9
log
@asm_mode integrated
@
text
@d52 1
@


1.8
log
@mkcclos inserted
@
text
@d69 1
a71 1
[sS]nap                           {return SNAP;}
@


1.7
log
@conditional instructions completed
@
text
@d75 1
d77 1
a77 1
[mM]kgaclos                        {return MKGACLOS;}
@


1.6
log
@pushret and conditinal labels
@
text
@d40 9
a49 1
[jJ]false_b                       {return JFALSE_B;}
d51 1
a51 1
[jJ]cond                          {return JFALSE;}
@


1.5
log
@data structure list implemented
@
text
@a89 3
jcond_{HEXA}":"                   {strncpy(yylval.func_lab,yytext,12);
                                   yylval.func_lab[12]='\0';
                                   return ULICOND_LABEL;} 
d91 1
a91 1
                                   return COND_LABEL;} 
d94 2
@


1.4
log
@mkgclos -> mkgaclos
@
text
@a79 4
TY_INTEGER                        {return TY_INTEGER;}
TY_REAL                           {return TY_REAL;}
TY_UNDEF                          {return TY_UNDEF;}  

a102 3
C_FUNC                            {return CFUNC;}
TY_COMB                           {return TYCOMB;}
TY_CONDI                          {return TYCONDI;}
a195 2
"]"                               {return RBRACK;}
"["                               {return LBRACK;}
d223 1
a223 1
  while(*s++)
d225 2
@


1.3
log
@hex numbers handled as integers
@
text
@d68 1
a68 1
[mM]kgclos                        {return MKGCLOS;}
@


1.2
log
@reals implemented
@
text
@d5 1
d10 1
d89 1
a89 1
0x{HEXA}                          {strcpy(yylval.hexnum,yytext);
d226 10
@


1.1
log
@Initial revision
@
text
@d100 5
a104 3
_real                             {return REAL;}
_mat                              {return MAT;}
_list                             {return LIST;}
@
