head	1.49;
access;
symbols;
locks; strict;
comment	@ * @;


1.49
date	96.03.12.17.01.22;	author stt;	state Exp;
branches;
next	1.48;

1.48
date	96.03.06.16.02.52;	author sf;	state Exp;
branches;
next	1.47;

1.47
date	96.02.15.16.44.09;	author cr;	state Exp;
branches;
next	1.46;

1.46
date	96.02.09.10.13.31;	author sf;	state Exp;
branches;
next	1.45;

1.45
date	96.02.01.11.39.40;	author sf;	state Exp;
branches;
next	1.44;

1.44
date	96.01.26.15.10.25;	author sf;	state Exp;
branches;
next	1.43;

1.43
date	95.08.15.09.22.36;	author sf;	state Exp;
branches;
next	1.42;

1.42
date	95.08.14.08.43.31;	author sf;	state Exp;
branches;
next	1.41;

1.41
date	95.08.02.12.46.26;	author sf;	state Exp;
branches;
next	1.40;

1.40
date	95.07.12.16.08.44;	author sf;	state Exp;
branches;
next	1.39;

1.39
date	95.07.11.16.49.42;	author sf;	state Exp;
branches;
next	1.38;

1.38
date	95.07.11.15.07.47;	author sf;	state Exp;
branches;
next	1.37;

1.37
date	95.07.10.15.53.08;	author sf;	state Exp;
branches;
next	1.36;

1.36
date	95.07.07.14.36.48;	author sf;	state Exp;
branches;
next	1.35;

1.35
date	95.07.07.13.26.26;	author sf;	state Exp;
branches;
next	1.34;

1.34
date	95.06.29.11.56.30;	author car;	state Exp;
branches;
next	1.33;

1.33
date	95.06.27.15.44.19;	author sf;	state Exp;
branches;
next	1.32;

1.32
date	95.05.18.13.52.07;	author sf;	state Exp;
branches;
next	1.31;

1.31
date	95.05.11.12.52.20;	author sf;	state Exp;
branches;
next	1.30;

1.30
date	95.04.27.14.00.35;	author sf;	state Exp;
branches;
next	1.29;

1.29
date	95.04.21.10.30.29;	author um;	state Exp;
branches;
next	1.28;

1.28
date	95.04.20.15.26.22;	author sf;	state Exp;
branches;
next	1.27;

1.27
date	95.04.20.07.32.02;	author sf;	state Exp;
branches;
next	1.26;

1.26
date	95.04.18.12.56.31;	author sf;	state Exp;
branches;
next	1.25;

1.25
date	95.04.17.14.13.01;	author sf;	state Exp;
branches;
next	1.24;

1.24
date	95.04.12.13.29.14;	author sf;	state Exp;
branches;
next	1.23;

1.23
date	95.04.10.14.48.43;	author sf;	state Exp;
branches;
next	1.22;

1.22
date	95.04.10.07.44.16;	author sf;	state Exp;
branches;
next	1.21;

1.21
date	95.04.05.15.21.35;	author sf;	state Exp;
branches;
next	1.20;

1.20
date	95.03.22.17.48.27;	author cr;	state Exp;
branches;
next	1.19;

1.19
date	95.03.10.16.13.44;	author sf;	state Exp;
branches;
next	1.18;

1.18
date	95.02.02.14.20.27;	author sf;	state Exp;
branches;
next	1.17;

1.17
date	95.01.06.16.47.31;	author sf;	state Exp;
branches;
next	1.16;

1.16
date	95.01.02.14.19.10;	author sf;	state Exp;
branches;
next	1.15;

1.15
date	94.12.21.16.36.21;	author sf;	state Exp;
branches;
next	1.14;

1.14
date	94.12.21.16.22.45;	author sf;	state Exp;
branches;
next	1.13;

1.13
date	94.12.19.13.59.29;	author sf;	state Exp;
branches;
next	1.12;

1.12
date	94.12.16.08.15.07;	author sf;	state Exp;
branches;
next	1.11;

1.11
date	94.12.14.10.20.31;	author sf;	state Exp;
branches;
next	1.10;

1.10
date	94.12.08.10.07.06;	author sf;	state Exp;
branches;
next	1.9;

1.9
date	94.12.02.10.00.58;	author um;	state Exp;
branches;
next	1.8;

1.8
date	94.12.01.11.12.09;	author sf;	state Exp;
branches;
next	1.7;

1.7
date	94.12.01.09.22.28;	author sf;	state Exp;
branches;
next	1.6;

1.6
date	94.11.28.10.22.01;	author sf;	state Exp;
branches;
next	1.5;

1.5
date	94.11.25.14.03.18;	author sf;	state Exp;
branches;
next	1.4;

1.4
date	94.11.24.10.21.11;	author car;	state Exp;
branches;
next	1.3;

1.3
date	94.11.21.11.27.18;	author sf;	state Exp;
branches;
next	1.2;

1.2
date	94.11.21.10.00.10;	author car;	state Exp;
branches;
next	1.1;

1.1
date	94.11.21.09.08.01;	author car;	state Exp;
branches;
next	;


desc
@initial incomplete version
@


1.49
log
@cases p_to_char, p_to_ord, p_sprintf, p_sscanf added.
@
text
@#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "mytypes.h"
#include "main.h"
#include "dbug.h"
#include "buildtree.h"
#include "optimizer.h"

extern CODE *functable;
extern char *primf_tab[];
extern PROGRAM *program_start;
extern int ref_inferred;

char *gimme_code();
void compile_typed_primf();
FUNDESC *find_desc(FUNDESC *, char *);

char *get_str_space();
extern int yyfail();

/*************************************************************************************/
/* duplicates is function from argument which is a ptr to ORDER until end of func    */
/* if flag!=0 all typeinformations will be cleared.				     */ 
/*************************************************************************************/

ORDER *dup_func(ORDER *dup_me,int flag)
{
  ORDER *to_be_delivered, *act, *last, *help;
  
  DBUG_ENTER("dup_func");
  while ((NULL != dup_me) &&
	 ((hashargs == GETORDERENTRY(dup_me, command)) ||
	  (hashtildeargs == GETORDERENTRY(dup_me, command)) ||
	  (hashrestype == GETORDERENTRY(dup_me, command))) &&
	 (0 != flag))
    dup_me = GETNEXTORDER(dup_me);
  if (NULL != dup_me)
  {
    if (NULL == (to_be_delivered = (ORDER *)malloc(sizeof(ORDER))))
      yyfail("unable to allocate memory");
    memcpy(to_be_delivered, dup_me, sizeof(ORDER));
    if (NULL != GETORDERARGS(dup_me, label))
    {
      if (NULL == (SETORDERARGS(to_be_delivered, label) = 
                    (char *)malloc(strlen(GETORDERARGS(dup_me, label)) + 1))) 
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(to_be_delivered, label), GETORDERARGS(dup_me, label));
    }
    if (NULL != GETORDERARGS(dup_me, ret))
    {
      if (NULL == (SETORDERARGS(to_be_delivered, ret) = 
                    (char *)malloc(strlen(GETORDERARGS(dup_me, ret)) + 1))) 
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(to_be_delivered, ret), GETORDERARGS(dup_me, ret));
    }
    if (0!=flag)
    {
      SETORDERENTRY(to_be_delivered, types)=0;
      SETORDERENTRY(to_be_delivered, typestouched)=0;
    }
    SETPREVORDER(to_be_delivered) = NULL;
    SETNEXTORDER(to_be_delivered) = NULL;
    dup_me = GETNEXTORDER(dup_me);
    while ((NULL != dup_me) &&
	   ((hashargs == GETORDERENTRY(dup_me, command)) ||
	    (hashtildeargs == GETORDERENTRY(dup_me, command)) ||
	    (hashrestype == GETORDERENTRY(dup_me, command))) &&
	   (0 != flag))
      dup_me=GETNEXTORDER(dup_me);
    act = dup_me;
    last = to_be_delivered;
  }
  while (NULL != act)
  {
    if (NULL == (help = (ORDER *)malloc(sizeof(ORDER))))
      yyfail("unable to allocate memory");
    memcpy(help, act, sizeof(ORDER));
    if (NULL != GETORDERARGS(act, label))
    {
      if (NULL == (SETORDERARGS(help, label) = 
                    (char *)malloc(strlen(GETORDERARGS(act, label)) + 1))) 
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(help, label), GETORDERARGS(act, label));
    }
    if (NULL != GETORDERARGS(act, ret))
    {
      if (NULL == (SETORDERARGS(help, ret) = 
                    (char *)malloc(strlen(GETORDERARGS(act, ret)) + 1))) 
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(help, ret), GETORDERARGS(act, ret));
    }
    if (0!=flag)
    {
      SETORDERENTRY(help, types)=0;
      SETORDERENTRY(help, typestouched)=0;
    }
    SETNEXTORDER(last) = help; 
    SETPREVORDER(help) = last;
    SETNEXTORDER(help) = NULL;
    last = help;
    act = GETNEXTORDER(act);
    while ((NULL != act) &&
	   ((hashargs == GETORDERENTRY(act, command)) ||
	    (hashtildeargs == GETORDERENTRY(act, command)) ||
	    (hashrestype == GETORDERENTRY(act, command))) &&
	   (0 != flag))
      act = GETNEXTORDER(act);
  }
  DBUG_RETURN(to_be_delivered);
}


/*************************************************************************/
/* converts a stack_w-access to code and sets the code_ok-flag           */
/* primarily used by compile_typed_primf                                 */
/*************************************************************************/

char *gimme_code(ORDER *o)
{
  char text[80];

  DBUG_ENTER("gimme_code");
  
  switch(GETORDERENTRY(o, command))
  {
  case pushaw:
  {
    sprintf(text,"peek(a,%d)",GETORDERARGS(o, n));
    break;
  }
  case pushtw:
  {
    sprintf(text,"peek(t,%d)",GETORDERARGS(o, n));
    break;
  }
  case moveaw:
  {
    sprintf(text,"pop(a)");
    break;
  }
  case movetw:
  {
    sprintf(text,"pop(t)");
    break;
  }
  case pushcw_i:
  {
    sprintf(text,"%d",GETORDERARGS(o, n));
    break;
  }
  case pushcw_b:
  {
    if (GETORDERARGS(o, n)) 
      sprintf(text,"SA_TRUE");
    else 
      sprintf(text,"SA_FALSE");
    break;
  }
  default:
    fprintf(stderr,"Implement me in gimme_code !\n");
  }
  SETORDERENTRY(o, code) = get_str_space(text);
  strcpy(GETORDERENTRY(o, code), text);
  DBUG_RETURN(GETORDERENTRY(o, code));
}  


void make_one_function(PROGRAM *p)
{
  FUNCTION *func, *goal;
  ORDER *o1, *o2;

  DBUG_ENTER("make_one_function");
  goal = GETFIRSTFUNCTION(p);
  o1 = new_order(label, LABonefunc, "goal");
  insert_order_list(o1, GETFIRSTORDER(goal));
  func = GETNEXTFUNCTION(goal);
  while(NULL != func)
  {
    if (strcmp(GETNAME(func), "apply"))
    {
      /* first make a label and insert it*/
      o2 = new_order(label, LABonefunc, GETNAME(func));
      insert_order_list(o2, GETFIRSTORDER(func));
      /* second insert function */
      conc_order(o1, o2);
    }
    func = GETNEXTFUNCTION(func);
  }

  DBUG_VOID_RETURN;
}
/*************************************************************************/
/* counts the number of ASM-commands in a function                       */
/* except the function label                                             */
/*************************************************************************/

int count_command(FUNCTION *func) 
{
  int i = 0;
  ORDER *o;
  DBUG_ENTER("count_command");
  o = GETFIRSTORDER(func);
  while (o != NULL)
  {
    i++;
    o = GETNEXTORDER(o);
  }
  DBUG_RETURN(i);
}         
/*************************************************************************/
/* compiles all primitive functions without any type information         */
/* and converts all to reduma library calls                              */
/*************************************************************************/

void compile_delta(FUNCTION *f)
{
  ORDER *o;
  char text[160], help[80], *s;
  int refcnt_set;
  
  DBUG_ENTER("compile_delta");

  o = GETFIRSTORDER(f);
  while (NULL!=o)
  {
    refcnt_set = 0;
    switch(GETORDERENTRY(o, command))
    {
    case delta1:
    {
      if (uses_aux_var == GETORDERENTRY(GETPREVORDER(o), command))
        refcnt_set = 1; 
      switch(GETPRF(GETORDERARGS(o, primf)))
      {
      case p_to_field:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_to_field(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_to_field(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_to_list:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_to_list(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_to_list(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1, 
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_transform:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_transform(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_transform(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1, 
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_not:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_not(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_not(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_abs:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_abs(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_abs(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_neg:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_neg(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_neg(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
        if (1 != refcnt_set)
          strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_exp:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_exp(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_exp(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
        if (1 != refcnt_set)
         strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_ln:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_ln(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_ln(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_sin:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_sin(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_sin(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_cos:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_cos(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_cos(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_tan:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_tan(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_tan(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_floor:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_floor(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_floor(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_ceil:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_ceil(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_ceil(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_frac:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_frac(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_frac(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_trunc:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_trunc(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_trunc(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_vc_plus:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_vc_plus(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_vc_plus(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_vc_minus:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_vc_minus(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_vc_minus(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_vc_mult:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_vc_mult(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_vc_mult(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_vc_div:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_vc_div(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_vc_div(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_vc_min:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_vc_min(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_vc_min(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_vc_max:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_vc_max(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_vc_max(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_ldim:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_ldim(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_ldim(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_vdim:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_vdim(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_vdim(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_class:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_class(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_class(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_type:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_type(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_type(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_empty:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_empty(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_empty(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_transpose:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_transpose(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_transpose(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_reverse:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_reverse(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_reverse(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_to_scal:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_to_scal(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_to_scal(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_to_vect:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_to_vect(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_to_vect(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_to_tvect:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_to_tvect(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_to_tvect(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_to_mat:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_to_mat(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_to_mat(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_f_slots:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_slots(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_slots(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_to_char:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
          strcpy(text,"if (0 == nr_red_to_char(top(w)))\n");
        else
          strcpy(text,"if (0 == red_to_char(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
        if (1 != refcnt_set)
          strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_to_ord:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
          strcpy(text,"if (0 == nr_red_to_ord(top(w)))\n");
        else
          strcpy(text,"if (0 == red_to_ord(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
        if (1 != refcnt_set)
          strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      default:
      {
        yyfail("unknown primitive function with one arg in function %s.", 
               GETNAME(f));
      }
        ;
      } /* SWITCH(O->ARGS.PRIMF) */
      break;
    } /* CASE DELTA1: */
    case delta2:
    {
      if (uses_aux_var == GETORDERENTRY(GETPREVORDER(o), command))
        refcnt_set = 1; 
      switch(GETPRF(GETORDERARGS(o, primf)))
      {
      case p_mdim:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_mdim(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_mdim(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_eq:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_eq(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_eq(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_ne:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_neq(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_neq(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_f_eq:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_f_eq(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_f_eq(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_f_ne:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_f_ne(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_f_ne(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_ge:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_geq(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_geq(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_gt:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_gt(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_gt(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_lt:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_lt(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_lt(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_le:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_le(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_le(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_minus:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_minus(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_minus(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_plus:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_plus(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_plus(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_mult:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_mult(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_mult(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_div:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_div(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_div(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_mod:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_mod(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_mod(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_ip:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_ip(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_ip(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_max:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_max(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_max(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_min:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_min(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_min(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_and:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_and(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_and(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_or:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_or(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_or(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_xor:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_xor(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_xor(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_lselect:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_lselect(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_lselect(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_lcut:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_lcut(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_lcut(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_lrotate:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_lrotate(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_lrotate(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_lunite:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_lunite(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_lunite(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_vselect:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_vselect(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_vselect(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_vcut:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_vcut(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_vcut(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_vrotate:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_vrotate(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_vrotate(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_vunite:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_vunite(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_vunite(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_c_div:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_c_div(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_c_div(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_c_min:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_c_min(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_c_min(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_c_max:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_c_max(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_c_max(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_c_minus:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_c_minus(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_c_minus(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_c_mult:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_c_mult(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_c_mult(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_c_plus:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_c_plus(top(w), peek(w,1)))\n\n");
	else
	  strcpy(text,"if (0 == red_c_plus(top(w), peek(w,1)))\n\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
/* cr 22/03/95, kir(ff), START */
      case p_f_select:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_fselect(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_fselect(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_f_test:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_test(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_test(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_f_delete:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_delete(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_delete(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_quot:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_quot(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_quot(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_dim:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_dim(top(w), peek(w,1)))\n");
	else
	  strcpy(text,"if (0 == red_dim(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
/* cr 22/03/95, kir(ff), END */
      case p_sprintf:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
          strcpy(text,"if (0 == nr_red_sprintf(top(w), peek(w,1)))\n");
        else
          strcpy(text,"if (0 == red_sprintf(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
        if (1 != refcnt_set)
          strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_sscanf:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
          strcpy(text,"if (0 == nr_red_sscanf(top(w), peek(w,1)))\n");
        else
          strcpy(text,"if (0 == red_sscanf(top(w), peek(w,1)))\n");
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set ? 1 : -1,
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
        if (1 != refcnt_set)
          strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      default:
      {
        yyfail("unknown primitive function with two args in function %s.",
               GETNAME(f));
      }
        ;
      } /* SWITCH(O->ARGS.PRIMF) */
      break;
    } /* CASE DELTA2: */
      
    case delta3:
    {
      if (uses_aux_var == GETORDERENTRY(GETPREVORDER(o), command))
        refcnt_set = 1; 
      switch(GETPRF(GETORDERARGS(o, primf)))
      {
      case p_cut:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_cut(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_cut(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_substr:
      {      
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_substr(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_substr(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1, 
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;      
      }      
      case p_vreplace:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_vreplace(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_vreplace(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1, 
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_lreplace:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_lreplace(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_lreplace(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_mselect:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_mselect(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_mselect(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_mcut:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_mcut(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_mcut(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_mrotate:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_mrotate(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_mrotate(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_munite:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_munite(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_munite(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_mre_r:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_mre_r(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_mre_r(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_mre_c:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_mre_c(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_mre_c(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_select:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_select(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_select(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1, 
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_rotate:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_rotate(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_rotate(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1, 
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_unite:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_unite(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_unite(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1, 
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_ltransform:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_ltransform(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_ltransform(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
/* cr 22/03/95, kir(ff), START */
      case p_f_update:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_update(top(w), peek(w,1), peek(w,2)))\n");
	else
	  strcpy(text,"if (0 == red_update(top(w), peek(w,1), peek(w,2)))\n");
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
/* cr 22/03/95, kir(ff), END */
      default:
      {
        yyfail("unknown primitive function with three args in function %s.",
               GETNAME(f));
      }
        ;  
      } /* SWITCH(O->COMMAND) */
      break;     
    } /* CASE DELTA3: */


    case delta4:
    {
      if (uses_aux_var == GETORDERENTRY(GETPREVORDER(o), command))
        refcnt_set = 1; 
      switch(GETPRF(GETORDERARGS(o, primf)))
      {
      case p_replace:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_replace(top(w), peek(w,1), peek(w,2), peek(w,3)))\n");
	else
	  strcpy(text,"if (0 == red_replace(top(w), peek(w,1), peek(w,2), peek(w,3)))\n");
        sprintf(help, "\tf_mkdclos(%d, 4, 4, %s);\n", refcnt_set ? 1 : -1, 
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
          strcat(text,"else { drop(w, 3); repl(0, w, (int)_desc); }\n");
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_replace(top(w),peek(w,1),peek(w,2),peek(w,3));drop(w,4))");
	else
	  strcpy(text,"if (0 == red_replace(top(w),peek(w,1),peek(w,2),peek(w,3));drop(w,4); \npush((int)_desc);");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_mreplace:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_mreplace(top(w), peek(w,1), peek(w,2), peek(w,3)))\n");
	else
	  strcpy(text,"if (0 == red_mreplace(top(w), peek(w,1), peek(w,2), peek(w,3)))\n");
        sprintf(help, "\tf_mkdclos(%d, 4, 4, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 3); repl(0, w, (int)_desc); }\n");
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_mreplace(top(w),peek(w,1),peek(w,2),peek(w,3));drop(w,4);\npush((int)_desc);");
	else
	  strcpy(text,"if (0 == red_mreplace(top(w),peek(w,1),peek(w,2),peek(w,3));drop(w,4);\npush((int)_desc);");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      case p_repstr:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0== nr_red_repstr(top(w), peek(w,1), peek(w,2), peek(w,3)))\n");
	else
	  strcpy(text,"if (0 == red_repstr(top(w), peek(w,1), peek(w,2), peek(w,3)))\n");
        sprintf(help, "\tf_mkdclos(%d, 4, 4, %s);\n", refcnt_set ? 1 : -1,    
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)  
          strcat(text,"else { drop(w, 3); repl(0, w, (int)_desc); }\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
      default:
      {
        yyfail("unknown primitive function with four args in function %s.",
               GETNAME(f));
      }
        ;  
      } /* SWITCH(O->COMMAND) */     
    } /* CASE DELTA4: */
    case hashsetref:
      if (SREFexplicit == GETORDERARGS(o, n))
        ref_inferred = TRUE;
      if ((SREFimplicit == GETORDERARGS(o, n)) || (SREFkeepimpl == GETORDERARGS(o, n)))
        ref_inferred = FALSE;
      break; 
    default:
      ;
      
    } /* SWITCH(O->COMMAND) */ 
    o=GETNEXTORDER(o);   
  } /* WHILE (NULL!=o) */

  DBUG_VOID_RETURN;
}

  

/*************************************************************************/
/* Inserts a case for each label put into function and builds the        */
/* complete switchtable at the beginning of the function                 */
/*************************************************************************/


void insert_switchtable(FUNCTION *f, int i, ORDER *before_me)
{
  char *s, text[256], help[80];
  int j;
  
  
  DBUG_ENTER("insert_switch_table");
  insert_order_list(new_order(code_ok,"lab=kill_bits(pop(r));"),before_me);
  insert_order_list(new_order(code_ok,"LabSwitch:"),before_me);
  if (i > 4)
  {
    insert_order_list(new_order(code_ok,"switch(lab)"),before_me);
    insert_order_list(new_order(code_ok,"{"),before_me);

    for (j=0;j<i;j+=4)
    {
      sprintf(text,"case %d: goto L%d;",j,j);
      s=(char *)malloc(strlen(text)+1);
      if (NULL==s)
        yyfail("%s","Couldn't allocate memory !");
      strcpy(s,text);
      insert_order_list(new_order(code_ok,s),before_me);
    }
    sprintf(text, "default: fprintf(stderr, \"In function %s:\\n\");\n", GETNAME(f));
    strcat(text,"         fprintf(stderr,\"  Wrong Label: L%d;\\n\", lab);\n");
    sprintf(help, "controlled_exit(\"FATAL ERROR: Wrong Label in function %s\");\n", GETNAME(f));
    strcat(text, help);
    strcat(text, "exit(0);\n");
    s=(char *)malloc(strlen(text)+1);
    if (NULL==s)
      yyfail("%s","Couldn't allocate memory !");
    strcpy(s,text);
    insert_order_list(new_order(code_ok,s),before_me);
    
    insert_order_list(new_order(code_ok,"}"),before_me);
    
    DBUG_VOID_RETURN;
  }
}

/*************************************************************************/
/* Converts tail-jumps to tailnear or tailfar dependent if selftail-     */
/* recursive or not.                                                     */
/*************************************************************************/

void convert_tail(FUNCTION *f)
{
  char *act_func=GETNAME(f);
  ORDER *help=GETFIRSTORDER(f);
  
  DBUG_ENTER("convert_tail");
  while (NULL!=help)
  {
    switch(GETORDERENTRY(help, command))
    {
    case tail:
    {
/* check wether call to actual function **********/
      if (!strcmp(act_func, GETORDERARGS(help, label)))
      {
        SETORDERENTRY(help, command) = tailnear;
        SETORDERARGS(help, n) = 0;
      }
      else
      {
        SETORDERENTRY(help, command) = tailfar;
      }
      break;
    }
    default:
      ;
    }
    help=GETNEXTORDER(help);
  }
  DBUG_VOID_RETURN;
}

/*************************************************************************/
/* Traverses a whole function and inserts labels after each beta-call    */
/* Also checks if local or far jump and converts betaX and gammax-calls  */
/* to betaXfar|near, gammaXfar|near calls.                               */
/* Assumes NO code at beginning of function to insert LABEL0             */
/* Apply gets the return label in ORDER->args.m not n like the others    */
/*************************************************************************/
ORDER *search_last_delta(ORDER *o)
{
  while (((delta1 != GETORDERENTRY(o, command)) && 
          (stack_op != GETORDERENTRY(o, command)) && 
          (ris_stack_op != GETORDERENTRY(o, command))) && 
         ((delta2 != GETORDERENTRY(o, command)) && 
          (stack_op != GETORDERENTRY(o, command)) && 
          (ris_stack_op != GETORDERENTRY(o, command))) &&
         ((delta3 != GETORDERENTRY(o, command)) && 
          (stack_op != GETORDERENTRY(o, command)) &&
          (ris_stack_op != GETORDERENTRY(o, command))) &&
         ((delta4 != GETORDERENTRY(o, command)) && 
          (stack_op != GETORDERENTRY(o, command)) &&
          (ris_stack_op != GETORDERENTRY(o, command))))
    o = GETPREVORDER(o);
  return(o);
}

void insert_labels(FUNCTION *f)
{
  int i=4, j;
  ORDER *help, *nhelp, *help2, *insert_here;
  char *act_func=GETNAME(f),
       s[120]="", sp[64];
  
  DBUG_ENTER("insert_labels");

  help=GETFIRSTORDER(f);
  nhelp=new_order(code_ok,"L0:");
  insert_here=nhelp;
  insert_order_list(nhelp,help);  
  if (strncmp("case", GETNAME(f), 4) == 0)
    for(j = 0; j < GETDESCENTRY(GETDESC(f), nv); j++) {
      sprintf(sp, "sprintw(%d);", j);
      insert_order_list(new_order(code_ok,sp), help);
      }
  else
    for(j = 0; j < GETDESCENTRY(GETDESC(f), nv); j++) {
      sprintf(sp, "sprinta(%d);", j);
      insert_order_list(new_order(code_ok,sp), help);
      }
  for(j = 0; j < GETDESCENTRY(GETDESC(f), nfv); j++) {
    sprintf(sp, "sprintt(%d);", j);
    insert_order_list(new_order(code_ok,sp), help);
    }
  
  while ((code_ok == GETORDERENTRY(help, command)) || 
         (stack_op == GETORDERENTRY(help, command)))
    help=GETNEXTORDER(help);
  
  while (NULL!=help)
  {
    switch (GETORDERENTRY(help, command))
    {
    case pushaux:
      nhelp = new_order(uses_aux_var);
      help2 = search_last_delta(help);
      insert_order_list(nhelp, help2);
      break;
    case Case:
/* first: set the label behind the call **************/
      sprintf(s,"L%d",i);
      nhelp=new_order(label, LABfunc, s);
      insert_order_list(nhelp,GETNEXTORDER(help));
/* second: check if call to actual function **********/
      if (!strcmp(act_func,GETORDERARGS(help, label)))
      {
        SETORDERENTRY(help, command) = casenear;
      }
      else
      {
        SETORDERENTRY(help, command) = casefar;
      }
      if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(help, ret), act_func);
      SETORDERARGS(help, n) = i;
      i+=4;
      break;                  
    case gammacase:
/* first: set the label behind the call **************/
      sprintf(s,"L%d",i);
      nhelp=new_order(label, LABfunc, s);
      insert_order_list(nhelp,GETNEXTORDER(help));
/* second: check if call to actual function **********/
      if (!strcmp(act_func,GETORDERARGS(help, label)))
      {
        SETORDERENTRY(help, command) = gammacasenear;
      }
      else
      {
        SETORDERENTRY(help, command) = gammacasefar;
      }
      if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(help, ret), act_func);
      SETORDERARGS(help, n) = i;
      i+=4;
      break;                  
    case beta:
/* first: set the label behind the call **************/
        sprintf(s,"L%d",i);
        nhelp=new_order(label, LABfunc, s);
        insert_order_list(nhelp,GETNEXTORDER(help));
/* second: check if call to actual function **********/
        if (!strcmp(act_func,GETORDERARGS(help, label)))
        {
          SETORDERENTRY(help, command) = betanear;
        }
        else
        {
          SETORDERENTRY(help, command) = betafar;
        }
        if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
          yyfail("memory allocation failure");
        strcpy(SETORDERARGS(help, ret),act_func);
        SETORDERARGS(help, n) = i;
        i+=4;
      break;
    case tail:
/* check if call to actual function **********/
      if (!strcmp(act_func,GETORDERARGS(help, label)))
      {
        SETORDERENTRY(help, command) = tailnear;
      }
      else
      {
        SETORDERENTRY(help, command) = tailfar;
      }
      if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(help, ret),act_func);
      SETORDERARGS(help, n) = i;
      if ((rtf == GETORDERENTRY(GETNEXTORDER(help), command)) ||
          (rtt == GETORDERENTRY(GETNEXTORDER(help), command)) ||
          (rtc == GETORDERENTRY(GETNEXTORDER(help), command)) ||
          (rtp == GETORDERENTRY(GETNEXTORDER(help), command)))
        delete_order(GETNEXTORDER(help));

      break;

  case Gamma:
    {
         /* first: set the label behind the call **************/
      sprintf(s,"L%d",i);
      nhelp=new_order(label, LABfunc, s);
      insert_order_list(nhelp,GETNEXTORDER(help));
         /* second: check if call to actual function **********/
      if (!strcmp(act_func,GETORDERARGS(help, label)))
      {
        SETORDERENTRY(help, command) = gammanear;
      }
      else
      {
        SETORDERENTRY(help, command) = gammafar;
      }
      if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(help, ret), act_func);
      SETORDERARGS(help, n) = i;
      i+=4;
      break;
    }
  case gammabeta:
    {
/* first: set the label behind the call **************/
/* first: set the label behind the call **************/
      sprintf(s,"L%d",i);
      nhelp=new_order(label, LABfunc,s);
      insert_order_list(nhelp,GETNEXTORDER(help));
/* second: check if call to actual function **********/
      if (!strcmp(act_func,GETORDERARGS(help, label)))
      {
        SETORDERENTRY(help, command) = gammabetanear;
      }
      else
      {
        SETORDERENTRY(help, command) = gammabetafar;
      }
      if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(help, ret), act_func);
      SETORDERARGS(help, n) = i;
      i+=4;
      break;
    }

    case apply:
    {
/* first: set the label behind the call **************/
      sprintf(s,"L%d",i);
      nhelp=new_order(label, LABfunc,s);
      insert_order_list(nhelp,GETNEXTORDER(help));
/* second: check if call to actual function **********/
      if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(help, ret), act_func);
      SETORDERARGS(help, m)=i;
      i+=4;
      break;
    }
    case distend:
      sprintf(s,"L%d",i); 
      nhelp=new_order(label, LABfunc,s);
      insert_order_list(nhelp, GETNEXTORDER(help));
      if (NULL == (SETORDERENTRY(help, code) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERENTRY(help, code), act_func);
      SETORDERARGS(help, j)=i;
      i+=4;
      break;
    case distb:
      sprintf(s,"L%d",i); 
      nhelp=new_order(label, LABfunc,s);
      insert_order_list(nhelp, GETNEXTORDER(help));
      if (NULL == (SETORDERENTRY(help, code) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERENTRY(help, code), act_func);
      SETORDERARGS(help, j)=i;
      i+=4;
      break;
    case wait:
      sprintf(s,"L%d",i); 
      nhelp=new_order(label, LABfunc,s);
      insert_order_list(nhelp, GETNEXTORDER(help));
      if (NULL == (SETORDERENTRY(help, code) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERENTRY(help, code), act_func);
      SETORDERARGS(help, j)=i;
      i+=4;
      break;



    default: 
      ;
    }   /* SWITCH */
    help=GETNEXTORDER(help);
  }  /* WHILE */
  reset_inlined_flags();
  insert_switchtable(f,i, insert_here);
  
  DBUG_VOID_RETURN;
}  


void insert_labels_one_function(FUNCTION *f)
{
  int i=4, j;
  ORDER *help, *nhelp, *help2, *insert_here;
  char *act_func=GETNAME(f),
       s[120]="", sp[64];
  
  DBUG_ENTER("insert_labels_one_function");

  help=GETFIRSTORDER(f);
  nhelp=new_order(code_ok,"L0:");
  insert_here=nhelp;
  insert_order_list(nhelp,help);  
  if (strncmp("case", GETNAME(f), 4) == 0)
    for(j = 0; j < GETDESCENTRY(GETDESC(f), nv); j++) {
      sprintf(sp, "sprintw(%d);", j);
      insert_order_list(new_order(code_ok,sp), help);
      }
  else
    for(j = 0; j < GETDESCENTRY(GETDESC(f), nv); j++) {
      sprintf(sp, "sprinta(%d);", j);
      insert_order_list(new_order(code_ok,sp), help);
      }
  for(j = 0; j < GETDESCENTRY(GETDESC(f), nfv); j++) {
    sprintf(sp, "sprintt(%d);", j);
    insert_order_list(new_order(code_ok,sp), help);
    }
  
  while ((code_ok == GETORDERENTRY(help, command)) || 
         (stack_op == GETORDERENTRY(help, command)))
    help=GETNEXTORDER(help);
  
  while (NULL!=help)
  {
    switch (GETORDERENTRY(help, command))
    {
    case label:
      if (LABonefunc == GETORDERARGS(help, n))
      {
        FUNDESC *des;
        sprintf(s,"%d",i);
	if (strcmp(GETORDERARGS(help, label), "goal"))
	  des = find_desc(GETFIRSTDESC(program_start), GETORDERARGS(help, label));
	else
	  des = GETFIRSTDESC(program_start);
	free(SETDESCENTRY(des, label));
	SETDESCENTRY(des, label) = (char *)malloc(strlen(s) + 3);
	strcpy(SETDESCENTRY(des,label), s);
        sprintf(s,"L%d",i);
        insert_order_list(new_order(label, LABfunc, s), help);
        i+=4;
      }
      break;
    case pushaux:
      nhelp = new_order(uses_aux_var);
      help2 = search_last_delta(help);
      insert_order_list(nhelp, help2);
      break;


    case Case:
    case gammacase:
/* first: set the label behind the call **************/
      sprintf(s,"L%d",i);
      nhelp=new_order(label, LABfunc, s);
      insert_order_list(nhelp,GETNEXTORDER(help));
      SETORDERARGS(help, n) = i;
      i+=4;
      break;                  

    case beta:
/* first: set the label behind the call **************/
        sprintf(s,"L%d",i);
        nhelp=new_order(label, LABfunc, s);
        insert_order_list(nhelp,GETNEXTORDER(help));
        SETORDERARGS(help, n) = i;
        i+=4;
      break;
    case tail:
/* check if call to actual function **********/
      SETORDERARGS(help, n) = i;
      if ((rtf == GETORDERENTRY(GETNEXTORDER(help), command)) ||
          (rtt == GETORDERENTRY(GETNEXTORDER(help), command)) ||
          (rtc == GETORDERENTRY(GETNEXTORDER(help), command)) ||
          (rtp == GETORDERENTRY(GETNEXTORDER(help), command)))
        delete_order(GETNEXTORDER(help));

      break;

  case Gamma:
    {
         /* first: set the label behind the call **************/
      sprintf(s,"L%d",i);
      nhelp=new_order(label, LABfunc, s);
      insert_order_list(nhelp,GETNEXTORDER(help));
      break;
    }
  case gammabeta:
    {
/* first: set the label behind the call **************/
      sprintf(s,"L%d",i);
      nhelp=new_order(label, LABfunc,s);
      insert_order_list(nhelp,GETNEXTORDER(help));
      SETORDERARGS(help, n) = i;
      i+=4;
      break;
    }

    case apply:
    {
/* first: set the label behind the call **************/
      sprintf(s,"L%d",i);
      nhelp=new_order(label, LABfunc,s);
      insert_order_list(nhelp,GETNEXTORDER(help));
/* second: check if call to actual function **********/
      if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(help, ret), act_func);
      SETORDERARGS(help, m)=i;
      i+=4;
      break;
    }
    case distend:
      sprintf(s,"L%d",i); 
      nhelp=new_order(label, LABfunc,s);
      insert_order_list(nhelp, GETNEXTORDER(help));
      if (NULL == (SETORDERENTRY(help, code) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERENTRY(help, code), act_func);
      SETORDERARGS(help, j)=i;
      i+=4;
      break;
    case distb:
      sprintf(s,"L%d",i); 
      nhelp=new_order(label, LABfunc,s);
      insert_order_list(nhelp, GETNEXTORDER(help));
      if (NULL == (SETORDERENTRY(help, code) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERENTRY(help, code), act_func);
      SETORDERARGS(help, j)=i;
      i+=4;
      break;
    case wait:
      sprintf(s,"L%d",i); 
      nhelp=new_order(label, LABfunc,s);
      insert_order_list(nhelp, GETNEXTORDER(help));
      if (NULL == (SETORDERENTRY(help, code) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERENTRY(help, code), act_func);
      SETORDERARGS(help, j)=i;
      i+=4;
      break;



    default: 
      ;
    }   /* SWITCH */
    help=GETNEXTORDER(help);
  }  /* WHILE */
  reset_inlined_flags();
  insert_switchtable(f,i, insert_here);
  
  DBUG_VOID_RETURN;
}  

ORDER *last_push_r_before(ORDER *search_me)
{
  ORDER *found = search_me;
  
  DBUG_ENTER("last_push_r_before");
  while (pushr_p != GETORDERENTRY(found, command))
    found = GETPREVORDER(found);
  DBUG_RETURN(found);
}
@


1.48
log
@new function to search last pushr
@
text
@d798 34
d1512 34
@


1.47
log
@added p_f_delete, p_f_slots
@
text
@d2354 10
@


1.46
log
@output "Wrong Label" now with location (function)
@
text
@d781 17
d1416 17
@


1.45
log
@minor change on output
@
text
@d1827 1
a1827 1
  char *s, text[80];
d1848 5
a1852 1
    sprintf(text,"default: {fprintf(stderr,\"Wrong Label: L%%d;\\n\", lab);exit(0);\n}");
@


1.44
log
@*** empty log message ***
@
text
@d1848 1
a1848 1
    sprintf(text,"default: {fprintf(stderr,\"Wrong Label: L%%d;\\n\", lab);\n}");
@


1.43
log
@bug fixed in gammacase
@
text
@a1976 3
        if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
          yyfail("memory allocation failure");
        strcpy(SETORDERARGS(help, ret), act_func);
d1978 3
a1996 3
        if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
          yyfail("memory allocation failure");
        strcpy(SETORDERARGS(help, ret), act_func);
d1998 3
a2016 3
          if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
            yyfail("memory allocation failure");
          strcpy(SETORDERARGS(help, ret),act_func);
d2018 3
a2032 3
        if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
          yyfail("memory allocation failure");
        strcpy(SETORDERARGS(help, ret),act_func);
d2034 3
a2059 3
        if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
          yyfail("memory allocation failure");
        strcpy(SETORDERARGS(help, ret), act_func);
d2061 3
a2082 3
        if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
          yyfail("memory allocation failure");
        strcpy(SETORDERARGS(help, ret), act_func);
d2084 3
@


1.42
log
@ability to generated only one function
@
text
@d1965 19
d1989 12
a2000 3
      if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(help, ret),act_func);
d2209 2
a2211 24
/* first: set the label behind the call **************/
      sprintf(s,"L%d",i);
      nhelp=new_order(label, LABfunc, s);
      insert_order_list(nhelp,GETNEXTORDER(help));
/* second: check if call to actual function **********/
      if (!strcmp(act_func,GETORDERARGS(help, label)))
      {
        SETORDERENTRY(help, command) = casenear;
      }
      else
      {
        SETORDERENTRY(help, command) = casefar;
        if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
          yyfail("memory allocation failure");
        strcpy(SETORDERARGS(help, ret), act_func);
      }
      SETORDERARGS(help, n) = i;
      i+=4;
      if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(help, ret),act_func);
      SETORDERARGS(help, n) = i;
      i+=4;
      break;                  
a2216 17
/* second: check if call to actual function **********/
      if (!strcmp(act_func,GETORDERARGS(help, label)))
      {
        SETORDERENTRY(help, command) = gammacasenear;
      }
      else
      {
        SETORDERENTRY(help, command) = gammacasefar;
        if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
          yyfail("memory allocation failure");
        strcpy(SETORDERARGS(help, ret), act_func);
      }
      SETORDERARGS(help, n) = i;
      i+=4;
      if (NULL == (SETORDERARGS(help, ret) = (char *)malloc(strlen(act_func)+1)))
        yyfail("memory allocation failure");
      strcpy(SETORDERARGS(help, ret),act_func);
d2220 1
@


1.41
log
@bug fixed in call to nr_red_dim
@
text
@d17 1
d167 30
a196 1
          
d198 15
d2059 205
@


1.40
log
@*** empty log message ***
@
text
@d755 1
a755 1
	  strcpy(text,"if (0 == nr_red_mdim(top(w)))\n");
@


1.39
log
@*** empty log message ***
@
text
@d1803 1
a1803 1
    sprintf(text,"default: {fprintf(stderr,\"Wrong Label: L%%d;\", lab);\n}");
@


1.38
log
@mdim moved from delta1 to delta2 (bug fix)
@
text
@d757 1
a757 1
	  strcpy(text,"if (0 == red_mdim(top(w)))\n");
@


1.37
log
@rt[fctp] removed behind tail call
@
text
@a582 17
      case p_mdim:
      {
        SETORDERENTRY(o, command) = code_ok;
        if (ref_inferred)
	  strcpy(text,"if (0 == nr_red_mdim(top(w)))\n");
	else
	  strcpy(text,"if (0 == red_mdim(top(w)))\n");
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set ? 1 : -1,     
                      primf_tab[GETPRF(GETORDERARGS(o, primf))]);
        strcat(text, help);
         if (1 != refcnt_set)
           strcat(text,"else repl(0, w, (int)_desc);\n");
        s=get_str_space(text);
        strcpy(s,text);
        SETORDERENTRY(o, code) = s;
        break;
      }
d751 17
@


1.36
log
@label inserted behind distend
@
text
@d1965 5
@


1.35
log
@inserting labels for distb and wait
@
text
@d2028 10
@


1.34
log
@new instruction sprint[awrt] added for DBUG purposes
@
text
@d2028 20
@


1.33
log
@redundant switch at beginning of functions removed
@
text
@d1880 1
a1880 1
  int i=4;
d1883 1
a1883 1
       s[120]="";
d1891 14
@


1.32
log
@minor change in dynamic built closure for prim funcs
@
text
@a1786 1

d1789 4
a1792 2
  insert_order_list(new_order(code_ok,"switch(lab)"),before_me);
  insert_order_list(new_order(code_ok,"{"),before_me);
d1794 10
a1803 3
  for (j=0;j<i;j+=4)
  {
    sprintf(text,"case %d: goto L%d;",j,j);
d1809 4
a1813 10
  sprintf(text,"default: {fprintf(stderr,\"Wrong Label: L%%d;\", lab);\n}");
  s=(char *)malloc(strlen(text)+1);
  if (NULL==s)
    yyfail("%s","Couldn't allocate memory !");
  strcpy(s,text);
  insert_order_list(new_order(code_ok,s),before_me);
  
  insert_order_list(new_order(code_ok,"}"),before_me);
  
  DBUG_VOID_RETURN;
@


1.31
log
@norefcnt functions
@
text
@d188 1
a188 1
      if (uses_aux_var != GETORDERENTRY(GETPREVORDER(o), command))
d199 1
a199 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,
d202 1
a202 1
         if (0 != refcnt_set)
d216 1
a216 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,
d219 1
a219 1
         if (0 != refcnt_set)
d233 1
a233 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,
d236 1
a236 1
         if (0 != refcnt_set)
d250 1
a250 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d253 1
a253 1
         if (0 != refcnt_set)
d267 1
a267 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d270 1
a270 1
         if (0 != refcnt_set)
d284 1
a284 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d287 1
a287 1
        if (0 != refcnt_set)
d301 1
a301 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d304 1
a304 1
        if (0 != refcnt_set)
d318 1
a318 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d321 1
a321 1
         if (0 != refcnt_set)
d335 1
a335 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d338 1
a338 1
         if (0 != refcnt_set)
d352 1
a352 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d355 1
a355 1
         if (0 != refcnt_set)
d369 1
a369 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d372 1
a372 1
         if (0 != refcnt_set)
d386 1
a386 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d389 1
a389 1
         if (0 != refcnt_set)
d403 1
a403 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d406 1
a406 1
         if (0 != refcnt_set)
d420 1
a420 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d423 1
a423 1
         if (0 != refcnt_set)
d437 1
a437 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d440 1
a440 1
         if (0 != refcnt_set)
d454 1
a454 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d457 1
a457 1
         if (0 != refcnt_set)
d471 1
a471 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d474 1
a474 1
         if (0 != refcnt_set)
d488 1
a488 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d491 1
a491 1
         if (0 != refcnt_set)
d505 1
a505 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d508 1
a508 1
         if (0 != refcnt_set)
d522 1
a522 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d525 1
a525 1
         if (0 != refcnt_set)
d539 1
a539 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d542 1
a542 1
         if (0 != refcnt_set)
d556 1
a556 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d559 1
a559 1
         if (0 != refcnt_set)
d573 1
a573 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d576 1
a576 1
         if (0 != refcnt_set)
d590 1
a590 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d593 1
a593 1
         if (0 != refcnt_set)
d607 1
a607 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d610 1
a610 1
         if (0 != refcnt_set)
d624 1
a624 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d627 1
a627 1
         if (0 != refcnt_set)
d641 1
a641 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d644 1
a644 1
         if (0 != refcnt_set)
d658 1
a658 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d661 1
a661 1
         if (0 != refcnt_set)
d675 1
a675 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d678 1
a678 1
         if (0 != refcnt_set)
d692 1
a692 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d695 1
a695 1
         if (0 != refcnt_set)
d709 1
a709 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d712 1
a712 1
         if (0 != refcnt_set)
d726 1
a726 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d729 1
a729 1
         if (0 != refcnt_set)
d743 1
a743 1
        sprintf(help, "\tf_mkdclos(%d, 1, 1, %s);\n", refcnt_set,    
d746 1
a746 1
         if (0 != refcnt_set)
d764 1
a764 1
      if (uses_aux_var != GETORDERENTRY(GETPREVORDER(o), command))
d775 1
a775 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d778 1
a778 1
         if (0 != refcnt_set)
d792 1
a792 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d795 1
a795 1
         if (0 != refcnt_set)
d809 1
a809 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d812 1
a812 1
         if (0 != refcnt_set)
d826 1
a826 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d829 1
a829 1
         if (0 != refcnt_set)
d843 1
a843 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d846 1
a846 1
         if (0 != refcnt_set)
d860 1
a860 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d863 1
a863 1
         if (0 != refcnt_set)
d877 1
a877 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d880 1
a880 1
         if (0 != refcnt_set)
d894 1
a894 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d897 1
a897 1
         if (0 != refcnt_set)
d911 1
a911 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d914 1
a914 1
         if (0 != refcnt_set)
d928 1
a928 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d931 1
a931 1
         if (0 != refcnt_set)
d945 1
a945 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d948 1
a948 1
         if (0 != refcnt_set)
d962 1
a962 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d965 1
a965 1
         if (0 != refcnt_set)
d979 1
a979 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d982 1
a982 1
         if (0 != refcnt_set)
d996 1
a996 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d999 1
a999 1
         if (0 != refcnt_set)
d1013 1
a1013 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1016 1
a1016 1
         if (0 != refcnt_set)
d1030 1
a1030 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1033 1
a1033 1
         if (0 != refcnt_set)
d1047 1
a1047 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1050 1
a1050 1
         if (0 != refcnt_set)
d1064 1
a1064 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1067 1
a1067 1
         if (0 != refcnt_set)
d1081 1
a1081 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1084 1
a1084 1
         if (0 != refcnt_set)
d1098 1
a1098 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1101 1
a1101 1
         if (0 != refcnt_set)
d1115 1
a1115 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1118 1
a1118 1
         if (0 != refcnt_set)
d1132 1
a1132 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1135 1
a1135 1
         if (0 != refcnt_set)
d1149 1
a1149 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1152 1
a1152 1
         if (0 != refcnt_set)
d1166 1
a1166 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1169 1
a1169 1
         if (0 != refcnt_set)
d1183 1
a1183 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1186 1
a1186 1
         if (0 != refcnt_set)
d1200 1
a1200 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1203 1
a1203 1
         if (0 != refcnt_set)
d1217 1
a1217 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1220 1
a1220 1
         if (0 != refcnt_set)
d1234 1
a1234 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1237 1
a1237 1
         if (0 != refcnt_set)
d1251 1
a1251 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1254 1
a1254 1
         if (0 != refcnt_set)
d1268 1
a1268 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1271 1
a1271 1
         if (0 != refcnt_set)
d1285 1
a1285 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1288 1
a1288 1
         if (0 != refcnt_set)
d1302 1
a1302 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,   
d1305 1
a1305 1
         if (0 != refcnt_set)
d1319 1
a1319 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,   
d1322 1
a1322 1
         if (0 != refcnt_set)  
d1337 1
a1337 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1340 1
a1340 1
         if (0 != refcnt_set)  
d1354 1
a1354 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1357 1
a1357 1
         if (0 != refcnt_set)  
d1371 1
a1371 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1374 1
a1374 1
         if (0 != refcnt_set)  
d1388 1
a1388 1
        sprintf(help, "\tf_mkdclos(%d, 2, 2, %s);\n", refcnt_set,    
d1391 1
a1391 1
         if (0 != refcnt_set)  
d1411 1
a1411 1
      if (uses_aux_var != GETORDERENTRY(GETPREVORDER(o), command))
d1422 1
a1422 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,   
d1425 1
a1425 1
         if (0 != refcnt_set)
d1439 1
a1439 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,
d1442 1
a1442 1
         if (0 != refcnt_set)
d1456 1
a1456 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,
d1459 1
a1459 1
         if (0 != refcnt_set)
d1473 1
a1473 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,   
d1476 1
a1476 1
         if (0 != refcnt_set)  
d1490 1
a1490 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,   
d1493 1
a1493 1
         if (0 != refcnt_set)  
d1507 1
a1507 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,   
d1510 1
a1510 1
         if (0 != refcnt_set)  
d1524 1
a1524 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,   
d1527 1
a1527 1
         if (0 != refcnt_set)  
d1541 1
a1541 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,   
d1544 1
a1544 1
         if (0 != refcnt_set)  
d1558 1
a1558 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,   
d1561 1
a1561 1
         if (0 != refcnt_set)  
d1575 1
a1575 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,   
d1578 1
a1578 1
         if (0 != refcnt_set)  
d1592 1
a1592 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,
d1595 1
a1595 1
         if (0 != refcnt_set)
d1609 1
a1609 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,
d1612 1
a1612 1
         if (0 != refcnt_set)
d1626 1
a1626 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,
d1629 1
a1629 1
         if (0 != refcnt_set)
d1643 1
a1643 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,   
d1646 1
a1646 1
         if (0 != refcnt_set)  
d1661 1
a1661 1
        sprintf(help, "\tf_mkdclos(%d, 3, 3, %s);\n", refcnt_set,   
d1664 1
a1664 1
         if (0 != refcnt_set)  
d1685 1
a1685 1
      if (uses_aux_var != GETORDERENTRY(GETPREVORDER(o), command))
d1696 1
a1696 1
        sprintf(help, "\tf_mkdclos(%d, 4, 4, %s);\n", refcnt_set,
d1699 1
a1699 1
         if (0 != refcnt_set)
d1717 1
a1717 1
        sprintf(help, "\tf_mkdclos(%d, 4, 4, %s);\n", refcnt_set,   
d1720 1
a1720 1
         if (0 != refcnt_set)  
d1738 1
a1738 1
        sprintf(help, "\tf_mkdclos(%d, 4, 4, %s);\n", refcnt_set,   
d1741 1
a1741 1
         if (0 != refcnt_set)  
@


1.30
log
@bug fix in dup_func (cont_label in jcond2)
@
text
@d13 1
a14 1

d195 4
a198 1
        strcpy(text,"if (0 == red_to_field(top(w)))\n");
d212 4
a215 1
        strcpy(text,"if (0 == red_to_list(top(w)))\n");
d229 4
a232 1
        strcpy(text,"if (0 == red_transform(top(w)))\n");
d246 4
a249 1
        strcpy(text,"if (0 == red_not(top(w)))\n");
d263 4
a266 1
        strcpy(text,"if (0 == red_abs(top(w)))\n");
d280 4
a283 1
        strcpy(text,"if (0 == red_neg(top(w)))\n");
d286 3
a288 3
         if (0 != refcnt_set)
          strcat(text, help);
        strcat(text,"else repl(0, w, (int)_desc);\n");
d297 4
a300 1
        strcpy(text,"if (0 == red_exp(top(w)))\n");
d314 4
a317 1
        strcpy(text,"if (0 == red_ln(top(w)))\n");
d331 4
a334 1
        strcpy(text,"if (0 == red_sin(top(w)))\n");
d348 4
a351 1
        strcpy(text,"if (0 == red_cos(top(w)))\n");
d365 4
a368 1
        strcpy(text,"if (0 == red_tan(top(w)))\n");
d382 4
a385 1
        strcpy(text,"if (0 == red_floor(top(w)))\n");
d399 4
a402 1
        strcpy(text,"if (0 == red_ceil(top(w)))\n");
d416 4
a419 1
        strcpy(text,"if (0 == red_frac(top(w)))\n");
d433 4
a436 1
        strcpy(text,"if (0 == red_trunc(top(w)))\n");
d450 4
a453 1
        strcpy(text,"if (0 == red_vc_plus(top(w)))\n");
d467 4
a470 1
        strcpy(text,"if (0 == red_vc_minus(top(w)))\n");
d484 4
a487 1
        strcpy(text,"if (0 == red_vc_mult(top(w)))\n");
d501 4
a504 1
        strcpy(text,"if (0 == red_vc_div(top(w)))\n");
d518 4
a521 1
        strcpy(text,"if (0 == red_vc_min(top(w)))\n");
d535 4
a538 1
        strcpy(text,"if (0 == red_vc_max(top(w)))\n");
d552 4
a555 1
        strcpy(text,"if (0 == red_ldim(top(w)))\n");
d569 4
a572 1
        strcpy(text,"if (0 == red_vdim(top(w)))\n");
d586 4
a589 1
        strcpy(text,"if (0 == red_mdim(top(w)))\n");
d603 4
a606 1
        strcpy(text,"if (0 == red_class(top(w)))\n");
d620 4
a623 1
        strcpy(text,"if (0 == red_type(top(w)))\n");
d637 4
a640 1
        strcpy(text,"if (0 == red_empty(top(w)))\n");
d654 4
a657 1
        strcpy(text,"if (0 == red_transpose(top(w)))\n");
d671 4
a674 1
        strcpy(text,"if (0 == red_reverse(top(w)))\n");
d688 4
a691 1
        strcpy(text,"if (0 == red_to_scal(top(w)))\n");
d705 4
a708 1
        strcpy(text,"if (0 == red_to_vect(top(w)))\n");
d722 4
a725 1
        strcpy(text,"if (0 == red_to_tvect(top(w)))\n");
d739 4
a742 1
        strcpy(text,"if (0 == red_to_mat(top(w)))\n");
d771 4
a774 1
        strcpy(text,"if (0 == red_eq(top(w), peek(w,1)))\n");
d788 4
a791 1
        strcpy(text,"if (0 == red_neq(top(w), peek(w,1)))\n");
d805 4
a808 1
        strcpy(text,"if (0 == red_f_eq(top(w), peek(w,1)))\n");
d822 4
a825 1
        strcpy(text,"if (0 == red_f_ne(top(w), peek(w,1)))\n");
d839 4
a842 1
        strcpy(text,"if (0 == red_geq(top(w), peek(w,1)))\n");
d856 4
a859 1
        strcpy(text,"if (0 == red_gt(top(w), peek(w,1)))\n");
d873 4
a876 1
        strcpy(text,"if (0 == red_lt(top(w), peek(w,1)))\n");
d890 4
a893 1
        strcpy(text,"if (0 == red_le(top(w), peek(w,1)))\n");
d907 4
a910 1
        strcpy(text,"if (0 == red_minus(top(w), peek(w,1)))\n");
d924 4
a927 1
        strcpy(text,"if (0 == red_plus(top(w), peek(w,1)))\n");
d941 4
a944 1
        strcpy(text,"if (0 == red_mult(top(w), peek(w,1)))\n");
d958 4
a961 1
        strcpy(text,"if (0 == red_div(top(w), peek(w,1)))\n");
d975 4
a978 1
        strcpy(text,"if (0 == red_mod(top(w), peek(w,1)))\n");
d992 4
a995 1
        strcpy(text,"if (0 == red_ip(top(w), peek(w,1)))\n");
d1009 4
a1012 1
        strcpy(text,"if (0 == red_max(top(w), peek(w,1)))\n");
d1026 4
a1029 1
        strcpy(text,"if (0 == red_min(top(w), peek(w,1)))\n");
d1043 4
a1046 1
        strcpy(text,"if (0 == red_and(top(w), peek(w,1)))\n");
d1060 4
a1063 1
        strcpy(text,"if (0 == red_or(top(w), peek(w,1)))\n");
d1077 4
a1080 1
        strcpy(text,"if (0 == red_xor(top(w), peek(w,1)))\n");
d1094 4
a1097 1
        strcpy(text,"if (0 == red_lselect(top(w), peek(w,1)))\n");
d1111 4
a1114 1
        strcpy(text,"if (0 == red_lcut(top(w), peek(w,1)))\n");
d1128 4
a1131 1
        strcpy(text,"if (0 == red_lrotate(top(w), peek(w,1)))\n");
d1145 4
a1148 1
        strcpy(text,"if (0 == red_lunite(top(w), peek(w,1)))\n");
d1162 4
a1165 1
        strcpy(text,"if (0 == red_vselect(top(w), peek(w,1)))\n");
d1179 4
a1182 1
        strcpy(text,"if (0 == red_vcut(top(w), peek(w,1)))\n");
d1196 4
a1199 1
        strcpy(text,"if (0 == red_vrotate(top(w), peek(w,1)))\n");
d1213 4
a1216 1
        strcpy(text,"if (0 == red_vunite(top(w), peek(w,1)))\n");
d1230 4
a1233 1
        strcpy(text,"if (0 == red_c_div(top(w), peek(w,1)))\n");
d1247 4
a1250 1
        strcpy(text,"if (0 == red_c_min(top(w), peek(w,1)))\n");
d1264 4
a1267 1
        strcpy(text,"if (0 == red_c_max(top(w), peek(w,1)))\n");
d1281 4
a1284 1
        strcpy(text,"if (0 == red_c_minus(top(w), peek(w,1)))\n");
d1298 4
a1301 1
        strcpy(text,"if (0 == red_c_mult(top(w), peek(w,1)))\n");
d1315 4
a1318 1
        strcpy(text,"if (0 == red_c_plus(top(w), peek(w,1)))\n\n");
d1333 4
a1336 1
        strcpy(text,"if (0 == red_fselect(top(w), peek(w,1)))\n");
d1350 4
a1353 1
        strcpy(text,"if (0 == red_test(top(w), peek(w,1)))\n");
d1367 4
a1370 1
        strcpy(text,"if (0 == red_quot(top(w), peek(w,1)))\n");
d1384 4
a1387 1
        strcpy(text,"if (0 == red_dim(top(w), peek(w,1)))\n");
d1418 4
a1421 1
        strcpy(text,"if (0 == red_cut(top(w), peek(w,1), peek(w,2)))\n");
d1435 4
a1438 1
        strcpy(text,"if (0 == red_substr(top(w), peek(w,1), peek(w,2)))\n");
d1452 4
a1455 1
        strcpy(text,"if (0 == red_vreplace(top(w), peek(w,1), peek(w,2)))\n");
d1469 4
a1472 1
        strcpy(text,"if (0 == red_lreplace(top(w), peek(w,1), peek(w,2)))\n");
d1486 4
a1489 1
        strcpy(text,"if (0 == red_mselect(top(w), peek(w,1), peek(w,2)))\n");
d1503 4
a1506 1
        strcpy(text,"if (0 == red_mcut(top(w), peek(w,1), peek(w,2)))\n");
d1520 4
a1523 1
        strcpy(text,"if (0 == red_mrotate(top(w), peek(w,1), peek(w,2)))\n");
d1537 4
a1540 1
        strcpy(text,"if (0 == red_munite(top(w), peek(w,1), peek(w,2)))\n");
d1554 4
a1557 1
        strcpy(text,"if (0 == red_mre_r(top(w), peek(w,1), peek(w,2)))\n");
d1571 4
a1574 1
        strcpy(text,"if (0 == red_mre_c(top(w), peek(w,1), peek(w,2)))\n");
d1588 4
a1591 1
        strcpy(text,"if (0 == red_select(top(w), peek(w,1), peek(w,2)))\n");
d1605 4
a1608 1
        strcpy(text,"if (0 == red_rotate(top(w), peek(w,1), peek(w,2)))\n");
d1622 4
a1625 1
        strcpy(text,"if (0 == red_unite(top(w), peek(w,1), peek(w,2)))\n");
d1639 4
a1642 1
        strcpy(text,"if (0 == red_ltransform(top(w), peek(w,1), peek(w,2)))\n");
d1657 4
a1660 1
        strcpy(text,"if (0 == red_update(top(w), peek(w,1), peek(w,2)))\n");
d1692 4
a1695 1
        strcpy(text,"if (0 == red_replace(top(w), peek(w,1), peek(w,2), peek(w,3)))\n");
d1701 4
a1704 2
        strcpy(text,"if (0 == red_replace(top(w),peek(w,1),peek(w,2),peek(w,3));drop(w,4);
\npush((int)_desc);");
d1713 4
a1716 1
        strcpy(text,"if (0 == red_mreplace(top(w), peek(w,1), peek(w,2), peek(w,3)))\n");
d1722 4
a1725 1
        strcpy(text,"if (0 == red_mreplace(top(w),peek(w,1),peek(w,2),peek(w,3));drop(w,4);\npush((int)_desc);");
d1734 4
a1737 1
        strcpy(text,"if (0 == red_repstr(top(w), peek(w,1), peek(w,2), peek(w,3)))\n");
d1756 6
@


1.29
log
@flag added in dup_func
@
text
@d49 7
d84 7
@


1.28
log
@new function name handling
@
text
@d23 1
d26 1
a26 1
ORDER *dup_func(ORDER *dup_me)
d31 6
d49 5
d56 8
a63 1
    act = GETNEXTORDER(dup_me);
d71 12
d86 1
d88 6
a93 1
    last = help;
@


1.27
log
@new label handling in function duplication
@
text
@d1583 2
d1602 2
d1618 2
d1640 2
d1663 2
d1679 2
@


1.26
log
@new label handling
@
text
@d35 7
@


1.25
log
@new command: ris_stack_op
@
text
@d19 1
a19 1
int yyfail();
d1574 1
a1574 1
      nhelp=new_order(label,s);
d1583 1
a1583 1
        nhelp=new_order(label,s);
d1617 1
a1617 1
      nhelp=new_order(label,s);
d1638 1
a1638 1
      nhelp=new_order(label,s);
d1659 1
a1659 1
      nhelp=new_order(label,s);
@


1.24
log
@minor change
@
text
@d1527 12
a1538 4
  while ((delta1 != GETORDERENTRY(o, command)) && 
         (delta2 != GETORDERENTRY(o, command)) && 
         (delta3 != GETORDERENTRY(o, command)) && 
         (delta4 != GETORDERENTRY(o, command)))
@


1.23
log
@missing primitive functions implemented
@
text
@d1549 3
a1551 1
  while (code_ok == GETORDERENTRY(help, command)) help=GETNEXTORDER(help);
@


1.22
log
@dup_func() duplicates code
@
text
@d134 56
d1102 28
d1147 42
d1287 42
d1376 16
@


1.21
log
@additional parameter for f_mkdclos
@
text
@d5 1
d8 1
d12 1
d14 1
d21 33
d1350 1
a1350 1
  
d1379 2
a1380 2
      sprintf(s,"L%d:",i);
      nhelp=new_order(code_ok,s);
d1388 3
a1390 3
      sprintf(s,"L%d:",i);
      nhelp=new_order(code_ok,s);
      insert_order_list(nhelp,GETNEXTORDER(help));
d1392 11
a1402 12
      if (!strcmp(act_func,GETORDERARGS(help, label)))
      {
        SETORDERENTRY(help, command) = betanear;
      }
      else
      {
        SETORDERENTRY(help, command) = betafar;
        strcpy(SETORDERARGS(help, ret),act_func);
      }
      SETORDERARGS(help, n) = i;
      i+=4;
        
d1422 2
a1423 2
      sprintf(s,"L%d:",i);
      nhelp=new_order(code_ok,s);
d1439 1
a1439 1
    case gammabeta:
d1442 3
a1444 2
      sprintf(s,"L%d:",i);
      nhelp=new_order(code_ok,s);
d1464 2
a1465 2
      sprintf(s,"L%d:",i);
      nhelp=new_order(code_ok,s);
d1481 1
@


1.20
log
@added p_f_select,p_f_test,p_f_update to compile_delta
@
text
@d81 1
d88 1
d93 2
d101 1
a101 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d104 2
a105 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d115 1
a115 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d117 2
a118 1
        strcat(text, help);
d129 1
a129 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d132 2
a133 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d143 1
a143 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d146 2
a147 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d157 1
a157 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d160 2
a161 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d171 1
a171 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d174 2
a175 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d185 1
a185 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d188 2
a189 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d199 1
a199 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d202 2
a203 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d213 1
a213 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d216 2
a217 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d227 1
a227 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d230 2
a231 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d241 1
a241 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d244 2
a245 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d255 1
a255 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d258 2
a259 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d269 1
a269 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d272 2
a273 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d283 1
a283 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d286 2
a287 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d297 1
a297 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d300 2
a301 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d311 1
a311 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d314 2
a315 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d325 1
a325 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d328 2
a329 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d339 1
a339 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d342 2
a343 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d353 1
a353 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d356 2
a357 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d367 1
a367 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d370 2
a371 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d381 1
a381 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d384 2
a385 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d395 1
a395 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d398 2
a399 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d409 1
a409 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d412 2
a413 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d423 1
a423 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d426 2
a427 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d437 1
a437 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d440 2
a441 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d451 1
a451 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d454 2
a455 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d465 1
a465 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d468 2
a469 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d479 1
a479 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d482 2
a483 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d493 1
a493 1
        sprintf(help, "\tf_mkdclos(1, 1, %s);\n",   
d496 2
a497 1
        strcat(text,"else repl(0, w, (int)_desc);\n");
d514 2
d522 1
a522 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d525 2
a526 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d536 1
a536 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d539 2
a540 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d550 1
a550 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d553 2
a554 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d564 1
a564 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d567 2
a568 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d578 1
a578 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d581 2
a582 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d592 1
a592 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d595 2
a596 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d606 1
a606 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d609 2
a610 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d620 1
a620 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d623 2
a624 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d634 1
a634 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d637 2
a638 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d648 1
a648 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d651 2
a652 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d662 1
a662 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d665 2
a666 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d676 1
a676 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d679 2
a680 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d690 1
a690 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d693 2
a694 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d704 1
a704 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d707 2
a708 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d718 1
a718 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d721 2
a722 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d732 1
a732 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d735 2
a736 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d746 1
a746 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d749 2
a750 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d760 1
a760 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d763 2
a764 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d774 1
a774 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d777 2
a778 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d788 1
a788 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d791 2
a792 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d802 1
a802 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d805 2
a806 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d816 1
a816 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d819 2
a820 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d830 1
a830 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d833 2
a834 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d844 1
a844 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d847 2
a848 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d858 1
a858 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d861 2
a862 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d872 1
a872 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d875 2
a876 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d886 1
a886 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d889 2
a890 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d900 1
a900 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d903 2
a904 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d914 1
a914 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d917 2
a918 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d928 1
a928 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d931 2
a932 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d942 1
a942 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d945 2
a946 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d956 1
a956 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",  
d959 2
a960 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d970 1
a970 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",  
d973 2
a974 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d985 1
a985 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d988 2
a989 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d999 1
a999 1
        sprintf(help, "\tf_mkdclos(2, 2, %s);\n",   
d1002 2
a1003 1
        strcat(text,"else { drop(w, 1); repl(0, w, (int)_desc); }\n");
d1022 2
d1030 1
a1030 1
        sprintf(help, "\tf_mkdclos(3, 3, %s);\n",  
d1033 2
a1034 1
        strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
d1044 1
a1044 1
        sprintf(help, "\tf_mkdclos(3, 3, %s);\n",  
d1047 2
a1048 1
        strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
d1058 1
a1058 1
        sprintf(help, "\tf_mkdclos(3, 3, %s);\n",  
d1061 2
a1062 1
        strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
d1072 1
a1072 1
        sprintf(help, "\tf_mkdclos(3, 3, %s);\n",  
d1075 2
a1076 1
        strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
d1086 1
a1086 1
        sprintf(help, "\tf_mkdclos(3, 3, %s);\n",  
d1089 2
a1090 1
        strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
d1100 1
a1100 1
        sprintf(help, "\tf_mkdclos(3, 3, %s);\n",  
d1103 2
a1104 1
        strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
d1114 1
a1114 1
        sprintf(help, "\tf_mkdclos(3, 3, %s);\n",  
d1117 2
a1118 1
        strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
d1128 1
a1128 1
        sprintf(help, "\tf_mkdclos(3, 3, %s);\n",  
d1131 2
a1132 1
        strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
d1143 1
a1143 1
        sprintf(help, "\tf_mkdclos(3, 3, %s);\n",  
d1146 2
a1147 1
        strcat(text,"else { drop(w, 2); repl(0, w, (int)_desc); }\n");
d1167 2
d1175 1
a1175 1
        sprintf(help, "\tf_mkdclos(4, 4, %s);\n",  
d1178 2
a1179 1
        strcat(text,"else { drop(w, 3); repl(0, w, (int)_desc); }\n");
d1190 1
a1190 1
        sprintf(help, "\tf_mkdclos(4, 4, %s);\n",  
d1193 2
a1194 1
        strcat(text,"else { drop(w, 3); repl(0, w, (int)_desc); }\n");
d1304 10
a1313 1

d1317 1
a1317 1
  ORDER *help, *nhelp, *insert_here;
d1334 5
@


1.19
log
@pm implemented
@
text
@d912 28
d1058 15
@


1.18
log
@due to tagged data
@
text
@d1197 10
@


1.17
log
@minor changes
@
text
@d91 1
a91 1
      switch(GETORDERARGS(o, primf))
d98 1
a98 1
                      primf_tab[GETORDERARGS(o, primf)]);
d111 1
a111 1
                      primf_tab[GETORDERARGS(o, primf)]);
d124 1
a124 1
                      primf_tab[GETORDERARGS(o, primf)]);
d137 1
a137 1
                      primf_tab[GETORDERARGS(o, primf)]);
d150 1
a150 1
                      primf_tab[GETORDERARGS(o, primf)]);
d163 1
a163 1
                      primf_tab[GETORDERARGS(o, primf)]);
d176 1
a176 1
                      primf_tab[GETORDERARGS(o, primf)]);
d189 1
a189 1
                      primf_tab[GETORDERARGS(o, primf)]);
d202 1
a202 1
                      primf_tab[GETORDERARGS(o, primf)]);
d215 1
a215 1
                      primf_tab[GETORDERARGS(o, primf)]);
d228 1
a228 1
                      primf_tab[GETORDERARGS(o, primf)]);
d241 1
a241 1
                      primf_tab[GETORDERARGS(o, primf)]);
d254 1
a254 1
                      primf_tab[GETORDERARGS(o, primf)]);
d267 1
a267 1
                      primf_tab[GETORDERARGS(o, primf)]);
d280 1
a280 1
                      primf_tab[GETORDERARGS(o, primf)]);
d293 1
a293 1
                      primf_tab[GETORDERARGS(o, primf)]);
d306 1
a306 1
                      primf_tab[GETORDERARGS(o, primf)]);
d319 1
a319 1
                      primf_tab[GETORDERARGS(o, primf)]);
d332 1
a332 1
                      primf_tab[GETORDERARGS(o, primf)]);
d345 1
a345 1
                      primf_tab[GETORDERARGS(o, primf)]);
d358 1
a358 1
                      primf_tab[GETORDERARGS(o, primf)]);
d371 1
a371 1
                      primf_tab[GETORDERARGS(o, primf)]);
d384 1
a384 1
                      primf_tab[GETORDERARGS(o, primf)]);
d397 1
a397 1
                      primf_tab[GETORDERARGS(o, primf)]);
d410 1
a410 1
                      primf_tab[GETORDERARGS(o, primf)]);
d423 1
a423 1
                      primf_tab[GETORDERARGS(o, primf)]);
d436 1
a436 1
                      primf_tab[GETORDERARGS(o, primf)]);
d449 1
a449 1
                      primf_tab[GETORDERARGS(o, primf)]);
d462 1
a462 1
                      primf_tab[GETORDERARGS(o, primf)]);
d481 1
a481 1
      switch(GETORDERARGS(o, primf))
d488 1
a488 1
                      primf_tab[GETORDERARGS(o, primf)]);
d501 1
a501 1
                      primf_tab[GETORDERARGS(o, primf)]);
d514 1
a514 1
                      primf_tab[GETORDERARGS(o, primf)]);
d527 1
a527 1
                      primf_tab[GETORDERARGS(o, primf)]);
d540 1
a540 1
                      primf_tab[GETORDERARGS(o, primf)]);
d553 1
a553 1
                      primf_tab[GETORDERARGS(o, primf)]);
d566 1
a566 1
                      primf_tab[GETORDERARGS(o, primf)]);
d579 1
a579 1
                      primf_tab[GETORDERARGS(o, primf)]);
d592 1
a592 1
                      primf_tab[GETORDERARGS(o, primf)]);
d605 1
a605 1
                      primf_tab[GETORDERARGS(o, primf)]);
d618 1
a618 1
                      primf_tab[GETORDERARGS(o, primf)]);
d631 1
a631 1
                      primf_tab[GETORDERARGS(o, primf)]);
d644 1
a644 1
                      primf_tab[GETORDERARGS(o, primf)]);
d657 1
a657 1
                      primf_tab[GETORDERARGS(o, primf)]);
d670 1
a670 1
                      primf_tab[GETORDERARGS(o, primf)]);
d683 1
a683 1
                      primf_tab[GETORDERARGS(o, primf)]);
d696 1
a696 1
                      primf_tab[GETORDERARGS(o, primf)]);
d709 1
a709 1
                      primf_tab[GETORDERARGS(o, primf)]);
d722 1
a722 1
                      primf_tab[GETORDERARGS(o, primf)]);
d735 1
a735 1
                      primf_tab[GETORDERARGS(o, primf)]);
d748 1
a748 1
                      primf_tab[GETORDERARGS(o, primf)]);
d761 1
a761 1
                      primf_tab[GETORDERARGS(o, primf)]);
d774 1
a774 1
                      primf_tab[GETORDERARGS(o, primf)]);
d787 1
a787 1
                      primf_tab[GETORDERARGS(o, primf)]);
d800 1
a800 1
                      primf_tab[GETORDERARGS(o, primf)]);
d813 1
a813 1
                      primf_tab[GETORDERARGS(o, primf)]);
d826 1
a826 1
                      primf_tab[GETORDERARGS(o, primf)]);
d839 1
a839 1
                      primf_tab[GETORDERARGS(o, primf)]);
d852 1
a852 1
                      primf_tab[GETORDERARGS(o, primf)]);
d865 1
a865 1
                      primf_tab[GETORDERARGS(o, primf)]);
d878 1
a878 1
                      primf_tab[GETORDERARGS(o, primf)]);
d891 1
a891 1
                      primf_tab[GETORDERARGS(o, primf)]);
d904 1
a904 1
                      primf_tab[GETORDERARGS(o, primf)]);
d924 1
a924 1
      switch(GETORDERARGS(o, primf))
d931 1
a931 1
                      primf_tab[GETORDERARGS(o, primf)]);
d944 1
a944 1
                      primf_tab[GETORDERARGS(o, primf)]);
d957 1
a957 1
                      primf_tab[GETORDERARGS(o, primf)]);
d970 1
a970 1
                      primf_tab[GETORDERARGS(o, primf)]);
d983 1
a983 1
                      primf_tab[GETORDERARGS(o, primf)]);
d996 1
a996 1
                      primf_tab[GETORDERARGS(o, primf)]);
d1009 1
a1009 1
                      primf_tab[GETORDERARGS(o, primf)]);
d1022 1
a1022 1
                      primf_tab[GETORDERARGS(o, primf)]);
d1043 1
a1043 1
      switch(GETORDERARGS(o, primf))
d1050 1
a1050 1
                      primf_tab[GETORDERARGS(o, primf)]);
d1064 1
a1064 1
                      primf_tab[GETORDERARGS(o, primf)]);
d1216 15
@


1.16
log
@buildtree access macros implemented
@
text
@d96 2
a97 2
        strcpy(text,"red_abs(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d109 2
a110 2
        strcpy(text,"red_neg(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d122 2
a123 2
        strcpy(text,"red_exp(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d135 2
a136 2
        strcpy(text,"red_ln(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d148 2
a149 2
        strcpy(text,"red_sin(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d161 2
a162 2
        strcpy(text,"red_cos(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d174 2
a175 2
        strcpy(text,"red_tan(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d187 2
a188 2
        strcpy(text,"red_floor(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d200 2
a201 2
        strcpy(text,"red_ceil(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d213 2
a214 2
        strcpy(text,"red_frac(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d226 2
a227 2
        strcpy(text,"red_trunc(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d239 2
a240 2
        strcpy(text,"red_vc_plus(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d252 2
a253 2
        strcpy(text,"red_vc_minus(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d265 2
a266 2
        strcpy(text,"red_vc_mult(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d278 2
a279 2
        strcpy(text,"red_vc_div(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d291 2
a292 2
        strcpy(text,"red_vc_min(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d304 2
a305 2
        strcpy(text,"red_vc_max(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d317 2
a318 2
        strcpy(text,"red_ldim(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d330 2
a331 2
        strcpy(text,"red_vdim(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d343 2
a344 2
        strcpy(text,"red_mdim(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d356 2
a357 2
        strcpy(text,"red_class(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d369 2
a370 2
        strcpy(text,"red_type(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d382 2
a383 2
        strcpy(text,"red_empty(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d395 2
a396 2
        strcpy(text,"red_transpose(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d408 2
a409 2
        strcpy(text,"red_reverse(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d421 2
a422 2
        strcpy(text,"red_to_scal(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d434 2
a435 2
        strcpy(text,"red_to_vect(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d447 2
a448 2
        strcpy(text,"red_to_tvect(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d460 2
a461 2
        strcpy(text,"red_to_mat(top(w));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(1, 1, %s);\n",   
d486 2
a487 2
        strcpy(text,"red_eq(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d499 2
a500 2
        strcpy(text,"red_neq(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d512 2
a513 2
        strcpy(text,"red_f_eq(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d525 2
a526 2
        strcpy(text,"red_f_ne(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d538 2
a539 2
        strcpy(text,"red_geq(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d551 2
a552 2
        strcpy(text,"red_gt(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d564 2
a565 2
        strcpy(text,"red_lt(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d577 2
a578 2
        strcpy(text,"red_le(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d590 2
a591 2
        strcpy(text,"red_minus(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d603 2
a604 2
        strcpy(text,"red_plus(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d616 2
a617 2
        strcpy(text,"red_mult(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d629 2
a630 2
        strcpy(text,"red_div(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d642 2
a643 2
        strcpy(text,"red_mod(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d655 2
a656 2
        strcpy(text,"red_ip(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d668 2
a669 2
        strcpy(text,"red_max(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d681 2
a682 2
        strcpy(text,"red_min(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d694 2
a695 2
        strcpy(text,"red_and(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d707 2
a708 2
        strcpy(text,"red_or(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d720 2
a721 2
        strcpy(text,"red_xor(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d733 2
a734 2
        strcpy(text,"red_lselect(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d746 2
a747 2
        strcpy(text,"red_cut(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d759 2
a760 2
        strcpy(text,"red_lrotate(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d772 2
a773 2
        strcpy(text,"red_lunite(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d785 2
a786 2
        strcpy(text,"red_vselect(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d798 2
a799 2
        strcpy(text,"red_vcut(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d811 2
a812 2
        strcpy(text,"red_vrotate(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d824 2
a825 2
        strcpy(text,"red_vunite(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d837 2
a838 2
        strcpy(text,"red_c_div(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d850 2
a851 2
        strcpy(text,"red_c_min(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d863 2
a864 2
        strcpy(text,"red_c_max(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d876 2
a877 2
        strcpy(text,"red_c_minus(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",   
d889 2
a890 2
        strcpy(text,"red_c_mult(top(w), peek(w,1));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",  
d902 2
a903 2
        strcpy(text,"red_c_plus(top(w), peek(w,1));\n\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(2, 2, %s);\n",  
d929 2
a930 2
        strcpy(text,"red_lreplace(top(w), peek(w,1), peek(w,2));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(3, 3, %s);\n",  
d942 2
a943 2
        strcpy(text,"red_mselect(top(w), peek(w,1), peek(w,2));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(3, 3, %s);\n",  
d955 2
a956 2
        strcpy(text,"red_mcut(top(w), peek(w,1), peek(w,2));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(3, 3, %s);\n",  
d968 2
a969 2
        strcpy(text,"red_mrotate(top(w), peek(w,1), peek(w,2));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(3, 3, %s);\n",  
d981 2
a982 2
        strcpy(text,"red_munite(top(w), peek(w,1), peek(w,2));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(3, 3, %s);\n",  
d994 2
a995 2
        strcpy(text,"red_mre_r(top(w), peek(w,1), peek(w,2));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(3, 3, %s);\n",  
d1007 2
a1008 2
        strcpy(text,"red_mre_c(top(w), peek(w,1), peek(w,2));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(3, 3, %s);\n",  
d1020 2
a1021 2
        strcpy(text,"red_ltransform(top(w), peek(w,1), peek(w,2));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(3, 3, %s);\n",  
d1048 2
a1049 2
        strcpy(text,"red_mreplace(top(w), peek(w,1), peek(w,2), peek(w,3));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(4, 4, %s);\n",  
d1053 1
a1053 1
        strcpy(text,"red_mreplace(top(w),peek(w,1),peek(w,2),peek(w,3));drop(w,4);\npush((int)_desc);");
d1062 2
a1063 2
        strcpy(text,"red_repstr(top(w), peek(w,1), peek(w,2), peek(w,3));\n");
        sprintf(help, "if (0 == _desc) f_mkdclos(4, 4, %s);\n",  
@


1.15
log
@*** empty log message ***
@
text
@d29 1
a29 1
  switch(o->command)
d33 1
a33 1
    sprintf(text,"peek(a,%d)",o->args.n);
d38 1
a38 1
    sprintf(text,"peek(t,%d)",o->args.n);
d53 1
a53 1
    sprintf(text,"%d",o->args.n);
d58 1
a58 1
    if (o->args.n) 
d67 3
a69 3
  o->code=get_str_space(text);
  strcpy(o->code,text);
  DBUG_RETURN(o->code);
d84 1
a84 1
  o=f->order;
d87 1
a87 1
    switch(o->command)
d91 1
a91 1
      switch(o->args.primf)
d95 1
a95 1
        o->command=code_ok;
d98 1
a98 1
                      primf_tab[o->args.primf]);
d103 1
a103 1
        o->code=s;
d108 1
a108 1
        o->command=code_ok;
d111 1
a111 1
                      primf_tab[o->args.primf]);
d116 1
a116 1
        o->code=s;
d121 1
a121 1
        o->command=code_ok;
d124 1
a124 1
                      primf_tab[o->args.primf]);
d129 1
a129 1
        o->code=s;
d134 1
a134 1
        o->command=code_ok;
d137 1
a137 1
                      primf_tab[o->args.primf]);
d142 1
a142 1
        o->code=s;
d147 1
a147 1
        o->command=code_ok;
d150 1
a150 1
                      primf_tab[o->args.primf]);
d155 1
a155 1
        o->code=s;
d160 1
a160 1
        o->command=code_ok;
d163 1
a163 1
                      primf_tab[o->args.primf]);
d168 1
a168 1
        o->code=s;
d173 1
a173 1
        o->command=code_ok;
d176 1
a176 1
                      primf_tab[o->args.primf]);
d181 1
a181 1
        o->code=s;
d186 1
a186 1
        o->command=code_ok;
d189 1
a189 1
                      primf_tab[o->args.primf]);
d194 1
a194 1
        o->code=s;
d199 1
a199 1
        o->command=code_ok;
d202 1
a202 1
                      primf_tab[o->args.primf]);
d207 1
a207 1
        o->code=s;
d212 1
a212 1
        o->command=code_ok;
d215 1
a215 1
                      primf_tab[o->args.primf]);
d220 1
a220 1
        o->code=s;
d225 1
a225 1
        o->command=code_ok;
d228 1
a228 1
                      primf_tab[o->args.primf]);
d233 1
a233 1
        o->code=s;
d238 1
a238 1
        o->command=code_ok;
d241 1
a241 1
                      primf_tab[o->args.primf]);
d246 1
a246 1
        o->code=s;
d251 1
a251 1
        o->command=code_ok;
d254 1
a254 1
                      primf_tab[o->args.primf]);
d259 1
a259 1
        o->code=s;
d264 1
a264 1
        o->command=code_ok;
d267 1
a267 1
                      primf_tab[o->args.primf]);
d272 1
a272 1
        o->code=s;
d277 1
a277 1
        o->command=code_ok;
d280 1
a280 1
                      primf_tab[o->args.primf]);
d285 1
a285 1
        o->code=s;
d290 1
a290 1
        o->command=code_ok;
d293 1
a293 1
                      primf_tab[o->args.primf]);
d298 1
a298 1
        o->code=s;
d303 1
a303 1
        o->command=code_ok;
d306 1
a306 1
                      primf_tab[o->args.primf]);
d311 1
a311 1
        o->code=s;
d316 1
a316 1
        o->command=code_ok;
d319 1
a319 1
                      primf_tab[o->args.primf]);
d324 1
a324 1
        o->code=s;
d329 1
a329 1
        o->command=code_ok;
d332 1
a332 1
                      primf_tab[o->args.primf]);
d337 1
a337 1
        o->code=s;
d342 1
a342 1
        o->command=code_ok;
d345 1
a345 1
                      primf_tab[o->args.primf]);
d350 1
a350 1
        o->code=s;
d355 1
a355 1
        o->command=code_ok;
d358 1
a358 1
                      primf_tab[o->args.primf]);
d363 1
a363 1
        o->code=s;
d368 1
a368 1
        o->command=code_ok;
d371 1
a371 1
                      primf_tab[o->args.primf]);
d376 1
a376 1
        o->code=s;
d381 1
a381 1
        o->command=code_ok;
d384 1
a384 1
                      primf_tab[o->args.primf]);
d389 1
a389 1
        o->code=s;
d394 1
a394 1
        o->command=code_ok;
d397 1
a397 1
                      primf_tab[o->args.primf]);
d402 1
a402 1
        o->code=s;
d407 1
a407 1
        o->command=code_ok;
d410 1
a410 1
                      primf_tab[o->args.primf]);
d415 1
a415 1
        o->code=s;
d420 1
a420 1
        o->command=code_ok;
d423 1
a423 1
                      primf_tab[o->args.primf]);
d428 1
a428 1
        o->code=s;
d433 1
a433 1
        o->command=code_ok;
d436 1
a436 1
                      primf_tab[o->args.primf]);
d441 1
a441 1
        o->code=s;
d446 1
a446 1
        o->command=code_ok;
d449 1
a449 1
                      primf_tab[o->args.primf]);
d454 1
a454 1
        o->code=s;
d459 1
a459 1
        o->command=code_ok;
d462 1
a462 1
                      primf_tab[o->args.primf]);
d467 1
a467 1
        o->code=s;
d481 1
a481 1
      switch(o->args.primf)
d485 1
a485 1
        o->command=code_ok;
d488 1
a488 1
                      primf_tab[o->args.primf]);
d493 1
a493 1
        o->code=s;
d498 1
a498 1
        o->command=code_ok;
d501 1
a501 1
                      primf_tab[o->args.primf]);
d506 1
a506 1
        o->code=s;
d511 1
a511 1
        o->command=code_ok;
d514 1
a514 1
                      primf_tab[o->args.primf]);
d519 1
a519 1
        o->code=s;
d524 1
a524 1
        o->command=code_ok;
d527 1
a527 1
                      primf_tab[o->args.primf]);
d532 1
a532 1
        o->code=s;
d537 1
a537 1
        o->command=code_ok;
d540 1
a540 1
                      primf_tab[o->args.primf]);
d545 1
a545 1
        o->code=s;
d550 1
a550 1
        o->command=code_ok;
d553 1
a553 1
                      primf_tab[o->args.primf]);
d558 1
a558 1
        o->code=s;
d563 1
a563 1
        o->command=code_ok;
d566 1
a566 1
                      primf_tab[o->args.primf]);
d571 1
a571 1
        o->code=s;
d576 1
a576 1
        o->command=code_ok;
d579 1
a579 1
                      primf_tab[o->args.primf]);
d584 1
a584 1
        o->code=s;
d589 1
a589 1
        o->command=code_ok;
d592 1
a592 1
                      primf_tab[o->args.primf]);
d597 1
a597 1
        o->code=s;
d602 1
a602 1
        o->command=code_ok;
d605 1
a605 1
                      primf_tab[o->args.primf]);
d610 1
a610 1
        o->code=s;
d615 1
a615 1
        o->command=code_ok;
d618 1
a618 1
                      primf_tab[o->args.primf]);
d623 1
a623 1
        o->code=s;
d628 1
a628 1
        o->command=code_ok;
d631 1
a631 1
                      primf_tab[o->args.primf]);
d636 1
a636 1
        o->code=s;
d641 1
a641 1
        o->command=code_ok;
d644 1
a644 1
                      primf_tab[o->args.primf]);
d649 1
a649 1
        o->code=s;
d654 1
a654 1
        o->command=code_ok;
d657 1
a657 1
                      primf_tab[o->args.primf]);
d662 1
a662 1
        o->code=s;
d667 1
a667 1
        o->command=code_ok;
d670 1
a670 1
                      primf_tab[o->args.primf]);
d675 1
a675 1
        o->code=s;
d680 1
a680 1
        o->command=code_ok;
d683 1
a683 1
                      primf_tab[o->args.primf]);
d688 1
a688 1
        o->code=s;
d693 1
a693 1
        o->command=code_ok;
d696 1
a696 1
                      primf_tab[o->args.primf]);
d701 1
a701 1
        o->code=s;
d706 1
a706 1
        o->command=code_ok;
d709 1
a709 1
                      primf_tab[o->args.primf]);
d714 1
a714 1
        o->code=s;
d719 1
a719 1
        o->command=code_ok;
d722 1
a722 1
                      primf_tab[o->args.primf]);
d727 1
a727 1
        o->code=s;
d732 1
a732 1
        o->command=code_ok;
d735 1
a735 1
                      primf_tab[o->args.primf]);
d740 1
a740 1
        o->code=s;
d745 1
a745 1
        o->command=code_ok;
d748 1
a748 1
                      primf_tab[o->args.primf]);
d753 1
a753 1
        o->code=s;
d758 1
a758 1
        o->command=code_ok;
d761 1
a761 1
                      primf_tab[o->args.primf]);
d766 1
a766 1
        o->code=s;
d771 1
a771 1
        o->command=code_ok;
d774 1
a774 1
                      primf_tab[o->args.primf]);
d779 1
a779 1
        o->code=s;
d784 1
a784 1
        o->command=code_ok;
d787 1
a787 1
                      primf_tab[o->args.primf]);
d792 1
a792 1
        o->code=s;
d797 1
a797 1
        o->command=code_ok;
d800 1
a800 1
                      primf_tab[o->args.primf]);
d805 1
a805 1
        o->code=s;
d810 1
a810 1
        o->command=code_ok;
d813 1
a813 1
                      primf_tab[o->args.primf]);
d818 1
a818 1
        o->code=s;
d823 1
a823 1
        o->command=code_ok;
d826 1
a826 1
                      primf_tab[o->args.primf]);
d831 1
a831 1
        o->code=s;
d836 1
a836 1
        o->command=code_ok;
d839 1
a839 1
                      primf_tab[o->args.primf]);
d844 1
a844 1
        o->code=s;
d849 1
a849 1
        o->command=code_ok;
d852 1
a852 1
                      primf_tab[o->args.primf]);
d857 1
a857 1
        o->code=s;
d862 1
a862 1
        o->command=code_ok;
d865 1
a865 1
                      primf_tab[o->args.primf]);
d870 1
a870 1
        o->code=s;
d875 1
a875 1
        o->command=code_ok;
d878 1
a878 1
                      primf_tab[o->args.primf]);
d883 1
a883 1
        o->code=s;
d888 1
a888 1
        o->command=code_ok;
d891 1
a891 1
                      primf_tab[o->args.primf]);
d896 1
a896 1
        o->code=s;
d901 1
a901 1
        o->command=code_ok;
d904 1
a904 1
                      primf_tab[o->args.primf]);
d909 1
a909 1
        o->code=s;
d924 1
a924 1
      switch(o->args.primf)
d928 1
a928 1
        o->command=code_ok;
d931 1
a931 1
                      primf_tab[o->args.primf]);
d936 1
a936 1
        o->code=s;
d941 1
a941 1
        o->command=code_ok;
d944 1
a944 1
                      primf_tab[o->args.primf]);
d949 1
a949 1
        o->code=s;
d954 1
a954 1
        o->command=code_ok;
d957 1
a957 1
                      primf_tab[o->args.primf]);
d962 1
a962 1
        o->code=s;
d967 1
a967 1
        o->command=code_ok;
d970 1
a970 1
                      primf_tab[o->args.primf]);
d975 1
a975 1
        o->code=s;
d980 1
a980 1
        o->command=code_ok;
d983 1
a983 1
                      primf_tab[o->args.primf]);
d988 1
a988 1
        o->code=s;
d993 1
a993 1
        o->command=code_ok;
d996 1
a996 1
                      primf_tab[o->args.primf]);
d1001 1
a1001 1
        o->code=s;
d1006 1
a1006 1
        o->command=code_ok;
d1009 1
a1009 1
                      primf_tab[o->args.primf]);
d1014 1
a1014 1
        o->code=s;
d1019 1
a1019 1
        o->command=code_ok;
d1022 1
a1022 1
                      primf_tab[o->args.primf]);
d1027 1
a1027 1
        o->code=s;
d1043 1
a1043 1
      switch(o->args.primf)
d1047 1
a1047 1
        o->command=code_ok;
d1050 1
a1050 1
                      primf_tab[o->args.primf]);
d1056 1
a1056 1
        o->code=s;
d1061 1
a1061 1
        o->command=code_ok;
d1064 1
a1064 1
                      primf_tab[o->args.primf]);
d1069 1
a1069 1
        o->code=s;
d1145 1
a1145 1
    switch(help->command)
d1150 1
a1150 1
      if (!strcmp(act_func,help->args.label))
d1152 2
a1153 2
        help->command=tailnear;
        help->args.n=0;
d1157 1
a1157 1
        help->command=tailfar;
d1191 1
a1191 1
  while (code_ok==help->command) help=GETNEXTORDER(help);
d1195 1
a1195 1
    switch (help->command)
d1203 1
a1203 1
      if (!strcmp(act_func,help->args.label))
d1205 1
a1205 1
        help->command=betanear;
d1209 2
a1210 2
        help->command=betafar;
        strcpy(help->args.ret,act_func);
d1212 1
a1212 1
      help->args.n=i;
d1223 1
a1223 1
      if (!strcmp(act_func,help->args.label))
d1225 1
a1225 1
        help->command=gammanear;
d1229 2
a1230 2
        help->command=gammafar;
        strcpy(help->args.ret,act_func);
d1232 1
a1232 1
      help->args.n=i;
d1243 1
a1243 1
      if (!strcmp(act_func,help->args.label))
d1245 1
a1245 1
        help->command=gammabetanear;
d1249 2
a1250 2
        help->command=gammabetafar;
        strcpy(help->args.ret,act_func);
d1252 1
a1252 1
      help->args.n=i;
d1264 2
a1265 2
      strcpy(help->args.ret,act_func);
      help->args.m=i;
@


1.14
log
@*** empty log message ***
@
text
@d473 1
a473 1
               f->name);
d915 1
a915 1
               f->name);
d1033 1
a1033 1
               f->name);
d1075 1
a1075 1
               f->name);
@


1.13
log
@bugfix
@
text
@d1084 1
a1084 1
    o=o->next;   
d1139 2
a1140 2
  char *act_func=f->name;
  ORDER *help=f->order;
d1164 1
a1164 1
    help=help->next;
d1181 1
a1181 1
  char *act_func=f->name,
d1186 1
a1186 1
  help=f->order;
d1191 1
a1191 1
  while (code_ok==help->command) help=help->next;
d1201 1
a1201 1
      insert_order_list(nhelp,help->next);
d1221 1
a1221 1
      insert_order_list(nhelp,help->next);
d1241 1
a1241 1
      insert_order_list(nhelp,help->next);
d1262 1
a1262 1
      insert_order_list(nhelp,help->next);
d1275 1
a1275 1
    help=help->next;
@


1.12
log
@bugfix
@
text
@d100 1
a100 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d113 1
a113 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d126 1
a126 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d139 1
a139 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d152 1
a152 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d165 1
a165 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d178 1
a178 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d191 1
a191 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d204 1
a204 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d217 1
a217 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d230 1
a230 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d243 1
a243 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d256 1
a256 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d269 1
a269 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d282 1
a282 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d295 1
a295 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d308 1
a308 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d321 1
a321 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d334 1
a334 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d347 1
a347 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d360 1
a360 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d373 1
a373 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d386 1
a386 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d399 1
a399 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d412 1
a412 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d425 1
a425 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d438 1
a438 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d451 1
a451 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d464 1
a464 1
        strcat(text,"else repl(1, w, (int)_desc);\n");
d490 1
a490 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d503 1
a503 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d516 1
a516 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d529 1
a529 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d542 1
a542 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d555 1
a555 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d568 1
a568 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d581 1
a581 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d594 1
a594 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d607 1
a607 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d620 1
a620 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d633 1
a633 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d646 1
a646 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d659 1
a659 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d672 1
a672 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d685 1
a685 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d698 1
a698 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d711 1
a711 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d724 1
a724 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d737 1
a737 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d750 1
a750 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d763 1
a763 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d776 1
a776 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d789 1
a789 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d802 1
a802 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d815 1
a815 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d828 1
a828 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d841 1
a841 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d854 1
a854 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d867 1
a867 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d880 1
a880 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d893 1
a893 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d906 1
a906 1
        strcat(text,"else { drop(w, 1); repl(1, w, (int)_desc); }\n");
d933 1
a933 1
        strcat(text,"else { drop(w, 2); repl(1, w, (int)_desc); }\n");
d946 1
a946 1
        strcat(text,"else { drop(w, 2); repl(1, w, (int)_desc); }\n");
d959 1
a959 1
        strcat(text,"else { drop(w, 2); repl(1, w, (int)_desc); }\n");
d972 1
a972 1
        strcat(text,"else { drop(w, 2); repl(1, w, (int)_desc); }\n");
d985 1
a985 1
        strcat(text,"else { drop(w, 2); repl(1, w, (int)_desc); }\n");
d998 1
a998 1
        strcat(text,"else { drop(w, 2); repl(1, w, (int)_desc); }\n");
d1011 1
a1011 1
        strcat(text,"else { drop(w, 2); repl(1, w, (int)_desc); }\n");
d1024 1
a1024 1
        strcat(text,"else { drop(w, 2); repl(1, w, (int)_desc); }\n");
d1052 1
a1052 1
        strcat(text,"else { drop(w, 3); repl(1, w, (int)_desc); }\n");
d1066 1
a1066 1
        strcat(text,"else { drop(w, 3); repl(1, w, (int)_desc); }\n");
@


1.11
log
@*** empty log message ***
@
text
@d919 1
d1036 2
a1037 1
      } /* SWITCH(O->COMMAND) */     
d1085 1
a1085 1
  } /* WHILE (NULL!=O) */
@


1.10
log
@typed orders removed
@
text
@d9 1
d80 1
a80 1
  char text[100], *s;
d96 5
a100 1
        strcpy(text,"red_abs(pop(w));\npush((int)_desc);");
d109 5
a113 1
        strcpy(text,"red_neg(pop(w));\npush((int)_desc);");
d122 5
a126 1
        strcpy(text,"red_exp(pop(w));\npush((int)_desc);");
d135 5
a139 1
        strcpy(text,"red_ln(pop(w));\npush((int)_desc);");
d148 5
a152 1
        strcpy(text,"red_sin(pop(w));\npush((int)_desc);");
d161 5
a165 1
        strcpy(text,"red_cos(pop(w));\npush((int)_desc);");
d174 5
a178 1
        strcpy(text,"red_tan(pop(w));\npush((int)_desc);");
d187 5
a191 1
        strcpy(text,"red_floor(pop(w));\npush((int)_desc);");
d200 5
a204 1
        strcpy(text,"red_ceil(pop(w));\npush((int)_desc);");
d213 5
a217 1
        strcpy(text,"red_frac(pop(w));\npush((int)_desc);");
d226 5
a230 1
        strcpy(text,"red_trunc(pop(w));\npush((int)_desc);");
d239 5
a243 1
        strcpy(text,"red_vc_plus(pop(w));\npush((int)_desc);");
d252 5
a256 1
        strcpy(text,"red_vc_minus(pop(w));\npush((int)_desc);");
d265 5
a269 1
        strcpy(text,"red_vc_mult(pop(w));\npush((int)_desc);");
d278 5
a282 1
        strcpy(text,"red_vc_div(pop(w));\npush((int)_desc);");
d291 5
a295 1
        strcpy(text,"red_vc_min(pop(w));\npush((int)_desc);");
d304 5
a308 1
        strcpy(text,"red_vc_max(pop(w));\npush((int)_desc);");
d317 5
a321 1
        strcpy(text,"red_ldim(pop(w));\npush((int)_desc);");
d330 5
a334 1
        strcpy(text,"red_vdim(pop(w));\npush((int)_desc);");
d343 5
a347 1
        strcpy(text,"red_lmim(pop(w));\npush((int)_desc);");
d356 5
a360 1
        strcpy(text,"red_class(pop(w));\npush((int)_desc);");
d369 5
a373 1
        strcpy(text,"red_type(pop(w));\npush((int)_desc);");
d382 5
a386 1
        strcpy(text,"red_empty(pop(w));\npush((int)_desc);");
d395 5
a399 1
        strcpy(text,"red_transpose(pop(w));\npush((int)_desc);");
d408 5
a412 1
        strcpy(text,"red_reverse(pop(w));\npush((int)_desc);");
d421 5
a425 1
        strcpy(text,"red_to_scal(pop(w));\npush((int)_desc);");
d434 5
a438 1
        strcpy(text,"red_to_vect(pop(w));\npush((int)_desc);");
d447 5
a451 1
        strcpy(text,"red_to_tvect(pop(w));\npush((int)_desc);");
d460 5
a464 1
        strcpy(text,"red_to_mat(pop(w));\npush((int)_desc);");
d471 4
d486 5
a490 1
        strcpy(text,"red_eq(top(w), peek(w,1));drop(w,2);\npush((int)_desc);");
d499 5
a503 1
        strcpy(text,"red_neq(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d512 5
a516 1
        strcpy(text,"red_f_eq(top(w), peek(w,1));drop(w,2);\npush((int)_desc);");
d525 5
a529 1
        strcpy(text,"red_f_eq(top(w),peek(w,1));drop(w,2);\npush(NOT_BOOL((int)_desc));");
d538 5
a542 1
        strcpy(text,"red_geq(top(w), peek(w,1));drop(w,2);\npush(int)_desc);");
d551 5
a555 1
        strcpy(text,"red_gt(top(w), peek(w,1));drop(w,2);\npush((int)_desc);");
d564 5
a568 1
        strcpy(text,"red_lt(top(w), peek(w,1));drop(w,2);\npush((int)_desc);");
d577 5
a581 1
        strcpy(text,"red_le(top(w), peek(w,1));drop(w,2);\npush((int)_desc);");
d590 5
a594 1
        strcpy(text,"red_minus(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d603 5
a607 1
        strcpy(text,"red_plus(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d616 5
a620 1
        strcpy(text,"red_mult(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d629 5
a633 1
        strcpy(text,"red_div(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d642 5
a646 1
        strcpy(text,"red_mod(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d655 5
a659 1
        strcpy(text,"red_ip(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d668 5
a672 1
        strcpy(text,"red_max(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d681 5
a685 1
        strcpy(text,"red_min(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d694 5
a698 1
        strcpy(text,"red_and(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d707 5
a711 1
        strcpy(text,"red_or(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d720 5
a724 1
        strcpy(text,"red_xor(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d733 5
a737 1
        strcpy(text,"red_lselect(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d746 5
a750 1
        strcpy(text,"red_lcut(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d759 5
a763 1
        strcpy(text,"red_lrotate(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d772 5
a776 1
        strcpy(text,"red_lunite(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d785 5
a789 1
        strcpy(text,"red_vselect(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d798 5
a802 1
        strcpy(text,"red_vcut(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d811 5
a815 1
        strcpy(text,"red_lrotate(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d824 5
a828 1
        strcpy(text,"red_lunite(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d837 5
a841 1
        strcpy(text,"red_c_div(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d850 5
a854 1
        strcpy(text,"red_c_min(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d863 5
a867 1
        strcpy(text,"red_c_max(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d876 5
a880 1
        strcpy(text,"red_c_minus(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d889 5
a893 1
        strcpy(text,"red_c_mult(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d902 5
a906 1
        strcpy(text,"red_c_plus(top(w),peek(w,1));drop(w,2);\npush((int)_desc);");
d913 4
a920 7







d928 5
a932 1
        strcpy(text,"red_lreplace(top(w),peek(w,1),peek(w,2));drop(w,3);\npush((int)_desc);");
d941 5
a945 1
        strcpy(text,"red_mselect(top(w),peek(w,1),peek(w,2));drop(w,3);\npush((int)_desc);");
d954 5
a958 1
        strcpy(text,"red_mcut(top(w),peek(w,1),peek(w,2));drop(w,3);\npush((int)_desc);");
d967 5
a971 1
        strcpy(text,"red_mrotate(top(w),peek(w,1),peek(w,2));drop(w,3);\npush((int)_desc);");
d980 5
a984 1
        strcpy(text,"red_munite(top(w),peek(w,1),peek(w,2));drop(w,3);\npush((int)_desc);");
d993 5
a997 1
        strcpy(text,"red_mre_r(top(w),peek(w,1),peek(w,2));drop(w,3);\npush((int)_desc);");
d1006 5
a1010 1
        strcpy(text,"red_mre_c(top(w),peek(w,1),peek(w,2));drop(w,3);\npush((int)_desc);");
d1019 5
a1023 1
        strcpy(text,"red_ltransform(top(w),peek(w,1),peek(w,2));drop(w,3);\npush((int)_desc);");
d1030 4
d1046 5
d1060 5
a1064 1
        strcpy(text,"red_repstr(top(w),peek(w,1),peek(w,2),peek(w,3));drop(w,4);\npush((int)_desc);");
d1071 4
@


1.9
log
@plus_ii -> add_ii
@
text
@a15 92
/*************************************************************************/
/* compiles patterns like                                                */
/*   stack_w_access                                                      */
/*   stack_w_access                                                      */
/*   typed_primfunc                                                      */
/* to                                                                    */
/*   pushcw_b(direct_value op direct_value)        for example in le_ii  */
/* so it kills the two preceeding orders in list and sets the optiflag   */
/* in the resulting order                                                */
/*************************************************************************/

void compile_typed_primf(FUNCTION *f)
{
#define USERDEFINED(p)  ((tail==p)||(beta==p)||(Gamma==p)||(gammabeta==p))

  char text[80];
  ORDER *o;
    
  DBUG_ENTER("compile_typed_primf");

  o=f->order;
  while (NULL!=o)
  {
    switch(o->command)
    {
    case le_ii:
    {
      if (USERDEFINED(o->prev->command)||USERDEFINED(o->prev->prev->command))
        strcpy(text,"repl(1, w,top(w) <= peek(w,1));drop(w,1);");
      else
      {
        sprintf(text,"(%s <= %s)",gimme_code(o->prev->prev), \
                                       gimme_code(o->prev));
        delete_order(o->prev->prev);
        delete_order(o->prev);
        o->code=get_str_space(text);
        o->opti=TRUE;
        o->command=pushcw_b;
      }
    }
    case mult_ii:
    {
      if (USERDEFINED(o->prev->command)||USERDEFINED(o->prev->prev->command))
        strcpy(text,"repl(1, w,top(w) * peek(w,1));drop(w,1);");
      else
      {
        sprintf(text,"(%s * %s)",gimme_code(o->prev->prev), \
                                       gimme_code(o->prev));
        delete_order(o->prev->prev);
        delete_order(o->prev);
        o->code=get_str_space(text);
        o->opti=TRUE;
        o->command=pushcw_b;
      }
    }
    case add_ii:
    {
      if (USERDEFINED(o->prev->command)||USERDEFINED(o->prev->prev->command))
        strcpy(text,"repl(1, w,top(w) + peek(w,1));drop(w,1);");
      else
      {
        sprintf(text,"(%s + %s)",gimme_code(o->prev->prev), \
                                       gimme_code(o->prev));
        delete_order(o->prev->prev);
        delete_order(o->prev);
        o->code=get_str_space(text);
        o->opti=TRUE;
        o->command=pushcw_b;
      }
    }
    case minus_ii:
    {
      if (USERDEFINED(o->prev->command)||USERDEFINED(o->prev->prev->command))
        strcpy(text,"repl(1, w,top(w) - peek(w,1));drop(w,1);");
      else
      {
        sprintf(text,"(%s - %s)",gimme_code(o->prev->prev), \
                                       gimme_code(o->prev));
        delete_order(o->prev->prev);
        delete_order(o->prev);
        o->code=get_str_space(text);
        o->opti=TRUE;
        o->command=pushcw_b;
      }
    }
    default:
      fprintf(stderr,"implement me in compile_typed_primf\n");
    }
  o=o->next;
  }
  DBUG_VOID_RETURN;
}
@


1.8
log
@revision of apply{near|far} to apply
@
text
@d71 1
a71 1
    case plus_ii:
@


1.7
log
@applynear and applyfar implemented
@
text
@d1055 1
a1055 9
      if (!strcmp(act_func,help->args.label))
      {
        help->command=applynear;
      }
      else
      {
        help->command=applyfar;
        strcpy(help->args.ret,act_func);
      }
@


1.6
log
@*** empty log message ***
@
text
@d965 1
d1047 1
d1049 22
@


1.5
log
@Macro USERDEFINED extended
@
text
@d44 1
a44 1
        strcpy(text,"repl1(w,top(w) <= peek(w,1));drop(w,1);");
d59 1
a59 1
        strcpy(text,"repl1(w,top(w) * peek(w,1));drop(w,1);");
d74 1
a74 1
        strcpy(text,"repl1(w,top(w) + peek(w,1));drop(w,1);");
d89 1
a89 1
        strcpy(text,"repl1(w,top(w) - peek(w,1));drop(w,1);");
@


1.4
log
@fixed arity orders removed
@
text
@d29 1
a29 1
#define USERDEFINED(p)  ((beta==p)||(Gamma==p)||(gammabeta==p))
@


1.3
log
@#include "comp_support.h" entfernt
#define USERDEFINED(p) eingefuegt
@
text
@a131 10
  case pushaw0:
  {
    sprintf(text,"peek(a,0)");
    break;
  }
  case pushtw0:
  {
    sprintf(text,"peek(t,0)");
    break;
  }
d1006 1
a1006 101
    case beta0:
    {
         /* first: set the label behind the call **************/
      sprintf(s,"L%d:",i);
      nhelp=new_order(code_ok,s);
      insert_order_list(nhelp,help->next);
         /* second: check if call to actual function **********/
      if (!strcmp(act_func,help->args.label))
      {
        help->command=beta0near;
      }
      else
      {
        help->command=beta0far;
        strcpy(help->args.ret,act_func);
      }
      help->args.n=i;
      i+=4;
      break;
    }
    case beta1:
    {
         /* first: set the label behind the call **************/
      sprintf(s,"L%d:",i);
      nhelp=new_order(code_ok,s);
      insert_order_list(nhelp,help->next);
         /* second: check if call to actual function **********/
      if (!strcmp(act_func,help->args.label))
      {
        help->command=beta1near;
      }
      else
      {
        help->command=beta1far;
        strcpy(help->args.ret,act_func);
      }
      help->args.n=i;
      i+=4;
      break;
    }
    case betaq:
    {
         /* first: set the label behind the call **************/
      sprintf(s,"L%d:",i);
      nhelp=new_order(code_ok,s);
      insert_order_list(nhelp,help->next);
         /* second: check if call to actual function **********/
      if (!strcmp(act_func,help->args.label))
      {
        help->command=betaqnear;
      }
      else
      {
        help->command=betaqfar;
        strcpy(help->args.ret,act_func);
      }
      help->args.n=i;
      i+=4;
      break;
    }
    case betaq0:
    {
         /* first: set the label behind the call **************/
      sprintf(s,"L%d:",i);
      nhelp=new_order(code_ok,s);
      insert_order_list(nhelp,help->next);
         /* second: check if call to actual function **********/
      if (!strcmp(act_func,help->args.label))
      {
        help->command=betaq0near;
      }
      else
      {
        help->command=betaq0far;
        strcpy(help->args.ret,act_func);
      }
      help->args.n=i;
      i+=4;
      break;
    }
    case betaq1:
    {
         /* first: set the label behind the call **************/
      sprintf(s,"L%d:",i);
      nhelp=new_order(code_ok,s);
      insert_order_list(nhelp,help->next);
         /* second: check if call to actual function **********/
      if (!strcmp(act_func,help->args.label))
      {
        help->command=betaq1near;
      }
      else
      {
        help->command=betaq1far;
        strcpy(help->args.ret,act_func);
      }
      help->args.n=i;
      i+=4;
      break;
    }
    case Gamma:
@


1.2
log
@initial incomplete version
@
text
@a5 1
#include "comp_support.h"
d29 2
@


1.1
log
@Initial revision
@
text
@a3 1
#include "rstelem.h"
@
