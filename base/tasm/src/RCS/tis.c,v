head	1.88;
access;
symbols;
locks; strict;
comment	@ * @;


1.88
date	96.07.08.12.01.38;	author um;	state Exp;
branches;
next	1.87;

1.87
date	96.05.09.13.07.25;	author cr;	state Exp;
branches;
next	1.86;

1.86
date	96.05.07.11.04.44;	author um;	state Exp;
branches;
next	1.85;

1.85
date	96.03.12.17.01.22;	author stt;	state Exp;
branches;
next	1.84;

1.84
date	96.02.23.14.10.32;	author rs;	state Exp;
branches;
next	1.83;

1.83
date	96.02.19.13.54.20;	author cr;	state Exp;
branches;
next	1.82;

1.82
date	96.02.16.13.52.28;	author stt;	state Exp;
branches;
next	1.81;

1.81
date	96.02.13.16.25.00;	author stt;	state Exp;
branches;
next	1.80;

1.80
date	96.02.12.10.50.00;	author um;	state Exp;
branches;
next	1.79;

1.79
date	96.01.18.10.44.08;	author um;	state Exp;
branches;
next	1.78;

1.78
date	95.08.15.07.32.41;	author um;	state Exp;
branches;
next	1.77;

1.77
date	95.08.02.08.20.43;	author um;	state Exp;
branches;
next	1.76;

1.76
date	95.07.10.07.38.38;	author um;	state Exp;
branches;
next	1.75;

1.75
date	95.07.04.09.34.02;	author um;	state Exp;
branches;
next	1.74;

1.74
date	95.06.30.08.33.40;	author um;	state Exp;
branches;
next	1.73;

1.73
date	95.06.15.10.02.39;	author um;	state Exp;
branches;
next	1.72;

1.72
date	95.06.06.10.25.24;	author um;	state Exp;
branches;
next	1.71;

1.71
date	95.05.29.12.01.49;	author um;	state Exp;
branches;
next	1.70;

1.70
date	95.05.24.10.15.58;	author um;	state Exp;
branches;
next	1.69;

1.69
date	95.05.23.11.54.34;	author um;	state Exp;
branches;
next	1.68;

1.68
date	95.05.17.12.12.29;	author um;	state Exp;
branches;
next	1.67;

1.67
date	95.05.17.07.56.20;	author um;	state Exp;
branches;
next	1.66;

1.66
date	95.05.15.10.17.21;	author um;	state Exp;
branches;
next	1.65;

1.65
date	95.05.12.11.57.31;	author um;	state Exp;
branches;
next	1.64;

1.64
date	95.05.12.07.10.38;	author um;	state Exp;
branches;
next	1.63;

1.63
date	95.05.10.06.31.35;	author um;	state Exp;
branches;
next	1.62;

1.62
date	95.05.08.08.46.20;	author um;	state Exp;
branches;
next	1.61;

1.61
date	95.05.02.07.43.51;	author um;	state Exp;
branches;
next	1.60;

1.60
date	95.04.27.11.32.59;	author um;	state Exp;
branches;
next	1.59;

1.59
date	95.04.26.15.21.25;	author um;	state Exp;
branches;
next	1.58;

1.58
date	95.04.25.08.00.00;	author um;	state Exp;
branches;
next	1.57;

1.57
date	95.04.21.08.36.59;	author um;	state Exp;
branches;
next	1.56;

1.56
date	95.04.20.12.14.17;	author um;	state Exp;
branches;
next	1.55;

1.55
date	95.04.20.10.07.43;	author um;	state Exp;
branches;
next	1.54;

1.54
date	95.04.13.09.38.13;	author um;	state Exp;
branches;
next	1.53;

1.53
date	95.04.12.07.51.15;	author um;	state Exp;
branches;
next	1.52;

1.52
date	95.04.11.09.36.19;	author um;	state Exp;
branches;
next	1.51;

1.51
date	95.04.11.08.19.35;	author um;	state Exp;
branches;
next	1.50;

1.50
date	95.04.05.10.14.12;	author um;	state Exp;
branches;
next	1.49;

1.49
date	95.03.28.09.10.33;	author um;	state Exp;
branches;
next	1.48;

1.48
date	95.03.28.08.33.25;	author um;	state Exp;
branches;
next	1.47;

1.47
date	95.03.27.08.44.09;	author um;	state Exp;
branches;
next	1.46;

1.46
date	95.03.22.10.41.48;	author um;	state Exp;
branches;
next	1.45;

1.45
date	95.03.20.09.17.15;	author um;	state Exp;
branches;
next	1.44;

1.44
date	95.03.16.09.01.36;	author um;	state Exp;
branches;
next	1.43;

1.43
date	95.03.15.08.24.50;	author um;	state Exp;
branches;
next	1.42;

1.42
date	95.03.13.10.59.42;	author um;	state Exp;
branches;
next	1.41;

1.41
date	95.03.08.08.46.24;	author um;	state Exp;
branches;
next	1.40;

1.40
date	95.03.07.13.41.16;	author um;	state Exp;
branches;
next	1.39;

1.39
date	95.03.07.07.57.34;	author um;	state Exp;
branches;
next	1.38;

1.38
date	95.03.06.09.51.03;	author um;	state Exp;
branches;
next	1.37;

1.37
date	95.03.02.15.21.35;	author um;	state Exp;
branches;
next	1.36;

1.36
date	95.02.14.08.07.49;	author um;	state Exp;
branches;
next	1.35;

1.35
date	95.02.07.08.54.02;	author um;	state Exp;
branches;
next	1.34;

1.34
date	95.02.03.07.56.22;	author um;	state Exp;
branches;
next	1.33;

1.33
date	95.02.02.13.21.44;	author um;	state Exp;
branches;
next	1.32;

1.32
date	95.01.30.15.09.40;	author um;	state Exp;
branches;
next	1.31;

1.31
date	95.01.26.09.57.19;	author um;	state Exp;
branches;
next	1.30;

1.30
date	95.01.18.07.50.52;	author um;	state Exp;
branches;
next	1.29;

1.29
date	95.01.16.07.25.00;	author um;	state Exp;
branches;
next	1.28;

1.28
date	95.01.05.08.37.07;	author um;	state Exp;
branches;
next	1.27;

1.27
date	94.12.30.07.59.37;	author um;	state Exp;
branches;
next	1.26;

1.26
date	94.12.28.09.14.30;	author um;	state Exp;
branches;
next	1.25;

1.25
date	94.12.23.08.46.51;	author um;	state Exp;
branches;
next	1.24;

1.24
date	94.12.22.11.15.49;	author um;	state Exp;
branches;
next	1.23;

1.23
date	94.12.22.08.23.29;	author um;	state Exp;
branches;
next	1.22;

1.22
date	94.12.19.16.02.30;	author um;	state Exp;
branches;
next	1.21;

1.21
date	94.12.19.07.14.49;	author um;	state Exp;
branches;
next	1.20;

1.20
date	94.12.16.08.03.34;	author um;	state Exp;
branches;
next	1.19;

1.19
date	94.12.15.14.18.14;	author um;	state Exp;
branches;
next	1.18;

1.18
date	94.12.15.09.36.42;	author um;	state Exp;
branches;
next	1.17;

1.17
date	94.12.09.09.42.10;	author um;	state Exp;
branches;
next	1.16;

1.16
date	94.12.08.15.26.12;	author um;	state Exp;
branches;
next	1.15;

1.15
date	94.12.08.09.49.53;	author um;	state Exp;
branches;
next	1.14;

1.14
date	94.12.06.09.48.48;	author um;	state Exp;
branches;
next	1.13;

1.13
date	94.12.02.09.53.44;	author um;	state Exp;
branches;
next	1.12;

1.12
date	94.12.01.16.08.24;	author um;	state Exp;
branches;
next	1.11;

1.11
date	94.12.01.14.29.48;	author um;	state Exp;
branches;
next	1.10;

1.10
date	94.11.30.07.32.46;	author um;	state Exp;
branches;
next	1.9;

1.9
date	94.11.29.09.49.37;	author um;	state Exp;
branches;
next	1.8;

1.8
date	94.11.25.12.52.37;	author um;	state Exp;
branches;
next	1.7;

1.7
date	94.11.24.10.13.55;	author car;	state Exp;
branches;
next	1.6;

1.6
date	94.11.24.09.55.41;	author um;	state Exp;
branches;
next	1.5;

1.5
date	94.11.23.07.22.49;	author um;	state Exp;
branches;
next	1.4;

1.4
date	94.11.22.10.21.11;	author um;	state Exp;
branches;
next	1.3;

1.3
date	94.11.21.15.59.47;	author um;	state Exp;
branches;
next	1.2;

1.2
date	94.11.21.11.02.36;	author um;	state Exp;
branches;
next	1.1;

1.1
date	94.11.21.09.08.01;	author car;	state Exp;
branches;
next	;


desc
@initial incomplete version
@


1.88
log
@bugfix in 'bad recursion' for gammabeta
@
text
@#include <malloc.h>
#include <string.h>
#include "mytypes.h"
#include "loctypes.h"
#include "dbug.h"
#include "buildtree.h"
#include "support.h"
#include "tiny.h"
#include "tis.h"
#include "error.h"
#include "main.h"

FUNLIST *flbase=NULL;
char *vtis=VTIS;
STACK *func_dump;
/* constant ASM commands */
ORDER CONST_EXT={ext,{NULL},NULL,NULL,NULL,0,0},
      CONST_RTF	={rtf,{NULL},NULL,NULL,NULL,0,0,0,0},
      CONST_CCLOS={mkcclos,{0,0,0,0,0,0.0,"","",NULL,NULL,NULL,0},
		       NULL,NULL,NULL,0,0,0,0};
/* constant STackELeMent */
STELM CONST_NONE={tp_none,{tp_none,NULL},{NULL}};
KNOWLEDGE know=kn_sure;
int tis_state=0,do_dupe,dup_count=0,dup_num,max_desc_adr=0,new_params=0,
    clos_exe=0,arg_check=0;
ORDER *ord;
STACK *w,*a,*t,*r,*ret;

/************************************************************************/
/* returns type of executed function					*/
/* (used by execution)							*/
/************************************************************************/
STELM *exe_func()
{
STELM d_stelm;
long i;

DBUG_ENTER("exe_func");
while (TRUE)
  {
  if (_db_keyword_("STACKS"))
    stack_display();
  switch (GETORDERENTRY(ord,command))		/* command to be executed */
    {
    case pushcw_i:
      {
      DBUG_ORDERS("pushcw_i\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      d_stelm.type=tp_int;			/* set type int */
      d_stelm.subtype.type=tp_none;		/* set clear subtype */
      d_stelm.subtype.next=NULL;
      w=st_push(w,&d_stelm);
      ord=GETNEXTORDER(ord);
      break;
      }
    case pushcw_b:
      {
      DBUG_ORDERS("pushcw_b\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      d_stelm.type=tp_bool;			/* set type bool */
      d_stelm.subtype.type=tp_none;		/* set clear subtype */
      d_stelm.subtype.next=NULL;
      w=st_push(w,&d_stelm);
      ord=GETNEXTORDER(ord);
      break;
      }      
    case pushcw_pf:
      {
      DBUG_ORDERS("pushcw_pf\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      if (ISIA(GETORDERARGS(ord,primf)))
        w=st_push(w,&CONST_NONE);
      else
      {
        d_stelm.type=tp_prim;			/* set type prim */
        d_stelm.dat.prim=GETORDERARGS(ord,n);	/* which prim. function */
        d_stelm.subtype.type=tp_none;		/* set clear subtype */
        d_stelm.subtype.next=NULL;
        w=st_push(w,&d_stelm);
      }
      ord=GETNEXTORDER(ord);
      break;
      }
    case pushaw:
      {
      DBUG_ORDERS("pushaw\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      w=st_push(w,st_read(a,GETORDERARGS(ord,n))); /* copy element */ 
      ord=GETNEXTORDER(ord);
      break;
      }
    case pushtw:
      {
      DBUG_ORDERS("pushtw\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      w=st_push(w,st_read(t,GETORDERARGS(ord,n)));  /* copy element */ 
      ord=GETNEXTORDER(ord);
      break;
      }
    case pushtr:
      {
      DBUG_ORDERS("pushtr\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      r=st_push(r,st_read(t,GETORDERARGS(ord,n)));  /* copy element */ 
      ord=GETNEXTORDER(ord);
      break;
      }
      
    case pushar:
      {
      DBUG_ORDERS("pushar\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      r=st_push(r,st_read(a,GETORDERARGS(ord,n)));  /* copy element */ 
      ord=GETNEXTORDER(ord);
      break;
      }
    case pushr_p:
      {
      STELM *arg;
      
      DBUG_ORDERS("pushr_p\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      arg=find_address(GETORDERARGS(ord,desc));	/* search for adress */
      r=st_push(r,arg);				/* push arg to r STACK */
      stelm_free(arg);				/* free buffer */
      ord=GETNEXTORDER(ord);
      break;
      }
    case pushw_p:
      {
      STELM *arg;
      
      DBUG_ORDERS("pushw_p\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      arg=find_address(GETORDERARGS(ord,desc));	/* search for adress */
      w=st_push(w,arg);				/* push arg to w STACK */
      stelm_free(arg);				/* free buffer */
      ord=GETNEXTORDER(ord);
      break;
      }
    case pushaux:
      {
      DBUG_ORDERS("pushaux\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      						/* do nothing */
      ord=GETNEXTORDER(ord);			
      break;
      }
    case moveaw:
      {
      STELM *arg;
      
      DBUG_ORDERS("moveaw\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      arg=st_pop(a);				/* pop element from a STACK */
      w=st_push(w,arg);				/* push element to w STACK */
      stelm_free(arg);				/* free buffer */
      ord=GETNEXTORDER(ord);
      break;
      }
    case movear:
      {
      STELM *arg;
      
      DBUG_ORDERS("movear\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      arg=st_pop(a);				/* pop element from a STACK */
      r=st_push(r,arg);				/* push element to r STACK */
      stelm_free(arg);				/* free buffer */
      ord=GETNEXTORDER(ord);
      break;
      }
    case apply:
      {
      STELM *func,res;
      long arity;
      CLOSURE *clos;
      
      DBUG_ORDERS("apply\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      func=st_pop(w);				/* apply what ? */
      switch (GETSTELMTYPE(func))				
	{
	case tp_func:				/* we have a function! */
	  {
	  FUNDESC *des;
	  STELM *result,*old_func;
	  long i;
	  RETURNADR *rt;
	  ORDER *old_ord;
	  
	  des=GETSTELMDATA(func,desc);		/* get function descriptor */
          if (0!=GETORDERARGS(ord,m))
	    arity=GETORDERARGS(ord,m);		/* restore prev set apply-arity */
	  else
	    arity=GETORDERARGS(ord,n);		/* set normal apply-arity */
	  if (NULL==des)			/* no desciptor */
	    {
	    for (i=0; i<arity; i++)		/* remove all args from w STACK */
	      st_pop(w);
	    w=st_push(w,&CONST_NONE);		/* push result none */
	    SETORDERARGS(ord,m)=0;		/* set no args left */
	    insert_restype(&CONST_NONE,ord);	/* inser result type */
	    ord=GETNEXTORDER(ord);
	    }
	  else					/* there is a function desciptor */
	    {
	    if (NULL==(SETORDERARGS(ord,label)=
		malloc(strlen(GETDESCENTRY(des,label))+1))) /* store functionlable */
	      yyfail("%s","no memory for label!");
	    strcpy(SETORDERARGS(ord,label),GETDESCENTRY(des,label)); 
	    					/* remember last functioncall */
	    if (GETDESCENTRY(des,nv)<=arity)		/* if execution possible */
	      {
	      if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
		result=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
				  t,GETDESCENTRY(des,nfv));
	      else				/* we have a conditional */
		result=get_result(GETDESCENTRY(des,label),a,GETDESCENTRY(des,nv)-1,
				  t,GETDESCENTRY(des,nfv)/4);
	      if ((NULL!=ret) && (0<GETTOPOFSTACK(ret))) /* returnstack not empty */
		{
		old_func=getfunc_ret();			/* gets last functioncall */
		if (DT_CONDITIONAL!=GETDESCENTRY(des,tag)) /* sets dependencies */
		  set_depend(des,w,t,old_func);
		else
		  set_depend(des,a,t,old_func);
		}
	      if (((NULL!=result) && (tp_illegal!=result->type)) && 
		  				/* do we have a valid result ? */
		  (0==tis_state))	/* old result stored or second try */
		{
		if (arity==GETDESCENTRY(des,nv))/* if arity fits the need */
		  insert_restype(result,ord);	/* insert result type */
		if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
		  				/* remove args from w STACK */
		  {
		  for (i=0; i<GETDESCENTRY(des,nv); i++)
		    stelm_free(st_pop(w));
		  }
		else				/* for conditional one args less */
		  {
		  for (i=1; i<GETDESCENTRY(des,nv); i++)
		    stelm_free(st_pop(w));
		  }
		w=st_push(w,result);		/* push result */
		arity-=GETDESCENTRY(des,nv);	/* overloaded apply ? */
		SETORDERARGS(ord,m)=arity;	/* calc new arity */
		if (0==arity)
		  {
		  SETORDERARGS(ord,k)=-1;	/* order executed */
		  ord=GETNEXTORDER(ord);
		  }
		}
	      else				/* result unknown unitl now */
		{
		tis_state=0;
		old_ord=search_ret(ord);
		if (NULL==old_ord)		/* first call from here! */
		  {
		  if (NULL==(rt=malloc(sizeof(RETURNADR))))
		    yyfail("%s","no memory for returnadress!");
		  rt->ord=ord;			/* remember enviroment of func */
		  w=st_push(w,func);		/* save function */
		  rt->w=w;			/* store STACKs */
		  rt->a=a;
		  rt->t=t;
		  rt->r=r;
		  rt->status=(clos_exe*CLOS_EXE)+(new_params*NEW_PARAMS);
		  ret=st_push(ret,new_stelm(tp_returnadr,rt));
		  /* returndata stored */
		  if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))	/* COMBinator */
		    {
		    if (DT_CASE!=GETDESCENTRY(des,tag))		/* no CASE */
		      {
		      a=st_make(w,GETDESCENTRY(des,nv)+1);
		      				/* build new frames; +1 for func */
		      st_pop(a);			/* remove func from stack */
		      w=NULL;
		      t=st_make(t,GETDESCENTRY(des,nfv));
		      r=NULL;
		      SETORDERARGS(ord,m)=arity-GETDESCENTRY(des,nv);
		      					/* store overload arity */
		      ord=find_func(GETFIRSTFUNCTION(program_start),
				    GETDESCENTRY(des,label));
		      insert_args(a,GETDESCENTRY(des,nv),t,GETDESCENTRY(des,nfv),ord);
		      }
		    else				/* it is a CASE */
		      {
		      w=st_make(w,GETDESCENTRY(des,nv)+1);
		      				/* build new frames; +1 for func */
		      st_pop(w);			/* remove func from stack */
		      a=NULL;
		      t=st_make(t,GETDESCENTRY(des,nfv));
		      r=NULL;
		      SETORDERARGS(ord,m)=arity-GETDESCENTRY(des,nv);
		      					/* store overload arity */
		      ord=find_func(GETFIRSTFUNCTION(program_start),
				  GETDESCENTRY(des,label));
		      insert_args(w,GETDESCENTRY(des,nv),t,GETDESCENTRY(des,nfv),ord);
		      }
		    }
		  else					/* CONDItional */
		    {
		    char *str;
		    
		    w=st_make(w,2);			/* frame = bool + CONDI */
		    st_pop(w);				/* remove func from stack */
		    a=st_make(a,GETDESCENTRY(des,nv)-1); /* argument frame */
		    t=st_make(t,GETDESCENTRY(des,nfv)/4); /* tilde frame */
		    r=NULL;
		    SETORDERARGS(ord,m)=arity-GETDESCENTRY(des,nv);
		    					/* store overload arity */
		    if (NULL==(str=malloc(strlen(GETDESCENTRY(des,label)))))
		      yyfail("%s","no memory for label!");
		    strcpy(str,"func_");		/* build function label */
		    strcpy(&str[5],&(GETDESCENTRY(des,label)[6]));
		    ord=find_func(GETFIRSTFUNCTION(program_start),str);
		    if (1<GETDESCENTRY(des,nv))		/* are there any args */
		      insert_args(a,GETDESCENTRY(des,nv)-1,t,
				  GETDESCENTRY(des,nfv)/4,GETNEXTORDER(ord));
		    free(str);
		    }
		  }
		else					/* have been here before */
		  {
		  if (old_ord!=ord)			/* old_ord must be jcond */
		    {
		    if (NULL==(rt=malloc(sizeof(RETURNADR))))
		      yyfail("%s","no memory for returnadress!");
		    rt->ord=ord;			/* remember enviroment of func */
		    rt->status=(clos_exe*CLOS_EXE)+MUST_EXE; /* must execute */
		    rt->w=w;				/* store STACKs */
		    rt->w=st_push(w,func);
		    rt->a=a;
		    rt->t=t;
		    rt->r=r;
		    func_dump=st_push(func_dump,new_stelm(tp_returnadr,rt)); 
		    					/* returndata stored */
		    restore_ret(old_ord);		/* restors state of old_ord */
		    SETORDERENTRY(old_ord,branch)=
		      -GETORDERENTRY(old_ord,branch); /* then-case without result */
		    }
		  else					/* bad recursion */
		    {
		    if (((gammabeta==GETORDERENTRY(ord,command)) ||
			 (gammacase==GETORDERENTRY(ord,command))) ||
			(Gamma==GETORDERENTRY(ord,command)))
		      insert_functype(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
				      r,GETDESCENTRY(des,nfv),&CONST_NONE,kn_sure);
		    else
		      insert_functype(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
				      t,GETDESCENTRY(des,nfv),&CONST_NONE,kn_sure);
		    for (i=0; i<GETDESCENTRY(des,nv); i++) /* remove args from stack */
		      stelm_free(st_pop(w));
		    w=st_push(w,&CONST_NONE);		/* set result none */
		    ord=GETNEXTORDER(ord);
		    }
		  }
		}	  
	      }
	    else					/* build closure */
	      {
	      if (NULL==(clos=malloc(sizeof(CLOSURE))))
		yyfail("%s","no memory for closure");
	      if (NULL==(clos->desc=malloc(sizeof(FUNDESC))))
		yyfail("%s","no memory for descriptor!");
	      clos->desc=des;				/* set closure data */
	      clos->i=arity;
	      clos->j=GETDESCENTRY(clos->desc,nv);
	      clos->k=GETDESCENTRY(clos->desc,nfv);
	      if (0!=clos->i)				/* are there any args ? */
		{
		if (NULL==(clos->w=malloc(sizeof(STELM)*(clos->i))))
		  yyfail("%s","no memory for closure");
		stelm_cpy(clos->w,st_read(w,clos->i-1),clos->i);
		for (i=0; i<clos->i; i++)		/* copy args */
		  stelm_free(st_pop(w));
		}
	      else					/* no args */
		clos->w=NULL;
	      if (0!=clos->k)				/* are there any targs ? */
		{
		if (NULL==(clos->t=malloc(sizeof(STELM)*(clos->k))))
		  yyfail("%s","no memory for closure");
		stelm_cpy(clos->t,st_read(t,clos->k-1),clos->k);
		for (i=0; i<clos->k; i++)		/* copy args */
		  stelm_free(st_pop(t));
		}
	      else					/* no targs */
		clos->t=NULL;
	      res.type=tp_clos;
	      res.dat.clos=clos;
	      w=st_push(w,&res);			/* push closure on W Stack */	
	      stelm_free(func);
	      insert_restype(&res,ord);			/* set restype */
	      ord=GETNEXTORDER(ord);
	      }
	    }
	  break;
	  }
	case tp_prim:
	  {
	  int arity;
	  
	  if (0!=GETORDERARGS(ord,m))
	    arity=GETORDERARGS(ord,m);		/* restore prev set apply-value */
	  else
	    arity=GETORDERARGS(ord,n);		/* set normal apply-value */
          switch (GETPRF(GETSTELMDATA(func,prim)))/* unary primitiv function */
	    {
 	    case p_not:
	    case p_abs:
	    case p_trunc:
	    case p_floor:
	    case p_ceil:
	    case p_frac:
	    case p_tan:
	    case p_ln:
	    case p_exp:
	    case p_class: 
	    case p_vdim:
	    case p_type:
	    case p_transpose:
	    case p_reverse:
	    case p_transform:
	    case p_to_vect:
	    case p_to_tvect:
	    case p_to_mat:
	    case p_to_scal:
	    case p_to_list:
	    case p_to_field:
	    case p_vc_max:
	    case p_vc_min:
	    case p_vc_plus:
	    case p_vc_minus:
	    case p_vc_mult:
	    case p_vc_div:
	    case p_empty:
	    case p_sin:
	    case p_cos:
	    case p_neg:
	    case p_ldim: 
            case p_to_char:
            case p_to_ord:
	      {
	      if (1==arity)				/* arity of ap matches */
		exe_prim1(GETSTELMDATA(func,prim));	/* execute primfunction */
	      else
		{					/* this makes no sense */
		while (0<arity)				/* remove args */
		  {
		  st_pop(w);
		  arity--;
		  }
		w=st_push(w,&CONST_NONE);		/* push NONE as result */
		}
	      break;
	      }
	    case p_lselect:			/* very special prim.func. */
	      {					/* result can be function!!! */
	      CLOSURE *clos;
	      
	      if (2<=arity)			/* check arity */
		{
		exe_prim2(GETSTELMDATA(func,prim));	/* execute primfunction */
		SETORDERARGS(ord,m)=arity-2;
		if (0!=GETORDERARGS(ord,m))
		  {
		  delete_order(GETPREVORDER(ord));
		  ord=GETPREVORDER(ord);	/* back because of orderadvancement */
		  }
		}
	      else					/* closure */
		{
		if (NULL==(clos=malloc(sizeof(CLOSURE))))
		  yyfail("%s","no memory for closure");
		clos->desc=NULL;			/* remember primfunc */
		clos->k=GETSTELMDATA(func,prim);
		clos->i=GETORDERARGS(ord,n);
		clos->j=GETORDERARGS(ord,m);
		if (0!=clos->i)				/* there ara aruments */
		  {
		  if (NULL==(clos->w=malloc(sizeof(STELM)*(clos->i))))
		    yyfail("%s","no memory for closure");
		  stelm_cpy(clos->w,st_read(w,clos->i-1),clos->i);
		  for (i=0; i<clos->i; i++)
		    stelm_free(st_pop(w));
		  }
		else					/* no args  */
		  clos->w=NULL;
		d_stelm.type=tp_clos;
		d_stelm.dat.clos=clos;
		w=st_push(w,&d_stelm);
		}
	      break;
	      }
	    case p_plus:
	    case p_minus:
	    case p_mult:
	    case p_div:
	    case p_mod:
	    case p_or:
	    case p_and:
	    case p_xor:
	    case p_eq:
	    case p_ne:
	    case p_lt:
	    case p_le:
	    case p_gt:
	    case p_ge:
	    case p_lcut:
	    case p_lunite:
	    case p_max:
	    case p_min:
	    case p_quot:
	    case p_ip:
	    case p_dim: 
	    case p_mdim:
	    case p_vcut:
	    case p_vrotate:
	    case p_vselect:
	    case p_lrotate:
	    case p_vunite:
	    case p_c_max:
	    case p_c_min:
	    case p_c_plus:
	    case p_c_minus:
	    case p_c_mult:
	    case p_c_div: 
	    case p_f_eq:
	    case p_f_ne:
            case p_sprintf:
            case p_sscanf:
	      {
	      CLOSURE *clos;
	      
	      if (2==arity)
		exe_prim2(GETSTELMDATA(func,prim));	/* execute primfunction */
	      else
		{
		if (2<arity)
		  {					/* this makes no sense */
		  while (0<arity)
		    {					/* remove arguments */
		    st_pop(w);
		    arity--;
		    }
		  w=st_push(w,&CONST_NONE);
		  }
		else					/* make closure */
		  {
		  if (NULL==(clos=malloc(sizeof(CLOSURE))))
		    yyfail("%s","no memory for closure");
		  clos->desc=NULL;			/* remember primfunc */
		  clos->k=GETSTELMDATA(func,prim);
		  clos->i=GETORDERARGS(ord,n);
		  clos->j=GETORDERARGS(ord,m);
		  if (0!=clos->i)			/* there are arguments */
		    {
		    if (NULL==(clos->w=malloc(sizeof(STELM)*(clos->i))))
		      yyfail("%s","no memory for closure");
		    stelm_cpy(clos->w,st_read(w,clos->i-1),clos->i);
		    for (i=0; i<clos->i; i++)
		      stelm_free(st_pop(w));
		    }
		  else
		    clos->w=NULL;			/* no arguments */
		  d_stelm.type=tp_clos;
		  d_stelm.dat.clos=clos;
		  w=st_push(w,&d_stelm);
		  }
		}
	      break;
	      }
	    case p_lreplace:
	    case p_cut:
	    case p_mcut:
	    case p_ltransform:
	    case p_rotate:
	    case p_mrotate: 
	    case p_select: 
	    case p_mselect: 
	    case p_substr:
	    case p_vreplace:
	    case p_unite:
	    case p_munite:
	    case p_mre_c:
	    case p_mre_r:
	      {
	      CLOSURE *clos;
	      
	      if (3==arity)
		exe_prim3(GETSTELMDATA(func,prim));	/* execute primfunction */
	      else
		{
		if (3<arity)
		  {					/* this makes no sense */
		  while (0<arity)
		    {
		    st_pop(w);
		    arity--;
		    }
		  w=st_push(w,&CONST_NONE);
		  }
		else					/* make closure */
		  {
		  if (NULL==(clos=malloc(sizeof(CLOSURE))))
		    yyfail("%s","no memory for closure");
		  clos->desc=NULL;			/* remember primfunc */
		  clos->k=GETSTELMDATA(func,prim);
		  clos->i=GETORDERARGS(ord,n);
		  clos->j=GETORDERARGS(ord,m);
		  if (0!=clos->i)
		    {
		    if (NULL==(clos->w=malloc(sizeof(STELM)*(clos->i))))
		      yyfail("%s","no memory for closure");
		    stelm_cpy(clos->w,st_read(w,clos->i-1),clos->i);
		    for (i=0; i<clos->i; i++)
		      stelm_free(st_pop(w));
		    }
		  else
		    clos->w=NULL;
		  d_stelm.type=tp_clos;
		  d_stelm.dat.clos=clos;
		  w=st_push(w,&d_stelm);
		  }
		}
	      break;
	      }
	    case p_repstr:
	    case p_replace:
	    case p_mreplace:
	      {
	      CLOSURE *clos;
	      
	      if (4==arity)
		exe_prim4(GETSTELMDATA(func,prim));	/* execute primfunction */
	      else
		{
		if (4<arity)
		  {					/* this makes no sense */
		  while (0<arity)
		    {
		    st_pop(w);
		    arity--;
		    }
		  w=st_push(w,&CONST_NONE);
		  }
		else					/* make closure */
		  {
		  if (NULL==(clos=malloc(sizeof(CLOSURE))))
		    yyfail("%s","no memory for closure");
		  clos->desc=NULL;			/* remember primfunc */
		  clos->k=GETSTELMDATA(func,prim);
		  clos->i=GETORDERARGS(ord,n);
		  clos->j=GETORDERARGS(ord,m);
		  if (0!=clos->i)
		    {
		    if (NULL==(clos->w=malloc(sizeof(STELM)*(clos->i))))
		      yyfail("%s","no memory for closure");
		    stelm_cpy(clos->w,st_read(w,clos->i-1),clos->i);
		    for (i=0; i<clos->i; i++)
		      stelm_free(st_pop(w));
		    }
		  else
		    clos->w=NULL;			/* there are no arguments */
		  d_stelm.type=tp_clos;
		  d_stelm.dat.clos=clos;
		  w=st_push(w,&d_stelm);
		  }
		}
	      break;
	      }
	    default:				/* primitive function not known */
	      {
	      yyfail("%s","unknown primitive function!");
	      break;
	      }
	    }
	  ord=GETNEXTORDER(ord);
	  break;
	  }
        case tp_clos:
	  {
	  long i,j;
	  STELM dummy;
	  CLOSURE *clos;
	  FUNDESC *des;
	  PRIMF primf;
	  STACK *arg;
	  
	  if (NULL==GETSTELMDATA(func,clos))
	    {
	    if (0!=GETORDERARGS(ord,m))
	      arity=GETORDERARGS(ord,m);		/* restore prev set apply-value */
	    else
	      arity=GETORDERARGS(ord,n);		/* set normal apply-value */
	    for (i=0;i<arity;i++)
	      st_pop(w);
	    w=st_push(w,&CONST_NONE);
	    insert_restype(&CONST_NONE,ord);
	    ord=GETNEXTORDER(ord);
	    }
	  else
	    {
	    clos=GETSTELMDATA(func,clos);		/* get closure data */
	    des=clos->desc;
	    primf=clos->k;
	    if (0!=GETORDERARGS(ord,m))
	      arity=GETORDERARGS(ord,m);		/* restore prev set apply-value */
	    else
	      arity=GETORDERARGS(ord,n);		/* set normal apply-value */
	    if ((NULL!=des) && 			/* if CONDI unfold to A STACK */
		(DT_CONDITIONAL==GETDESCENTRY(des,tag)))
	      arg=a;
	    else
	      arg=w;
	    for (i=0; i<clos->i; i++)			/* unfold W-frame */
	      {
	      arg=st_push(arg,&(clos->w[i]));
	      stelm_free(&(clos->w[i]));
	      }
	    if (NULL!=clos->w)				/* free stored frame */
	      free(clos->w);
	    i=clos->i+arity;				/* calc no. of args */	
	    if (clos->j<=i) 				/* arity <= no. of args */
	      {
	      if (NULL!=des)				/* got FUNDESC */
		{
		for (j=0; j<clos->k; j++)		/* unfold T-frame */
		  {
		  t=st_push(t,&(clos->t[j]));
		  stelm_free(&(clos->t[j]));
		  }
		if (NULL!=clos->t)			/* free stored frame */
		  free(clos->t);
		dummy.type=tp_func;
		dummy.dat.desc=des;
		}
	      else					/* primitiv function */
		{
		dummy.type=tp_prim;
		dummy.dat.prim=primf;
		}
	      if ((NULL!=des) && (DT_CONDITIONAL==GETDESCENTRY(des,tag)))
		a=arg;
	      else
		w=arg;
	      w=st_push(w,&dummy);			/* store function */
	      SETORDERARGS(ord,m)=i;
	      }
	    else					/* new CLOSURE to build */
	      {
	      clos->i=i;				/* new no of args stored */
	      if(NULL==(clos->w=malloc(sizeof(STELM)*i)))
		yyfail("%s","no memory for new closure");
	      stelm_cpy(clos->w,&(arg->stack[arg->topofstack-i]),i); /* store args */
	      for (i=0; i<clos->i; i++)			/* free frame on stack */
		stelm_free(st_pop(arg));
	      dummy.type=tp_clos;
	      dummy.dat.clos=clos;
	      if (DT_CONDITIONAL==GETDESCENTRY(des,tag))
		a=arg;
	      else
		w=arg;
	      w=st_push(w,&dummy);			/* push closure on stack */
	      insert_restype(&dummy,ord);
	      ord=GETNEXTORDER(ord);
	      }
	    }
	  break;
	  }
	default:				/* illegal function call */
	  {					/* no valid function */
	  int j;
	  
	  if (0!=GETORDERARGS(ord,m))
	    j=GETORDERARGS(ord,m);
	  else
	    j=GETORDERARGS(ord,n);
	  for (i=0; i<j;i++)			/* remove arguments */
	    st_pop(w);
	  w=st_push(w,&CONST_NONE);		/* result of function is unknown */
	  insert_restype(&CONST_NONE,ord);
	  ord=GETNEXTORDER(ord);
	  break;
	  }
	}
      stelm_free(func);
      break;
      }
    case gammabeta:
    case tail:
    case beta:
    case Case:
    case gammacase:
    case Gamma:
      {
      STELM *result,*old_func;
      FUNDESC *des;
      ORDER *old_ord;
      RETURNADR *rt;
      
      DBUG_ORDERS("[Gamma]beta|case\\tail\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      des=find_desc(GETFIRSTDESC(program_start),GETORDERARGS(ord,label));
      DBUG_PRINT("ORDERS",("%d %s\n",ord->command, GETDESCENTRY(des,label)));
      /* what kind of functioncall do we have? do we know the result? */
      if (((gammabeta==GETORDERENTRY(ord,command)) ||
	   (gammacase==GETORDERENTRY(ord,command))) ||
	  (Gamma==GETORDERENTRY(ord,command)))
	result=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			  r,GETDESCENTRY(des,nfv));
      else
	result=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			  t,GETDESCENTRY(des,nfv));
      des=find_desc(GETFIRSTDESC(program_start),GETORDERARGS(ord,label));
      if ((NULL!=ret) && (0<GETTOPOFSTACK(ret)))
	{
	old_func=getfunc_ret();
        if (((gammabeta==GETORDERENTRY(ord,command)) ||
	     (gammacase==GETORDERENTRY(ord,command))) ||
	    (Gamma==GETORDERENTRY(ord,command)))
	  set_depend(des,w,r,old_func);
        else
	  set_depend(des,w,t,old_func);
	}
      if (((NULL!=result) && (tp_illegal!=result->type)) &&
	  (0==tis_state)) 		/* old result stored or second try */
	{
	insert_restype(result,ord);
	SETORDERARGS(ord,k)=-1;			/* order executed */
	for (i=0; i<GETDESCENTRY(des,nv); i++)
	  stelm_free(st_pop(w));
	if (((gammabeta==GETORDERENTRY(ord,command)) ||	/* stack switch r<->t */
	     (gammacase==GETORDERENTRY(ord,command))) ||
	    (Gamma==GETORDERENTRY(ord,command)))
	  {
	  STACK *dummy;
	  
	  dummy=r;				/* stack switch with dummy */
	  r=t;
	  t=dummy;
	  }
	w=st_push(w,result);
	ord=GETNEXTORDER(ord);
	}
      else
        {
	tis_state=0;
	old_ord=search_ret(ord);
	if (NULL==old_ord)			/* first call from here */
	  {
	  if (NULL==(rt=malloc(sizeof(RETURNADR))))
	    yyfail("%s","no memory for returnadress!");
	  rt->ord=ord;				/* remember enviroment of func */
	  rt->status=(clos_exe*CLOS_EXE)+(new_params*NEW_PARAMS);
	  rt->w=w;
	  rt->a=a;
	  if (((gammabeta==GETORDERENTRY(ord,command)) || /* stack switch r<->t */
	       (gammacase==GETORDERENTRY(ord,command))) ||
	      (Gamma==GETORDERENTRY(ord,command)))
	    {
	    rt->t=r;
	    rt->r=t;
	    }
	  else
	    {
	    rt->t=t;
	    rt->r=r;
	    }
	  ret=st_push(ret,new_stelm(tp_returnadr,rt)); /* returndata stored */
	  if (((Case==GETORDERENTRY(ord,command)) ||
	       (gammacase==GETORDERENTRY(ord,command))) ||
	      (Gamma==GETORDERENTRY(ord,command)))
	    {
	    w=st_make(w,GETDESCENTRY(des,nv));		/* build new frames */
	    a=NULL;
	    }
	  else
	    {
	    a=st_make(w,GETDESCENTRY(des,nv));		/* build new frames */
	    w=NULL;
	    }	    
	  if (((gammabeta==GETORDERENTRY(ord,command)) ||
	       (gammacase==GETORDERENTRY(ord,command))) ||
	      (Gamma==GETORDERENTRY(ord,command)))
	    t=st_make(r,GETDESCENTRY(des,nfv));
	  else
	    t=st_make(t,GETDESCENTRY(des,nfv));
	  r=NULL;
	  old_ord=ord;
	  ord=find_func(GETFIRSTFUNCTION(program_start),GETDESCENTRY(des,label));
	  if (((Case==GETORDERENTRY(old_ord,command)) ||
	       (gammacase==GETORDERENTRY(old_ord,command))) ||
	      (Gamma==GETORDERENTRY(old_ord,command)))
	    insert_args(w,GETDESCENTRY(des,nv),t,GETDESCENTRY(des,nfv),ord);
	  else
	    insert_args(a,GETDESCENTRY(des,nv),t,GETDESCENTRY(des,nfv),ord);
	  }
	else					/* have been here before */
	  {
	  if (old_ord!=ord)			/* old_ord must be jcond */
	    {
	    if (NULL==(rt=malloc(sizeof(RETURNADR))))
	      yyfail("%s","no memory for returnadress!");
	    rt->ord=ord;			/* remember enviroment of func */
	    rt->status=(clos_exe*CLOS_EXE)+MUST_EXE;
	    rt->w=w;
	    rt->a=a;
	    if (((Case==GETORDERENTRY(old_ord,command)) ||
	       (gammacase==GETORDERENTRY(old_ord,command))) ||
	      (Gamma==GETORDERENTRY(old_ord,command)))
	      {
	      rt->t=r;
	      rt->r=t;
	      }
	    else
	      {
	      rt->t=t;
	      rt->r=r;
	      }
	    func_dump=st_push(func_dump,new_stelm(tp_returnadr,rt)); 
	    /* returndata stored */
	    restore_ret(old_ord);		/* restors state of old_ord */
	    SETORDERENTRY(old_ord,branch)=-GETORDERENTRY(old_ord,branch); 
	    					/* then-case without result */
	    }
	  else					/* bad recursion */
	    {
	    if (((gammabeta==GETORDERENTRY(ord,command)) ||
		 (gammacase==GETORDERENTRY(ord,command))) ||
		(Gamma==GETORDERENTRY(ord,command)))
	      insert_functype(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			      r,GETDESCENTRY(des,nfv),&CONST_NONE,kn_sure);
	    else
	      insert_functype(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			      t,GETDESCENTRY(des,nfv),&CONST_NONE,kn_sure);
	    for (i=0; i<GETDESCENTRY(des,nv); i++)
	      stelm_free(st_pop(w));
	    if (((gammabeta==GETORDERENTRY(ord,command)) ||
		 (gammacase==GETORDERENTRY(ord,command))) ||
		(Gamma==GETORDERENTRY(ord,command)))
              {
              STACK *dstack;

              dstack=r;
              r=t;
              t=dstack;
              }
	    w=st_push(w,&CONST_NONE);
	    ord=GETNEXTORDER(ord);
	    }
	  }
	}
      break;
      }
    case mkap:						/* illegal function call */
      {
      int i;
      
      DBUG_ORDERS("mkap\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      for (i=0; i<=ord->args.n;i++)			/* remove args from STACK */
	st_pop(w);
      w=st_push(w,&CONST_NONE);			/* result useless closure == none */
      ord=GETNEXTORDER(ord);
      break;
      }	
    case mkiclos:					/* just an other closure */
      {
      int i;
    
      for(i=0; i<=ord->args.n;i++)			/* pop arguments */
        st_pop(w);
      w=st_push(w,&CONST_NONE);			/* result ist NONE */
      ord=GETNEXTORDER(ord);
      break;
      }
    case mkdclos:
      {
      STELM *prim,dummy;
      CLOSURE *clos;
      
      DBUG_ORDERS("mkdclos\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      prim=st_pop(w);					/* get prim function */
      if (NULL==(clos=malloc(sizeof(CLOSURE))))
	yyfail("%s","no memory for closure");
      clos->desc=NULL;					/* remember primfunc */
      clos->k=GETSTELMDATA(prim,prim);			/* store function */
      clos->i=GETORDERARGS(ord,n);
      clos->j=GETORDERARGS(ord,m);
      if (0!=clos->i)				/* do we have any arguments */
	{
	if (NULL==(clos->w=malloc(sizeof(STELM)*(clos->i))))
	  yyfail("%s","no memory for closure");
	stelm_cpy(clos->w,st_read(w,clos->i-1),clos->i); /* store all args */
	for (i=0; i<clos->i; i++)			/* free STACK elements */
	  stelm_free(st_pop(w));
	}
      else
	clos->w=NULL;					/* no args there */
      dummy.type=tp_clos;				/* init closure data */
      dummy.dat.clos=clos;
      dummy.subtype.type=tp_none;			/* set no subtype */
      dummy.subtype.next=NULL;
      stelm_free(prim);
      w=st_push(w,&dummy);				/* push closure */
      ord=GETNEXTORDER(ord);
      break;
      }
    case mkilist:					/* build an inverted list */
    case mklist:					/* build a list */
      {
      int i;
      STELM *stelm;
      
      DBUG_ORDERS("mklist\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      d_stelm.type=tp_list;				/* we have a list */
      d_stelm.subtype.type=tp_empty;			/* start with empty */
      d_stelm.subtype.next=NULL;
      for (i=0; i<GETORDERARGS(ord,n); i++)		/* check all elements */
	{
	stelm=st_pop(w);				/* get element */
        dump_list_func(stelm);				/* if function or closure, */
							/* they must be executed */
   	if ((tp_empty!=d_stelm.subtype.type) &&	/* if stored type do not match */
	    (d_stelm.subtype.type!=GETSTELMTYPE(stelm))) /* set type to none */
	  {
	  SUBTYPE *subt,*dsubt;
		  
          d_stelm.subtype.type=tp_none;
	  subt=d_stelm.subtype.next;
	  while (NULL!=subt)				/* free whole structure */
	    {
	    dsubt=subt->next;
	    free(subt);
	    subt=dsubt;
	    }
	  d_stelm.subtype.next=NULL;
	  }
        else						/* types match */
	  {
	  if (tp_empty==d_stelm.subtype.type)
	    {
	    d_stelm.subtype.type=GETSTELMTYPE(stelm);
	    if (((tp_list==GETSTELMTYPE(stelm)) || (tp_matrix==GETSTELMTYPE(stelm))) ||
		((tp_vect==GETSTELMTYPE(stelm)) || (tp_tvect==GETSTELMTYPE(stelm))))
	      d_stelm.subtype.next=subtype_cpy(&stelm->subtype);
	    else
	      {
	      SUBTYPE *subt,*dsubt;
		  
              subt=d_stelm.subtype.next;
	      while (NULL!=subt)			/* free whole structure */
	        {
		dsubt=subt->next;
		free(subt);
		subt=dsubt;
	    	}
	      d_stelm.subtype.next=NULL;
	      }
	    }
	  else
	    subtypecmp(d_stelm.subtype.next,&(stelm->subtype));
	  }
	stelm_free(stelm);
	}
      w=st_push(w,&d_stelm);
      ord=GETNEXTORDER(ord);
      break;
      }
    case mkframe: 				/* cr 19.02.96 */
      {
      DBUG_ORDERS("mkframe\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      for (i=0; i<GETORDERARGS(ord,n); i++)     /* check all elements */
	{
          st_pop(w);                            /* get element */
        }
      w=st_push(w,&CONST_NONE);
      ord=GETNEXTORDER(ord);
      break;
      }
    case mkslot: /* cr 19.02.96 */
      {
      DBUG_ORDERS("mkslot\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      st_pop(w);
      st_pop(w);
      w=st_push(w,&CONST_NONE);
      ord=GETNEXTORDER(ord);
      break;
      }
    case mkcase:				/* nothing to do */
      {
      DBUG_ORDERS("mkcase\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      st_pop(w);
      w=st_push(w,&CONST_NONE);
      ord=GETNEXTORDER(ord);
      break;
      }
    case mkgaclos:
      {
      STACK *d;
      STELM *arg;
      d=t;					/* switch STACK T & R */
      t=r;
      r=d;
      arg=st_pop(t);
      w=st_push(w,arg);				/* move function to W STACK */
      stelm_free(arg);
      }
    case mkcclos:
    case mkbclos:				/* build up closure */
    case mksclos:
      {
      STELM *func,res;
      CLOSURE *clos;
      
      DBUG_ORDERS("mkgaclos\\mkcclos\\mkbclos\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      func=st_pop(w);				/* get function */
      if (NULL==(clos=malloc(sizeof(CLOSURE))))
	yyfail("%s","no memory for closure");
      clos->desc=GETSTELMDATA(func,desc);	/* function data */
      clos->i=GETORDERARGS(ord,n);
      clos->j=GETORDERARGS(ord,m);
      clos->k=GETORDERARGS(ord,k);
      if (0<clos->i)				/* save args */
	{
	if (NULL==(clos->w=malloc(sizeof(STELM)*(clos->i))))
	  yyfail("%s","no memory for closure");
	stelm_cpy(clos->w,st_read(w,clos->i-1),clos->i);
	for (i=0; i<clos->i; i++)
	  stelm_free(st_pop(w));
	}
      else
	clos->w=NULL;
      if (0<clos->k)				/* save tildeargs */
	{
	if (NULL==(clos->t=malloc(sizeof(STELM)*(clos->k))))
	  yyfail("%s","no memory for closure");
	stelm_cpy(clos->t,st_read(t,clos->k-1),clos->k);
	}
      else
	clos->t=NULL;
      res.type=tp_clos;				/* build up result of command */
      res.dat.clos=clos;
      res.subtype.type=tp_none;
      res.subtype.next=NULL;
      w=st_push(w,&res);
      if (1==clos_exe)
	dump_list_func(&res);
      ord=GETNEXTORDER(ord);
      break;
      }
    case delta1:				/* execute prim.funcs. */
      DBUG_ORDERS("delta1\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      exe_prim1(GETORDERARGS(ord,primf));
      ord=GETNEXTORDER(ord);
      break;
    case delta2:
      DBUG_ORDERS("delta2\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      exe_prim2(GETORDERARGS(ord,primf));
      ord=GETNEXTORDER(ord);
      break;
    case delta3:
      {
      DBUG_ORDERS("delta3\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      exe_prim3(GETORDERARGS(ord,primf));
      ord=GETNEXTORDER(ord);
      break;
      }
    case delta4:
      {
      DBUG_ORDERS("delta4\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      exe_prim4(GETORDERARGS(ord,primf));
      ord=GETNEXTORDER(ord);
      break;
      }
    case intact:				/* interaction */
      {
      int i, dim;
    
      dim = get_ia_arity(GETIA(GETORDERARGS(ord,primf)));
      for(i=0; i<dim;i++)
        st_pop(w);
      w=st_push(w,&CONST_NONE);
      ord=GETNEXTORDER(ord);
      break;
      }
    case jump:					/* direct jump */
      {
      STELM *res;
      
      DBUG_ORDERS("jump()\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      if (LABbt==GETORDERARGS(ord,n))		/* get label */
	{
	res=st_pop(ret);
	w=GETSTELMDATA(res,ret)->w;		/* restore stacks */
        a=GETSTELMDATA(res,ret)->a;
        t=GETSTELMDATA(res,ret)->t;
        r=GETSTELMDATA(res,ret)->r;
        ord=GETSTELMDATA(res,ret)->ord;
	if (0!=GETSTELMDATA(res,ret)->branch)	/* check for other branch */
	  SETORDERENTRY(ord,branch)=GETSTELMDATA(res,ret)->branch;
	clos_exe=(GETSTELMDATA(res,ret)->status&CLOS_EXE)/CLOS_EXE;
	new_params=(GETSTELMDATA(res,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	}
      else
        ord=find_label(GETNEXTORDER(ord),GETORDERARGS(ord,label));
      break;
      }
    case jcond2:				/* conditional jumps */
    case jcond:
    case jfalse:
    case jfalse2:
    case jtrue:
    case jtrue2:
      {
      STELM *res;
      ORDER *old_ord;
      RETURNADR *rt;
      FUNDESC *des;
      int dep=0;
      STELM *freturn;
      
      DBUG_ORDERS("jfalse\\jcond\\jcond2\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      old_ord=search_ret(ord);
      if (NULL==old_ord)			/* first call from here */
	{
	if (1==new_params)
	  backupoldjcond();
	if (3==GETORDERENTRY(ord,branch))	/* jcond finished */
	  {
	  SETORDERENTRY(ord,branch)=0;
          st_free(w);
          st_free(a);
          st_free(r);
          st_free(t);
          res=st_pop(ret);			/* gets return ord */
          w=GETSTELMDATA(res,ret)->w;		/* restore stacks */
          a=GETSTELMDATA(res,ret)->a;
          t=GETSTELMDATA(res,ret)->t;
          r=GETSTELMDATA(res,ret)->r;
          ord=GETSTELMDATA(res,ret)->ord;
	  if (0!=GETSTELMDATA(res,ret)->branch)
	    SETORDERENTRY(ord,branch)=GETSTELMDATA(res,ret)->branch;
	  clos_exe=(GETSTELMDATA(res,ret)->status&CLOS_EXE)/CLOS_EXE;
	  new_params=(GETSTELMDATA(res,ret)->status&NEW_PARAMS)/NEW_PARAMS;
          stelm_free(res);
          if BETAFUNCS(GETORDERENTRY(ord,command))
            {
             if (apply==GETORDERENTRY(ord,command))
	       {
	       res=st_pop(w);
	       des=GETSTELMDATA(res,desc);
	       }
             else
	       des=find_desc(GETFIRSTDESC(program_start),GETORDERARGS(ord,label));
	    if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
	      {
	      res=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			     t,GETDESCENTRY(des,nfv));
	      for (i=0; i<GETDESCENTRY(des,nv); i++)
	        stelm_free(st_pop(w));
              w=st_push(w,res);
	      }
	    else
	      {
	      res=get_result(GETDESCENTRY(des,label),a,GETDESCENTRY(des,nv)-1,
			     t,GETDESCENTRY(des,nfv)/4);
	      stelm_free(st_pop(w));
	      for (i=0; i<GETDESCENTRY(des,nv)-1; i++)
	        stelm_free(st_pop(a));
              w=st_push(w,res);
	      }
	    ord=GETNEXTORDER(ord);
	    }
          }
	else
	  {
	  if (NULL==(rt=malloc(sizeof(RETURNADR))))
	    yyfail("%s","no memory for returnadress!");
	  rt->ord=ord;				/* remember enviroment of func */
	  rt->status=(clos_exe*CLOS_EXE)+(new_params*NEW_PARAMS);
	  rt->branch=0;
	  rt->w=w;
	  rt->a=a;
	  rt->t=t;
	  rt->r=r;
	  freturn=new_stelm(tp_returnadr,rt);
	  ret=st_push(ret,freturn);			/* returndata stored */
	  stelm_free(freturn);
	  if (NULL!=w)
	    w=st_make(w,GETTOPOFSTACK(w));
	  if (NULL!=a)
	    a=st_make(a,GETTOPOFSTACK(a));
	  if (NULL!=t)
	    t=st_make(t,GETTOPOFSTACK(t));
	  if (NULL!=r)
	    r=st_make(r,GETTOPOFSTACK(r));
	  res=st_pop(w);
	  if (tp_bool!=GETSTELMTYPE(res))		/* no bool found */
	    {
	    stelm_free(res);
	    freturn=getfunc_ret();			/* gets last function */
	    if (NULL!=freturn)
	      {
	      des=find_desc(GETFIRSTDESC(program_start),
			    freturn->dat.ret->ord->args.label);
	      if (apply==freturn->dat.ret->ord->command)
		{
		STACK *dummy;
		
		if (DT_CONDITIONAL==GETDESCENTRY(des,tag))
		  dummy=st_make(freturn->dat.ret->w,2);
		else
		  dummy=st_make(freturn->dat.ret->w,des->nv+1);
		st_pop(dummy);
		if ((DT_COMBINATOR==des->tag) || (DT_CASE==des->tag))
		  dep=insert_functype(des->label,dummy,des->nv,freturn->dat.ret->t,
				      des->nfv,&CONST_NONE,kn_sure);
		else
		  dep=insert_functype(des->label,a,des->nv-1,freturn->dat.ret->t,
				      des->nfv/4,&CONST_NONE,kn_sure);
		st_free(dummy);
		}
	      else
		dep=insert_functype(des->label,freturn->dat.ret->w,des->nv,
				    freturn->dat.ret->t,des->nfv,&CONST_NONE,kn_sure);
	      }
	    SETORDERENTRY(ord,types)=tp_none;
	    SETORDERENTRY(ord,typestouched)=1;
	    }
	  else
	    {
	    if (0==GETORDERENTRY(ord,typestouched))
	      {
	      SETORDERENTRY(ord,types)=tp_bool;
	      SETORDERENTRY(ord,typestouched)=1;
	      }
	    }
	  if (0!=dep)
	    {
	    return_to_call(freturn);
	    tis_state=1;
	    ord=freturn->dat.ret->ord;
	    if (0!=GETSTELMDATA(freturn,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	    clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	    new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
    	    w=freturn->dat.ret->w;
	    a=freturn->dat.ret->a;
	    if (((gammabeta==GETORDERENTRY(ord,command)) ||
		 (gammacase==GETORDERENTRY(ord,command))) ||
		(Gamma==GETORDERENTRY(ord,command)))
	      {
	      r=freturn->dat.ret->t;
	      t=freturn->dat.ret->r;
	      }
	    else
	      {
	      r=freturn->dat.ret->r;
	      t=freturn->dat.ret->t;
	      }
	    st_pop(ret);
            break;
	    }
	  switch (GETORDERENTRY(ord,branch))
	    {
	    case 0:
	    case 2:
	      {
	      SETORDERENTRY(ord,branch)=GETORDERENTRY(ord,branch) | 1;
	      ord=GETNEXTORDER(ord);
	      break;
	      }
	    case 1:
	      {
	      SETORDERENTRY(ord,branch)=3;
	      ord=find_label(GETNEXTORDER(ord),GETORDERARGS(ord,label));
	      break;
	      }
	    case -1:
	      {
	      SETORDERENTRY(ord,branch)=2;
	      ord=find_label(GETNEXTORDER(ord),GETORDERARGS(ord,label));
	      break;
	      }
	    case -2:
	    case -3:
	      {						/* jcond with no result */
	      SETORDERENTRY(ord,branch)=0;		/* jcond finished */
	      w=st_push(w,&CONST_NONE);
	      ord=&CONST_RTF;				/* goto rtf */
	      break;
	      }
	    default:
	      {
	      yyfail("%s","illegal jcond construction!");
	      break;
	      }
	    }
	  }
	}
      else					/* was here before */
        {
	if (((3==GETORDERENTRY(ord,branch)) || (2==GETORDERENTRY(ord,branch))) && 
	    (old_ord==ord))
	  {
	  STELM *label;
	  STACK *dummy;
	  
	  label=st_pop(ret);
	  while (!BETAFUNCS(GETORDERENTRY(GETSTELMDATA(label,ret)->ord,command)))
	    {
	    st_free(GETSTELMDATA(label,ret)->w);
	    st_free(GETSTELMDATA(label,ret)->a);
	    st_free(GETSTELMDATA(label,ret)->r);
	    st_free(GETSTELMDATA(label,ret)->t);
	    SETORDERENTRY(GETSTELMDATA(label,ret)->ord,branch)=0;
	    stelm_free(label);
	    label=st_pop(ret);
	    }
	  dummy=findfcall(label);		/* searches for functioncall */
	  if (NULL!=dummy)
	    {
	    st_free(w);
	    clos_exe=(GETSTELMDATA(label,ret)->status&CLOS_EXE)/CLOS_EXE;
	    new_params=(GETSTELMDATA(label,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	    ord=GETSTELMDATA(label,ret)->ord;
	    if (0!=GETSTELMDATA(label,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(label,ret)->branch;
            w=GETSTELMDATA(label,ret)->w;
	    st_free(a);
	    a=GETSTELMDATA(label,ret)->a;
	    st_free(r);
	    st_free(t);
	    if (((gammabeta==GETORDERENTRY(ord,command)) ||
		 (gammacase==GETORDERENTRY(ord,command))) ||
		(Gamma==GETORDERENTRY(ord,command)))
	      {
	      r=GETSTELMDATA(label,ret)->t;
	      t=GETSTELMDATA(label,ret)->r;
	      }
	    else
	      {
	      r=GETSTELMDATA(label,ret)->r;
	      t=GETSTELMDATA(label,ret)->t;
	      }
	    }
	  else
	    {
	    ret=st_push(ret,label);
	    SETORDERENTRY(old_ord,branch)=-GETORDERENTRY(old_ord,branch);
	    st_free(w);
	    st_free(a);
	    st_free(r);
	    st_free(t);
	    while (old_ord!=(GETSTELMDATA((res=st_pop(ret)),ret)->ord))
	      {
	      if BETAFUNCS(GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command))
		{
		if ((gammabeta==GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)) ||
		    (gammacase==GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)) ||
		    (Gamma==GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)))
		  {
		  STACK *d;
		  
		  d=GETSTELMDATA(res,ret)->t;
		  GETSTELMDATA(res,ret)->t=GETSTELMDATA(res,ret)->r;
		  GETSTELMDATA(res,ret)->r=d;
		  }
		func_dump=st_push(func_dump,res);
		}
	      else
		{
		SETORDERENTRY(GETSTELMDATA(res,ret)->ord,branch)=0;
		st_free(GETSTELMDATA(res,ret)->w);
		st_free(GETSTELMDATA(res,ret)->a);
		st_free(GETSTELMDATA(res,ret)->r);
		st_free(GETSTELMDATA(res,ret)->t);
		}
	      stelm_free(res);
	      }
	    clos_exe=(GETSTELMDATA(res,ret)->status&CLOS_EXE)/CLOS_EXE;
	    new_params=(GETSTELMDATA(res,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	    ord=GETSTELMDATA(res,ret)->ord;
	    if (0!=GETSTELMDATA(res,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(res,ret)->branch;
	    w=GETSTELMDATA(res,ret)->w;
	    a=GETSTELMDATA(res,ret)->a;
	    if (((gammabeta==GETORDERENTRY(ord,command)) ||
		 (gammacase==GETORDERENTRY(ord,command))) ||
		(Gamma==GETORDERENTRY(ord,command)))
	      {
	      r=GETSTELMDATA(res,ret)->t;
	      t=GETSTELMDATA(res,ret)->r;
	      }
	    else
	      {
	      r=GETSTELMDATA(res,ret)->r;
	      t=GETSTELMDATA(res,ret)->t;
	      }
	    stelm_free(res);
	    }
	  }
	else						/* standart returning */
	  {
	  FUNDESC *des;
	  STELM *result;
	  
          SETORDERENTRY(old_ord,branch)=-GETORDERENTRY(old_ord,branch);
	  st_free(w);
	  st_free(a);
	  st_free(r);
	  st_free(t);
	  while (old_ord!=(GETSTELMDATA((res=st_pop(ret)),ret)->ord))
	    {
	    if BETAFUNCS(GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command))
	      {
	      des=find_desc(GETFIRSTDESC(program_start),
			    res->dat.ret->ord->args.label);
	      result=get_result(des->label,res->dat.ret->w,des->nv,
				res->dat.ret->t,des->nfv);
	      if ((NULL!=result) && (tp_illegal!=result->type))
		break;
	      else
		{
		if ((gammabeta==GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)) ||
		    (gammacase==GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)) ||
		    (Gamma==GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)))
		  {
		  STACK *d;
		  
		  d=GETSTELMDATA(res,ret)->t;
		  GETSTELMDATA(res,ret)->t=GETSTELMDATA(res,ret)->r;
		  GETSTELMDATA(res,ret)->r=d;
		  }
		func_dump=st_push(func_dump,res);
		}
	      }
	    else
	      {
	      SETORDERENTRY(GETSTELMDATA(res,ret)->ord,branch)=0;
	      st_free(GETSTELMDATA(res,ret)->w);
	      st_free(GETSTELMDATA(res,ret)->a);
	      st_free(GETSTELMDATA(res,ret)->r);
	      st_free(GETSTELMDATA(res,ret)->t);
	      }
	    stelm_free(res);
	    }
	  clos_exe=(GETSTELMDATA(res,ret)->status&CLOS_EXE)/CLOS_EXE;
	  new_params=(GETSTELMDATA(res,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	  w=GETSTELMDATA(res,ret)->w;
	  a=GETSTELMDATA(res,ret)->a;
	  r=GETSTELMDATA(res,ret)->r;
	  t=GETSTELMDATA(res,ret)->t;
	  if BETAFUNCS(GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command))
	    {
	    for (i=0; i<des->nv; i++)
	      st_pop(w);
	    w=st_push(w,result);
	    ord=GETSTELMDATA(res,ret)->ord->next;
	    }
	  else
	    ord=GETSTELMDATA(res,ret)->ord;
	  if (0!=GETSTELMDATA(res,ret)->branch)
	    SETORDERENTRY(ord,branch)=GETSTELMDATA(res,ret)->branch;
	  stelm_free(res);
	  }
	}
      break;
      }
    case freea:
      {
      DBUG_ORDERS("freea\t\t\tw:%d, a:%d, r:%d. t:%d, ret:%d");
      for (i=0; i<GETORDERARGS(ord,n); i++)
	stelm_free(st_pop(a));
      ord=GETNEXTORDER(ord);
      break;
      }
    case freer:
      {
      DBUG_ORDERS("freer\t\t\tw:%d, a:%d, r:%d. t:%d, ret:%d");
      for (i=0; i<GETORDERARGS(ord,n); i++)
	stelm_free(st_pop(r));
      ord=GETNEXTORDER(ord);
      break;
      }
    case freeswt:
      {
      STACK *d;
      
      DBUG_ORDERS("freeswt\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      for (i=0; i<GETORDERARGS(ord,n); i++)
	stelm_free(st_pop(t));
      d=r;
      r=t;
      t=d;
      ord=GETNEXTORDER(ord);
      break;
      }
    case rtm:
    case rtt:
      {
      STELM *arg;
      
      if (rtm==ord->command)
	{
	arg=st_pop(a);
        w=st_push(w,arg);				/* moveaw */
        stelm_free(arg);
	}
      }
    case rtf:
      {
      STELM res,*freturn;
      FUNDESC *des;
      KNOWLEDGE kn;
      int dep;
      
      DBUG_ORDERS("rtf\\rtm\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      stelm_cpy(&res,st_pop(w),1);
      st_free(w);
      st_free(a);
      st_free(r);
      st_free(t);
      freturn=getfunc_ret();			/* gets last function */
      if BETAFUNCS(GETORDERENTRY(GETSTELMDATA(st_read(ret,0),ret)->ord,command))
	kn=kn_sure;
      else
	kn=kn_partly;
      if (NULL==freturn)			/* dump execution end */
	DBUG_RETURN((STELM *)NULL);
      if (apply==GETORDERENTRY(GETSTELMDATA(freturn,ret)->ord,command))
	{
	STACK *dummy;
	
	des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desc);
	if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
	  {
	  dummy=st_make(GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv)+1);
	  					/* get copy of stack */
	  st_pop(dummy);			/* remove function from stack */
          dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv),
		              GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
			      &res,kn);
	  if (0!=dep)
	    {
	    return_to_call(freturn);
	    tis_state=1;
	    clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	    new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	    ord=freturn->dat.ret->ord;
	    if (0!=GETSTELMDATA(freturn,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	    w=freturn->dat.ret->w;
	    a=freturn->dat.ret->a;
	    r=freturn->dat.ret->r;
	    t=freturn->dat.ret->t;
	    st_pop(ret);
	    break;
	    }
	  stelm_cpy(&res,get_result(GETDESCENTRY(des,label),dummy,
		    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
				    GETDESCENTRY(des,nfv)),1);
	  }
	else
	  {
	  dummy=st_make(GETSTELMDATA(freturn,ret)->a,GETDESCENTRY(des,nv)-1);
	  					/* get copy of stack */
          dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv)-1,
			      GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
			      &res,kn);	  
	  if (0!=dep)
	    {
	    return_to_call(freturn);
	    tis_state=1;
	    clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	    new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	    ord=freturn->dat.ret->ord;
	    if (0!=GETSTELMDATA(freturn,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	    w=freturn->dat.ret->w;
	    a=freturn->dat.ret->a;
	    r=freturn->dat.ret->r;
	    t=freturn->dat.ret->t;
	    st_pop(ret);
            break;
	    }
	  stelm_cpy(&res,get_result(GETDESCENTRY(des,label),dummy,
		    GETDESCENTRY(des,nv)-1,GETSTELMDATA(freturn,ret)->t,
		    GETDESCENTRY(des,nfv)/4),1);
	  }
	st_free(dummy);					/* free dummy stack */
	}
      else
	{
	des=find_desc(GETFIRSTDESC(program_start),
		      GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,label));
	dep=insert_functype(GETDESCENTRY(des,label),GETSTELMDATA(freturn,ret)->w,
			    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			    GETDESCENTRY(des,nfv),&res,kn);
	if (0!=dep)
	  {
	  return_to_call(freturn);
	  tis_state=1;
	  ord=freturn->dat.ret->ord;
	  w=freturn->dat.ret->w;
	  a=freturn->dat.ret->a;
	  if (((gammabeta!=GETORDERENTRY(ord,command)) &&
	       (gammacase!=GETORDERENTRY(ord,command))) &&
	      (Gamma!=GETORDERENTRY(ord,command))) 
	    {
	    r=freturn->dat.ret->r;
	    t=freturn->dat.ret->t;
	    }
	  else
	    {
	    r=freturn->dat.ret->t;
	    t=freturn->dat.ret->r;
	    }
	  st_pop(ret);
          break;
	  }
        stelm_cpy(&res,get_result(GETDESCENTRY(des,label),
		  GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv),
		  GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)),1);
	}
      if (0==GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,m))
	insert_restype(&res,GETSTELMDATA(freturn,ret)->ord);
      SETORDERARGS(GETSTELMDATA(freturn,ret)->ord,k)=-1; /* order executed */
      freturn=st_pop(ret);			/* restors former state */
      ord=GETSTELMDATA(freturn,ret)->ord;
      if (0!=GETSTELMDATA(freturn,ret)->branch)
	SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
      clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
      new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
      w=GETSTELMDATA(freturn,ret)->w;		/* restore stacks */
      a=GETSTELMDATA(freturn,ret)->a;
      t=GETSTELMDATA(freturn,ret)->t;
      r=GETSTELMDATA(freturn,ret)->r;
      stelm_free(freturn);
      if BETAFUNCS(GETORDERENTRY(ord,command))
        {
	for (i=0; i<GETDESCENTRY(des,nv); i++)
	  stelm_free(st_pop(w));
	if (apply==GETORDERENTRY(ord,command))
	  {
	  stelm_free(st_pop(w));
          w=st_push(w,&res);
	  if (0==GETORDERARGS(ord,m))
	    ord=GETNEXTORDER(ord);
	  }
	else
	  {
	  if (Gamma==ord->command)
	    {
	    STACK *dummy;
	    
	    dummy=r;
	    r=t;
	    t=dummy;
	    }
	  w=st_push(w,&res);
	  ord=GETNEXTORDER(ord);
	  }
	}
      break;
      }
    case rtp:
      {
      STELM *res,*freturn;
      FUNDESC *des;
      KNOWLEDGE kn;
      int dep;
      
      DBUG_ORDERS("rtp\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      res=find_address(GETORDERARGS(ord,desc));
      st_free(w);
      st_free(a);
      st_free(r);
      st_free(t);
      freturn=getfunc_ret();			/* gets last function */
      if BETAFUNCS(GETORDERENTRY(GETSTELMDATA(st_read(ret,0),ret)->ord,command))
	kn=kn_sure;
      else
	kn=kn_partly;
      if (NULL==freturn)			/* dump execution end */
	DBUG_RETURN((STELM *)NULL);
      if (apply==GETORDERENTRY(GETSTELMDATA(freturn,ret)->ord,command))
	{
	STACK *dummy;
	
	des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desc);
	if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
	  {
	  dummy=st_make(GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv)+1);
	  					/* get copy of stack */
	  st_pop(dummy);			/* remove function from stack */
          dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv),
			      GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
			      res,kn);
	  if (0!=dep)
	    {
	    return_to_call(freturn);
	    tis_state=1;
	    ord=freturn->dat.ret->ord;
	    if (0!=GETSTELMDATA(freturn,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	    clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	    new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	    w=freturn->dat.ret->w;
	    a=freturn->dat.ret->a;
	    r=freturn->dat.ret->r;
	    t=freturn->dat.ret->t;
	    st_pop(ret);
            break;
	    }
	  stelm_cpy(res,get_result(GETDESCENTRY(des,label),dummy,
		    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
				   GETDESCENTRY(des,nfv)),1);
	  }
	else
	  {
	  dummy=st_make(GETSTELMDATA(freturn,ret)->a,GETDESCENTRY(des,nv)-1);
	  					/* get copy of stack */
          dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv)-1,
			      GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
			      res,kn);	  
	  if (0!=dep)
	    {
	    return_to_call(freturn);
	    tis_state=1;
	    ord=freturn->dat.ret->ord;
	    if (0!=GETSTELMDATA(freturn,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	    clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	    new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	    w=freturn->dat.ret->w;
	    a=freturn->dat.ret->a;
	    r=freturn->dat.ret->r;
	    t=freturn->dat.ret->t;
	    st_pop(ret);
            break;
	    }
	  stelm_cpy(res,get_result(GETDESCENTRY(des,label),dummy,
		    GETDESCENTRY(des,nv)-1,GETSTELMDATA(freturn,ret)->t,
				   GETDESCENTRY(des,nfv)/4),1);
	  }
	st_free(dummy);					/* free dummy stack */
	}
      else
	{
	des=find_desc(GETFIRSTDESC(program_start),
		      GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,label));
	dep=insert_functype(GETDESCENTRY(des,label),GETSTELMDATA(freturn,ret)->w,
			    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			    GETDESCENTRY(des,nfv),res,kn);
	if (0!=dep)
	  {
	  return_to_call(freturn);
	  tis_state=1;
	  ord=freturn->dat.ret->ord;
	  if (0!=GETSTELMDATA(freturn,ret)->branch)
	    SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	  clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	  new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	  w=freturn->dat.ret->w;
	  a=freturn->dat.ret->a;
	  r=freturn->dat.ret->r;
	  t=freturn->dat.ret->t;
	  st_pop(ret);
          break;
	  }
	stelm_cpy(res,get_result(GETDESCENTRY(des,label),
		  GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv),
		  GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)),1);
	}
      if (0==GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,m))
	insert_restype(res,GETSTELMDATA(freturn,ret)->ord);
      SETORDERARGS(GETSTELMDATA(freturn,ret)->ord,k)=-1;  /* order executed */
      freturn=st_pop(ret);			/* restors former state */
      ord=GETSTELMDATA(freturn,ret)->ord;
      if (0!=GETSTELMDATA(freturn,ret)->branch)
	SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
      clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
      new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
      w=GETSTELMDATA(freturn,ret)->w;		/* restore stacks */
      a=GETSTELMDATA(freturn,ret)->a;
      t=GETSTELMDATA(freturn,ret)->t;
      r=GETSTELMDATA(freturn,ret)->r;
      stelm_free(freturn);
      if BETAFUNCS(GETORDERENTRY(ord,command))
	{
        for (i=0; i<GETDESCENTRY(des,nv); i++)
	  stelm_free(st_pop(w));
	if (apply==GETORDERENTRY(ord,command))
	  {
	  stelm_free(st_pop(w));
          w=st_push(w,res);
	  if (0==GETORDERARGS(ord,m))
	    ord=GETNEXTORDER(ord);
	  }
	else
	  {
	  w=st_push(w,res);
	  ord=GETNEXTORDER(ord);
	  }
	}
      break;
      }
    case rtc_pf:
      {
      STELM res={tp_prim,{tp_none,NULL},{NULL}}, *freturn;
      FUNDESC *des;
      KNOWLEDGE kn;
      int dep;
      
      DBUG_ORDERS("rtc_pf\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      if (ISIA(GETORDERARGS(ord,primf)))
        {
        w=st_push(w,&CONST_NONE);
        ord=GETNEXTORDER(ord);
        }
      else
        {
        res.dat.prim=GETORDERARGS(ord,n);		/* which prim. function */
        st_free(w);
        st_free(a);
        st_free(r);
        st_free(t);
        freturn=getfunc_ret();			/* gets last function */
        if BETAFUNCS(GETORDERENTRY(GETSTELMDATA(st_read(ret,0),ret)->ord,command))
          kn=kn_sure;
        else
          kn=kn_partly;
        if (NULL!=freturn)			/* no dump execution end */
          {
          if (apply==GETORDERENTRY(GETSTELMDATA(freturn,ret)->ord,command))
            {
            STACK *dummy;
            
            des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desc);
            if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
              {
              dummy=st_make(GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv)+1);
              /* get copy of stack */
              st_pop(dummy);			/* remove function from stack */
              dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv),
                                  GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
                                  &res,kn);
              if (0!=dep)
                {
                return_to_call(freturn);
                tis_state=1;
                ord=freturn->dat.ret->ord;
                if (0!=GETSTELMDATA(freturn,ret)->branch)
                  SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
                clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
                new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
                w=freturn->dat.ret->w;
                a=freturn->dat.ret->a;
                r=freturn->dat.ret->r;
                t=freturn->dat.ret->t;
                st_pop(ret);
                break;
                }
              stelm_cpy(&res,get_result(GETDESCENTRY(des,label),dummy,
                                        GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
                                        GETDESCENTRY(des,nfv)),1);
              }
            else
              {
              dummy=st_make(GETSTELMDATA(freturn,ret)->a,GETDESCENTRY(des,nv)-1);
              /* get copy of stack */
              dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv)-1,
                                  GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
                                  &res,kn);	  
              if (0!=dep)
                {
                return_to_call(freturn);
                tis_state=1;
                ord=freturn->dat.ret->ord;
                if (0!=GETSTELMDATA(freturn,ret)->branch)
                  SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
                clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
                new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
                w=freturn->dat.ret->w;
                a=freturn->dat.ret->a;
                r=freturn->dat.ret->r;
                t=freturn->dat.ret->t;
                st_pop(ret);
                break;
                }
              stelm_cpy(&res,get_result(GETDESCENTRY(des,label),dummy,
                                        GETDESCENTRY(des,nv)-1,GETSTELMDATA(freturn,ret)->t,
                                        GETDESCENTRY(des,nfv)/4),1);
              }
            st_free(dummy);					/* free dummy stack */
            }
          else
            {
            des=find_desc(GETFIRSTDESC(program_start),
                          GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,label));
            dep=insert_functype(GETDESCENTRY(des,label),GETSTELMDATA(freturn,ret)->w,
                                GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
                                GETDESCENTRY(des,nfv),&res,kn);
            if (0!=dep)
              {
              return_to_call(freturn);
              tis_state=1;
              ord=freturn->dat.ret->ord;
              if (0!=GETSTELMDATA(freturn,ret)->branch)
                SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
              clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
              new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
              w=freturn->dat.ret->w;
              a=freturn->dat.ret->a;
              r=freturn->dat.ret->r;
              t=freturn->dat.ret->t;
              st_pop(ret);
              break;
              }
            stelm_cpy(&res,get_result(GETDESCENTRY(des,label),
                                      GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv),
                                      GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)),1);
            }
          if (0==GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,m))
            insert_restype(&res,GETSTELMDATA(freturn,ret)->ord);
          SETORDERARGS(GETSTELMDATA(freturn,ret)->ord,k)=-1;  /* order executed */
          }
        freturn=st_pop(ret);			/* restors former state */
        ord=GETSTELMDATA(freturn,ret)->ord;
        if (0!=GETSTELMDATA(freturn,ret)->branch)
          SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
        clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
        new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
        w=GETSTELMDATA(freturn,ret)->w;		/* restore stacks */
        a=GETSTELMDATA(freturn,ret)->a;
        t=GETSTELMDATA(freturn,ret)->t;
        r=GETSTELMDATA(freturn,ret)->r;
        stelm_free(freturn);
        if BETAFUNCS(GETORDERENTRY(ord,command))
          {
          for (i=0; i<GETDESCENTRY(des,nv); i++)
            stelm_free(st_pop(w));
          if (apply==GETORDERENTRY(ord,command))
            {
            stelm_free(st_pop(w));
            w=st_push(w,&res);
            if (0==GETORDERARGS(ord,m))
              ord=GETNEXTORDER(ord);
            }
          else
            {
            w=st_push(w,&res);
            ord=GETNEXTORDER(ord);
            }
          }
        }
      break;
      }
    case rtc_i:
      {
      STELM res={tp_int,{tp_none,NULL},{NULL}},*freturn;
      FUNDESC *des;
      KNOWLEDGE kn;
      int dep;
      
      DBUG_ORDERS("rtc_i\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      st_free(w);
      st_free(a);
      st_free(r);
      st_free(t);
      freturn=getfunc_ret();			/* gets last function */
      if BETAFUNCS(GETORDERENTRY(GETSTELMDATA(st_read(ret,0),ret)->ord,command))
	kn=kn_sure;
      else
	kn=kn_partly;
      if (NULL!=freturn)			/* no dump execution end */
	{
	if (apply==GETORDERENTRY(GETSTELMDATA(freturn,ret)->ord,command))
	  {
	  STACK *dummy;
	  
	  des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desc);
	  if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
	    {
	    dummy=st_make(GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv)+1);
	    /* get copy of stack */
	    st_pop(dummy);			/* remove function from stack */
	    dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv),
				GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
				&res,kn);
	    if (0!=dep)
	      {
	      return_to_call(freturn);
	      tis_state=1;
	      ord=freturn->dat.ret->ord;
	      if (0!=GETSTELMDATA(freturn,ret)->branch)
	        SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	      clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	      new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	      w=freturn->dat.ret->w;
	      a=freturn->dat.ret->a;
	      r=freturn->dat.ret->r;
	      t=freturn->dat.ret->t;
	      st_pop(ret);
	      break;
	      }
	    stelm_cpy(&res,get_result(GETDESCENTRY(des,label),dummy,
				      GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
				      GETDESCENTRY(des,nfv)),1);
	    }
	  else
	    {
	    dummy=st_make(GETSTELMDATA(freturn,ret)->a,GETDESCENTRY(des,nv)-1);
	    /* get copy of stack */
	    dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv)-1,
				GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
				&res,kn);	  
	    if (0!=dep)
	      {
	      return_to_call(freturn);
	      tis_state=1;
	      ord=freturn->dat.ret->ord;
	      if (0!=GETSTELMDATA(freturn,ret)->branch)
	        SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	      clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	      new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	      w=freturn->dat.ret->w;
	      a=freturn->dat.ret->a;
	      r=freturn->dat.ret->r;
	      t=freturn->dat.ret->t;
	      st_pop(ret);
	      break;
	      }
	    stelm_cpy(&res,get_result(GETDESCENTRY(des,label),dummy,
				      GETDESCENTRY(des,nv)-1,GETSTELMDATA(freturn,ret)->t,
				      GETDESCENTRY(des,nfv)/4),1);
	    }
	  st_free(dummy);					/* free dummy stack */
	  }
	else
	  {
	  des=find_desc(GETFIRSTDESC(program_start),
			GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,label));
	  dep=insert_functype(GETDESCENTRY(des,label),GETSTELMDATA(freturn,ret)->w,
			      GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			      GETDESCENTRY(des,nfv),&res,kn);
	  if (0!=dep)
	    {
	    return_to_call(freturn);
	    tis_state=1;
	    ord=freturn->dat.ret->ord;
	    if (0!=GETSTELMDATA(freturn,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	    clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	    new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	    w=freturn->dat.ret->w;
	    a=freturn->dat.ret->a;
	    r=freturn->dat.ret->r;
	    t=freturn->dat.ret->t;
	    st_pop(ret);
            break;
	    }
	  stelm_cpy(&res,get_result(GETDESCENTRY(des,label),
				    GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv),
				    GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)),1);
	  }
	if (0==GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,m))
	  insert_restype(&res,GETSTELMDATA(freturn,ret)->ord);
        SETORDERARGS(GETSTELMDATA(freturn,ret)->ord,k)=-1;  /* order executed */
	}
      freturn=st_pop(ret);			/* restors former state */
      ord=GETSTELMDATA(freturn,ret)->ord;
      if (0!=GETSTELMDATA(freturn,ret)->branch)
	SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
      clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
      new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
      w=GETSTELMDATA(freturn,ret)->w;		/* restore stacks */
      a=GETSTELMDATA(freturn,ret)->a;
      t=GETSTELMDATA(freturn,ret)->t;
      r=GETSTELMDATA(freturn,ret)->r;
      stelm_free(freturn);
      if BETAFUNCS(GETORDERENTRY(ord,command))
	{
        for (i=0; i<GETDESCENTRY(des,nv); i++)
	  stelm_free(st_pop(w));
	if (apply==GETORDERENTRY(ord,command))
	  {
	  stelm_free(st_pop(w));
          w=st_push(w,&res);
	  if (0==GETORDERARGS(ord,m))
	    ord=GETNEXTORDER(ord);
	  }
	else
	  {
	  w=st_push(w,&res);
	  ord=GETNEXTORDER(ord);
	  }
	}
      break;
      }
    case rtc_b:
      {
      STELM res={tp_bool,{tp_none,NULL},{NULL}},*freturn;
      FUNDESC *des;
      KNOWLEDGE kn;
      int dep;
      
      DBUG_ORDERS("rtc_i\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      st_free(w);
      st_free(a);
      st_free(r);
      st_free(t);
      freturn=getfunc_ret();			/* gets last function */
      if BETAFUNCS(GETORDERENTRY(GETSTELMDATA(st_read(ret,0),ret)->ord,command))
	kn=kn_sure;
      else
	kn=kn_partly;
      if (NULL==freturn)			/* dump execution end */
	DBUG_RETURN((STELM *)NULL);
      if (apply==GETORDERENTRY(GETSTELMDATA(freturn,ret)->ord,command))
	{
	STACK *dummy;
	
	des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desc);
	if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
	  {
	  dummy=st_make(GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv)+1);
	  					/* get copy of stack */
	  st_pop(dummy);			/* remove function from stack */
          dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv),
			      GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
			      &res,kn);
	  if (0!=dep)
	    {
	    return_to_call(freturn);
	    tis_state=1;
	    ord=freturn->dat.ret->ord;
	    if (0!=GETSTELMDATA(freturn,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	    clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	    new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	    w=freturn->dat.ret->w;
	    a=freturn->dat.ret->a;
	    r=freturn->dat.ret->r;
	    t=freturn->dat.ret->t;
	    st_pop(ret);
            break;
	    }
	  stelm_cpy(&res,get_result(GETDESCENTRY(des,label),dummy,
		    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
		    GETDESCENTRY(des,nfv)),1);
	  }
	else
	  {
	  dummy=st_make(GETSTELMDATA(freturn,ret)->a,GETDESCENTRY(des,nv)-1);
	  					/* get copy of stack */
          dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv)-1,
			      GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
			      &res,kn);	  
	  if (0!=dep)
	    {
	    return_to_call(freturn);
	    tis_state=1;
	    ord=freturn->dat.ret->ord;
	    if (0!=GETSTELMDATA(freturn,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	    clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	    new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	    w=freturn->dat.ret->w;
	    a=freturn->dat.ret->a;
	    r=freturn->dat.ret->r;
	    t=freturn->dat.ret->t;
	    st_pop(ret);
            break;
	    }
	  stelm_cpy(&res,get_result(GETDESCENTRY(des,label),dummy,
		    GETDESCENTRY(des,nv)-1,GETSTELMDATA(freturn,ret)->t,
		    GETDESCENTRY(des,nfv)/4),1);
	  }
	st_free(dummy);					/* free dummy stack */
	}
      else
	{
	des=find_desc(GETFIRSTDESC(program_start),
		      GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,label));
	dep=insert_functype(GETDESCENTRY(des,label),GETSTELMDATA(freturn,ret)->w,
			    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			    GETDESCENTRY(des,nfv),&res,kn);
	  if (0!=dep)
	    {
	    return_to_call(freturn);
	    tis_state=1;
	    ord=freturn->dat.ret->ord;
	    w=freturn->dat.ret->w;
	    a=freturn->dat.ret->a;
	    r=freturn->dat.ret->r;
	    t=freturn->dat.ret->t;
	    st_pop(ret);
            break;
	    }
	stelm_cpy(&res,get_result(GETDESCENTRY(des,label),
		  GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv),
	          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)),1);
	}
      if (0==GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,m))
	insert_restype(&res,GETSTELMDATA(freturn,ret)->ord);
      SETORDERARGS(GETSTELMDATA(freturn,ret)->ord,k)=-1;  /* order executed */
      freturn=st_pop(ret);			/* restors former state */
      ord=GETSTELMDATA(freturn,ret)->ord;
      if (0!=GETSTELMDATA(freturn,ret)->branch)
	SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
      clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
      new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
      w=GETSTELMDATA(freturn,ret)->w;		/* restore stacks */
      a=GETSTELMDATA(freturn,ret)->a;
      t=GETSTELMDATA(freturn,ret)->t;
      r=GETSTELMDATA(freturn,ret)->r;
      stelm_free(freturn);
      if BETAFUNCS(GETORDERENTRY(ord,command))
	{
        for (i=0; i<GETDESCENTRY(des,nv); i++)
	  stelm_free(st_pop(w));
	if (apply==GETORDERENTRY(ord,command))
	  {
	  stelm_free(st_pop(w));
          w=st_push(w,&res);
	  if (0==GETORDERARGS(ord,m))
	    ord=GETNEXTORDER(ord);
	  }
	else
	  {
	  w=st_push(w,&res);
	  ord=GETNEXTORDER(ord);
	  }
	}
      break;
      }
    case ext:
      {
      STELM *res,*d;
      
      DBUG_ORDERS("ext\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      res=st_pop(w);
      if ((NULL!=t) && (0!=GETTOPOFSTACK(t)) && (0==GETTOPOFSTACK(ret)))
	fprintf(stderr,"exit with elements on T-stack!\n");
      if ((NULL!=r) && (0!=GETTOPOFSTACK(r)) && (0==GETTOPOFSTACK(ret)))
	fprintf(stderr,"exit with elements on R-stack!\n");
      if ((NULL!=a) && (0!=GETTOPOFSTACK(a)) && (0==GETTOPOFSTACK(ret)))
	fprintf(stderr,"exit with elements on A-stack!\n");
      if ((NULL!=w) && (0!=GETTOPOFSTACK(w)) && (0==GETTOPOFSTACK(ret)))
	fprintf(stderr,"exit with >1 elements on W-stack!\n");
      insert_restype(res,ord);
      ord->types=TYPES2LONG(GETSTELMTYPE(res),tp_none,tp_none,tp_none);
      if ((NULL!=ret) && (0<GETTOPOFSTACK(ret)))	/* still sometings to do */
	{
	d=st_pop(ret);
	if JCONDS(GETORDERENTRY(GETSTELMDATA(d,ret)->ord,command))
	  						/* command == jcond ? */
	  {
	  if (3==GETORDERENTRY(GETSTELMDATA(d,ret)->ord,branch))
	    						/* jcond already executed */
	    DBUG_RETURN(res);
	  ord=GETSTELMDATA(d,ret)->ord;			/* restore prev. state */
	  if (0!=GETSTELMDATA(d,ret)->branch)
	    SETORDERENTRY(ord,branch)=GETSTELMDATA(d,ret)->branch;
	  clos_exe=(GETSTELMDATA(d,ret)->status&CLOS_EXE)/CLOS_EXE;
	  new_params=(GETSTELMDATA(d,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	  w=GETSTELMDATA(d,ret)->w;
	  a=GETSTELMDATA(d,ret)->a;
	  r=GETSTELMDATA(d,ret)->r;
	  t=GETSTELMDATA(d,ret)->t;
	  }
	else 
	  {
	  if (ext!=GETORDERENTRY(GETSTELMDATA(d,ret)->ord,command))
	    yyfail("%s","illegal returnadress at ext!\n");	/* error */
	  else
	    DBUG_RETURN(res);
	  }
	}
      else						/* the end */
        DBUG_RETURN(res);
      break;
      }
    case label:
    case hashargs:
    case hashtildeargs:
    case hashrestype:
    case hashsetref:
      ord=GETNEXTORDER(ord);
      break;
    case end:
      DBUG_ORDERS("end\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      break;
    case tguard:
    case matcharbs:
    case matchbool:
    case matchin:
    case matchprim:
    case matchstr:
    case matchlist:
    case matchint:
    case matcharb:
      {
      STELM *tow,*freturn,*res;
      RETURNADR *rt;
      ORDER *old_ord;
      FUNDESC *des;
      int dep=0;
      
      DBUG_ORDERS("matchX//tguard\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      old_ord=search_ret(ord);			/* first call form here ? */
      if (NULL==old_ord)
	{
	if (1==new_params)			/* call with new params */
	  backupoldjcond();
	if (3==GETORDERENTRY(ord,branch))
	  {
	  SETORDERENTRY(ord,branch)=0;
	  st_free(w);
	  st_free(a);
	  st_free(t);
	  st_free(r);
	  res=st_pop(ret);
          w=GETSTELMDATA(res,ret)->w;		/* restore stacks */
          a=GETSTELMDATA(res,ret)->a;
          t=GETSTELMDATA(res,ret)->t;
          r=GETSTELMDATA(res,ret)->r;
          ord=GETSTELMDATA(res,ret)->ord;
          if (0!=GETSTELMDATA(res,ret)->branch)
	    SETORDERENTRY(ord,branch)=GETSTELMDATA(res,ret)->branch;
	  clos_exe=(GETSTELMDATA(res,ret)->status&CLOS_EXE)/CLOS_EXE;
	  new_params=(GETSTELMDATA(res,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	  stelm_free(res);
          if BETAFUNCS(GETORDERENTRY(ord,command))
            {
            if (apply==GETORDERENTRY(ord,command))
	      {
	      res=st_pop(w);
	      des=GETSTELMDATA(res,desc);
	      }
            else
	      des=find_desc(GETFIRSTDESC(program_start),GETORDERARGS(ord,label));
	    if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
	      {
	      res=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			     t,GETDESCENTRY(des,nfv));
	      for (i=0; i<GETDESCENTRY(des,nv); i++)
	        stelm_free(st_pop(w));
              w=st_push(w,res);
	      }
	    else
	      {
	      res=get_result(GETDESCENTRY(des,label),a,GETDESCENTRY(des,nv)-1,
			     t,GETDESCENTRY(des,nfv)/4);
	      stelm_free(st_pop(w));
	      for (i=0; i<GETDESCENTRY(des,nv)-1; i++)
	        stelm_free(st_pop(a));
	      w=st_push(w,res);
	      }
	    ord=GETNEXTORDER(ord);
	    }
	  }
	else					/* at least one branch to go */
	  {
	  if (NULL==(rt=malloc(sizeof(RETURNADR))))
	    yyfail("%s","no memory for returnadress!");
	  rt->ord=ord;
	  rt->status=(clos_exe*CLOS_EXE)+(new_params*NEW_PARAMS);
	  rt->branch=0;
	  rt->w=w;
	  rt->a=a;
	  rt->t=t;
	  rt->r=r;
	  tow=new_stelm(tp_returnadr,rt);
	  ret=st_push(ret,tow);
	  stelm_free(tow);
	  if (NULL!=w)
	    w=st_make(w,GETTOPOFSTACK(w));	/* save complete STACK */
	  if (NULL!=a)
	    a=st_make(a,GETTOPOFSTACK(a));	/* save complete STACK */
	  if (NULL!=t)
	    t=st_make(t,GETTOPOFSTACK(t));	/* save complete STACK */
	  if (NULL!=r)
	    r=st_make(r,GETTOPOFSTACK(r));	/* save complete STACK */
          tow=st_read(w,0);		/* get pointer of top element of stack w */
	  if (0==GETORDERENTRY(ord,typestouched))
	    {
	    SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tow),tp_none,
						tp_none,tp_none); /* internal types */
	    SETORDERENTRY(ord,typestouched)=1;
	    }
	  else
	    if (GETSTELMTYPE(tow)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	      SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
	  if (((tp_clos==GETSTELMTYPE(tow)) || (tp_var==GETSTELMTYPE(tow))) ||
	      (tp_none==GETSTELMTYPE(tow)))		/* undecided possible */
	    {
	    freturn=getfunc_ret();
	    des=find_desc(GETFIRSTDESC(program_start),freturn->dat.ret->ord->args.label);
	    if (apply==freturn->dat.ret->ord->command)
	      {
	      STACK *dummy;
	      
	      dummy=st_make(freturn->dat.ret->w,des->nv+1);
	      st_pop(dummy);
	      if ((DT_COMBINATOR==des->tag) || (DT_CASE==des->tag))
		dep=insert_functype(des->label,dummy,des->nv,freturn->dat.ret->t,
				    des->nfv,&CONST_NONE,kn_sure);
	      else
		dep=insert_functype(des->label,a,des->nv-1,freturn->dat.ret->t,
				    des->nfv/4,&CONST_NONE,kn_sure);
	      st_free(dummy);
	      }
	    else
	      dep=insert_functype(des->label,freturn->dat.ret->w,des->nv,
			      freturn->dat.ret->t,des->nfv,&CONST_NONE,kn_sure);
	    }
	  if (0!=dep)
	    {
	    return_to_call(freturn);
	    tis_state=1;
	    ord=freturn->dat.ret->ord;
	    if (0!=GETSTELMDATA(freturn,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	    clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	    new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	    w=freturn->dat.ret->w;
	    a=freturn->dat.ret->a;
	    if (((gammabeta==GETORDERENTRY(ord,command)) ||  /* only gammacase */
		 (gammacase==GETORDERENTRY(ord,command))) ||
		(Gamma==GETORDERENTRY(ord,command)))
	      {
	      t=freturn->dat.ret->r;
	      r=freturn->dat.ret->t;
	      }
	    else
	      {
	      t=freturn->dat.ret->t;
	      r=freturn->dat.ret->r;
	      }
	    st_pop(ret);
	    break;					/* end matchX */
	    }
	  switch (GETORDERENTRY(ord,command))
	    {
	    case matchlist:
	    case matcharb:
	      {
	      if ((tp_list!=GETSTELMTYPE(tow)) &&	/* definitly fail */
		  (tp_none!=GETSTELMTYPE(tow)))
		SETORDERENTRY(ord,branch)=1;
	      break;
	      }
	    case matchin:
	    case matchstr:
	    case matcharbs:
	      {
	      if ((tp_string!=GETSTELMTYPE(tow)) &&	/* definitly fail */
		  (tp_none!=GETSTELMTYPE(tow)))
		SETORDERENTRY(ord,branch)=1;
	      break;
	      }
	    case matchprim:
	      {
	      if ((tp_none!=GETSTELMTYPE(tow)) &&	/* definitly fail */
		  (((ISCHAR(GETORDERARGS(ord,n))) && (tp_char!=GETSTELMTYPE(tow))) ||
		   ((ISPRF(GETORDERARGS(ord,n))) && (tp_prim!=GETSTELMTYPE(tow)))))
		SETORDERENTRY(ord,branch)=1;
	      break;
	      }
	    case matchint:
	      {
	      if ((tp_int!=GETSTELMTYPE(tow)) &&	/* definitly fail */
		  (tp_none!=GETSTELMTYPE(tow)))
		SETORDERENTRY(ord,branch)=1;
	      break;
	      }
	    case matchbool:
	      {
	      if ((tp_bool!=GETSTELMTYPE(tow)) &&	/* definitly fail */
		  (tp_none!=GETSTELMTYPE(tow)))
		SETORDERENTRY(ord,branch)=1;
	      break;
	      }
	    case tguard:
	      {
	      if ((tp_bool!=GETSTELMTYPE(tow)) &&	/* definitly fail */
		  (tp_none!=GETSTELMTYPE(tow)) &&
		  (tp_var!=GETSTELMTYPE(tow)) &&
		  (tp_clos!=GETSTELMTYPE(tow)))
		SETORDERENTRY(ord,branch)=1;
	      break;
	      }
	    default:
	      {
	      yyfail("%s","illegal command for match!");
	      break;
	      }
	    }
	  if ((tp_clos!=GETSTELMTYPE(tow)) && (tp_var!=GETSTELMTYPE(tow)))
	    {					/* NOT undecided */
	    switch (GETORDERENTRY(ord,branch))
	      {
	      case 0:
	      case 2:
		{
		SETORDERENTRY(ord,branch)=GETORDERENTRY(ord,branch) | 1;
		ord=GETNEXTORDER(ord);
		break;
		}
	      case 1:
		{
		SETORDERENTRY(ord,branch)=3;
		if (NULL==(tow=gotofail()))
		  ord=find_label(GETNEXTORDER(ord),GETORDERARGS(ord,label));
		else
		  {
		  ord=tow->dat.ret->ord;
		  if (0!=GETSTELMDATA(tow,ret)->branch)
		    SETORDERENTRY(ord,branch)=GETSTELMDATA(tow,ret)->branch;
		  clos_exe=(GETSTELMDATA(tow,ret)->status&CLOS_EXE)/CLOS_EXE;
		  new_params=(GETSTELMDATA(tow,ret)->status&NEW_PARAMS)/NEW_PARAMS;
		  w=tow->dat.ret->w;
		  a=tow->dat.ret->a;
		  t=tow->dat.ret->t;
		  r=tow->dat.ret->r;
		  }
		break;
		}
	      case -1:
		{
		SETORDERENTRY(ord,branch)=2;
		ord=find_label(GETNEXTORDER(ord),GETORDERARGS(ord,label));
		break;
		}
	      case -2:
		{
		SETORDERENTRY(ord,branch)=0;
		w=st_push(w,&CONST_NONE);
		ord=&CONST_RTF;
		break;
		}
	      default:
		{
		yyfail("%s","illegal match construction!");
		break;
		}
	      }	    
	    }
	  else					/* undecided */
	    {
	    ord=freturn->dat.ret->ord;
	    if (0!=GETSTELMDATA(freturn,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	    clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	    new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	    st_free(w);
	    w=freturn->dat.ret->w;
	    st_free(a);
	    a=freturn->dat.ret->a;
	    st_free(t);
	    t=freturn->dat.ret->t;
	    st_free(r);
	    r=freturn->dat.ret->r;
	    for (i=0;i<des->nv;i++)
	      st_pop(w);
	    w=st_push(w,&CONST_NONE);
	    ord=GETNEXTORDER(ord);
	    }
	  }
	}
      else						/* was here before */
	{
	if (((3==GETORDERENTRY(ord,branch)) || (2==GETORDERENTRY(ord,branch))) && 
	    (old_ord==ord))
	  {
	  STELM *label;
	  
	  label=st_pop(ret);
	  while ((GETSTELMDATA(label,ret)->ord)!=old_ord)
	    {
	    st_free(GETSTELMDATA(label,ret)->w);
	    st_free(GETSTELMDATA(label,ret)->a);
	    st_free(GETSTELMDATA(label,ret)->r);
	    st_free(GETSTELMDATA(label,ret)->t);
	    SETORDERENTRY(GETSTELMDATA(label,ret)->ord,branch)=0;
	    stelm_free(label);
	    label=st_pop(ret);
	    }
	  label=st_pop(ret);
	  clos_exe=(GETSTELMDATA(label,ret)->status&CLOS_EXE)/CLOS_EXE;
	  new_params=(GETSTELMDATA(label,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	  st_free(w);
	  w=GETSTELMDATA(label,ret)->w;
	  st_free(a);
	  a=GETSTELMDATA(label,ret)->a;
	  st_free(r);
	  r=GETSTELMDATA(label,ret)->r;
	  st_free(t);
	  t=GETSTELMDATA(label,ret)->t;
	  ord=GETSTELMDATA(label,ret)->ord;
	  if (0!=GETSTELMDATA(label,ret)->branch)
	    SETORDERENTRY(ord,branch)=GETSTELMDATA(label,ret)->branch;
	  if (((gammabeta==GETORDERENTRY(ord,command)) ||
		 (gammacase==GETORDERENTRY(ord,command))) ||
		(Gamma==GETORDERENTRY(ord,command)))
	    {
	    STACK *dummy;
	    
	    dummy=t;
	    t=r;
	    r=dummy;
	    }
	  }
	else						/* standart returning */
	  {
	  FUNDESC *des;
	  STELM *result;
	  
          SETORDERENTRY(old_ord,branch)=-GETORDERENTRY(old_ord,branch);
	  st_free(w);
	  st_free(a);
	  st_free(r);
	  st_free(t);
	  while (old_ord!=(GETSTELMDATA((res=st_pop(ret)),ret)->ord))
	    {
	    if BETAFUNCS(GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command))
	      {
	      des=find_desc(GETFIRSTDESC(program_start),
			    res->dat.ret->ord->args.label);
	      result=get_result(des->label,res->dat.ret->w,des->nv,
				res->dat.ret->t,des->nfv);
	      if ((NULL!=result) && (tp_illegal!=result->type))
		break;
	      else
		{
		if ((gammabeta==GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)) ||
		    (gammacase==GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)) ||
		    (Gamma==GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)))
		  {
		  STACK *d;
		  
		  d=GETSTELMDATA(res,ret)->t;
		  GETSTELMDATA(res,ret)->t=GETSTELMDATA(res,ret)->r;
		  GETSTELMDATA(res,ret)->r=d;
		  }
		func_dump=st_push(func_dump,res);
		}
	      }
	    else
	      {
	      SETORDERENTRY(GETSTELMDATA(res,ret)->ord,branch)=0;
	      st_free(GETSTELMDATA(res,ret)->w);
	      st_free(GETSTELMDATA(res,ret)->a);
	      st_free(GETSTELMDATA(res,ret)->r);
	      st_free(GETSTELMDATA(res,ret)->t);
	      }
	    stelm_free(res);
	    }
	  clos_exe=(GETSTELMDATA(res,ret)->status&CLOS_EXE)/CLOS_EXE;
	  new_params=(GETSTELMDATA(res,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	  w=GETSTELMDATA(res,ret)->w;
	  a=GETSTELMDATA(res,ret)->a;
	  r=GETSTELMDATA(res,ret)->r;
	  t=GETSTELMDATA(res,ret)->t;
	  if BETAFUNCS(GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command))
	    {
	    for (i=0; i<des->nv; i++)
	      st_pop(w);
	    w=st_push(w,result);
	    ord=GETSTELMDATA(res,ret)->ord->next;
	    }
	  else
	    ord=GETSTELMDATA(res,ret)->ord;
	  if (0!=GETSTELMDATA(res,ret)->branch)
	    SETORDERENTRY(ord,branch)=GETSTELMDATA(res,ret)->branch;
	  stelm_free(res);
	  }	
	}
      break;
      }
    case mkaframe:
      {
      int i;
      
      DBUG_ORDERS("mkaframe\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      for (i=0;i<GETORDERARGS(ord,n);i++)
	a=st_push(a,&CONST_NONE);
      ord=GETNEXTORDER(ord);
      break;
      }
    case mkbtframe:
      {
      int i;
      
      DBUG_ORDERS("mkbtframe\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      for (i=0;i<GETORDERARGS(ord,n);i++)
	r=st_push(r,&CONST_NONE);
      ord=GETNEXTORDER(ord);
      break;
      }
    case mkwframe:
      {
      int i;
      
      DBUG_ORDERS("mkwframe\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      for (i=0;i<GETORDERARGS(ord,n);i++)
	w=st_push(w,&CONST_NONE);
      w=st_push(w,st_read(w,GETORDERARGS(ord,n)));
      ord=GETNEXTORDER(ord);
      break;
      }      
    case saveptr:
      {
      DBUG_ORDERS("saveptr\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      stelm_cpy(st_read(w,GETORDERARGS(ord,n)),st_read(w,1),1);
      ord=GETNEXTORDER(ord);
      break;
      }
    case nestlist:
      {
      DBUG_ORDERS("nestlist\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      stelm_cpy(st_read(w,1),st_read(w,0),1);
      ord=GETNEXTORDER(ord);
      break;
      }
    case advance:
    case endlist:
      {
      DBUG_ORDERS("advance//endlist\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      ord=GETNEXTORDER(ord);
      break;
      }
    case decw:
    case deca:
    case dect:
    case decr:
    case tdecw:
    case tdeca:
    case tdect:
    case tdecr:
      {
      DBUG_ORDERS("[t]dec(w|a|t|r)\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      ord=GETNEXTORDER(ord);
      break;
      }
    case incw:
    case inca:
    case inct:
    case incr:
    case tincw:
    case tinca:
    case tinct:
    case tincr:
      {
      DBUG_ORDERS("[t]inc(w|a|t|r)\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      ord=GETNEXTORDER(ord);
      break;
      }
    case dereference:
      {
      STELM *stelm;
      
      DBUG_ORDERS("dereference\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      if ((tp_list==GETSTELMTYPE(st_read(w,1))) || 
	  (tp_string==GETSTELMTYPE(st_read(w,1))))
	{
	if (tp_empty==st_read(w,1)->subtype.type)
	  stelm=&CONST_NONE;
	else
	  {
	  if (NULL!=st_read(w,1)->subtype.next)
	    stelm=new_stelm(st_read(w,1)->subtype.type,
			    subtype_cpy(st_read(w,1)->subtype.next));
	  else
	    stelm=new_stelm(st_read(w,1)->subtype.type,NULL);
	  }
	}
      else
	stelm=&CONST_NONE;
      stelm_cpy(st_read(w,0),stelm,1);
      insert_restype(stelm,ord);
      stelm_free(stelm);
      ord=GETNEXTORDER(ord);
      break;
      }
    case pick:
      {
      DBUG_ORDERS("pick\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      stelm_cpy(st_read(w,0),st_read(w,GETORDERARGS(ord,n)),1);
      ord=GETNEXTORDER(ord);
      break;
      }
    case startsubl:
      {
      DBUG_ORDERS("startsubl\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      stelm_cpy(st_read(r,GETORDERARGS(ord,n)),st_read(w,0),1);
      stelm_cpy(st_read(r,GETORDERARGS(ord,m)),st_read(w,1),1);
      ord=GETNEXTORDER(ord);
      break;
      }
    case endsubl:
      {
      DBUG_ORDERS("endsubl\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      stelm_cpy(st_read(r,GETORDERARGS(ord,n)),st_read(w,1),1);
      ord=GETNEXTORDER(ord);
      break;
      }
    case restoreptr:
      {
      DBUG_ORDERS("restoreptr\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      stelm_cpy(st_read(w,1),st_read(w,GETORDERARGS(ord,n)),1);
      ord=GETNEXTORDER(ord);
      break;
      }
    case bindsubl:
      {
      DBUG_ORDERS("bindsubl\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      stelm_cpy(st_read(a,GETORDERARGS(ord,l)),st_read(r,GETORDERARGS(ord,n)),1);
      ord=GETNEXTORDER(ord);
      break;
      }
    case rmwframe:
      {
      int i;
      
      DBUG_ORDERS("rmwframe\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      for (i=0; i<GETORDERARGS(ord,n);i++)
	st_pop(w);
      ord=GETNEXTORDER(ord);
      break;
      }
    case rmbtframe:
      {
      int i;
      
      DBUG_ORDERS("rmbtframe\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      for (i=0; i<GETORDERARGS(ord,n);i++)
	st_pop(r);
      ord=GETNEXTORDER(ord);
      break;
      }
    case drop:
      {
      DBUG_ORDERS("drop\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      st_pop(w);
      ord=GETNEXTORDER(ord);
      break;
      }
    case binds:
    case bind:
      {
      DBUG_ORDERS("bind[s]\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      stelm_cpy(st_read(a,GETORDERARGS(ord,n)),st_read(w,0),1);
      ord=GETNEXTORDER(ord);
      break;
      }
    case initbt:
      {
      STELM *stelm;
      
      DBUG_ORDERS("initbt\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      stelm_cpy(st_read(r,GETORDERARGS(ord,m)),st_read(w,1),1);
      stelm_cpy(st_read(r,GETORDERARGS(ord,k)),st_read(w,1),1);
      stelm_cpy(st_read(r,GETORDERARGS(ord,l)),st_read(w,0),1);
      stelm=new_stelm(st_read(w,0)->subtype.type,st_read(w,0)->subtype.next);
      stelm_cpy(st_read(r,GETORDERARGS(ord,j)),stelm,1);
      stelm_free(stelm);
      ord=GETNEXTORDER(ord);
      break;
      }
    case atstart:
    case atend:
      {
      DBUG_ORDERS("atend//atstart\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      ord=GETNEXTORDER(ord);
      break;
      }
    case savebt:
      {
      DBUG_ORDERS("savebt\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      stelm_cpy(st_read(r,GETORDERARGS(ord,n)),st_read(w,1),1);
      ord=GETNEXTORDER(ord);
      break;
      }
    case restorebt:
      {
      DBUG_ORDERS("restorebt\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      stelm_cpy(st_read(w,1),st_read(r,GETORDERARGS(ord,n)),1);
      ord=GETNEXTORDER(ord);
      break;
      }
    case fetch:
      {
      STELM *stelm;
      
      DBUG_ORDERS("fetch\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      if ((tp_list==GETSTELMTYPE(st_read(w,0))) || 
	  (tp_string==GETSTELMTYPE(st_read(w,0))))
	stelm=new_stelm(st_read(w,0)->subtype.type,
			subtype_cpy(st_read(w,0)->subtype.next));
      else
	stelm=new_stelm(tp_none,NULL);
      stelm_cpy(st_read(w,0),stelm,1);
      insert_restype(stelm,ord);
      stelm_free(stelm);
      ord=GETNEXTORDER(ord);
      break;
      }
    case pushh:
    case poph:
    case wait:
    case dist:
    case distb:
    case distend:
    case count:
    case msdistend:
    case msnodist:
      {
      ord=GETNEXTORDER(ord);
      break;
      }
    default:
      {
      fprintf(stderr,"unknown command!");
      exit(0);
      break;
      }
    }
  }
DBUG_RETURN((STELM *)NULL);				/* code never reached */
}

/************************************************************************/
/* controls execution of asmt-code for typechecking			*/
/* (used by tis)							*/
/************************************************************************/
void execution()
{
STELM *goaltype,*dummy;
RETURNADR NULL_ret={NULL,NULL,NULL,NULL,NULL};
STACK *d;
FUNDESC *des;

DBUG_ENTER("execution");
des=GETFIRSTDESC(program_start);
while (NULL!=des)
  {
  if (max_desc_adr<des->address)
    max_desc_adr=des->address;
  des=des->next;
  }
ord=GETFIRSTFUNCTION(program_start)->order;
w=(STACK *)NULL;
a=(STACK *)NULL;
t=(STACK *)NULL;
r=(STACK *)NULL;
ret=(STACK *)NULL;
goaltype=exe_func();
DBUG_PRINT("ORDERS",("executing dump functions ..."));
while ((NULL!=func_dump) && (0<GETTOPOFSTACK(func_dump)))
  {
  dummy=st_pop(func_dump);
  if ((-1!=GETORDERARGS(GETSTELMDATA(dummy,ret)->ord,k)) ||
      (MUST_EXE==GETORDERENTRY(GETSTELMDATA(dummy,ret),status)))
    {
    NULL_ret.ord=&CONST_EXT;
    d=st_push(NULL,new_stelm(tp_returnadr,&NULL_ret));
    ord=GETSTELMDATA(dummy,ret)->ord;
    if (0!=GETSTELMDATA(dummy,ret)->branch)
      SETORDERENTRY(ord,branch)=GETSTELMDATA(dummy,ret)->branch;
    w=GETSTELMDATA(dummy,ret)->w;
    a=GETSTELMDATA(dummy,ret)->a;
    clos_exe=(GETSTELMDATA(dummy,ret)->status&CLOS_EXE)/CLOS_EXE;
    new_params=(GETSTELMDATA(dummy,ret)->status&NEW_PARAMS)/NEW_PARAMS;
    t=GETSTELMDATA(dummy,ret)->t;
    r=GETSTELMDATA(dummy,ret)->r;
    ret=d;
    dummy=exe_func();
    }
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* Is a kind of MAIN for the tis project				*/
/* (used by main)							*/
/************************************************************************/
int tis()
{
DBUG_ENTER("tis");
execution();
DBUG_RETURN(0);
}
@


1.87
log
@comment closed (grrrrrr)
@
text
@d794 1
d928 1
a928 1
/*	    if (((gammabeta==GETORDERENTRY(ord,command)) ||
d937 1
a937 1
              } */
@


1.86
log
@*** empty log message ***
@
text
@d1175 1
a1175 1
    case jump:					/* direct jump *
@


1.85
log
@cases p_to_char, p_to_ord, p_sprintf, p_sscanf added.
@
text
@d16 4
a19 3
ORDER CONST_EXT={ext,{NULL},NULL,NULL,NULL,0,0};
ORDER CONST_RTF	={rtf,{NULL},NULL,NULL,NULL,0,0,0,0},
  CONST_CCLOS={mkcclos,{0,0,0,0,0,0.0,"","",NULL,NULL,NULL,0},
d21 1
d43 1
a43 1
  switch (GETORDERENTRY(ord,command))
d168 1
a168 1
      func=st_pop(w);					/* apply what ? */
d171 1
a171 1
	case tp_func:					/* we have a function */
d217 1
a217 1
		  			/* do we have a valid result ? */
d220 2
a221 2
		if (arity==GETDESCENTRY(des,nv))	/* if arity fits the need */
		  insert_restype(result,ord);		/* insert result type */
d233 3
a235 3
		w=st_push(w,result);			/* push result */
		arity-=GETDESCENTRY(des,nv);		/* overloaded apply ? */
		SETORDERARGS(ord,m)=arity;
d238 1
a238 1
		  SETORDERARGS(ord,k)=-1;			/* order executed */
d246 1
a246 1
		if (NULL==old_ord)		/* first call from here */
d349 1
a349 1
	    else						/* build closure */
d364 1
a364 1
		for (i=0; i<clos->i; i++)			/* copy args */
d374 1
a374 1
		for (i=0; i<clos->k; i++)			/* copy args */
d396 2
a397 2
	    arity=GETORDERARGS(ord,n);			/* set normal apply-value */
          switch (GETPRF(GETSTELMDATA(func,prim)))
d434 1
a434 1
	      if (1==arity)
d438 1
a438 1
		while (0<arity)
d443 1
a443 1
		w=st_push(w,&CONST_NONE);
d447 2
a448 2
	    case p_lselect:
	      {
d451 1
a451 1
	      if (2<=arity)
d458 1
a458 1
		  ord=GETPREVORDER(ord);	/* because of orderadvancement */
d469 1
a469 1
		if (0!=clos->i)
d477 1
a477 1
		else
d532 1
a532 1
		    {
d546 1
a546 1
		  if (0!=clos->i)
d555 1
a555 1
		    clos->w=NULL;
d654 1
a654 1
		    clos->w=NULL;
d694 1
a694 1
	    clos=GETSTELMDATA(func,clos);			/* get closure data */
d718 1
a718 1
		for (j=0; j<clos->k; j++)			/* unfold T-frame */
d740 1
a740 1
	    else						/* new CLOSURE to build */
d742 1
a742 1
	      clos->i=i;					/* new no of args stored */
d761 2
a762 2
	default:					/* illegal function call */
	  {
d769 1
a769 1
	  for (i=0; i<j;i++)
d771 1
a771 1
	  w=st_push(w,&CONST_NONE);
d794 1
d827 1
a827 1
	  dummy=r;
d858 1
a858 2
	  ret=st_push(ret,new_stelm(tp_returnadr,rt)); 
	  /* returndata stored */
d955 1
a955 1
    case mkiclos:
d959 1
a959 1
      for(i=0; i<=ord->args.n;i++)
d961 1
a961 1
      w=st_push(w,&CONST_NONE);
d997 2
a998 2
    case mkilist:
    case mklist:
d1058 1
a1058 1
    case mkframe: /* cr 19.02.96 */
d1078 1
a1078 1
    case mkcase:
d1098 1
a1098 1
    case mkbclos:
d1105 1
a1105 1
      func=st_pop(w);
d1108 1
a1108 1
      clos->desc=GETSTELMDATA(func,desc);
d1112 1
a1112 1
      if (0<clos->i)
d1122 1
a1122 1
      if (0<clos->k)
d1130 1
a1130 1
      res.type=tp_clos;
d1140 1
a1140 1
    case delta1:
d1164 1
a1164 1
    case intact:
d1175 1
a1175 1
    case jump:
d1180 1
a1180 1
      if (LABbt==GETORDERARGS(ord,n))
d1188 1
a1188 1
	if (0!=GETSTELMDATA(res,ret)->branch)
d1197 1
a1197 1
    case jcond2:
@


1.84
log
@new (t)ASM commands: count(x), msdistend, msnodist
@
text
@d429 2
d518 2
@


1.83
log
@dummy entries (no information) for frame operations
@
text
@d3001 3
@


1.82
log
@cases pushcw_pf and rtc_pf are extended for interactions.
@
text
@d1052 20
@


1.81
log
@cases for mkiclos and intact added.
@
text
@d66 10
a75 5
      d_stelm.type=tp_prim;			/* set type prim */
      d_stelm.dat.prim=GETORDERARGS(ord,n);	/* which prim. function */
      d_stelm.subtype.type=tp_none;		/* set clear subtype */
      d_stelm.subtype.next=NULL;
      w=st_push(w,&d_stelm);
d1880 5
a1884 8
      res.dat.prim=GETORDERARGS(ord,n);		/* which prim. function */
      st_free(w);
      st_free(a);
      st_free(r);
      st_free(t);
      freturn=getfunc_ret();			/* gets last function */
      if BETAFUNCS(GETORDERENTRY(GETSTELMDATA(st_read(ret,0),ret)->ord,command))
	kn=kn_sure;
d1886 135
a2020 124
	kn=kn_partly;
      if (NULL!=freturn)			/* no dump execution end */
	{
	if (apply==GETORDERENTRY(GETSTELMDATA(freturn,ret)->ord,command))
	  {
	  STACK *dummy;
	  
	  des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desc);
	  if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
	    {
	    dummy=st_make(GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv)+1);
	    /* get copy of stack */
	    st_pop(dummy);			/* remove function from stack */
	    dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv),
				GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
				&res,kn);
	    if (0!=dep)
	      {
	      return_to_call(freturn);
	      tis_state=1;
	      ord=freturn->dat.ret->ord;
	      if (0!=GETSTELMDATA(freturn,ret)->branch)
	        SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	      clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	      new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	      w=freturn->dat.ret->w;
	      a=freturn->dat.ret->a;
	      r=freturn->dat.ret->r;
	      t=freturn->dat.ret->t;
	      st_pop(ret);
	      break;
	      }
	    stelm_cpy(&res,get_result(GETDESCENTRY(des,label),dummy,
				      GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
				      GETDESCENTRY(des,nfv)),1);
	    }
	  else
	    {
	    dummy=st_make(GETSTELMDATA(freturn,ret)->a,GETDESCENTRY(des,nv)-1);
	    /* get copy of stack */
	    dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv)-1,
				GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
				&res,kn);	  
	    if (0!=dep)
	      {
	      return_to_call(freturn);
	      tis_state=1;
	      ord=freturn->dat.ret->ord;
	      if (0!=GETSTELMDATA(freturn,ret)->branch)
	        SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	      clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	      new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	      w=freturn->dat.ret->w;
	      a=freturn->dat.ret->a;
	      r=freturn->dat.ret->r;
	      t=freturn->dat.ret->t;
	      st_pop(ret);
	      break;
	      }
	    stelm_cpy(&res,get_result(GETDESCENTRY(des,label),dummy,
				      GETDESCENTRY(des,nv)-1,GETSTELMDATA(freturn,ret)->t,
				      GETDESCENTRY(des,nfv)/4),1);
	    }
	  st_free(dummy);					/* free dummy stack */
	  }
	else
	  {
	  des=find_desc(GETFIRSTDESC(program_start),
			GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,label));
	  dep=insert_functype(GETDESCENTRY(des,label),GETSTELMDATA(freturn,ret)->w,
			      GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			      GETDESCENTRY(des,nfv),&res,kn);
	  if (0!=dep)
	    {
	    return_to_call(freturn);
	    tis_state=1;
	    ord=freturn->dat.ret->ord;
	    if (0!=GETSTELMDATA(freturn,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
	    clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
	    new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
	    w=freturn->dat.ret->w;
	    a=freturn->dat.ret->a;
	    r=freturn->dat.ret->r;
	    t=freturn->dat.ret->t;
	    st_pop(ret);
            break;
	    }
	  stelm_cpy(&res,get_result(GETDESCENTRY(des,label),
				    GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv),
				    GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)),1);
	  }
	if (0==GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,m))
	  insert_restype(&res,GETSTELMDATA(freturn,ret)->ord);
        SETORDERARGS(GETSTELMDATA(freturn,ret)->ord,k)=-1;  /* order executed */
	}
      freturn=st_pop(ret);			/* restors former state */
      ord=GETSTELMDATA(freturn,ret)->ord;
      if (0!=GETSTELMDATA(freturn,ret)->branch)
	SETORDERENTRY(ord,branch)=GETSTELMDATA(freturn,ret)->branch;
      clos_exe=(GETSTELMDATA(freturn,ret)->status&CLOS_EXE)/CLOS_EXE;
      new_params=(GETSTELMDATA(freturn,ret)->status&NEW_PARAMS)/NEW_PARAMS;
      w=GETSTELMDATA(freturn,ret)->w;		/* restore stacks */
      a=GETSTELMDATA(freturn,ret)->a;
      t=GETSTELMDATA(freturn,ret)->t;
      r=GETSTELMDATA(freturn,ret)->r;
      stelm_free(freturn);
      if BETAFUNCS(GETORDERENTRY(ord,command))
	{
        for (i=0; i<GETDESCENTRY(des,nv); i++)
	  stelm_free(st_pop(w));
	if (apply==GETORDERENTRY(ord,command))
	  {
	  stelm_free(st_pop(w));
          w=st_push(w,&res);
	  if (0==GETORDERARGS(ord,m))
	    ord=GETNEXTORDER(ord);
	  }
	else
	  {
	  w=st_push(w,&res);
	  ord=GETNEXTORDER(ord);
	  }
	}
@


1.80
log
@rtc_pf added
@
text
@d7 1
d944 10
d1130 11
@


1.79
log
@missing rtt fixed
@
text
@d1845 143
@


1.78
log
@dereference Problem fixed
@
text
@d915 1
a915 1
	    if (((gammabeta==GETORDERENTRY(ord,command)) ||
d924 1
a924 1
              }
d1536 1
d1540 6
a1545 3
      arg=st_pop(a);
      w=st_push(w,arg);					/* moveaw */
      stelm_free(arg);
d1645 1
a1645 1
	      (Gamma!=GETORDERENTRY(ord,command)))
d1689 8
@


1.77
log
@freea implemented
@
text
@d1322 1
a1323 1
	      
d2643 2
a2644 3
	if (NULL!=st_read(w,1)->subtype.next)
	  stelm=new_stelm(st_read(w,1)->subtype.type,
			  subtype_cpy(st_read(w,1)->subtype.next));
d2646 7
a2652 1
	  stelm=new_stelm(st_read(w,1)->subtype.type,NULL);
@


1.76
log
@dist*, wait, pushh & poph implemented
@
text
@d1514 8
@


1.75
log
@! some primitiv functions changed !
@
text
@d2772 10
@


1.74
log
@PM backtrack bug fixed
@
text
@a781 13
      if ((beta==GETORDERENTRY(ord,command)) && (NULL!=t) &&
	  (des->nfv>GETTOPOFSTACK(t)))
	{					/* pfusch wegen Bug in tred */
	STACK *dt=NULL;
	
	printf("warning: bug short-cut taken ...\n");
	for (i=0; i<des->nfv-GETTOPOFSTACK(t); i++)
	  dt=st_push(dt,&CONST_NONE);
	for (i=0; i<GETTOPOFSTACK(t); i++)
	  dt=st_push(dt,&(t->stack[i]));
	st_free(t);
	t=dt;
	}
d1127 1
a1127 1
      if (0==strncmp(GETORDERARGS(ord,label),"bt_",2))
@


1.73
log
@some bugfixes in gamma handling and matchX
@
text
@d751 7
a757 1
	  for (i=0; i<GETORDERARGS(ord,n);i++)
d782 13
d821 1
a821 1
	if (((gammabeta==GETORDERENTRY(ord,command)) ||		/* stack switch r<->t */
d846 1
a846 1
	  if (((gammabeta==GETORDERENTRY(ord,command)) ||
d898 12
a909 2
	    rt->t=t;
	    rt->r=r;
d1137 2
d1140 15
a1154 1
      ord=find_label(GETNEXTORDER(ord),GETORDERARGS(ord,label));
d1224 1
a1224 1
else
d1407 11
d1419 1
d1468 2
a1469 8
/*	      if (((gammabeta!=GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)) &&
		   (gammacase!=GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command))) &&
		  (Gamma!=GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command))) */
		result=get_result(des->label,res->dat.ret->w,des->nv,
				  res->dat.ret->t,des->nfv);
/*	      else
		result=get_result(des->label,res->dat.ret->w,des->nv,
				  res->dat.ret->r,des->nfv); */
d1473 11
d1485 1
d2194 1
a2194 1
	if (1==new_params)
d2258 1
a2258 1
	    w=st_make(w,GETTOPOFSTACK(w));
d2260 1
a2260 1
	    a=st_make(a,GETTOPOFSTACK(a));
d2262 1
a2262 1
	    t=st_make(t,GETTOPOFSTACK(t));
d2264 1
a2264 1
	    r=st_make(r,GETTOPOFSTACK(r));
d2309 1
a2309 1
	    if (((gammabeta==GETORDERENTRY(ord,command)) ||
d2322 1
a2322 1
	    break;
d2400 1
a2400 1
	            SETORDERENTRY(ord,branch)=GETSTELMDATA(tow,ret)->branch;
d2516 11
d2528 1
@


1.72
log
@PM bugs removed
@
text
@d45 2
a46 2
      d_stelm.type=tp_int;
      d_stelm.subtype.type=tp_none;
d55 2
a56 2
      d_stelm.type=tp_bool;
      d_stelm.subtype.type=tp_none;
d65 4
a68 2
      d_stelm.type=tp_prim;
      d_stelm.dat.prim=GETORDERARGS(ord,n);
d76 1
a76 1
      w=st_push(w,st_read(a,GETORDERARGS(ord,n)));
d83 1
a83 1
      w=st_push(w,st_read(t,GETORDERARGS(ord,n)));
d90 1
a90 1
      r=st_push(r,st_read(t,GETORDERARGS(ord,n)));
d98 1
a98 1
      r=st_push(r,st_read(a,GETORDERARGS(ord,n)));
d107 3
a109 3
      arg=find_address(GETORDERARGS(ord,desc));		/* search for adress */
      r=st_push(r,arg);
      stelm_free(arg);
d118 3
a120 3
      arg=find_address(GETORDERARGS(ord,desc));
      w=st_push(w,arg);
      stelm_free(arg);
d127 2
a128 1
      ord=GETNEXTORDER(ord);
d136 3
a138 3
      arg=st_pop(a);
      w=st_push(w,arg);
      stelm_free(arg);
d147 3
a149 3
      arg=st_pop(a);
      r=st_push(r,arg);
      stelm_free(arg);
d163 1
a163 1
	case tp_func:
d171 1
a171 1
	  des=GETSTELMDATA(func,desc);
d173 1
a173 1
	    arity=GETORDERARGS(ord,m);		/* restore prev set apply-value */
d175 2
a176 2
	    arity=GETORDERARGS(ord,n);		/* set normal apply-value */
	  if (NULL==des)
d178 1
a178 1
	    for (i=0; i<arity; i++)
d180 3
a182 3
	    w=st_push(w,&CONST_NONE);
	    SETORDERARGS(ord,m)=0;
	    insert_restype(&CONST_NONE,ord);
d185 1
a185 1
	  else
d188 1
a188 1
		       malloc(strlen(GETDESCENTRY(des,label))+1)))
d191 2
a192 2
	    /* remember last functioncall */
	    if (GETDESCENTRY(des,nv)<=arity)		/* execution possible */
d197 1
a197 1
	      else
d200 1
a200 1
	      if ((NULL!=ret) && (0<GETTOPOFSTACK(ret)))
d202 2
a203 2
		old_func=getfunc_ret();
		if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
d208 3
a210 2
	      if (((NULL!=result) && (tp_illegal!=result->type)) &&
		  (0==tis_state))		/* old result stored or second try */
d212 2
a213 2
		if (arity==GETDESCENTRY(des,nv))
		  insert_restype(result,ord);
d215 1
d220 1
a220 1
		else
d222 1
a222 1
		  for (i=0; i<GETDESCENTRY(des,nv); i++)
d225 1
a225 1
		w=st_push(w,result);
d244 1
a244 1
		  rt->w=w;
d251 1
a251 1
		  if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))		/* COMB */
d253 1
a253 1
		    if (DT_CASE!=GETDESCENTRY(des,tag))
d256 1
a256 1
		      /* build new frames; +1 for func */
d261 2
a262 1
		      SETORDERARGS(ord,m)=arity-GETDESCENTRY(des,nv); /* store overload arity */
d267 1
a267 1
		    else
d270 1
a270 1
		      /* build new frames; +1 for func */
d275 2
a276 1
		      SETORDERARGS(ord,m)=arity-GETDESCENTRY(des,nv); /* store overload arity */
d282 1
a282 1
		  else					/* CONDI */
d286 4
a289 4
		    w=st_make(w,2);		/* frame = bool + CONDI */
		    st_pop(w);			/* remove func from stack */
		    a=st_make(a,GETDESCENTRY(des,nv)-1);	/* argument frame ready */
		    t=st_make(t,GETDESCENTRY(des,nfv)/4);
d291 2
a292 1
		    SETORDERARGS(ord,m)=arity-GETDESCENTRY(des,nv); /* store overload arity */
d295 1
a295 1
		    strcpy(str,"func_");
d298 1
a298 1
		    if (1<GETDESCENTRY(des,nv))
d305 1
a305 1
		  {					/* Hier fehlt CONDI !!! */
d311 2
a312 2
		    rt->status=(clos_exe*CLOS_EXE)+MUST_EXE;
		    rt->w=w;
d318 2
a319 1
		    /* returndata stored */		    restore_ret(old_ord);		/* restors state of old_ord */
d677 1
d802 1
a802 1
	if (((gammabeta==GETORDERENTRY(ord,command)) ||
d921 1
a921 1
      for (i=0; i<=ord->args.n;i++)
d923 1
a923 1
      w=st_push(w,&CONST_NONE);
d933 1
a933 1
      prim=st_pop(w);
d937 1
a937 1
      clos->k=GETSTELMDATA(prim,prim);
d940 1
a940 1
      if (0!=clos->i)
d944 2
a945 2
	stelm_cpy(clos->w,st_read(w,clos->i-1),clos->i);
	for (i=0; i<clos->i; i++)
d949 2
a950 2
	clos->w=NULL;
      dummy.type=tp_clos;
d952 1
a952 1
      dummy.subtype.type=tp_none;
d955 1
a955 1
      w=st_push(w,&dummy);
d966 4
a969 3
      d_stelm.type=tp_list;
      d_stelm.subtype.type=tp_empty;
      for (i=0; i<GETORDERARGS(ord,n); i++)
d971 19
a989 6
	stelm=st_pop(w);
        dump_list_func(stelm);
   	if ((tp_empty!=d_stelm.subtype.type) &&
	    (d_stelm.subtype.type!=GETSTELMTYPE(stelm)))
	  d_stelm.subtype.type=tp_none;
        else
d998 10
d1009 1
d1112 1
a1112 1
    case jcond2:					/* noch zu ueberpruefen */
d1179 1
a1179 1
	else
d1253 12
a1264 2
	    r=freturn->dat.ret->r;
	    t=freturn->dat.ret->t;
d1321 1
d1330 3
a1336 1
	    r=GETSTELMDATA(label,ret)->r;
d1338 12
a1349 4
	    t=GETSTELMDATA(label,ret)->t;
	    ord=GETSTELMDATA(label,ret)->ord;
	    if (0!=GETSTELMDATA(label,ret)->branch)
	      SETORDERENTRY(ord,branch)=GETSTELMDATA(label,ret)->branch;
a1374 4
	    w=GETSTELMDATA(res,ret)->w;
	    a=GETSTELMDATA(res,ret)->a;
	    r=GETSTELMDATA(res,ret)->r;
	    t=GETSTELMDATA(res,ret)->t;
d1378 14
d1411 1
a1411 1
	      if (((gammabeta!=GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)) &&
d1413 1
a1413 1
		  (Gamma!=GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)))
d1416 1
a1416 1
	      else
d1418 1
a1418 1
				  res->dat.ret->r,des->nfv);
d2131 2
d2146 5
a2150 1
          stelm_free(res);
d2153 19
a2171 10
             if (apply==GETORDERENTRY(ord,command))
	       {
	       res=st_pop(w);
	       des=GETSTELMDATA(res,desc);
	       }
             else
	       des=find_desc(GETFIRSTDESC(program_start),GETORDERARGS(ord,label));
	    res=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			   t,GETDESCENTRY(des,nfv)/4);
	    for (i=0; i<GETDESCENTRY(des,nv); i++)
d2173 4
a2176 1
            w=st_push(w,res);
d2203 1
a2203 1
	  if (GETORDERENTRY(ord,typestouched)==0)
d2246 12
a2257 2
	    t=freturn->dat.ret->t;
	    r=freturn->dat.ret->r;
d2305 3
a2307 1
		  (tp_none!=GETSTELMTYPE(tow)))
d2404 1
d2421 10
d2448 2
a2449 8
	      if (((gammabeta!=GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)) &&
		   (gammacase!=GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command))) &&
		  (Gamma!=GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)))
	        result=get_result(des->label,res->dat.ret->w,des->nv,
				  res->dat.ret->t,des->nfv);
	      else
		result=get_result(des->label,res->dat.ret->w,des->nv,
				  res->dat.ret->r,des->nfv);
d2703 1
a2703 1
	stelm_cpy(stelm,&CONST_NONE,1);
@


1.71
log
@infinit loop removed
@
text
@d254 6
d267 6
a273 6
		    t=st_make(t,GETDESCENTRY(des,nfv));
		    r=NULL;
		    SETORDERARGS(ord,m)=arity-GETDESCENTRY(des,nv); /* store overload arity */
		    ord=find_func(GETFIRSTFUNCTION(program_start),
				  GETDESCENTRY(des,label));
		    insert_args(a,GETDESCENTRY(des,nv),t,GETDESCENTRY(des,nfv),ord);
d985 8
a1003 1
    case mkcase:
d2088 1
a2088 1
	    res=get_result(GETDESCENTRY(des,label),a,GETDESCENTRY(des,nv)-1,
d2090 2
a2091 3
	    stelm_free(st_pop(w));
	    for (i=0; i<GETDESCENTRY(des,nv)-1; i++)
	      stelm_free(st_pop(a));
d2102 1
d2662 2
a2663 12
    if (((gammabeta==GETORDERENTRY(GETSTELMDATA(dummy,ret)->ord,command)) ||
	 (gammacase==GETORDERENTRY(GETSTELMDATA(dummy,ret)->ord,command))) ||
	(Gamma==GETORDERENTRY(GETSTELMDATA(dummy,ret)->ord,command)))
      {
      t=GETSTELMDATA(dummy,ret)->r;
      r=GETSTELMDATA(dummy,ret)->t;
      }
    else
      {
      t=GETSTELMDATA(dummy,ret)->t;
      r=GETSTELMDATA(dummy,ret)->r;
      }
@


1.70
log
@bug in fkochside sample removed
@
text
@d22 1
a22 1
    clos_exe=0;
d1097 2
d1137 1
d1199 2
d1279 2
d1311 2
d1370 2
d1446 2
d1473 2
d1526 2
d1592 2
d1619 2
d1648 2
d1668 2
d1733 2
d1760 2
d1789 2
d1810 2
d1875 2
d1902 2
d1947 2
d2001 2
d2143 2
d2227 2
d2261 2
d2309 2
d2366 2
d2643 2
@


1.69
log
@bug with recursiv functions with changing parameters removed
@
text
@d294 11
a306 1
		    restore_ret(old_ord);		/* restors state of old_ord */
d857 10
d2586 2
a2587 1
if (-1!=GETORDERARGS(GETSTELMDATA(dummy,ret)->ord,k)) 
@


1.68
log
@mklist problem fixed
@
text
@d243 1
a243 1
		  rt->status=clos_exe;
d798 1
a798 1
	  rt->status=clos_exe;
d847 1
a849 1
	    restore_ret(old_ord);		/* restors state of old_ord */
d1062 2
d1077 2
a1078 4
	  if (EXE_CLOS==(GETSTELMDATA(res,ret)->status|EXE_CLOS))
	    clos_exe=1;
	  else
	    clos_exe=0;
d1114 1
a1114 1
	  rt->status=clos_exe;
d1176 2
a1177 4
	    if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	      clos_exe=1;
	    else
	      clos_exe=0;
d1244 2
a1245 4
	    if (EXE_CLOS==(GETSTELMDATA(label,ret)->status|EXE_CLOS))
	      clos_exe=1;
	    else
	      clos_exe=0;
d1277 2
a1278 4
	    if (EXE_CLOS==(GETSTELMDATA(res,ret)->status|EXE_CLOS))
	      clos_exe=1;
	    else
	      clos_exe=0;
d1312 2
a1314 2
	      else
		break;
d1326 3
a1328 5
	  if (EXE_CLOS==(GETSTELMDATA(res,ret)->status|EXE_CLOS))
	      clos_exe=1;
	    else
	      clos_exe=0;
	    w=GETSTELMDATA(res,ret)->w;
d1412 2
a1413 4
	    if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	      clos_exe=1;
	    else
	      clos_exe=0;
d1437 2
a1438 4
	    if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	      clos_exe=1;
	    else
	      clos_exe=0;
d1491 2
a1492 4
      if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	clos_exe=1;
      else
	clos_exe=0;
d1555 2
a1556 4
	    if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	      clos_exe=1;
	    else
	      clos_exe=0;
d1580 2
a1581 4
	    if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	      clos_exe=1;
	    else
	      clos_exe=0;
d1607 2
a1608 4
	  if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	    clos_exe=1;
	  else
	    clos_exe=0;
d1625 2
a1626 4
      if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	clos_exe=1;
      else
        clos_exe=0;
d1688 2
a1689 4
	      if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	        clos_exe=1;
	      else
	        clos_exe=0;
d1713 2
a1714 4
	      if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	        clos_exe=1;
	      else
	        clos_exe=0;
d1740 2
a1741 4
	    if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	      clos_exe=1;
	    else
	      clos_exe=0;
d1759 2
a1760 4
      if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	clos_exe=1;
      else
        clos_exe=0;
d1822 2
a1823 4
	    if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	      clos_exe=1;
	    else
	      clos_exe=0;
d1847 2
a1848 4
	    if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	      clos_exe=1;
	    else
	      clos_exe=0;
d1890 2
a1891 4
      if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	clos_exe=1;
      else
	clos_exe=0;
d1942 2
a1943 4
	  if (EXE_CLOS==(GETSTELMDATA(d,ret)->status|EXE_CLOS))
	    clos_exe=1;
	  else
	    clos_exe=0;
d2028 1
a2028 1
	  rt->status=clos_exe;
d2082 2
a2083 4
	    if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	      clos_exe=1;
	    else
	      clos_exe=0;
d2164 2
a2165 4
		  if (EXE_CLOS==(GETSTELMDATA(tow,ret)->status|EXE_CLOS))
	            clos_exe=1;
	          else
	            clos_exe=0;
d2196 2
a2197 4
	    if (EXE_CLOS==(GETSTELMDATA(freturn,ret)->status|EXE_CLOS))
	      clos_exe=1;
	    else
	      clos_exe=0;
d2231 2
a2232 4
	  if (EXE_CLOS==(GETSTELMDATA(label,ret)->status|EXE_CLOS))
	    clos_exe=1;
	  else
	    clos_exe=0;
d2282 2
a2283 4
	  if (EXE_CLOS==(GETSTELMDATA(res,ret)->status|EXE_CLOS))
	    clos_exe=1;
	  else
	    clos_exe=0;
d2573 2
a2574 4
    if (EXE_CLOS==(GETSTELMDATA(dummy,ret)->status|EXE_CLOS))
      clos_exe=1;
    else
      clos_exe=0;
@


1.67
log
@jcond without bool bugfixed
@
text
@d243 1
a243 1
		  rt->status=0;
d798 1
a798 1
	  rt->status=0;
d1009 2
d1114 1
a1114 1
	  rt->status=0;
d1143 4
a1146 1
		dummy=st_make(freturn->dat.ret->w,des->nv+1);
d1176 5
a1180 1
	    w=freturn->dat.ret->w;
d1246 5
a1250 1
	    w=GETSTELMDATA(label,ret)->w;
d1281 4
d1332 5
a1336 1
	  w=GETSTELMDATA(res,ret)->w;
d1420 4
d1447 4
d1503 4
d1569 4
d1596 4
d1625 4
d1645 4
d1710 4
d1737 4
d1766 4
d1787 4
d1852 4
d1879 4
d1924 4
d1978 4
d2066 1
a2066 1
	  rt->status=0;
d2120 4
d2204 4
d2238 4
d2275 4
d2328 4
@


1.66
log
@mklist with functions and/or closures bugfixed
@
text
@d15 1
d17 2
a18 2
      CONST_CCLOS={mkcclos,{0,0,0,0,0,0.0,"","",NULL,NULL,NULL,0},
			   NULL,NULL,NULL,0,0,0,0};
d21 2
a22 1
int tis_state=0,do_dupe,dup_count=0,dup_num,max_desc_adr=0;
d243 1
d524 1
a524 1
		break;
d798 1
d848 1
a848 1
	    /* then-case without result */
d926 1
a926 1
      int i,j;
a927 3
      RETURNADR *rt;
      FUNDESC *des;
      CLOSURE *clos;
d935 2
a936 55
	if (tp_func==GETSTELMTYPE(stelm))
	  {
	  if (NULL==(rt=malloc(sizeof(RETURNADR))))
	    yyfail("%s","no memory for returnadress!");
	  rt->a=NULL;
	  for (j=0;j<GETSTELMDATA(stelm,desc)->nv;j++)
	    rt->a=st_push(rt->a,&CONST_NONE);
	  rt->ord=find_func(GETFIRSTFUNCTION(program_start),
			    GETDESCENTRY(GETSTELMDATA(stelm,desc),label));
	  rt->w=NULL;
	  rt->t=NULL;
	  rt->r=NULL;
	  insert_args(rt->a,GETDESCENTRY(GETSTELMDATA(stelm,desc),nv),
		      NULL,0,rt->ord);
	  func_dump=st_push(func_dump,new_stelm(tp_returnadr,rt));
	  }
	if ((tp_clos==GETSTELMTYPE(stelm)) &&	    /* closure, but no deltaclos */
	    (NULL!=GETSTELMDATA(stelm,clos)->desc))
	  {
	  if (NULL==(rt=malloc(sizeof(RETURNADR))))
	    yyfail("%s","no memory for returnadress!");
	  clos=GETSTELMDATA(stelm,clos);
	  des=clos->desc;
	  rt->a=NULL;
	  for (j=0;j<des->nv-clos->i;j++)
	    rt->a=st_push(rt->a,&CONST_NONE);
	  for (j=0;j<clos->i;j++)
	    {
	    rt->a=st_push(rt->a,&(clos->w[j]));
	    stelm_free(&(clos->w[j]));
	    }
	  clos->w=NULL;
	  rt->t=NULL;
	  for (j=0;j<clos->k;j++)
	    {
	    rt->t=st_push(rt->t,&(clos->t[j]));
	    stelm_free(&(clos->t[j]));
	    }
	  clos->t=NULL;
	  rt->r=NULL;
	  rt->ord=find_func(GETFIRSTFUNCTION(program_start),GETDESCENTRY(des,label));
	  if (DT_CONDITIONAL==GETDESCENTRY(des,tag))
	    {
	    rt->w=rt->a;
	    rt->a=NULL;
	    }
	  else
	    {
	    rt->w=NULL;
	    insert_args(rt->a,GETDESCENTRY(des,nv),
		        rt->t,GETDESCENTRY(des,nfv),rt->ord);
	    }
	  func_dump=st_push(func_dump,new_stelm(tp_returnadr,rt));
	  }
	if ((tp_empty!=d_stelm.subtype.type) &&
d1073 4
d1112 1
d1133 1
a1133 3
	    des=find_desc(GETFIRSTDESC(program_start),
			  freturn->dat.ret->ord->args.label);
	    if (apply==freturn->dat.ret->ord->command)
d1135 16
a1150 7
	      STACK *dummy;
	      
	      dummy=st_make(freturn->dat.ret->w,des->nv+1);
	      st_pop(dummy);
	      if ((DT_COMBINATOR==des->tag) || (DT_CASE==des->tag))
		dep=insert_functype(des->label,dummy,des->nv,freturn->dat.ret->t,
				    des->nfv,&CONST_NONE,kn_sure);
d1152 2
a1153 3
		dep=insert_functype(des->label,a,des->nv-1,freturn->dat.ret->t,
				    des->nfv/4,&CONST_NONE,kn_sure);
	      st_free(dummy);
a1154 3
	    else
	      dep=insert_functype(des->label,freturn->dat.ret->w,des->nv,
			          freturn->dat.ret->t,des->nfv,&CONST_NONE,kn_sure);
d1641 1
a1641 3
      if (NULL==freturn)			/* dump execution end */
	DBUG_RETURN((STELM *)NULL);
      if (apply==GETORDERENTRY(GETSTELMDATA(freturn,ret)->ord,command))
d1643 1
a1643 4
	STACK *dummy;
	
	des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desc);
	if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
d1645 28
a1672 7
	  dummy=st_make(GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv)+1);
	  					/* get copy of stack */
	  st_pop(dummy);			/* remove function from stack */
          dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv),
			      GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
			      &res,kn);
	  if (0!=dep)
d1674 20
a1693 9
	    return_to_call(freturn);
	    tis_state=1;
	    ord=freturn->dat.ret->ord;
	    w=freturn->dat.ret->w;
	    a=freturn->dat.ret->a;
	    r=freturn->dat.ret->r;
	    t=freturn->dat.ret->t;
	    st_pop(ret);
            break;
d1695 1
a1695 3
	  stelm_cpy(&res,get_result(GETDESCENTRY(des,label),dummy,
		    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
				    GETDESCENTRY(des,nfv)),1);
d1699 5
a1703 30
	  dummy=st_make(GETSTELMDATA(freturn,ret)->a,GETDESCENTRY(des,nv)-1);
	  					/* get copy of stack */
          dep=insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv)-1,
			      GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
			      &res,kn);	  
	  if (0!=dep)
	    {
	    return_to_call(freturn);
	    tis_state=1;
	    ord=freturn->dat.ret->ord;
	    w=freturn->dat.ret->w;
	    a=freturn->dat.ret->a;
	    r=freturn->dat.ret->r;
	    t=freturn->dat.ret->t;
	    st_pop(ret);
            break;
	    }
	  stelm_cpy(&res,get_result(GETDESCENTRY(des,label),dummy,
		    GETDESCENTRY(des,nv)-1,GETSTELMDATA(freturn,ret)->t,
		    GETDESCENTRY(des,nfv)/4),1);
	  }
	st_free(dummy);					/* free dummy stack */
	}
      else
	{
	des=find_desc(GETFIRSTDESC(program_start),
		      GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,label));
	dep=insert_functype(GETDESCENTRY(des,label),GETSTELMDATA(freturn,ret)->w,
			    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			    GETDESCENTRY(des,nfv),&res,kn);
d1716 7
a1722 3
	stelm_cpy(&res,get_result(GETDESCENTRY(des,label),
		  GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv),
		  GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)),1);
a1723 3
      if (0==GETORDERARGS(GETSTELMDATA(freturn,ret)->ord,m))
	insert_restype(&res,GETSTELMDATA(freturn,ret)->ord);
      SETORDERARGS(GETSTELMDATA(freturn,ret)->ord,k)=-1;  /* order executed */
d1881 1
a1881 1
      if ((NULL!=t) && (0!=GETTOPOFSTACK(t)))
d1883 1
a1883 1
      if ((NULL!=r) && (0!=GETTOPOFSTACK(r)))
d1885 1
a1885 1
      if ((NULL!=a) && (0!=GETTOPOFSTACK(a)))
d1887 1
a1887 1
      if ((NULL!=w) && (0!=GETTOPOFSTACK(w)))
d1907 6
a1912 1
	  yyfail("%s","illegal returnadress at ext!\n");	/* error */
d1985 1
a2489 1
ORDER ord_ext={ext,{NULL},NULL,NULL,NULL,0,0};
d2515 1
a2515 1
    NULL_ret.ord=&ord_ext;
d2517 7
a2527 3
      ord=GETSTELMDATA(dummy,ret)->ord;
      w=GETSTELMDATA(dummy,ret)->w;
      a=GETSTELMDATA(dummy,ret)->a;
a2529 1
      ret=d;
a2532 3
      ord=GETSTELMDATA(dummy,ret)->ord;
      w=GETSTELMDATA(dummy,ret)->w;
      a=GETSTELMDATA(dummy,ret)->a;
a2534 1
      ret=d;
d2536 1
@


1.65
log
@tildeargs reimplemented in function cache
@
text
@d20 1
a20 1
int tis_state=0,do_dupe,dup_count=0,dup_num,max_desc_adr=0,new_params=0;
d173 1
a173 1
	    for (i=0; i<=arity; i++)
d640 1
a640 13
	  clos=GETSTELMDATA(func,clos);			/* get closure data */
	  des=clos->desc;
	  primf=clos->k;
          if (0!=GETORDERARGS(ord,m))
	    arity=GETORDERARGS(ord,m);		/* restore prev set apply-value */
	  else
	    arity=GETORDERARGS(ord,n);		/* set normal apply-value */
	  if ((NULL!=des) && 			/* if CONDI unfold to A STACK */
	      (DT_CONDITIONAL==GETDESCENTRY(des,tag)))
	    arg=a;
	  else
	    arg=w;
	  for (i=0; i<clos->i; i++)			/* unfold W-frame */
d642 8
a649 2
	    arg=st_push(arg,&(clos->w[i]));
	    stelm_free(&(clos->w[i]));
d651 1
a651 4
	  if (NULL!=clos->w)				/* free stored frame */
	    free(clos->w);
	  i=clos->i+arity;				/* calc no. of args */	
	  if (clos->j<=i) 				/* arity <= no. of args */
d653 13
a665 1
	    if (NULL!=des)				/* got FUNDESC */
d667 21
a687 1
	      for (j=0; j<clos->k; j++)			/* unfold T-frame */
d689 2
a690 2
		t=st_push(t,&(clos->t[j]));
		stelm_free(&(clos->t[j]));
d692 24
a715 9
	      if (NULL!=clos->t)			/* free stored frame */
		free(clos->t);
	      dummy.type=tp_func;
	      dummy.dat.desc=des;
	      }
	    else					/* primitiv function */
	      {
	      dummy.type=tp_prim;
	      dummy.dat.prim=primf;
a716 24
	    if ((NULL!=des) && (DT_CONDITIONAL==GETDESCENTRY(des,tag)))
	      a=arg;
	    else
	      w=arg;
	    w=st_push(w,&dummy);			/* store function */
	    SETORDERARGS(ord,m)=i;
	    }
	  else						/* new CLOSURE to build */
	    {
	    clos->i=i;					/* new no of args stored */
	    if(NULL==(clos->w=malloc(sizeof(STELM)*i)))
	      yyfail("%s","no memory for new closure");
	    stelm_cpy(clos->w,&(arg->stack[arg->topofstack-i]),i); /* store args */
	    for (i=0; i<clos->i; i++)			/* free frame on stack */
	      stelm_free(st_pop(arg));
	    dummy.type=tp_clos;
	    dummy.dat.clos=clos;
	    if (DT_CONDITIONAL==GETDESCENTRY(des,tag))
	      a=arg;
	    else
	      w=arg;
	    w=st_push(w,&dummy);			/* push closure on stack */
	    insert_restype(&dummy,ord);
	    ord=GETNEXTORDER(ord);
a745 1
      new_params=0;
d922 1
a922 1
      int i;
d924 3
d934 54
d1025 1
d1345 2
a1347 2
	      else
		func_dump=st_push(func_dump,res);
d1641 1
a1641 1
      SETORDERARGS(GETSTELMDATA(freturn,ret)->ord,k)=-1; /* order executed */
d1766 1
a1766 1
      SETORDERARGS(GETSTELMDATA(freturn,ret)->ord,k)=-1; /* order executed */
d1891 1
a1891 1
      SETORDERARGS(GETSTELMDATA(freturn,ret)->ord,k)=-1; /* order executed */
d2551 1
a2551 1
  if (-1!=GETORDERARGS(GETSTELMDATA(dummy,ret)->ord,k))
@


1.64
log
@some primitiv functions fixed & jcond bug removed
@
text
@d190 2
a191 1
		result=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv));
d193 2
a194 1
		result=get_result(GETDESCENTRY(des,label),a,GETDESCENTRY(des,nv)-1);
d297 8
a304 2
		    insert_functype(GETDESCENTRY(des,label),w,
				    GETDESCENTRY(des,nv),&CONST_NONE,kn_sure);
d734 8
a741 1
      result=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv));
d836 8
a843 2
	    insert_functype(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			    &CONST_NONE,kn_sure);
d1066 2
a1067 1
	      res=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv));
d1074 2
a1075 1
	      res=get_result(GETDESCENTRY(des,label),a,GETDESCENTRY(des,nv)-1);
d1118 2
a1119 1
		dep=insert_functype(des->label,dummy,des->nv,&CONST_NONE,kn_sure);
d1121 2
a1122 1
		dep=insert_functype(des->label,a,des->nv-1,&CONST_NONE,kn_sure);
d1127 1
a1127 1
			          &CONST_NONE,kn_sure);
d1265 8
a1272 1
	      result=get_result(des->label,res->dat.ret->w,des->nv);
d1366 2
a1367 1
		              &res,kn);
d1381 2
a1382 1
		    GETDESCENTRY(des,nv)),1);
d1389 1
d1404 2
a1405 1
		    GETDESCENTRY(des,nv)-1),1);
d1414 2
a1415 1
			    GETDESCENTRY(des,nv),&res,kn);
d1439 2
a1440 1
		  GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv)),1);
d1502 1
d1517 2
a1518 1
		    GETDESCENTRY(des,nv)),1);
d1525 1
d1540 2
a1541 1
		    GETDESCENTRY(des,nv)-1),1);
d1550 2
a1551 1
			    GETDESCENTRY(des,nv),res,kn);
d1565 2
a1566 1
		  GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv)),1);
d1627 1
d1642 2
a1643 1
		    GETDESCENTRY(des,nv)),1);
d1650 1
d1665 2
a1666 1
		    GETDESCENTRY(des,nv)-1),1);
d1675 2
a1676 1
			    GETDESCENTRY(des,nv),&res,kn);
d1690 2
a1691 1
		  GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv)),1);
d1752 1
d1767 2
a1768 1
		    GETDESCENTRY(des,nv)),1);
d1775 1
d1790 2
a1791 1
		    GETDESCENTRY(des,nv)-1),1);
d1800 2
a1801 1
			    GETDESCENTRY(des,nv),&res,kn);
d1815 2
a1816 1
		  GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv)),1);
d1938 2
a1939 1
	    res=get_result(GETDESCENTRY(des,label),a,GETDESCENTRY(des,nv)-1);
d1989 2
a1990 1
		dep=insert_functype(des->label,dummy,des->nv,&CONST_NONE,kn_sure);
d1992 2
a1993 1
		dep=insert_functype(des->label,a,des->nv-1,&CONST_NONE,kn_sure);
d1998 1
a1998 1
			      &CONST_NONE,kn_sure);
d2177 2
a2178 1
	        result=get_result(des->label,res->dat.ret->w,des->nv);
d2180 2
a2181 1
		result=get_result(des->label,res->dat.ret->w,des->nv);
@


1.63
log
@setref inserted
@
text
@d20 1
a20 1
int tis_state=0,do_dupe,dup_count=0,dup_num,max_desc_adr=0;
d724 1
d1103 2
a1104 1
	    SETORDERENTRY(ord,types)=tp_none;	    
d1107 7
a1113 1
	    SETORDERENTRY(ord,types)=tp_bool;
@


1.62
log
@lselect und lreplace bug removed
@
text
@d1825 1
@


1.61
log
@*** empty log message ***
@
text
@d171 1
a171 6
	  if (NULL==(SETORDERARGS(ord,label)=
		     malloc(strlen(GETDESCENTRY(des,label))+1)))
	    yyfail("%s","no memory for label!");
	  strcpy(SETORDERARGS(ord,label),GETDESCENTRY(des,label)); 
	  					/* remember last functioncall */
	  if (GETDESCENTRY(des,nv)<=arity)		/* execution possible */
d173 15
a187 5
	    if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
	      result=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv));
	    else
	      result=get_result(GETDESCENTRY(des,label),a,GETDESCENTRY(des,nv)-1);
	    if ((NULL!=ret) && (0<GETTOPOFSTACK(ret)))
a188 1
	      old_func=getfunc_ret();
d190 1
a190 1
	        set_depend(des,w,t,old_func);
d192 2
a193 8
		set_depend(des,a,t,old_func);
	      }
	    if (((NULL!=result) && (tp_illegal!=result->type)) &&
		(0==tis_state))		/* old result stored or second try */
	      {
	      if (arity==GETDESCENTRY(des,nv))
	        insert_restype(result,ord);
	      if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))
d195 5
a199 2
		for (i=0; i<GETDESCENTRY(des,nv); i++)
		  stelm_free(st_pop(w));
d201 2
a202 1
	      else
d204 20
a223 2
		for (i=0; i<GETDESCENTRY(des,nv); i++)
		  stelm_free(st_pop(w));
d225 1
a225 4
	      w=st_push(w,result);
	      arity-=GETDESCENTRY(des,nv);		/* overloaded apply ? */
	      SETORDERARGS(ord,m)=arity;
	      if (0==arity)
d227 3
a229 21
		SETORDERARGS(ord,k)=-1;			/* order executed */
		ord=GETNEXTORDER(ord);
		}
	      }
	    else				/* result unknown unitl now */
	      {
	      tis_state=0;
	      old_ord=search_ret(ord);
	      if (NULL==old_ord)		/* first call from here */
		{
		if (NULL==(rt=malloc(sizeof(RETURNADR))))
		  yyfail("%s","no memory for returnadress!");
		rt->ord=ord;			/* remember enviroment of func */
		w=st_push(w,func);		/* save function */
		rt->w=w;
		rt->a=a;
		rt->t=t;
		rt->r=r;
		ret=st_push(ret,new_stelm(tp_returnadr,rt));
							/* returndata stored */
		if (DT_CONDITIONAL!=GETDESCENTRY(des,tag))		/* COMB */
d231 11
a241 1
		  if (DT_CASE!=GETDESCENTRY(des,tag))
d243 20
a262 4
		    a=st_make(w,GETDESCENTRY(des,nv)+1);
		    				/* build new frames; +1 for func */
		    st_pop(a);			/* remove func from stack */
		    w=NULL;
d264 1
a264 1
		  else
d266 3
a268 2
		    w=st_make(w,GETDESCENTRY(des,nv)+1);
		    				/* build new frames; +1 for func */
d270 13
a282 1
		    a=NULL;
a283 6
		  t=st_make(t,GETDESCENTRY(des,nfv));
		  r=NULL;
		  SETORDERARGS(ord,m)=arity-GETDESCENTRY(des,nv); /* store overload arity */
		  ord=find_func(GETFIRSTFUNCTION(program_start),
			        GETDESCENTRY(des,label));
		  insert_args(a,GETDESCENTRY(des,nv),t,GETDESCENTRY(des,nfv),ord);
d285 17
a301 37
		else					/* CONDI */
		  {
		  char *str;
		  
		  w=st_make(w,2);		/* frame = bool + CONDI */
		  st_pop(w);			/* remove func from stack */
		  a=st_make(a,GETDESCENTRY(des,nv)-1);	/* argument frame ready */
		  t=st_make(t,GETDESCENTRY(des,nfv)/4);
		  r=NULL;
		  SETORDERARGS(ord,m)=arity-GETDESCENTRY(des,nv); /* store overload arity */
		  if (NULL==(str=malloc(strlen(GETDESCENTRY(des,label)))))
		    yyfail("%s","no memory for label!");
		  strcpy(str,"func_");
		  strcpy(&str[5],&(GETDESCENTRY(des,label)[6]));
		  ord=find_func(GETFIRSTFUNCTION(program_start),str);
		  if (1<GETDESCENTRY(des,nv))
		    insert_args(a,GETDESCENTRY(des,nv)-1,t,
				GETDESCENTRY(des,nfv)/4,GETNEXTORDER(ord));
		  free(str);
		  }
		}
	      else					/* have been here before */
		{					/* Hier fehlt CONDI !!! */
		if (old_ord!=ord)			/* old_ord must be jcond */
		  {
		  SETORDERENTRY(old_ord,branch)=
		    -GETORDERENTRY(old_ord,branch); /* then-case without result */
		  restore_ret(old_ord);		/* restors state of old_ord */
		  }
		else					/* bad recursion */
		  {
		  insert_functype(GETDESCENTRY(des,label),w,
				  GETDESCENTRY(des,nv),&CONST_NONE,kn_sure);
		  for (i=0; i<GETDESCENTRY(des,nv); i++) /* remove args from stack */
		    stelm_free(st_pop(w));
		  w=st_push(w,&CONST_NONE);		/* set result none */
		  ord=GETNEXTORDER(ord);
d303 1
a303 20
		}
	      }	  
	    }
	  else						/* build closure */
	    {
	    if (NULL==(clos=malloc(sizeof(CLOSURE))))
	      yyfail("%s","no memory for closure");
	    if (NULL==(clos->desc=malloc(sizeof(FUNDESC))))
	      yyfail("%s","no memory for descriptor!");
	    clos->desc=des;				/* set closure data */
	    clos->i=arity;
	    clos->j=GETDESCENTRY(clos->desc,nv);
	    clos->k=GETDESCENTRY(clos->desc,nfv);
	    if (0!=clos->i)				/* are there any args ? */
	      {
	      if (NULL==(clos->w=malloc(sizeof(STELM)*(clos->i))))
		yyfail("%s","no memory for closure");
	      stelm_cpy(clos->w,st_read(w,clos->i-1),clos->i);
	      for (i=0; i<clos->i; i++)			/* copy args */
		stelm_free(st_pop(w));
d305 1
a305 3
	    else					/* no args */
	      clos->w=NULL;
	    if (0!=clos->k)				/* are there any targs ? */
d307 1
a307 1
	      if (NULL==(clos->t=malloc(sizeof(STELM)*(clos->k))))
d309 32
a340 3
	      stelm_cpy(clos->t,st_read(t,clos->k-1),clos->k);
	      for (i=0; i<clos->k; i++)			/* copy args */
		stelm_free(st_pop(t));
a341 8
	    else					/* no targs */
	      clos->t=NULL;
	    res.type=tp_clos;
	    res.dat.clos=clos;
	    w=st_push(w,&res);			/* push closure on W Stack */	
	    stelm_free(func);
	    insert_restype(&res,ord);			/* set restype */
	    ord=GETNEXTORDER(ord);
@


1.60
log
@*** empty log message ***
@
text
@d179 1
a179 2
	      result=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
				t,GETDESCENTRY(des,nfv));
d181 1
a181 2
	      result=get_result(GETDESCENTRY(des,label),a,GETDESCENTRY(des,nv)-1,
				t,GETDESCENTRY(des,nfv)/4);
d285 1
a285 2
				  GETDESCENTRY(des,nv),t,
				  GETDESCENTRY(des,nfv),&CONST_NONE,kn_sure);
d713 1
a713 8
      if (((gammabeta==GETORDERENTRY(ord,command)) ||
	   (gammacase==GETORDERENTRY(ord,command))) || 
	  (Gamma==GETORDERENTRY(ord,command)))
	result=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			  r,GETDESCENTRY(des,nfv));
      else
	result=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			  t,GETDESCENTRY(des,nfv));
d808 2
a809 8
	    if (((gammabeta==GETORDERENTRY(ord,command)) ||
		 (gammacase==GETORDERENTRY(ord,command))) ||
		(Gamma==GETORDERENTRY(ord,command)))
	      insert_functype(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			      r,GETDESCENTRY(des,nfv),&CONST_NONE,kn_sure);
	    else
	      insert_functype(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			      t,GETDESCENTRY(des,nfv),&CONST_NONE,kn_sure);
d1032 1
a1032 2
	      res=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			     t,GETDESCENTRY(des,nfv));
d1039 1
a1039 2
	      res=get_result(GETDESCENTRY(des,label),a,GETDESCENTRY(des,nv)-1,
			     t,GETDESCENTRY(des,nfv)/4);
d1082 1
a1082 2
		dep=insert_functype(des->label,dummy,des->nv,freturn->dat.ret->t,
			            des->nfv,&CONST_NONE,kn_sure);
d1084 1
a1084 2
		dep=insert_functype(des->label,a,des->nv-1,freturn->dat.ret->t,
			            des->nfv/4,&CONST_NONE,kn_sure);
d1089 1
a1089 2
			          freturn->dat.ret->t,des->nfv,&CONST_NONE,
			          kn_sure);
d1220 1
a1220 8
	      if (((gammabeta!=GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)) &&
		   (gammacase!=GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command))) &&
		  (Gamma!=GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command)))
	        result=get_result(des->label,res->dat.ret->w,des->nv,
				  res->dat.ret->t,des->nfv);
	      else
		result=get_result(des->label,res->dat.ret->w,des->nv,
				  res->dat.ret->r,des->nfv);
d1314 1
a1314 2
		              GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
			      &res,kn);
d1328 1
a1328 2
		    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
		    GETDESCENTRY(des,nfv)),1);
a1334 1
		              GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
d1349 1
a1349 2
		    GETDESCENTRY(des,nv)-1,GETSTELMDATA(freturn,ret)->t,
		    GETDESCENTRY(des,nfv)/4),1);
d1358 1
a1358 2
			    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			    GETDESCENTRY(des,nfv),&res,kn);
d1382 1
a1382 2
		  GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv),
		  GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)),1);
a1443 1
		              GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
d1458 1
a1458 2
		    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
		    GETDESCENTRY(des,nfv)),1);
a1464 1
		              GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
d1479 1
a1479 2
		    GETDESCENTRY(des,nv)-1,GETSTELMDATA(freturn,ret)->t,
		    GETDESCENTRY(des,nfv)/4),1);
d1488 1
a1488 2
			    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			    GETDESCENTRY(des,nfv),res,kn);
d1502 1
a1502 2
		  GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv),
		  GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)),1);
a1562 1
		              GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
d1577 1
a1577 2
		    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
		    GETDESCENTRY(des,nfv)),1);
a1583 1
		              GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
d1598 1
a1598 2
		    GETDESCENTRY(des,nv)-1,GETSTELMDATA(freturn,ret)->t,
		    GETDESCENTRY(des,nfv)/4),1);
d1607 1
a1607 2
			    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			    GETDESCENTRY(des,nfv),&res,kn);
d1621 1
a1621 2
		  GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv),
		  GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)),1);
a1681 1
		              GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
d1696 1
a1696 2
		    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
		    GETDESCENTRY(des,nfv)),1);
a1702 1
		              GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
d1717 1
a1717 2
		    GETDESCENTRY(des,nv)-1,GETSTELMDATA(freturn,ret)->t,
		    GETDESCENTRY(des,nfv)/4),1);
d1726 1
a1726 2
			    GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			    GETDESCENTRY(des,nfv),&res,kn);
d1740 1
a1740 2
		  GETSTELMDATA(freturn,ret)->w,GETDESCENTRY(des,nv),
		  GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)),1);
d1861 1
a1861 2
	    res=get_result(GETDESCENTRY(des,label),a,GETDESCENTRY(des,nv)-1,
			   t,GETDESCENTRY(des,nfv)/4);
d1911 1
a1911 2
		dep=insert_functype(des->label,dummy,des->nv,freturn->dat.ret->t,
				des->nfv,&CONST_NONE,kn_sure);
d1913 1
a1913 2
		dep=insert_functype(des->label,a,des->nv-1,freturn->dat.ret->t,
				des->nfv/4,&CONST_NONE,kn_sure);
d1918 1
a1918 1
			      freturn->dat.ret->t,des->nfv,&CONST_NONE,kn_sure);
d2097 1
a2097 2
	        result=get_result(des->label,res->dat.ret->w,des->nv,
				  res->dat.ret->t,des->nfv);
d2099 1
a2099 2
		result=get_result(des->label,res->dat.ret->w,des->nv,
				  res->dat.ret->r,des->nfv);
@


1.59
log
@gammabeta bug (removing t-frame & switch) removed
@
text
@d397 1
d399 7
d848 2
d2283 1
a2283 1
	stelm_cpy(stelm,&CONST_NONE,1);
@


1.58
log
@initbt bug removed
@
text
@d823 7
a829 2
	      for (i=0; i<GETDESCENTRY(des,nfv); i++)
	        stelm_free(st_pop(r));
@


1.57
log
@fundesc address made unique
@
text
@d2354 1
a2354 2
      stelm=new_stelm(st_read(w,0)->subtype.type,
		      subtype_cpy(st_read(w,0)->subtype.next));
@


1.56
log
@option -dx handling implemented
@
text
@d20 1
a20 1
int tis_state=0,do_dupe,dup_count=0,dup_num;
d2420 1
d2423 7
@


1.55
log
@function duplication - first part
@
text
@d20 1
a20 1
int tis_state=0,do_dupe=1,dup_count=0;
@


1.54
log
@STACKS & ORDER changed to global
@
text
@d20 1
a20 1
int tis_state=0,do_dupe=1;
d44 1
a44 1
      d_stelm.subtype.type=tp_none;;
d54 1
a54 1
      d_stelm.subtype.type=tp_none;;
d170 4
a173 1
	    arity=GETORDERARGS(ord,n);			/* set normal apply-value */
d257 1
a257 1
		  char str[12]="func_";
d265 3
d273 1
d716 1
d866 2
@


1.53
log
@lselect on empty list changed
@
text
@d20 3
a22 1
int tis_state=0;
d28 1
a28 1
STELM *exe_func(ORDER *ord, STACK *w, STACK *a, STACK *t, STACK *r,STACK *ret)
d37 1
a37 1
    stack_display(w,a,r,t);
d183 1
a183 1
	      old_func=getfunc_ret(ret);
d216 1
a216 1
	      old_ord=search_ret(ord,ret);
d275 1
a275 6
		  result=restore_ret(old_ord,ret);	/* restors state of old_ord */
		  w=GETSTELMDATA(result,ret)->w;	/* restore stacks */
		  a=GETSTELMDATA(result,ret)->a;
		  t=GETSTELMDATA(result,ret)->t;
		  r=GETSTELMDATA(result,ret)->r;
		  ord=GETSTELMDATA(result,ret)->ord;
d373 1
a373 1
		exe_prim1(ord,w,GETSTELMDATA(func,prim)); /* execute primfunction */
d390 1
a390 1
		exe_prim2(ord,w,GETSTELMDATA(func,prim)); /* execute primfunction */
d454 1
a454 1
		exe_prim2(ord,w,GETSTELMDATA(func,prim)); /* execute primfunction */
d509 1
a509 1
		exe_prim3(ord,w,GETSTELMDATA(func,prim)); /* execute primfunction */
d553 1
a553 1
		exe_prim4(ord,w,GETSTELMDATA(func,prim)); /* execute primfunction */
d711 1
a711 1
	old_func=getfunc_ret(ret);
d742 1
a742 1
	old_ord=search_ret(ord,ret);
d798 1
a798 6
	    result=restore_ret(old_ord,ret);	/* restors state of old_ord */
	    w=GETSTELMDATA(result,ret)->w;		/* restore stacks */
	    a=GETSTELMDATA(result,ret)->a;
	    t=GETSTELMDATA(result,ret)->t;
	    r=GETSTELMDATA(result,ret)->r;
	    ord=GETSTELMDATA(result,ret)->ord;	/* set continuation */
d944 2
d952 1
a952 1
      exe_prim1(ord,w,GETORDERARGS(ord,primf));
d957 1
a957 1
      exe_prim2(ord,w,GETORDERARGS(ord,primf));
d963 1
a963 1
      exe_prim3(ord,w,GETORDERARGS(ord,primf));
d970 1
a970 1
      exe_prim4(ord,w,GETORDERARGS(ord,primf));
d995 1
a995 1
      old_ord=search_ret(ord,ret);
d1065 1
a1065 1
	    freturn=getfunc_ret(ret);			/* gets last function */
d1092 1
a1092 1
	    return_to_call(freturn,ret);
d1157 1
a1157 1
	  dummy=findfcall(label,ret);		/* searches for functioncall */
d1299 1
a1299 1
      freturn=getfunc_ret(ret);			/* gets last function */
d1321 1
a1321 1
	    return_to_call(freturn,ret);
d1344 1
a1344 1
	    return_to_call(freturn,ret);
d1369 1
a1369 1
	  return_to_call(freturn,ret);
d1435 1
a1435 1
      freturn=getfunc_ret(ret);			/* gets last function */
d1457 1
a1457 1
	    return_to_call(freturn,ret);
d1480 1
a1480 1
	    return_to_call(freturn,ret);
d1505 1
a1505 1
	  return_to_call(freturn,ret);
d1560 1
a1560 1
      freturn=getfunc_ret(ret);			/* gets last function */
d1582 1
a1582 1
	    return_to_call(freturn,ret);
d1605 1
a1605 1
	    return_to_call(freturn,ret);
d1630 1
a1630 1
	    return_to_call(freturn,ret);
d1685 1
a1685 1
      freturn=getfunc_ret(ret);			/* gets last function */
d1707 1
a1707 1
	    return_to_call(freturn,ret);
d1730 1
a1730 1
	    return_to_call(freturn,ret);
d1755 1
a1755 1
	    return_to_call(freturn,ret);
d1862 1
a1862 1
      old_ord=search_ret(ord,ret);		/* first call form here ? */
d1930 1
a1930 1
	    freturn=getfunc_ret(ret);
d1952 1
a1952 1
	    return_to_call(freturn,ret);
d2030 1
a2030 1
		if (NULL==(tow=gotofail(ord,ret)))
d2408 1
a2408 1
RETURNADR ret={NULL,NULL,NULL,NULL,NULL};
d2412 7
a2418 1
goaltype=exe_func(GETFIRSTFUNCTION(program_start)->order,NULL,NULL,NULL,NULL,NULL);
d2425 2
a2426 2
    ret.ord=&ord_ext;
    d=st_push(NULL,new_stelm(tp_returnadr,&ret));
d2430 8
a2437 3
      dummy=exe_func(GETSTELMDATA(dummy,ret)->ord,GETSTELMDATA(dummy,ret)->w,
		     GETSTELMDATA(dummy,ret)->a,GETSTELMDATA(dummy,ret)->r,
		     GETSTELMDATA(dummy,ret)->t,d);
d2439 9
a2447 3
      dummy=exe_func(GETSTELMDATA(dummy,ret)->ord,GETSTELMDATA(dummy,ret)->w,
		     GETSTELMDATA(dummy,ret)->a,GETSTELMDATA(dummy,ret)->t,
		     GETSTELMDATA(dummy,ret)->r,d);
@


1.52
log
@minor bugs removed
@
text
@d18 1
a18 1
STELM CONST_NONE={tp_none,{{tp_none,NULL}}};
d42 2
a43 2
      d_stelm.dat.subtype.type=tp_none;;
      d_stelm.dat.subtype.next=NULL;
d52 2
a53 2
      d_stelm.dat.subtype.type=tp_none;;
      d_stelm.dat.subtype.next=NULL;
d879 1
a879 1
      d_stelm.dat.subtype.type=tp_empty;
d883 3
a885 3
	if ((tp_empty!=d_stelm.dat.subtype.type) &&
	    (d_stelm.dat.subtype.type!=GETSTELMTYPE(stelm)))
	  d_stelm.dat.subtype.type=tp_none;
d888 1
a888 1
	  if (tp_empty==d_stelm.dat.subtype.type)
d890 1
a890 1
	    d_stelm.dat.subtype.type=GETSTELMTYPE(stelm);
d893 1
a893 1
	      d_stelm.dat.subtype.next=subtype_cpy(&stelm->dat.subtype);
d895 1
a895 1
	      d_stelm.dat.subtype.next=NULL;
d898 1
a898 1
	    subtypecmp(d_stelm.dat.subtype.next,&(stelm->dat.subtype));
d1556 1
a1556 1
      STELM res={tp_int,{{tp_none,NULL}}},*freturn;
d1681 1
a1681 1
      STELM res={tp_bool,{{tp_none,NULL}}},*freturn;
d2256 7
a2262 2
	stelm=new_stelm(st_read(w,1)->dat.subtype.type,
			subtype_cpy(st_read(w,1)->dat.subtype.next));
d2350 2
a2351 2
      stelm=new_stelm(st_read(w,0)->dat.subtype.type,
		      subtype_cpy(st_read(w,0)->dat.subtype.next));
d2385 2
a2386 2
	stelm=new_stelm(st_read(w,0)->dat.subtype.type,
			subtype_cpy(st_read(w,0)->dat.subtype.next));
@


1.51
log
@primitive functions bugfixed
@
text
@d42 2
a43 1
      d_stelm.dat.desc=NULL;
d52 2
a53 1
      d_stelm.dat.desc=NULL;
@


1.50
log
@all primitive functions implemented
@
text
@d18 1
a18 1
STELM CONST_NONE={tp_none,tp_none,{NULL}};
d116 6
d500 1
a500 1
	    case p_substruct:
a872 1
      TP_TYPES tp=tp_empty;
d876 2
d881 3
a883 2
	if ((tp_empty!=tp) && (tp!=GETSTELMTYPE(stelm)))
	  tp=tp_none;
d885 13
a897 1
          tp=GETSTELMTYPE(stelm);
d900 1
a900 2
      stelm=new_stelm(tp_list,(void *)tp);
      w=st_push(w,stelm);
d1554 1
a1554 1
      STELM res={tp_int,tp_none,{NULL}},*freturn;
d1679 1
a1679 1
      STELM res={tp_bool,tp_none,{NULL}},*freturn;
d2254 2
a2255 1
	stelm=new_stelm(st_read(w,1)->listtype,NULL);
d2343 2
a2344 1
      stelm=new_stelm(st_read(w,0)->listtype,NULL);
d2378 2
a2379 1
	stelm=new_stelm(st_read(w,0)->listtype,NULL);
@


1.49
log
@Gamma implemented
@
text
@d179 1
a179 1
	    if (((NULL!=result)&& (tp_illegal!=result->type)) &&
d326 265
a590 1
	  exe_prim(ord,w,GETSTELMDATA(func,prim));	/* execute primfunction */
d758 1
a758 1
	  						/* returndata stored */
d792 1
a792 1
	    					/* then-case without result */
d902 1
a902 1

d936 4
d941 4
d947 9
a955 2
      DBUG_ORDERS("delta\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      exe_prim(ord,w,GETORDERARGS(ord,primf));
d2199 26
@


1.48
log
@PM implemented
@
text
@d423 1
d430 1
a430 1
      DBUG_ORDERS("[gamma]beta|case\\tail\tw:%d, a:%d, r:%d, t:%d, ret:%d");
d432 3
a434 2
      if ((gammabeta==GETORDERENTRY(ord,command)) ||
	  (gammacase==GETORDERENTRY(ord,command)))
d443 3
a445 2
        if ((gammabeta==GETORDERENTRY(ord,command)) ||
	    (gammacase==GETORDERENTRY(ord,command)))
d457 3
a459 2
	if ((gammabeta==GETORDERENTRY(ord,command)) ||
	    (gammacase==GETORDERENTRY(ord,command)))
d481 3
a483 2
	  if ((gammabeta==GETORDERENTRY(ord,command)) ||
	      (gammacase==GETORDERENTRY(ord,command)))
d495 3
a497 2
	  if ((Case==GETORDERENTRY(ord,command)) ||
	      (gammacase==GETORDERENTRY(ord,command)))
d507 3
a509 2
	  if ((gammabeta==GETORDERENTRY(ord,command)) ||
	      (gammacase==GETORDERENTRY(ord,command)))
d516 3
a518 2
	  if ((Case==GETORDERENTRY(old_ord,command)) ||
	      (gammacase==GETORDERENTRY(old_ord,command)))
d538 3
a540 2
	    if ((gammabeta==GETORDERENTRY(ord,command)) ||
		(gammacase==GETORDERENTRY(ord,command)))
d548 3
a550 2
	    if ((gammabeta==GETORDERENTRY(ord,command)) ||
		(gammacase==GETORDERENTRY(ord,command)))
d922 3
a924 1
	      if (gammabeta!=GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command))
d1080 3
a1082 2
	  if ((gammabeta!=GETORDERENTRY(ord,command)) &&
	      (gammacase!=GETORDERENTRY(ord,command)))
d1830 3
a1832 1
	      if (gammabeta!=GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command))
d2093 3
a2095 1
    if (gammabeta==GETORDERENTRY(GETSTELMDATA(dummy,ret)->ord,command))
@


1.47
log
@PM partly implemented
@
text
@d221 14
a234 4
		  a=st_make(w,GETDESCENTRY(des,nv)+1);
		  				/* build new frames; +1 for func */
		  st_pop(a);			/* remove func from stack */
		  w=NULL;
d239 1
a239 1
				GETDESCENTRY(des,label));
d405 1
a405 1
	default:
d407 5
a411 1
	  yyfail("%s","can't handle type of apply!");
d550 1
a550 1
    case mkap:
d553 1
a553 1
      for (i=0; i<ord->args.n;i++)
d589 1
d622 1
d1539 5
d1554 1
a1554 1
      DBUG_ORDERS("matcharb//-int//tguard\tw:%d, a:%d, r:%d, t:%d, ret:%d");
d1660 1
a1660 1
	      if ((tp_list!=GETSTELMTYPE(tow)) &&	/* definetly fail */
d1665 17
d1684 8
a1691 1
	      if ((tp_int!=GETSTELMTYPE(tow)) &&	/* definetly fail */
d1698 1
a1698 1
	      if ((tp_bool!=GETSTELMTYPE(tow)) &&	/* definetly fail */
a1895 2
      STELM *stelm;
      
d1897 1
a1897 8
      if (tp_list==GETSTELMTYPE(st_read(w,0)))
	{
	stelm=new_stelm(st_read(w,0)->listtype,NULL);
        stelm_cpy(st_read(w,1),stelm,1);
        stelm_free(stelm);
	}
      else
	stelm_cpy(st_read(w,1),&CONST_NONE,1);
d1910 2
d1913 8
a1920 2
      stelm_cpy(st_read(w,0),st_read(w,1),1);
      insert_restype(st_read(w,0),ord);
d1987 1
d1990 1
a1990 1
      DBUG_ORDERS("bind\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
a1994 7
    case mkcase:
      {
      DBUG_ORDERS("mkcase\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      w=st_push(w,&CONST_NONE);				/* debug version */
      ord=GETNEXTORDER(ord);
      break;
      }
a2029 1
    case binds:
d2031 15
a2045 5
    case matcharbs:
    case matchbool:
    case matchin:
    case matchprim:
    case matchstr:
@


1.46
log
@jcond changed, now using branch
@
text
@d18 1
a263 1
		  result=new_stelm(tp_none,NULL);
d266 1
a266 1
				  GETDESCENTRY(des,nfv),result,kn_sure);
d269 1
a269 1
		  w=st_push(w,result);			/* set result none */
a515 1
	    result=new_stelm(tp_none,NULL);
d519 1
a519 1
			      r,GETDESCENTRY(des,nfv),result,kn_sure);
d522 1
a522 1
			      t,GETDESCENTRY(des,nfv),result,kn_sure);
d529 1
a529 1
	    w=st_push(w,result);
a538 2
      STELM res={tp_none,tp_none,{NULL}};
      
d541 1
a541 1
      w=st_push(w,&res);
d730 3
a732 1
	  ret=st_push(ret,new_stelm(tp_returnadr,rt));/* returndata stored */
a747 1
	    res=new_stelm(tp_none,NULL);
d755 2
a756 2
		dep=insert_functype(des->label,dummy,des->nv,
			            freturn->dat.ret->t,des->nfv,res,kn_sure);
d758 2
a759 2
		dep=insert_functype(des->label,a,des->nv-1,
			            freturn->dat.ret->t,des->nfv/4,res,kn_sure);
d764 1
a764 1
			          freturn->dat.ret->t,des->nfv,res,
d766 1
a766 1
	    SETORDERENTRY(ord,types)=tp_none;
a781 1
	  stelm_free(res);
d804 1
a804 2
	      {
	      STELM stelm={tp_none,tp_none,{NULL}};/* jcond with no result */
d807 1
a807 1
	      w=st_push(w,&stelm);
d811 1
a811 1
	    case -3:
d1522 3
d1528 2
d1531 1
d1533 37
a1569 18
      DBUG_ORDERS("matcharb\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
      tow=st_read(w,0);			/* get pointer of top element of stack w */
      if (GETORDERENTRY(ord,typestouched)==0)
        {
        SETORDERENTRY(ord,types)=TYPES2LONG(GETSTELMTYPE(tow),tp_none,
					    tp_none,tp_none); /* internal types */
        SETORDERENTRY(ord,typestouched)=1;
        }
      else
        if (GETSTELMTYPE(tow)!=GETTYPE(0,GETORDERENTRY(ord,types)))
	  SETORDERENTRY(ord,types)=GETORDERENTRY(ord,types) & SETTYPE(0,tp_none);
      if (((tp_clos==GETSTELMTYPE(tow)) || (tp_var==GETSTELMTYPE(tow))) ||
	  (tp_none==GETSTELMTYPE(tow)))		/* undecided possible */
	{
	freturn=getfunc_ret(ret);
	des=find_desc(GETFIRSTDESC(program_start),freturn->dat.ret->ord->args.label);
	res=new_stelm(tp_none,NULL);
        if (apply==freturn->dat.ret->ord->command)
d1571 36
a1606 1
	  STACK *dummy;
d1608 118
a1725 9
	  dummy=st_make(freturn->dat.ret->w,des->nv+1);
	  st_pop(dummy);
	  if ((DT_COMBINATOR==des->tag) || (DT_CASE==des->tag))
	    insert_functype(des->label,dummy,des->nv,
			        freturn->dat.ret->t,des->nfv,res,kn_sure);
	  else
	    insert_functype(des->label,a,des->nv-1,
			        freturn->dat.ret->t,des->nfv/4,res,kn_sure);
	  st_free(dummy);
a1726 7
	else
	  insert_functype(des->label,freturn->dat.ret->w,des->nv,
			  freturn->dat.ret->t,des->nfv,res,kn_sure);
	}
      if ((tp_clos!=GETSTELMTYPE(tow)) && (tp_var!=GETSTELMTYPE(tow)))
	{					/* NOT undecided */
	
d1728 1
a1728 1
      else					/* undecided */
d1730 78
a1807 1
	
a1808 1
      ord=GETNEXTORDER(ord);	
d1816 2
a1817 2
      for (i=0;i<ord->args.n;i++)
	a=st_push(a,new_stelm(tp_none,NULL));
d1826 2
a1827 2
      for (i=0;i<ord->args.n;i++)
	r=st_push(r,new_stelm(tp_none,NULL));
d1836 3
a1838 3
      for (i=0;i<ord->args.n;i++)
	w=st_push(w,new_stelm(tp_none,NULL));
      w=st_push(w,st_read(w,ord->args.n));
d1842 7
a1848 1
    case mkcase:
d1850 30
d1881 21
a1901 1
    case restorebt:
d1903 23
d1927 51
a1977 1
    case rmwframe:
d1979 13
a1991 7
    case saveptr:
    case startsubl:
    case tguard:
    case advance:
    case atend:
    case atstart:
    case bind:
a1992 5
    case bindsubl:
    case dereference:
    case drop:
    case endlist:
    case endsubl:
a1993 1
    case initbt:
a1996 2
    case matchint:
    case matchlist:
@


1.45
log
@minor bug in gammabeta removed
@
text
@d15 3
a17 2
ORDER CONST_RTF	={rtf,{NULL},NULL,NULL,NULL,0,0},
      CONST_CCLOS={mkcclos,{0,0,0,0,0,0.0,"","",NULL,NULL,NULL,0},NULL,NULL,NULL,0,0};
d41 1
a41 1
      d_stelm.dat.desclist=NULL;
d50 1
a50 1
      d_stelm.dat.desclist=NULL;
d155 1
a155 1
	  des=GETSTELMDATA(func,desclist)->desc;
d252 2
a253 1
		  SETORDERARGS(old_ord,k)=-GETORDERARGS(old_ord,k); /* then-case without result */
d279 3
a281 3
	    if (NULL==(clos->desclist=malloc(sizeof(DESCLIST))))
	      yyfail("%s","no memory for descriptorlist!");
	    clos->desclist->desc=des;			/* set closure data */
d283 2
a284 2
	    clos->j=GETDESCENTRY(clos->desclist->desc,nv);
	    clos->k=GETDESCENTRY(clos->desclist->desc,nfv);
a323 1
	  DESCLIST *ld;
d330 1
a330 4
	  if (clos->desclist!=NULL)
	    des=clos->desclist->desc;
	  else
	    des=NULL;
d361 1
a361 6
	      if (NULL==(ld=malloc(sizeof(DESCLIST))))
		yyfail("%s","no memory for descriptorlist");
	      dummy.dat.desclist=ld;
	      dummy.dat.desclist->desc=des;
	      dummy.dat.desclist->next=NULL;
	      free(ld);
d505 1
a505 1
	    SETORDERARGS(old_ord,k)=-GETORDERARGS(old_ord,k); 
d537 11
d557 1
a557 1
      clos->desclist=NULL;					/* remember primfunc */
d573 1
a574 1
      stelm_free(prim);
d620 1
a620 1
      clos->desclist=GETSTELMDATA(func,desclist);
d681 1
a681 1
	if (3==GETORDERARGS(ord,k))		/* jcond finished */
d683 1
a683 1
	  SETORDERARGS(ord,k)=0;
d700 1
a700 1
	       des=GETSTELMDATA(res,desclist)->desc;
d752 11
a762 1
	      yyfail("%s","conditional without boolean value not yet implemented");
a771 1
	    
d785 1
a785 1
	  switch (GETORDERARGS(ord,k))
d790 1
a790 1
	      SETORDERARGS(ord,k)=GETORDERARGS(ord,k) | 1;
d796 1
a796 1
	      SETORDERARGS(ord,k)=3;
d802 1
a802 1
	      SETORDERARGS(ord,k)=2;
d810 1
a810 1
	      SETORDERARGS(ord,k)=0;			/* jcond finished */
d825 1
a825 1
	if (((3==GETORDERARGS(ord,k)) || (2==GETORDERARGS(ord,k))) && 
d838 1
a838 1
	    SETORDERARGS(GETSTELMDATA(label,ret)->ord,k)=0;
d857 1
a857 1
	    SETORDERARGS(old_ord,k)=-GETORDERARGS(old_ord,k);
d868 1
a868 1
		SETORDERARGS(GETSTELMDATA(res,ret)->ord,k)=0;
d889 1
a889 1
          SETORDERARGS(old_ord,k)=-GETORDERARGS(old_ord,k);
d913 1
a913 1
	      SETORDERARGS(GETSTELMDATA(res,ret)->ord,k)=0;
d992 1
a992 1
	des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desclist)->desc;
d1056 11
a1066 2
	  r=freturn->dat.ret->r;
	  t=freturn->dat.ret->t;
d1127 1
a1127 1
	des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desclist)->desc;
d1252 1
a1252 1
	des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desclist)->desc;
d1377 1
a1377 1
	des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desclist)->desc;
d1501 1
a1501 1
	  if (3==GETORDERARGS(GETSTELMDATA(d,ret)->ord,k))
d1528 2
a1529 1
      STELM *tow;
d1542 33
a1574 1
      
@


1.44
log
@minor bug in mkcclos and jcond removed
@
text
@d449 7
a455 2
	  for (i=0; i<GETDESCENTRY(des,nfv); i++)
	    stelm_free(st_pop(r));	  
d738 2
a739 2
	  res=st_pop(w);				/* get hopefully tp_bool */
	  if (tp_bool!=GETSTELMTYPE(res))
d843 1
a843 1
	    ret->topofstack++;
@


1.43
log
@lists bugfixed, implementation of PM started
@
text
@d665 2
d735 16
a750 1
	    yyfail("%s","conditional without boolean value not yet implemented");
d752 16
d769 29
a797 2
	    SETORDERENTRY(ord,types)=tp_bool;
	    switch (GETORDERARGS(ord,k))
d799 2
a800 33
	      case 0:
	      case 2:
		{
		SETORDERARGS(ord,k)=GETORDERARGS(ord,k) | 1;
		ord=GETNEXTORDER(ord);
		break;
	        }
	      case 1:
	     	{
		SETORDERARGS(ord,k)=3;
		ord=find_label(GETNEXTORDER(ord),GETORDERARGS(ord,label));
		break;
		}
	      case -1:
		{
		SETORDERARGS(ord,k)=2;
		ord=find_label(GETNEXTORDER(ord),GETORDERARGS(ord,label));
		break;
		}
	      case -2:
		{
		STELM stelm={tp_none,tp_none,{NULL}};/* jcond with no result */
		
		SETORDERARGS(ord,k)=0;			/* jcond finished */
		w=st_push(w,&stelm);
		ord=&CONST_RTF;				/* goto rtf */
		break;
		}
	      case -3:
		{
		yyfail("%s","illegal jcond construction!");
		break;
		}
@


1.42
log
@lists on their way
@
text
@d414 2
d422 1
a422 1
      DBUG_ORDERS("[gamma]beta\\tail\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
d424 2
a425 1
      if (gammabeta==GETORDERENTRY(ord,command))
d434 2
a435 1
        if (gammabeta==GETORDERENTRY(ord,command))
d447 2
a448 1
	if (gammabeta==GETORDERENTRY(ord,command))
d465 2
a466 1
	  if (gammabeta==GETORDERENTRY(ord,command))
d478 13
a490 3
	  a=st_make(w,GETDESCENTRY(des,nv));		/* build new frames */
	  w=NULL;
	  if (gammabeta==GETORDERENTRY(ord,command))
d495 1
d497 5
a501 1
	  insert_args(a,GETDESCENTRY(des,nv),t,GETDESCENTRY(des,nfv),ord);
d507 2
a508 1
	    SETORDERARGS(old_ord,k)=-GETORDERARGS(old_ord,k); /* then-case without result */
d519 2
a520 1
	    if (gammabeta==GETORDERENTRY(ord,command))
d528 2
a529 1
	    if (gammabeta==GETORDERENTRY(ord,command))
d572 1
a572 1
      TP_TYPES tp=tp_empty,ttp=tp_empty;
a573 1
      STELMLIST *sl=NULL,*dsl;
d579 4
a582 122
	switch (GETSTELMTYPE(stelm))
	  {
	  case tp_none:
	  case tp_int:
	  case tp_real:
	  case tp_digit:
	  case tp_bool:
	  case tp_string:
	  case tp_empty:
            {
	    if ((tp_empty!=tp) && (tp!=GETSTELMTYPE(stelm)))
	      {
	      tp=tp_none;
	      ttp=tp_none;
	      while (NULL!=sl)
		{
		dsl=sl;
		sl=sl->next;
		free(dsl);
		}
	      }
            else
	      {
              tp=GETSTELMTYPE(stelm);
	      ttp=GETSTELMTYPE(stelm);
	      }
	    break;
	    }
          case tp_list:
	    {
	    if ((tp_empty!=tp) && (tp!=GETSTELMTYPE(stelm)))
	      {
	      tp=tp_none;
	      ttp=tp_none;
	      while (NULL!=sl)
		{
		dsl=sl;
		sl=sl->next;
		free(dsl);
		}
	      }
	    else
	      {
	      tp=tp_list;
	      ttp=tp_list;
	      dsl=sl;
	      if (NULL==(sl=malloc(sizeof(STELMLIST))))
		yyfail("%s","no memory for listelements");
	      sl->next=dsl;
	      if (NULL==(sl->stelm=malloc(sizeof(STELM))))
		yyfail("%s","no memory for listelement");
	      stelm_cpy(sl->stelm,stelm,1);	
	      }
	    break;
	    }
	  case tp_prim:
	    {
	    if ((tp_empty!=tp) && (tp!=GETSTELMTYPE(stelm)))
	      {
	      tp=tp_none;
	      ttp=tp_none;
	      while (NULL!=sl)
		{
		dsl=sl;
		sl=sl->next;
		free(dsl);
		}		
	      }
	    else
	      {
	      tp=tp_prim;
	      ttp=tp_prim;
	      dsl=sl;
	      if (NULL==(sl=malloc(sizeof(PRIMLIST))))
		yyfail("%s","no memory for listelements");
	      sl->next=dsl;
	      sl->stelm=(STELM *)GETSTELMDATA(stelm,prim);
	      }
	    break;
	    }
	  case tp_clos:
	  case tp_func:
	    {
	    if (((tp_empty!=tp) && (tp!=tp_func)) && (tp!=tp_clos))
	      {
	      tp=tp_none;
	      ttp=tp_none;
	      while (NULL!=sl)
		{
		dsl=sl;
		sl=sl->next;
		free(dsl);
		}
	      }
            else
              {
	      if ((tp_empty!=tp) && (tp!=GETSTELMTYPE(stelm)))
		{
		tp=tp_func;
		ttp=tp_none;
		}
	      else
		{
		tp=GETSTELMTYPE(stelm);
		ttp=GETSTELMTYPE(stelm);
		dsl=sl;
		if (NULL==(sl=malloc(sizeof(STELMLIST))))
		  yyfail("%s","no memory for listelements");
		sl->next=dsl;
		if (NULL==(sl->stelm=malloc(sizeof(STELM))))
		  yyfail("%s","no memory for listelements");
		stelm_cpy(sl->stelm,stelm,1);
		}
	      }
	    break;
	    }
	  default:
	    {
	    yyfail("%s","unknown listelement for mklist");
	    break;
	    }
	  }
d585 1
a585 10
      if (tp_list==ttp)
	{
        if (NULL==(stelm=malloc(sizeof(STELM))))
	  yyfail("%s","no memory for listelememnts!");
	SETSTELMTYPE(stelm)=tp_list;
	SETSTELMLIST(stelm)=tp_list;
	SETSTELMDATA(stelm,stelmlist)=sl;
	}
      else
        stelm=new_stelm(tp_list,new_stelm(ttp,sl));
d641 1
d643 1
a643 1
      DBUG_ORDERS("delta2\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
d1470 60
a1535 1
    case Case:
a1540 1
    case gammacase:
a1541 1
    case matcharb:
a1548 14
    case mkaframe:
    case mkbtframe:
    case mkcase:
    case mkwframe:
    case nestlist:
    case pick:
    case restorebt:
    case restoreptr:
    case rmbtframe:
    case rmwframe:
    case savebt:
    case saveptr:
    case startsubl:
    case tguard:
@


1.41
log
@*** empty log message ***
@
text
@d586 1
a586 1
	    if ((tp_empty!=tp) && (tp!=tp_list))
d612 24
d639 1
a639 1
	    if (((tp_empty!=tp) && (tp!=tp_func)) && ((tp!=tp_prim) && (tp!=tp_clos)))
d680 10
a689 2
      stelm=new_stelm(tp_list,new_stelm(tp_func,sl));
      stelm->listtype=ttp;
@


1.40
log
@compare on lists and closures implemented
@
text
@d641 2
d656 1
a656 1
      stelm=new_stelm(tp_list,sl);
@


1.39
log
@dependencies added to apply
@
text
@d1539 36
@


1.38
log
@problems with depending recursiv functions removed
@
text
@d172 4
a175 1
	      set_depend(des,w,t,old_func);
d719 1
a719 1
      DBUG_ORDERS("jump(%s)\t\tw:%d, a:%d, r:%d, t:%d, ret:%d");
@


1.37
log
@function dependency tree build
@
text
@d16 1
a16 1
      CONST_CCLOS={mkcclos,{0,0,0,0,"","",NULL,NULL,0},NULL,NULL,NULL,0,0};
d18 1
d169 1
a169 1
	    if (NULL!=ret)
d174 2
a175 1
	    if ((NULL!=result)&& (tp_illegal!=result->type)) /* old result stored */
d200 1
d425 1
a425 1
      if (NULL!=ret)
d433 2
a434 1
      if ((NULL!=result) && (tp_illegal!=result->type))	/* old result stored */
d448 1
a798 1
	    {
a799 1
	    }
d828 1
a828 1
		SETORDERARGS(ord,k)=3;			/* jcond finished */
d857 1
d905 4
a908 1
	  SETORDERARGS(old_ord,k)=-GETORDERARGS(old_ord,k);
d916 14
a929 1
	      func_dump=st_push(func_dump,res);
d944 9
a952 1
	  ord=GETSTELMDATA(res,ret)->ord;
d992 1
d1017 15
a1031 3
          insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv),
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
			  &res,kn);
d1040 15
a1054 3
          insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv)-1,
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
			  &res,kn);	  
d1065 15
a1079 3
	insert_functype(GETDESCENTRY(des,label),GETSTELMDATA(freturn,ret)->w,
			GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			GETDESCENTRY(des,nfv),&res,kn);
d1118 1
d1143 15
a1157 3
          insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv),
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
			  res,kn);
d1166 15
a1180 3
          insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv)-1,
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
			  res,kn);	  
d1191 15
a1205 3
	insert_functype(GETDESCENTRY(des,label),GETSTELMDATA(freturn,ret)->w,
			GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			GETDESCENTRY(des,nfv),res,kn);
d1244 1
d1268 15
a1282 3
          insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv),
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
			  &res,kn);
d1291 15
a1305 3
          insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv)-1,
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
			  &res,kn);	  
d1316 16
a1331 4
	insert_functype(GETDESCENTRY(des,label),GETSTELMDATA(freturn,ret)->w,
			GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			GETDESCENTRY(des,nfv),&res,kn);
        stelm_cpy(&res,get_result(GETDESCENTRY(des,label),
d1369 1
d1393 15
a1407 3
          insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv),
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),
			  &res,kn);
d1416 15
a1430 3
          insert_functype(GETDESCENTRY(des,label),dummy,GETDESCENTRY(des,nv)-1,
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,
			  &res,kn);	  
d1441 16
a1456 4
	insert_functype(GETDESCENTRY(des,label),GETSTELMDATA(freturn,ret)->w,
			GETDESCENTRY(des,nv),GETSTELMDATA(freturn,ret)->t,
			GETDESCENTRY(des,nfv),&res,kn);
        stelm_cpy(&res,get_result(GETDESCENTRY(des,label),
@


1.36
log
@hashstring removed
@
text
@d17 1
d148 1
a148 1
	  STELM *result;
d168 1
a168 1
	    if (NULL!=result)				/* old result stored */
d170 5
d409 1
a409 1
      STELM *result;
d414 1
a414 1
      DBUG_ORDERS("[gamma]beta\\tail\tw:%d, a:%d, r:%d, t:%d, ret:%d");
d416 15
a430 3
      result=get_result(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			t,GETDESCENTRY(des,nfv));
      if (NULL!=result)				/* old result stored */
d438 1
a438 2
	    stelm_free(st_pop(r));
	  
@


1.35
log
@lists have changed, primitiv apply bugfixed
@
text
@d203 2
a204 1
		ret=st_push(ret,new_stelm(tp_returnadr,rt)); /* returndata stored */
d207 2
a208 1
		  a=st_make(w,GETDESCENTRY(des,nv)+1);	/* build new frames; +1 for func */
d445 2
a446 1
	  ret=st_push(ret,new_stelm(tp_returnadr,rt)); /* returndata stored */
d766 1
a766 1
	  ret=st_push(ret,new_stelm(tp_returnadr,rt)); /* returndata stored */
d806 1
a806 1
		STELM stelm={tp_none,tp_none,{NULL}};	/* jcond with no result */
@


1.34
log
@bug fix
@
text
@d250 1
a250 1
				  GETDESCENTRY(des,nfv),result);
d471 1
a471 1
			      r,GETDESCENTRY(des,nfv),result);
d474 1
a474 1
			      t,GETDESCENTRY(des,nfv),result);
d577 2
d943 1
d952 4
d969 2
a970 1
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),&res);
d980 2
a981 1
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,&res);	  
d994 1
a994 1
			GETDESCENTRY(des,nfv),&res);
d1032 2
a1033 1

d1041 4
d1058 5
a1062 1
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),res);
d1069 5
a1073 1
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,res);	  
d1083 5
a1087 2
			GETDESCENTRY(des,nfv),res);
        }
d1121 2
a1122 1

d1129 4
d1146 5
a1150 1
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),&res);
d1157 5
a1161 1
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,&res);	  
d1171 5
a1175 2
			GETDESCENTRY(des,nfv),&res);
        }
d1209 2
a1210 1

d1217 4
d1234 5
a1238 1
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv),&res);
d1245 5
a1249 1
		          GETSTELMDATA(freturn,ret)->t,GETDESCENTRY(des,nfv)/4,&res);	  
d1259 5
a1263 2
			GETDESCENTRY(des,nfv),&res);
        }
@


1.33
log
@lists have been changed, hash -> hashargs ...
@
text
@d1277 1
a1277 1
    case hashrestypes:
@


1.32
log
@*** empty log message ***
@
text
@d520 1
a520 1
      TP_TYPES tp=tp_empty;
d522 1
d537 19
d557 24
d585 29
a621 4
	if ((tp_empty!=tp) && (tp!=GETSTELMTYPE(stelm)))
	  tp=tp_none;
        else
          tp=GETSTELMTYPE(stelm);
d624 2
a625 1
      stelm=new_stelm(tp_list,new_stelm(tp,NULL));
d801 1
a801 1
		STELM stelm={tp_none,{NULL}};		/* jcond with no result */
d1094 1
a1094 1
      STELM res={tp_int,{NULL}},*freturn;
d1166 1
a1166 1
      STELM res={tp_bool,{NULL}},*freturn;
d1275 3
a1277 1
    case hash:
@


1.31
log
@some types modified
@
text
@d36 1
a36 6
      DBUG_PRINT("ORDERS",("pushcw_i\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d45 1
a45 6
      DBUG_PRINT("ORDERS",("pushcw_b\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d54 1
a54 6
      DBUG_PRINT("ORDERS",("pushcw_pf\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d63 1
a63 6
      DBUG_PRINT("ORDERS",("pushaw\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d70 1
a70 6
      DBUG_PRINT("ORDERS",("pushtw\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d77 1
a77 6
      DBUG_PRINT("ORDERS",("pushtr\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d85 1
a85 6
      DBUG_PRINT("ORDERS",("pushar\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d94 1
a94 6
      DBUG_PRINT("ORDERS",("pushr_p\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d105 1
a105 6
      DBUG_PRINT("ORDERS",("pushw_p\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d116 1
a116 6
      DBUG_PRINT("ORDERS",("moveaw\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d127 1
a127 6
      DBUG_PRINT("ORDERS",("movear\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d140 1
a140 6
      DBUG_PRINT("ORDERS",("apply\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
a397 75
      {
      STELM *result;
      FUNDESC *des;
      ORDER *old_ord;
      RETURNADR *rt;
      
      DBUG_PRINT("ORDERS",("gammabeta(%s)\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   GETORDERARGS(ord,label),
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
      des=find_desc(GETFIRSTDESC(program_start),GETORDERARGS(ord,label));
      result=get_result(GETDESCENTRY(des,label),w,
			GETDESCENTRY(des,nv),r,GETDESCENTRY(des,nfv));
      if (NULL!=result)					/* old result stored */
	{
	insert_restype(result,ord);
	GETORDERARGS(ord,k)=-1;				/* order executed */
	for (i=0; i<GETDESCENTRY(des,nv); i++)
	  stelm_free(st_pop(w));
	for (i=0; i<GETDESCENTRY(des,nfv); i++)
	  stelm_free(st_pop(r));
	w=st_push(w,result);
	ord=GETNEXTORDER(ord);
        }
      else					/* result unknown until now */
	{
	old_ord=search_ret(ord,ret);
	if (NULL==old_ord)			/* first call from here */
	  {
	  if (NULL==(rt=malloc(sizeof(RETURNADR))))
	    yyfail("%s","no memory for returnadress!");
	  rt->ord=ord;				/* remember enviroment of func */
	  rt->w=w;
	  rt->a=a;
	  rt->t=r;
	  rt->r=t;
	  ret=st_push(ret,new_stelm(tp_returnadr,rt)); /* returndata stored */
	  a=st_make(w,GETDESCENTRY(des,nv));	/* build new frames */
	  w=NULL;
	  t=st_make(r,GETDESCENTRY(des,nfv));
	  r=NULL;
	  ord=find_func(GETFIRSTFUNCTION(program_start),GETDESCENTRY(des,label));
	  insert_args(a,GETDESCENTRY(des,nv),t,GETDESCENTRY(des,nfv),ord);
	  }
	else					/* was here before */
	  {
	  if (old_ord!=ord)			/* old_ord must be jcond */
	    {
	    SETORDERARGS(old_ord,k)=-SETORDERARGS(old_ord,k); /* then-case without result */
	    result=restore_ret(old_ord,ret);	/* restors state of old_ord */
	    w=GETSTELMDATA(result,ret)->w;		/* restore stacks */
	    a=GETSTELMDATA(result,ret)->a;
	    t=GETSTELMDATA(result,ret)->t;
	    r=GETSTELMDATA(result,ret)->r;
	    ord=GETSTELMDATA(result,ret)->ord;	/* set continuation */
	    }
	  else					/* bad recursion */
	    {
	    result=new_stelm(tp_none,NULL);	/* set result to none */
	    insert_functype(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			    r,GETDESCENTRY(des,nfv),result);
	    for (i=0; i<GETDESCENTRY(des,nv); i++)		/* remove argumentframe */
	      stelm_free(st_pop(w));
	    for (i=0; i<GETDESCENTRY(des,nfv); i++)		/* remove tildeframe */
	      stelm_free(st_pop(r));
	    w=st_push(w,result);		/* store result */
	    ord=GETNEXTORDER(ord);
	    }
	  }
	}      
      break;
      }
d406 1
a406 7
      DBUG_PRINT("ORDERS",("beta\\tail(%s)\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   ord->args.label,
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d416 4
d433 10
a442 2
	  rt->t=t;
	  rt->r=r;
d446 4
a449 1
	  t=st_make(t,GETDESCENTRY(des,nfv));
d469 6
a474 2
	    insert_functype(GETDESCENTRY(des,label),w,GETDESCENTRY(des,nv),
			    t,GETDESCENTRY(des,nfv),result);
d477 3
d492 1
a492 6
      DBUG_PRINT("ORDERS",("mkdclos\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d523 1
a523 6
      DBUG_PRINT("ORDERS",("mklist\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
                           (NULL==w) ? NULL : GETTOPOFSTACK(w),
                           (NULL==a) ? NULL : GETTOPOFSTACK(a),
                           (NULL==r) ? NULL : GETTOPOFSTACK(r),
                           (NULL==t) ? NULL : GETTOPOFSTACK(t),
                           (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d527 22
d577 1
a577 6
      DBUG_PRINT("ORDERS",("mkgaclos\\mkcclos\\mkbclos\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
a599 2
/*	for (i=0; i<clos->k; i++)
	  stelm_free(st_pop(t)); */
d612 1
a612 6
      DBUG_PRINT("ORDERS",("delta2\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d619 1
a619 7
      DBUG_PRINT("ORDERS",("jump(%s)\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   ord->args.label,
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d635 1
a635 6
      DBUG_PRINT("ORDERS",("jfalse\\jcond\\jcond2\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d700 1
a700 1
	  res=st_pop(w);
d703 1
a703 1
	    /* Grosses Problem !!! */
d707 1
d840 1
a840 6
      DBUG_PRINT("ORDERS",("freea\t\t\tw:%d, a:%d, r:%d. t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d850 1
a850 6
      DBUG_PRINT("ORDERS",("freeswt\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d872 1
a872 6
      DBUG_PRINT("ORDERS",("rtf\\rtm\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d954 1
a954 7
      DBUG_PRINT("ORDERS",("rtp\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
            
d1027 1
a1027 6
      DBUG_PRINT("ORDERS",("rtc_i\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d1099 1
a1099 6
      DBUG_PRINT("ORDERS",("rtc_i\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d1170 1
a1170 6
      DBUG_PRINT("ORDERS",("ext\t\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
d1209 1
a1209 6
      DBUG_PRINT("ORDERS",("end\tw:%d, a:%d, r:%d, t:%d, ret:%d",
			   (NULL==w) ? NULL : GETTOPOFSTACK(w),
			   (NULL==a) ? NULL : GETTOPOFSTACK(a),
			   (NULL==r) ? NULL : GETTOPOFSTACK(r),
			   (NULL==t) ? NULL : GETTOPOFSTACK(t),
			   (NULL==ret) ? NULL : GETTOPOFSTACK(ret)));
@


1.30
log
@list and descriptor concept changed
@
text
@d647 6
d656 1
a656 3
	if ((tp_empty==tp) || (tp==GETSTELMTYPE(stelm)))
	  tp=GETSTELMTYPE(stelm);
	else
d658 2
d712 2
a713 2
	for (i=0; i<clos->k; i++)
	  stelm_free(st_pop(t));
d723 1
d1088 79
@


1.29
log
@first try with lists
@
text
@d43 1
a43 1
      d_stelm.dat.desc=NULL;
d57 1
a57 1
      d_stelm.dat.desc=NULL;
d212 1
a212 1
	  des=GETSTELMDATA(func,desc);
d323 3
a325 1
	    clos->desc=des;				/* set closure data */
d327 2
a328 2
	    clos->j=GETDESCENTRY(clos->desc,nv);
	    clos->k=GETDESCENTRY(clos->desc,nfv);
d368 1
d375 4
a378 1
	  des=clos->desc;
d384 2
a385 1
	  if (DT_CONDITIONAL==GETDESCENTRY(des,tag)) /* if CONDI unfold to A STACK */
d409 6
a414 1
	      dummy.dat.desc=des;
d421 1
a421 1
	    if (DT_CONDITIONAL==GETDESCENTRY(des,tag))
d620 1
a620 1
      clos->desc=NULL;					/* remember primfunc */
d656 1
a656 1
      stelm=new_stelm((tp | tp_list),NULL);
d687 1
a687 1
      clos->desc=GETSTELMDATA(func,desc);
d781 1
a781 1
	       des=GETSTELMDATA(res,desc);
d875 1
d886 42
a927 10
	  ret=findfcall(label,ret);		/* searches for functioncall */
	  st_free(w);
	  w=GETSTELMDATA(label,ret)->w;
	  st_free(a);
	  a=GETSTELMDATA(label,ret)->a;
	  st_free(r);
	  r=GETSTELMDATA(label,ret)->r;
	  st_free(t);
	  t=GETSTELMDATA(label,ret)->t;
	  ord=GETSTELMDATA(label,ret)->ord;
d1022 1
a1022 1
	des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desc);
d1108 1
a1108 1
	des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desc);
d1185 1
a1185 1
	des=GETSTELMDATA((st_read(GETSTELMDATA(freturn,ret)->w,0)),desc);
@


1.28
log
@tiny bug in mkcclos removed
@
text
@d217 2
d629 20
d752 1
d848 1
a848 1
	      case -3:				/* should not be possible */
d850 2
a851 1
		yyfail("%s","unpredictable if then else!");
d859 2
a860 6
	SETORDERARGS(old_ord,k)=-GETORDERARGS(old_ord,k);
        st_free(w);
	st_free(a);
	st_free(r);
	st_free(t);
	while (old_ord!=(GETSTELMDATA((res=st_pop(ret)),ret)->ord))
d862 30
a891 3
	  if BETAFUNCS(GETORDERENTRY(GETSTELMDATA(res,ret)->ord,command))
	    func_dump=st_push(func_dump,res);
	  else
d893 11
a903 4
	    st_free(GETSTELMDATA(res,ret)->w);
	    st_free(GETSTELMDATA(res,ret)->a);
            st_free(GETSTELMDATA(res,ret)->r);
            st_free(GETSTELMDATA(res,ret)->t);
d905 6
a910 1
          stelm_free(res);
a911 6
	w=GETSTELMDATA(res,ret)->w;
	a=GETSTELMDATA(res,ret)->a;
	r=GETSTELMDATA(res,ret)->r;
	t=GETSTELMDATA(res,ret)->t;
	ord=GETSTELMDATA(res,ret)->ord;
	stelm_free(res);
d985 3
d995 3
d1008 4
a1011 1
        }
@


1.27
log
@mkcclos inserted for wrong handled jcond pointer
@
text
@d154 1
a154 11
      if (((tp_func==GETSTELMTYPE(arg)) && 
	   (DT_CONDITIONAL==GETDESCENTRY(GETSTELMDATA(arg,desc),tag))) && 
	  (0<GETDESCENTRY(GETSTELMDATA(arg,desc),nfv)))
	{
	CONST_CCLOS.args.m=GETDESCENTRY(GETSTELMDATA(arg,desc),nv);
	CONST_CCLOS.args.k=GETDESCENTRY(GETSTELMDATA(arg,desc),nfv);
	CONST_CCLOS.next=GETNEXTORDER(ord);
	ord=&CONST_CCLOS;
	}
      else
        ord=GETNEXTORDER(ord);
d656 1
a656 4
      if (DT_CONDITIONAL==clos->desc->tag)
	clos->k=GETORDERARGS(ord,k/4);
      else
	clos->k=GETORDERARGS(ord,k);
d710 3
@


1.26
log
@new macros inserted
@
text
@d15 2
a16 1
ORDER CONST_RTF={rtf,{NULL},NULL,NULL,NULL,0,0};
d154 11
a164 1
      ord=GETNEXTORDER(ord);
d666 4
a669 1
      clos->k=GETORDERARGS(ord,k);
@


1.25
log
@mkclos bug removed
@
text
@d36 5
a40 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d50 5
a54 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d64 5
a68 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d78 5
a82 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d90 5
a94 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d102 5
a106 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d115 5
a119 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d129 6
a134 6
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
      arg=find_address(GETORDERARGS(ord,desc));
d145 5
a149 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d161 5
a165 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d177 5
a181 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d195 5
a199 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d201 1
a201 1
      switch (func->type)				
d211 1
a211 1
	  des=func->dat.desc;
d216 1
a216 1
	  if (des->nv<=arity)				/* execution possible */
d296 5
a300 5
		  w=result->dat.ret->w;			/* restore stacks */
		  a=result->dat.ret->a;
		  t=result->dat.ret->t;
		  r=result->dat.ret->r;
		  ord=result->dat.ret->ord;
d328 1
a328 1
	      stelm_cpy(clos->w,&(w->stack[w->topofstack-clos->i]),clos->i);
d338 1
a338 1
	      stelm_cpy(clos->t,&(t->stack[t->topofstack-clos->k]),clos->k);
d355 1
a355 1
	  exe_prim(ord,w,func->dat.prim);		/* execute primfunction */
d368 1
a368 1
	  clos=func->dat.clos;				/* get closure data */
d451 5
a455 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d487 1
a487 1
	  ord=find_func(GETFIRSTFUNCTION(program_start),des->label);
d496 5
a500 5
	    w=result->dat.ret->w;		/* restore stacks */
	    a=result->dat.ret->a;
	    t=result->dat.ret->t;
	    r=result->dat.ret->r;
	    ord=result->dat.ret->ord;		/* set continuation */
d528 5
a532 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d571 5
a575 5
	    w=result->dat.ret->w;		/* restore stacks */
	    a=result->dat.ret->a;
	    t=result->dat.ret->t;
	    r=result->dat.ret->r;
	    ord=result->dat.ret->ord;		/* set continuation */
d597 5
a601 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d606 1
a606 1
      clos->k=prim->dat.prim;
d629 1
a629 1
      
d633 3
a635 1
      w=st_push(w,st_pop(t));			/* move function to W STACK */
d644 5
a648 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d652 1
a652 1
      clos->desc=func->dat.desc;
d685 6
a690 6
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
      exe_prim(ord,w,ord->args.primf);
d698 5
a702 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d716 5
a720 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d731 5
a735 5
          w=res->dat.ret->w;			/* restore stacks */
          a=res->dat.ret->a;
          t=res->dat.ret->t;
          r=res->dat.ret->r;
          ord=res->dat.ret->ord;
d742 1
a742 1
	       des=res->dat.desc;
d777 1
a777 1
	    w=st_make(w,w->topofstack);
d779 1
a779 1
	    a=st_make(a,a->topofstack);
d781 1
a781 1
	    t=st_make(t,t->topofstack);
d783 1
a783 1
	    r=st_make(r,r->topofstack);
d785 1
a785 1
	  if (tp_bool!=res->type)
d836 1
a836 1
	while (old_ord!=((res=st_pop(ret))->dat.ret->ord))
d838 1
a838 1
	  if BETAFUNCS(GETORDERENTRY(res->dat.ret->ord,command))
d842 4
a845 4
	    st_free(res->dat.ret->w);
	    st_free(res->dat.ret->a);
            st_free(res->dat.ret->r);
            st_free(res->dat.ret->t);
d849 5
a853 5
	w=res->dat.ret->w;
	a=res->dat.ret->a;
	r=res->dat.ret->r;
	t=res->dat.ret->t;
	ord=res->dat.ret->ord;
d861 5
a865 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d876 5
a880 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d891 5
a895 1
      w=st_push(w,st_pop(a));				/* moveaw */
d903 5
a907 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d916 1
a916 1
      if (apply==GETORDERENTRY(freturn->dat.ret->ord,command))
d920 1
a920 1
	des=(st_read(freturn->dat.ret->w,0))->dat.desc;
d923 2
a924 1
	  dummy=st_make(freturn->dat.ret->w,GETDESCENTRY(des,nv)+1); /* get copy of stack */
d927 1
a927 1
		          freturn->dat.ret->t,GETDESCENTRY(des,nfv),&res);
d931 2
a932 1
	  dummy=st_make(freturn->dat.ret->a,GETDESCENTRY(des,nv)-1); /* get copy of stack */
d934 1
a934 1
		          freturn->dat.ret->t,GETDESCENTRY(des,nfv)/4,&res);	  
d941 3
a943 3
		      GETORDERARGS(freturn->dat.ret->ord,label));
	insert_functype(GETDESCENTRY(des,label),freturn->dat.ret->w,
			GETDESCENTRY(des,nv),freturn->dat.ret->t,
d946 3
a948 3
      if (0==GETORDERARGS(freturn->dat.ret->ord,m))
	insert_restype(&res,freturn->dat.ret->ord);
      SETORDERARGS(freturn->dat.ret->ord,k)=-1;	/* order executed */
d950 5
a954 5
      ord=freturn->dat.ret->ord;
      w=freturn->dat.ret->w;			/* restore stacks */
      a=freturn->dat.ret->a;
      t=freturn->dat.ret->t;
      r=freturn->dat.ret->r;
d956 1
a956 1
      if BETAFUNCS(ord->command)
d981 5
a985 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d993 1
a993 1
      if (apply==GETORDERENTRY(freturn->dat.ret->ord,command))
d997 1
a997 1
	des=(st_read(freturn->dat.ret->w,0))->dat.desc;
d1000 2
a1001 1
	  dummy=st_make(freturn->dat.ret->w,GETDESCENTRY(des,nv)+1); /* get copy of stack */
d1004 1
a1004 1
		          freturn->dat.ret->t,GETDESCENTRY(des,nfv),&res);
d1008 2
a1009 1
	  dummy=st_make(freturn->dat.ret->a,GETDESCENTRY(des,nv)-1); /* get copy of stack */
d1011 1
a1011 1
		          freturn->dat.ret->t,GETDESCENTRY(des,nfv)/4,&res);	  
d1018 3
a1020 3
		      GETORDERARGS(freturn->dat.ret->ord,label));
	insert_functype(GETDESCENTRY(des,label),freturn->dat.ret->w,
			GETDESCENTRY(des,nv),freturn->dat.ret->t,
d1023 3
a1025 3
      if (0==GETORDERARGS(freturn->dat.ret->ord,m))
	insert_restype(&res,freturn->dat.ret->ord);
      SETORDERARGS(freturn->dat.ret->ord,k)=-1;		/* order executed */
d1027 5
a1031 5
      ord=freturn->dat.ret->ord;
      w=freturn->dat.ret->w;			/* restore stacks */
      a=freturn->dat.ret->a;
      t=freturn->dat.ret->t;
      r=freturn->dat.ret->r;
d1058 5
a1062 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d1070 1
a1070 1
      if (apply==GETORDERENTRY(freturn->dat.ret->ord,command))
d1074 1
a1074 1
	des=(st_read(freturn->dat.ret->w,0))->dat.desc;
d1077 2
a1078 1
	  dummy=st_make(freturn->dat.ret->w,GETDESCENTRY(des,nv)+1); /* get copy of stack */
d1081 1
a1081 1
		          freturn->dat.ret->t,GETDESCENTRY(des,nfv),&res);
d1085 2
a1086 1
	  dummy=st_make(freturn->dat.ret->a,GETDESCENTRY(des,nv)-1); /* get copy of stack */
d1088 1
a1088 1
		          freturn->dat.ret->t,GETDESCENTRY(des,nfv)/4,&res);	  
d1095 3
a1097 3
		      GETORDERARGS(freturn->dat.ret->ord,label));
	insert_functype(GETDESCENTRY(des,label),freturn->dat.ret->w,
			GETDESCENTRY(des,nv),freturn->dat.ret->t,
d1100 3
a1102 3
      if (0==GETORDERARGS(freturn->dat.ret->ord,m))
	insert_restype(&res,freturn->dat.ret->ord);
      SETORDERARGS(freturn->dat.ret->ord,k)=-1;		/* order executed */
d1104 5
a1108 5
      ord=freturn->dat.ret->ord;
      w=freturn->dat.ret->w;			/* restore stacks */
      a=freturn->dat.ret->a;
      t=freturn->dat.ret->t;
      r=freturn->dat.ret->r;
d1134 5
a1138 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d1140 1
a1140 1
      if ((NULL!=t) && (0!=t->topofstack))
d1142 1
a1142 1
      if ((NULL!=r) && (0!=r->topofstack))
d1144 1
a1144 1
      if ((NULL!=a) && (0!=a->topofstack))
d1146 1
a1146 1
      if ((NULL!=w) && (0!=w->topofstack))
d1149 2
a1150 2
      ord->types=TYPES2LONG(res->type,tp_none,tp_none,tp_none);
      if ((NULL!=ret) && (0<ret->topofstack))		/* still sometings to do */
d1153 2
a1154 1
	if JCONDS(GETORDERENTRY(d->dat.ret->ord,command)) /* command == jcond ? */
d1156 2
a1157 1
	  if (3==GETORDERARGS(d->dat.ret->ord,k)) /* jcond already executed */
d1159 5
a1163 5
	  ord=d->dat.ret->ord;				/* restore prev. state */
	  w=d->dat.ret->w;
	  a=d->dat.ret->a;
	  r=d->dat.ret->r;
	  t=d->dat.ret->t;
d1178 5
a1182 5
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==r) ? NULL : r->topofstack,
			   (NULL==t) ? NULL : t->topofstack,
			   (NULL==ret) ? NULL : ret->topofstack));
d1209 1
a1209 1
while ((NULL!=func_dump) && (0<func_dump->topofstack))
d1212 1
a1212 1
  if (-1!=GETORDERARGS(dummy->dat.ret->ord,k))
d1216 4
a1219 3
    if (gammabeta==GETORDERENTRY(dummy->dat.ret->ord,command))
      dummy=exe_func(dummy->dat.ret->ord,dummy->dat.ret->w,dummy->dat.ret->a,
		     dummy->dat.ret->r,dummy->dat.ret->t,d);
d1221 3
a1223 2
      dummy=exe_func(dummy->dat.ret->ord,dummy->dat.ret->w,dummy->dat.ret->a,
		     dummy->dat.ret->t,dummy->dat.ret->r,d);
@


1.24
log
@now using macros
@
text
@d29 2
d218 3
a220 2
	    if (DT_CONDITIONAL!=des->tag)
	      result=get_result(des->label,w,des->nv,t,des->nfv);
d222 2
a223 1
	      result=get_result(des->label,a,des->nv-1,t,des->nfv);
d255 2
a256 1
		rt->w=st_push(w,func);			/* save function */
d287 1
a287 1
				GETDESCENTRY(des,nfv),GETNEXTORDER(ord));
d641 1
a641 1
      DBUG_PRINT("ORDERS",("mkgaclos\\mkbclos\t\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d654 1
a654 1
      if (0!=clos->i)
d658 1
a658 1
	stelm_cpy(clos->w,&(w->stack[w->topofstack-clos->i]),clos->i);
d664 1
a664 1
      if (0!=clos->k)
d668 1
a668 1
	stelm_cpy(clos->t,&(t->stack[t->topofstack-clos->k]),clos->k);
a676 1
      stelm_free(func);
@


1.23
log
@jcond2, rtm, mkcclos implemented
@
text
@d29 1
a29 1
  switch (ord->command)
d42 1
a42 1
      ord=ord->next;
d56 1
a56 1
      ord=ord->next;
d68 1
a68 1
      d_stelm.dat.prim=ord->args.n;
d70 1
a70 1
      ord=ord->next;
d81 2
a82 2
      w=st_push(w,st_read(a,ord->args.n));
      ord=ord->next;
d93 2
a94 2
      w=st_push(w,st_read(t,ord->args.n));
      ord=ord->next;
d105 2
a106 2
      r=st_push(r,st_read(t,ord->args.n));
      ord=ord->next;
d118 2
a119 2
      r=st_push(r,st_read(a,ord->args.n));
      ord=ord->next;
d132 1
a132 1
      arg=find_address(ord->args.desc);
d135 1
a135 1
      ord=ord->next;
d148 1
a148 1
      arg=find_address(ord->args.desc);
d151 1
a151 1
      ord=ord->next;
d167 1
a167 1
      ord=ord->next;
d183 1
a183 1
      ord=ord->next;
d210 2
a211 2
          if (0!=ord->args.m)
	    arity=ord->args.m;			/* restore prev set apply-value */
d213 1
a213 1
	    arity=ord->args.n;				/* set normal apply-value */
d222 1
a222 1
	      if (arity==des->nv)
d224 1
a224 1
	      if (DT_CONDITIONAL!=des->tag)
d226 1
a226 1
		for (i=0; i<des->nv; i++)
d231 1
a231 1
		for (i=0; i<des->nv; i++)
d235 2
a236 2
	      arity-=des->nv;				/* overloaded apply ? */
	      ord->args.m=arity;
d239 2
a240 2
		ord->args.k=-1;				/* order executed */
		ord=ord->next;
d256 1
a256 1
		if (DT_CONDITIONAL!=des->tag)		/* COMB */
d258 1
a258 1
		  a=st_make(w,des->nv+1);	/* build new frames; +1 for func */
d261 1
a261 1
		  t=st_make(t,des->nfv);
d263 4
a266 3
		  ord->args.m=arity-des->nv;		/* store overload arity */
		  ord=find_func(GETFIRSTFUNCTION(program_start),des->label);
		  insert_args(a,des->nv,t,des->nfv,ord);
d274 2
a275 2
		  a=st_make(a,des->nv-1);	/* argument frame ready */
		  t=st_make(t,des->nfv/4);
d277 2
a278 2
		  ord->args.m=arity-des->nv;		/* store overload arity */
		  strcpy(&str[5],&(des->label[6]));
d280 3
a282 2
		  if (1<des->nv)
		    insert_args(a,des->nv-1,t,des->nfv,ord->next);
d289 1
a289 1
		  old_ord->args.k=-old_ord->args.k;	/* then-case without result */
d300 4
a303 2
		  insert_functype(des->label,w,des->nv,t,des->nfv,result);
		  for (i=0; i<des->nv; i++)	/* remove args from stack */
d306 1
a306 1
		  ord=ord->next;
d317 2
a318 2
	    clos->j=clos->desc->nv;
	    clos->k=clos->desc->nfv;
d344 1
a344 1
	    ord=ord->next;
d351 1
a351 1
	  ord=ord->next;
d366 2
a367 2
          if (0!=ord->args.m)
	    arity=ord->args.m;			/* restore prev set apply-value */
d369 2
a370 2
	    arity=ord->args.n;				/* set normal apply-value */
	  if (DT_CONDITIONAL==des->tag)		/* if CONDI unfold to A STACK */
d401 1
a401 1
	    if (DT_CONDITIONAL==des->tag)
d406 1
a406 1
	    ord->args.m=i;
d418 1
a418 1
	    if (DT_CONDITIONAL==des->tag)
d424 1
a424 1
	    ord=ord->next;
d445 1
a445 1
			   ord->args.label,
d451 3
a453 2
      des=find_desc(GETFIRSTDESC(program_start),ord->args.label);
      result=get_result(des->label,w,des->nv,r,des->nfv);
d457 2
a458 2
	ord->args.k=-1;					/* order executed */
	for (i=0; i<des->nv; i++)
d460 1
a460 1
	for (i=0; i<des->nfv; i++)
d463 1
a463 1
	ord=ord->next;
d478 1
a478 1
	  a=st_make(w,des->nv);			/* build new frames */
d480 1
a480 1
	  t=st_make(r,des->nfv);
d483 1
a483 1
	  insert_args(a,des->nv,t,des->nfv,ord);
d489 1
a489 1
	    old_ord->args.k=-old_ord->args.k;	/* then-case without result */
d500 3
a502 2
	    insert_functype(des->label,w,des->nv,r,des->nfv,result);
	    for (i=0; i<des->nv; i++)		/* remove argumentframe */
d504 1
a504 1
	    for (i=0; i<des->nfv; i++)		/* remove tildeframe */
d507 1
a507 1
	    ord=ord->next;
d528 3
a530 2
      des=find_desc(GETFIRSTDESC(program_start),ord->args.label);
      result=get_result(des->label,w,des->nv,t,des->nfv);
d534 2
a535 2
	ord->args.k=-1;					/* order executed */
	for (i=0; i<des->nv; i++)
d538 1
a538 1
	ord=ord->next;
d553 1
a553 1
	  a=st_make(w,des->nv);			/* build new frames */
d555 1
a555 1
	  t=st_make(t,des->nfv);
d557 2
a558 2
	  ord=find_func(GETFIRSTFUNCTION(program_start),des->label);
	  insert_args(a,des->nv,t,des->nfv,ord);
d564 1
a564 1
	    old_ord->args.k=-old_ord->args.k;	/* then-case without result */
d575 3
a577 2
	    insert_functype(des->label,w,des->nv,t,des->nfv,result);
	    for (i=0; i<des->nv; i++)
d580 1
a580 1
	    ord=ord->next;
d602 2
a603 2
      clos->i=ord->args.n;
      clos->j=ord->args.m;
d618 1
a618 1
      ord=ord->next;
d646 3
a648 3
      clos->i=ord->args.n;
      clos->j=ord->args.m;
      clos->k=ord->args.k;
d673 1
a673 1
      ord=ord->next;
d685 1
a685 1
      ord=ord->next;
d697 1
a697 1
      ord=find_label(ord->next,ord->args.label);
d718 1
a718 1
	if (3==ord->args.k)			/* jcond finished */
d731 1
a731 1
          if BETAFUNCS(ord->command)
d733 1
a733 1
             if (apply==ord->command)
d739 2
a740 2
	       des=find_desc(GETFIRSTDESC(program_start),ord->args.label);
	    if (DT_CONDITIONAL!=des->tag)
d742 3
a744 2
	      res=get_result(des->label,w,des->nv,t,des->nfv);
	      for (i=0; i<des->nv; i++)
d750 2
a751 1
	      res=get_result(des->label,a,des->nv-1,t,des->nfv/4);
d753 1
a753 1
	      for (i=0; i<des->nv-1; i++)
d757 1
a757 1
	    ord=ord->next;
d785 1
a785 1
	    switch (ord->args.k)
d790 2
a791 2
		ord->args.k=ord->args.k | 1;
		ord=ord->next;
d796 2
a797 2
		ord->args.k=3;
		ord=find_label(ord->next,ord->args.label);
d802 2
a803 2
		ord->args.k=2;
		ord=find_label(ord->next,ord->args.label);
d810 1
a810 1
		ord->args.k=3;				/* jcond finished */
d825 1
a825 1
	old_ord->args.k=-old_ord->args.k;
d832 1
a832 1
	  if BETAFUNCS(res->dat.ret->ord->command)
d860 1
a860 1
      for (i=0; i<ord->args.n; i++)
d862 1
a862 1
      ord=ord->next;
d875 1
a875 1
      for (i=0; i<ord->args.n; i++)
d880 1
a880 1
      ord=ord->next;
d906 1
a906 1
      if (apply==freturn->dat.ret->ord->command)
d911 1
a911 1
	if (DT_CONDITIONAL!=des->tag)
d913 1
a913 1
	  dummy=st_make(freturn->dat.ret->w,des->nv+1);	/* get copy of stack */
d915 2
a916 2
          insert_functype(des->label,dummy,des->nv,
		          freturn->dat.ret->t,des->nfv,&res);
d920 3
a922 3
	  dummy=st_make(freturn->dat.ret->a,des->nv-1);	/* get copy of stack */
          insert_functype(des->label,dummy,des->nv-1,
		          freturn->dat.ret->t,des->nfv/4,&res);	  
d928 5
a932 3
	des=find_desc(GETFIRSTDESC(program_start),freturn->dat.ret->ord->args.label);
	insert_functype(des->label,freturn->dat.ret->w,des->nv,
		        freturn->dat.ret->t,des->nfv,&res);
d934 1
a934 1
      if (0==freturn->dat.ret->ord->args.m)
d936 1
a936 1
      freturn->dat.ret->ord->args.k=-1;		/* order executed */
d946 1
a946 1
	for (i=0; i<des->nv; i++)
d948 1
a948 1
	if (apply==ord->command)
d952 2
a953 2
	  if (0==ord->args.m)
	    ord=ord->next;
d958 1
a958 1
	  ord=ord->next;
d981 1
a981 1
      if (apply==freturn->dat.ret->ord->command)
d986 1
a986 1
	if (DT_CONDITIONAL!=des->tag)
d988 1
a988 1
	  dummy=st_make(freturn->dat.ret->w,des->nv+1);	/* get copy of stack */
d990 2
a991 2
          insert_functype(des->label,dummy,des->nv,
		          freturn->dat.ret->t,des->nfv,&res);
d995 3
a997 3
	  dummy=st_make(freturn->dat.ret->a,des->nv-1);	/* get copy of stack */
          insert_functype(des->label,dummy,des->nv-1,
		          freturn->dat.ret->t,des->nfv/4,&res);	  
d1003 5
a1007 3
	des=find_desc(GETFIRSTDESC(program_start),freturn->dat.ret->ord->args.label);
	insert_functype(des->label,freturn->dat.ret->w,des->nv,
		        freturn->dat.ret->t,des->nfv,&res);
d1009 1
a1009 1
      if (0==freturn->dat.ret->ord->args.m)
d1011 1
a1011 1
      freturn->dat.ret->ord->args.k=-1;		/* order executed */
d1019 1
a1019 1
      if BETAFUNCS(ord->command)
d1021 1
a1021 1
        for (i=0; i<des->nv; i++)
d1023 1
a1023 1
	if (apply==ord->command)
d1027 2
a1028 2
	  if (0==ord->args.m)
	    ord=ord->next;
d1033 1
a1033 1
	  ord=ord->next;
d1056 1
a1056 1
      if (apply==freturn->dat.ret->ord->command)
d1061 1
a1061 1
	if (DT_CONDITIONAL!=des->tag)
d1063 1
a1063 1
	  dummy=st_make(freturn->dat.ret->w,des->nv+1);	/* get copy of stack */
d1065 2
a1066 2
          insert_functype(des->label,dummy,des->nv,
		          freturn->dat.ret->t,des->nfv,&res);
d1070 3
a1072 3
	  dummy=st_make(freturn->dat.ret->a,des->nv-1);	/* get copy of stack */
          insert_functype(des->label,dummy,des->nv-1,
		          freturn->dat.ret->t,des->nfv/4,&res);	  
d1078 5
a1082 3
	des=find_desc(GETFIRSTDESC(program_start),freturn->dat.ret->ord->args.label);
	insert_functype(des->label,freturn->dat.ret->w,des->nv,
		        freturn->dat.ret->t,des->nfv,&res);
d1084 1
a1084 1
      if (0==freturn->dat.ret->ord->args.m)
d1086 1
a1086 1
      freturn->dat.ret->ord->args.k=-1;		/* order executed */
d1094 1
a1094 1
      if BETAFUNCS(ord->command)
d1096 1
a1096 1
        for (i=0; i<des->nv; i++)
d1098 1
a1098 1
	if (apply==ord->command)
d1102 2
a1103 2
	  if (0==ord->args.m)
	    ord=ord->next;
d1108 1
a1108 1
	  ord=ord->next;
d1137 1
a1137 1
	if JCONDS(d->dat.ret->ord->command)		/* command == jcond ? */
d1139 1
a1139 1
	  if (3==d->dat.ret->ord->args.k)		/* jcond already executed */
d1156 1
a1156 1
      ord=ord->next;
d1194 1
a1194 1
  if (-1!=dummy->dat.ret->ord->args.k)
d1198 1
a1198 1
    if (gammabeta==dummy->dat.ret->ord->command)
@


1.22
log
@gammabeta corrected
@
text
@d15 1
a15 1
ORDER CONST_RTF={rtf,NULL,NULL,NULL,NULL,0,0};
d33 1
a33 1
      DBUG_PRINT("ORDERS",("pushcw_i\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d47 1
a47 1
      DBUG_PRINT("ORDERS",("pushcw_b\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d61 1
a61 1
      DBUG_PRINT("ORDERS",("pushcw_pf\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d75 1
a75 1
      DBUG_PRINT("ORDERS",("pushaw\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d87 1
a87 1
      DBUG_PRINT("ORDERS",("pushtw\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d99 1
a99 1
      DBUG_PRINT("ORDERS",("pushtr\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d112 1
a112 1
      DBUG_PRINT("ORDERS",("pushar\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d126 1
a126 1
      DBUG_PRINT("ORDERS",("pushr_p\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d142 1
a142 1
      DBUG_PRINT("ORDERS",("pushw_p\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d158 1
a158 1
      DBUG_PRINT("ORDERS",("moveaw\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d174 1
a174 1
      DBUG_PRINT("ORDERS",("movear\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d192 1
a192 1
      DBUG_PRINT("ORDERS",("apply\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d198 2
a199 2
      func=st_pop(w);
      switch (func->type)
d216 4
a219 1
	    result=get_result(des->label,w,des->nv,t,des->nfv);
d224 10
a233 2
	      for (i=0; i<des->nv; i++)
		stelm_free(st_pop(w));
d256 26
a281 8
		a=st_make(w,des->nv+1);		/* build new frames; +1 for func */
		st_pop(a);			/* remove func from stack */
		w=NULL;
		t=st_make(t,des->nfv);
		r=NULL;
		ord->args.m=arity-des->nv;		/* strore overload arity */
		ord=find_func(program_start->function,des->label);
		insert_args(a,des->nv,t,des->nfv,ord);
d284 1
a284 1
		{
d299 1
a299 1
		  for (i=0; i<des->nv; i++)
d301 1
a301 1
		  w=st_push(w,result);
d308 1
a308 1
	    {	    
d311 1
a311 1
	    clos->desc=des;
d315 1
a315 1
	    if (0!=clos->i)
d320 1
a320 1
	      for (i=0; i<clos->i; i++)
d323 1
a323 1
	    else
d325 1
a325 1
	    if (0!=clos->k)
d330 1
a330 1
	      for (i=0; i<clos->k; i++)
d333 1
a333 1
	    else
d337 1
a337 1
	    w=st_push(w,&res);
d339 1
a339 1
	    insert_restype(&res,ord);
d344 1
a344 1
	case tp_prim:					/* Stelligkeit pruefen !!! */
d346 1
a346 1
	  exe_prim(ord,w,func->dat.prim);
d357 1
d359 1
a359 1
	  clos=func->dat.clos;
d366 4
d372 1
a372 1
	    w=st_push(w,&(clos->w[i]));
d375 1
a375 1
	  if (NULL!=clos->w)
d387 1
a387 1
	      if (NULL!=clos->t)
d397 5
a401 1
	    w=st_push(w,&dummy);
d406 1
a406 1
	    clos->i=i;
d409 3
a411 3
	    stelm_cpy(clos->w,&(w->stack[w->topofstack-i]),i);
	    for (i=0; i<clos->i; i++)
	      stelm_free(st_pop(w));
d414 5
a418 1
	    w=st_push(w,&dummy);
d447 1
a447 1
      des=find_desc(program_start->desc,ord->args.label);
d477 1
a477 1
	  ord=find_func(program_start->function,des->label);
d494 1
a494 1
	    result=new_stelm(tp_none,NULL);
d496 1
a496 1
	    for (i=0; i<des->nv; i++)
d498 1
a498 1
	    for (i=0; i<des->nfv; i++)
d500 1
a500 1
	    w=st_push(w,result);
d515 1
a515 1
      DBUG_PRINT("ORDERS",("beta//tail(%s)\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d522 1
a522 1
      des=find_desc(program_start->desc,ord->args.label);
d550 1
a550 1
	  ord=find_func(program_start->function,des->label);
d583 1
a583 1
      DBUG_PRINT("ORDERS",("mkdclos\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d622 1
d628 1
a628 1
      DBUG_PRINT("ORDERS",("mkgaclos\\mkbclos\tw:%d, a:%d, t:%d, ret:%d",
d631 1
d670 1
a670 1
      DBUG_PRINT("ORDERS",("delta2\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d680 1
a680 1
    case jcond2:
d682 8
a689 1
      /* noch viel zu tun */
d692 1
d701 1
a701 1
      DBUG_PRINT("ORDERS",("jfalse//jcond\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d725 17
a741 3
	    des=find_desc(program_start->desc,ord->args.label);
	    res=get_result(ord->args.label,w,des->nv,t,des->nfv);
	    for (i=0; i<des->nv; i++)
d743 4
a746 1
            w=st_push(w,res);
d844 1
a844 1
      DBUG_PRINT("ORDERS",("freea\tw:%d, a:%d, r:%d. t:%d, ret:%d",
d859 1
a859 1
      DBUG_PRINT("ORDERS",("freeswt\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d872 5
a876 1
      }      
d882 1
a882 1
      DBUG_PRINT("ORDERS",("rtf\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d897 19
a915 2
	des=find_desc(program_start->desc,
	   (st_read(freturn->dat.ret->w,0))->dat.desc->label);
d917 5
a921 3
	des=find_desc(program_start->desc,freturn->dat.ret->ord->args.label);
      insert_functype(des->label,freturn->dat.ret->w,des->nv,
		      freturn->dat.ret->t,des->nfv,&res);
d956 1
a956 1
      DBUG_PRINT("ORDERS",("rtc_i\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d969 26
a994 3
      des=find_desc(program_start->desc,freturn->dat.ret->ord->args.label);
      insert_functype(des->label,freturn->dat.ret->w,des->nv,
		      freturn->dat.ret->t,des->nfv,&res);
d1029 1
a1029 1
      DBUG_PRINT("ORDERS",("rtc_i\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d1042 26
a1067 3
      des=find_desc(program_start->desc,freturn->dat.ret->ord->args.label);
      insert_functype(des->label,freturn->dat.ret->w,des->nv,
		      freturn->dat.ret->t,des->nfv,&res);
d1099 3
a1101 3
      STELM *res;

      DBUG_PRINT("ORDERS",("ext\tw:%d, a:%d, r:%d, t:%d, ret:%d",
d1108 1
a1108 1
      if ((NULL!=t) && (0!=*((long *)(t+SZ_LONG))))
d1110 3
a1112 1
      if ((NULL!=a) && (0!=*((long *)(a+SZ_LONG))))
d1114 1
a1114 1
      if ((NULL!=w) && (0!=*((long *)(w+SZ_LONG))))
d1118 18
a1135 1
      DBUG_RETURN(res);
d1168 1
a1168 1
ORDER ord_ext={ext,NULL,NULL,NULL,NULL,0,0};
d1173 1
a1173 1
goaltype=exe_func(program_start->function->order,NULL,NULL,NULL,NULL,NULL);
@


1.21
log
@minor bug removed
@
text
@d96 14
a109 1
      }      
d121 17
a137 1
      }      
d188 3
a190 1
      STELM *func;
d205 1
a205 1
	  long i,arity;
d210 2
a211 2
          if (0!=ord->args.k)
	    arity=ord->args.k;			/* restore prev set apply-value */
d219 2
a220 2
	      insert_restype(result,ord);
	      ord->args.k=-1;				/* order executed */
d225 1
a225 1
	      ord->args.k=arity;
d227 2
d230 1
d240 1
a240 2
		rt->w=w;
		rt->w=st_push(rt->w,func);		/* save function */
d245 2
a246 1
		a=st_make(w,des->nv);			/* build new frames */
d250 1
a250 1
		ord->args.k=arity-des->nv;		/* strore overload arity */
d264 1
d278 35
d315 1
a315 1
	case tp_prim:					/* Typen ueberpruefen !!! */
d331 5
a335 1
	  primf=func->dat.clos->k;
d343 1
a343 1
	  i=clos->i+ord->args.n;			/* calc no. of args */	
a345 7
	    for (j=0; j<clos->k; j++)			/* unfold T-frame */
	      {
	      t=st_push(t,&(clos->t[j]));
	      stelm_free(&(clos->t[j]));
	      }
	    if (clos->t)
	      free(clos->t);
d348 7
a356 2
	      w=st_push(w,&dummy);
	      ord->args.k=i;
a361 2
	      w=st_push(w,&dummy);
	      ord->args.k=i;
d363 2
d372 2
d377 1
d541 1
a541 1
      DBUG_PRINT("ORDERS",("mkdclos\tw:%d, a:%d, t:%d, ret:%d",
d544 1
d571 9
a580 1
    case mkgaclos:
d585 1
a585 1
      DBUG_PRINT("ORDERS",("mkgaclos//mkbclos\tw:%d, a:%d, t:%d, ret:%d",
d621 1
d636 5
d798 1
a798 1
      d=r;					/* switch stacks r <-> t */
d830 2
a831 1
      insert_restype(&res,freturn->dat.ret->ord);
d837 2
a838 12
      if (gammabeta==ord->command)
        {
        r=freturn->dat.ret->t;
        t=freturn->dat.ret->r;
	for (i=0; i<des->nfv; i++)
	  stelm_free(st_pop(r));	
	}
      else
	{	
        t=freturn->dat.ret->t;
        r=freturn->dat.ret->r;
	}
d843 13
a855 3
	  stelm_free(st_pop(w));	
        w=st_push(w,&res);
	ord=ord->next;
a856 1
      stelm_free(&res);
d880 2
a881 1
      insert_restype(&res,freturn->dat.ret->ord);
d887 2
a888 12
      if (gammabeta==ord->command)
        {
        r=freturn->dat.ret->t;
        t=freturn->dat.ret->r;
	for (i=0; i<des->nfv; i++)
	  stelm_free(st_pop(r));	
	}
      else
	{	
        t=freturn->dat.ret->t;
        r=freturn->dat.ret->r;
	}
d894 12
a905 2
        w=st_push(w,&res);
        ord=ord->next;
d930 2
a931 1
      insert_restype(&res,freturn->dat.ret->ord);
d937 2
a938 12
      if (gammabeta==ord->command)
        {
        r=freturn->dat.ret->t;
        t=freturn->dat.ret->r;
	for (i=0; i<des->nfv; i++)
	  stelm_free(st_pop(r));	
	}
      else
	{	
        t=freturn->dat.ret->t;
        r=freturn->dat.ret->r;
	}
d944 12
a955 2
        w=st_push(w,&res);
        ord=ord->next;
@


1.20
log
@indefi. jcond recognition inserted, minor bug removed
@
text
@d174 1
a174 1
	  long i;
d178 3
a180 11
          des=func->dat.desc;
          result=get_result(des->label,w,des->nv,t,des->nfv);
          if (NULL!=result)				/* old result stored */
	    {
	    insert_restype(result,ord);
	    ord->args.k=-1;				/* order executed */
	    for (i=0; i<des->nv; i++)
	      stelm_free(st_pop(w));
	    w=st_push(w,result);
	    ord=ord->next;
	    }
d182 2
d185 2
a186 2
	    old_ord=search_ret(ord,ret);
	    if (NULL==old_ord)				/* first call from here */
d188 9
a196 15
	      if (NULL==(rt=malloc(sizeof(RETURNADR))))
		yyfail("%s","no memory for returnadress!");
	      rt->ord=ord;				/* remember enviroment of func */
	      rt->w=w;
	      rt->w=st_push(rt->w,func);		/* save function */
	      rt->a=a;
	      rt->t=t;
	      rt->r=r;
	      ret=st_push(ret,new_stelm(tp_returnadr,rt)); /* returndata stored */
	      a=st_make(w,des->nv);			/* build new frames */
	      w=NULL;
	      t=st_make(t,des->nfv);
	      r=NULL;
	      ord=find_func(program_start->function,des->label);
	      insert_args(a,des->nv,t,des->nfv,ord);
d198 1
a198 1
	    else					/* have been here before */
d200 2
a201 1
	      if (old_ord!=ord)				/* old_ord must be jcond */
d203 16
a218 6
		ord->args.k=-ord->args.k;		/* then-case without result */
		result=restore_ret(old_ord,ret);	/* restors state of old_ord */
		w=result->dat.ret->w;			/* restore stacks */
		a=result->dat.ret->a;
		t=result->dat.ret->t;
		r=result->dat.ret->r;
d220 1
a220 1
	      else					/* bad recursion */
d222 18
a239 6
		result=new_stelm(tp_none,NULL);
		insert_functype(des->label,w,des->nv,t,des->nfv,result);
		for (i=0; i<des->nv; i++)
		  stelm_free(st_pop(w));
		w=st_push(w,result);
		ord=ord->next;
d241 2
a242 2
	      }
	    }	  
d367 1
a367 1
	    ord->args.k=-ord->args.k;		/* then-case without result */
d373 1
d440 1
a440 1
	    ord->args.k=-ord->args.k;		/* then-case without result */
d446 1
d656 1
a656 1
	old_ord->args.k=-ord->args.k;
d925 1
@


1.19
log
@bugs removed and concept changed
@
text
@d15 1
d625 8
@


1.18
log
@*** empty log message ***
@
text
@a155 2
    case apply_f:
    case apply_c:
d167 1
a167 1
/*     switch (func->type)
d171 66
d242 1
a242 1
	  STELM *res,dummy;
a246 1
	  ord->command=apply_c;
d248 1
a248 1
	  des=func->dat.clos->desc;
d250 1
a250 1
	  for (i=0; i<clos->i; i++)
d257 2
a258 2
	  i=clos->i+ord->args.n;	
	  if (clos->j<=i) 		
d260 1
a260 1
	    for (j=0; j<clos->k; j++)
d267 8
a274 1
	    if (NULL!=des)
d276 4
a279 6
	      res=do_func(clos->desc,ord,w,a,t,func_name,clos->desc->label);
	      for (j=0; j<clos->k; j++)
		stelm_free(st_pop(t));
	      i=i-clos->j;
	      if (0!=i)
		yyfail("%s","overloaded apply not yet implemented");
a280 2
	    else
	      exe_prim(ord,w,primf);
d282 1
a282 1
	  else					
d291 1
a294 5
	case tp_prim:
	  {
	  exe_prim(ord,w,func->dat.prim);
	  break;
	  }
d301 1
a301 2
      stelm_free(func); */
      ord=ord->next;
d478 1
d711 5
a715 1
      des=find_desc(program_start->desc,freturn->dat.ret->ord->args.label);
d912 1
a912 1
		     dummy->dat.ret->t,dummy->dat.ret->r,d);
d915 1
a915 1
		     dummy->dat.ret->r,dummy->dat.ret->t,d);
@


1.17
log
@minor change
@
text
@d13 2
a14 2
ORDER *badrecord;
char *vtis=VTIS,state=0;
a16 141
/* executes different function calls.					*/
/* (used by exe_func)							*/
/************************************************************************/
STELM *do_func(FUNDESC *des,ORDER *ord,STACK *w,STACK *a,STACK *t,char *func_name,
	       char *label)
{
STELM *func_res,*ftype,*result;
char d_str[MAX_LINE_LENGTH], *str;
int n, nt, i;
ORDER *beta_fun, *o;


DBUG_ENTER("do_func");
ftype=new_stelm(tp_illegal,NULL);      
beta_fun=find_func(program_start->function,label);
n=des->nv;
nt=des->nfv;
if (hash!=beta_fun->command)				/* no args inserted */
  {
  if (0<n)						/* if args present */
    {
    strcpy(d_str,"#args");
    for (i=0; i<n; i++)
      {
      d_str[strlen(d_str)+1]=0;
      d_str[strlen(d_str)]=' ';
      strcpy(&d_str[strlen(d_str)],long_type_names(st_read(w,i)->type));
      }
    if (NULL==(str=malloc(strlen(d_str)+1)))
      yyfail("%s","no memory for argshash!");
    strcpy(str,d_str);
    o=new_order(hash,str);
    insert_order_list(o,beta_fun);
    }
  if (0<nt)						/* if tildeargs present */
    {
    strcpy(d_str,"#tildeargs");
    for (i=0; i<nt; i++)
      {
      d_str[strlen(d_str)+1]=0;
      d_str[strlen(d_str)]=' ';
      strcpy(&d_str[strlen(d_str)],long_type_names(st_read(t,i)->type));
      }
    if (NULL==(str=malloc(strlen(d_str)+1)))
      yyfail("%s","no memory for tildeargshash!");
    strcpy(str,d_str);
    o=new_order(hash,str);
    insert_order_list(o,beta_fun);
    }
  }
result=get_result(label,w,n,t,nt);
if (NULL!=result)
  {
  while (0!=n)
    {
    stelm_free(st_pop(w));
    n--;
    }
  w=st_push(w,result);
  insert_restype(result,ord);
  }
else
  {
  if (ord->args.m==0)			/* first functioncall from here */
    {
    ord->args.m=1;			/* remember functioncall */
    if (NULL!=(func_res=gethash_restype(ord->prev)))	/* prototype ? */
      insert_functype(label,w,n,t,nt,func_res,kn_preset);
    if ((NULL!=func_name) && (0==(strcmp(label,func_name)))) /* localrecursion */
      {
      ord->args.m=0;			/* do functioncall another time */
      st_free(w);
      st_free(a);
      st_free(t);
      badrecord=ord;
      if (0<state)
	DBUG_RETURN(new_stelm(tp_doagain,NULL));
      else
	DBUG_RETURN(new_stelm(tp_badlocrec,NULL));
      }
    else						/* no local recursion */
      {
      result=exe_func(beta_fun,NULL,st_make(w,n),st_make(t,nt),label);
      switch (result->type)
	{
	case tp_doagain:
	  {
	  ord->args.m=0;
	  DBUG_RETURN(new_stelm(tp_doagain,NULL));	
	  break;
	  }
	case tp_badlocrec:
	  {
	  DBUG_RETURN(result);
	  break;
	  }
	case tp_badrecur:					/* tp_badrecur problem */
	  {
	  st_free(w);
	  st_free(a);
	  st_free(t);
	  if (badrecord==ord)
	    {
	    ord->args.m=0;
	    DBUG_RETURN(new_stelm(tp_doagain,NULL));	/* tp_badrecend */
	    }
	  else
	    {
	    ord->args.m=0;
	    DBUG_RETURN(new_stelm(tp_badrecur,NULL));
	    }
	  break;
	  }
	default:
	  {
	  insert_restype(result,ord);
	  while (0!=n)
	    {
	    stelm_free(st_pop(w));
	    n--;
	    }
	  w=st_push(w,result);
	  break;
	  }	
	}
      }
    }
  else							/* I was here before! */
    {
    st_free(w);
    st_free(a);
    st_free(t);
    ftype->type=tp_badrecur;
    ftype->dat.desc=NULL;
    badrecord=ord;
    }
  }
DBUG_RETURN(ftype);
}

/************************************************************************/
d20 1
a20 1
STELM *exe_func(ORDER *ord, STACK *w, STACK *a, STACK *t, char *func_name)
d22 2
a23 2
STELM ftype={tp_illegal,NULL}, d_stelm;
PROGRAM *root=program_start;
d26 1
a26 1
while (tp_illegal==ftype.type)
a27 3
#ifndef DBUG_OFF
  stack_display(w,a,t);
#endif
d32 1
a32 1
      DBUG_PRINT("ORDERS",("pushcw_i\tw:%d, a:%d, t:%d",
d35 3
a37 1
			   (NULL==t) ? NULL : t->topofstack));
d41 1
d46 1
a46 1
      DBUG_PRINT("ORDERS",("pushcw_b\tw:%d, a:%d, t:%d",
d49 3
a51 1
			   (NULL==t) ? NULL : t->topofstack));
d55 1
d60 1
a60 1
      DBUG_PRINT("ORDERS",("pushcw_pf\tw:%d, a:%d, t:%d",
d63 3
a65 1
			   (NULL==t) ? NULL : t->topofstack));
d69 1
d74 1
a74 1
      DBUG_PRINT("ORDERS",("pushaw\tw:%d, a:%d, t:%d",
d77 3
a79 1
			   (NULL==t) ? NULL : t->topofstack));
d81 1
d86 1
a86 1
      DBUG_PRINT("ORDERS",("pushtw\tw:%d, a:%d, t:%d",
d89 3
a91 1
			   (NULL==t) ? NULL : t->topofstack));
d93 1
d98 1
a98 1
      DBUG_PRINT("ORDERS",("pushar\tw:%d, a:%d, t:%d",
d101 5
a105 2
			   (NULL==t) ? NULL : t->topofstack));
      t=st_push(t,st_read(a,ord->args.n));
d112 1
a112 14
      DBUG_PRINT("ORDERS",("pushw_p\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      arg=find_address(ord->args.desc);
      w=st_push(w,arg);
      stelm_free(arg);
      break;
      }
    case pushr_p:
      {
      STELM *arg;
      
      DBUG_PRINT("ORDERS",("pushr_p\tw:%d, a:%d, t:%d",
d115 3
a117 1
			   (NULL==t) ? NULL : t->topofstack));
d121 1
d128 1
a128 1
      DBUG_PRINT("ORDERS",("moveaw\tw:%d, a:%d, t:%d",
d131 3
a133 1
			   (NULL==t) ? NULL : t->topofstack));
d137 1
d144 1
a144 1
      DBUG_PRINT("ORDERS",("movear\tw:%d, a:%d, t:%d",
d147 3
a149 1
			   (NULL==t) ? NULL : t->topofstack));
d151 1
a151 1
      t=st_push(t,arg);
d153 1
d160 1
a160 3
      STELM *func,*result;
      STACK *dw,*da,*dt;
      FUNDESC *des;
d162 1
a162 1
      DBUG_PRINT("ORDERS",("apply\tw:%d, a:%d, t:%d",
d165 3
a167 1
			   (NULL==t) ? NULL : t->topofstack));
d169 1
a169 1
      switch (func->type)
a172 51
	  dw=st_make(w,(NULL==w) ? 0 : w->topofstack);
	  da=st_make(a,(NULL==a) ? 0 : a->topofstack);
	  dt=st_make(t,(NULL==t) ? 0 : t->topofstack);
	  ord->command=apply_f;
	  des=func->dat.desc;
	  result=do_func(des,ord,w,a,t,func_name,func->dat.desc->label);
	  if (tp_badrecur==result->type)
	    {
	    st_free(dw);
	    st_free(da);
	    st_free(dt);
	    DBUG_RETURN(result);
	    }
	  if (tp_doagain==result->type)
	    {
	    if (0>=state)
	      {
	      stelm_free(result);
	      result=new_stelm(tp_none,NULL);
	      insert_functype(des->label,dw,des->nv,dt,des->nfv,result,kn_sure);
	      insert_restype(result,badrecord);
	      result=do_func(des,ord,dw,a,dt,func_name,des->label);
	      w=dw;
	      dw=NULL;
	      a=da;
	      da=NULL;
	      t=dt;
	      dt=NULL;
	      }
	    else
	      {
	      st_free(dw);
	      st_free(da);
	      st_free(dt);
	      DBUG_RETURN(result);
	      }
	    }	
          if (tp_badlocrec==result->type)
            {
            stelm_free(result);
            result=new_stelm(tp_none,NULL);
            insert_functype(des->label,dw,des->nv,dt,des->nfv,result,kn_sure);
            insert_restype(result,ord);
            insert_restype(result,badrecord);
            }
	  st_free(dw);
	  st_free(da);
	  st_free(dt);
	  ftype.type=result->type;
	  ftype.dat.desc=result->dat.desc;
	  stelm_free(result);
d194 2
a195 2
	  i=clos->i+ord->args.n;		/* new number of args */
	  if (clos->j<=i) 			/* got all args */
d206 1
a206 2
	      res=do_func(clos->desc,ord,w,a,t,func_name,
			  clos->desc->label);
d216 1
a216 1
	  else						/* not enough args */
d239 2
a240 1
      stelm_free(func);
d244 72
a319 1
      STACK *dw,*da,*dt;
d321 2
d324 1
a324 1
      DBUG_PRINT("ORDERS",("beta//tail//gammabeta(%s)\tw:%d, a:%d, t:%d",
d328 6
a333 8
			   (NULL==t) ? NULL : t->topofstack));
      state-=1;
      dw=st_make(w,(NULL==w) ? 0 : w->topofstack);	/* save old stacks */
      da=st_make(a,(NULL==a) ? 0 : a->topofstack);
      dt=st_make(t,(NULL==t) ? 0 : t->topofstack);
      des=find_desc(root->desc,ord->args.label);
      result=do_func(des,ord,w,a,t,func_name,ord->args.label);
      if (tp_badrecur==result->type)
d335 6
a340 4
	st_free(dw);
	st_free(da);
	st_free(dt);
	DBUG_RETURN(result);
d342 4
a345 3
      if (tp_doagain==result->type)
	{
	if (0>=state)
d347 14
a360 11
	  stelm_free(result);
	  result=new_stelm(tp_none,NULL);
	  insert_functype(ord->args.label,dw,des->nv,dt,des->nfv,result,kn_sure);
	  insert_restype(result,badrecord);
	  result=do_func(des,ord,dw,a,dt,func_name,ord->args.label);
	  w=dw;
	  dw=NULL;
	  a=da;
	  da=NULL;
	  t=dt;
	  dt=NULL;
d362 1
a362 1
	else
d364 18
a381 4
	  st_free(dw);
	  st_free(da);
	  st_free(dt);
	  DBUG_RETURN(result);
d383 1
a383 15
	}	
      if (tp_badlocrec==result->type)
        {
        stelm_free(result);
        result=new_stelm(tp_none,NULL);
        insert_functype(ord->args.label,dw,des->nv,dt,des->nfv,result,kn_sure);
        insert_restype(result,ord);
        insert_restype(result,badrecord);
        }
      st_free(dw);
      st_free(da);
      st_free(dt);
      ftype.type=result->type;
      ftype.dat.desc=result->dat.desc;
      stelm_free(result);
a389 1
      long i;
d391 1
a391 1
      DBUG_PRINT("ORDERS",("mkdclos\tw:%d, a:%d, t:%d",
d394 2
a395 1
			   (NULL==t) ? NULL : t->topofstack));
a423 1
      int i;
d425 1
a425 1
      DBUG_PRINT("ORDERS",("mkgaclos//mkbclos\tw:%d, a:%d, t:%d",
d428 2
a429 1
			   (NULL==t) ? NULL : t->topofstack));
d465 1
a465 1
      DBUG_PRINT("ORDERS",("delta2\tw:%d, a:%d, t:%d",
d468 3
a470 1
			   (NULL==t) ? NULL : t->topofstack));
d472 1
d478 3
a480 2
      STELM *res1, *res2;
      int n, nt;
a481 1
      ORDER *ord_cond;
d483 1
a483 1
      DBUG_PRINT("ORDERS",("jfalse//jcond\tw:%d, a:%d, t:%d",
d486 5
a490 3
			   (NULL==t) ? NULL : t->topofstack));
      res1=st_pop(w);
      if (tp_bool!=res1->type)
d492 47
a538 12
	/* Grosses Problem !!! */
	}
      else
	{
	/* ord->command=jfalse_b; */
	ord_cond=find_label(ord->next, ord->args.label);
	des=find_desc(root->desc,func_name);
	n=des->nv;
	nt=des->nfv;
	while(TRUE)
	  {	  
	  if (0==ord->args.n)			/* no recursion until now */
d540 1
a540 5
	    ord->args.n=1;
	    state=2;
	    res1=exe_func(ord->next,NULL,st_make(a,n),
			  st_make(t,nt),func_name);
	    switch (res1->type)
d542 2
a543 1
	      case tp_badrecur:
d545 8
a552 1
		DBUG_RETURN(res1);
d555 1
a555 1
	      case tp_doagain:
d557 2
a558 24
		state=2;					/* check it */
		res2=exe_func(ord_cond,NULL,st_make(a,n),
			      st_make(t,nt),func_name);
		if (0>res2->type)				/* no result at all */
		  {
		  res2->type=tp_none;
		  DBUG_RETURN(res2);
		  }
		else
		  {
		  insert_functype(func_name,a,n,t,nt,res2,kn_partial);	
		  state=2;					/* check it */
		  res1=exe_func(ord->next,NULL,st_make(a,n),
				st_make(t,nt),func_name);
		  if (res1->type==res2->type)
		    {
		    insert_functype(func_name,a,n,t,nt,res1,kn_sure);
		    st_free(w);
		    st_free(a);
		    st_free(t);
		    ord->args.n=0;
		    DBUG_RETURN(new_stelm(res1->type,res1->dat.desc));
		    }
		  }
d561 2
a562 1
	      default:
d564 1
a564 16
		insert_functype(func_name,a,n,t,nt,res1,kn_partial);
		state=2;					/* check it */
		res2=exe_func(ord_cond,NULL,st_make(a,n),
			      st_make(t,nt),func_name);
		if ((res1->type==res2->type) || ((tp_none==res2->type) ||
						 (tp_none==res1->type)))
		  {
		  insert_functype(func_name,a,n,t,nt,res2,kn_sure);
		  st_free(w);
		  st_free(a);
		  st_free(t);
		  ord->args.n=0;
		  DBUG_RETURN((res1->type==res2->type) 
			      ? new_stelm(res1->type,res1->dat.desc)
			      : new_stelm(tp_none,NULL));
		  }
d568 14
a581 1
	  else					/* once again at this position */
d583 4
a586 32
	    state=2;					/* check it */
	    res2=exe_func(ord_cond,NULL,st_make(a,n),
			  st_make(t,nt),func_name);
	    if (0>res2->type)				/* no result at all */
	      {
	      res2->type=tp_none;
	      DBUG_RETURN(res2);
	      }
	    else
	      {
	      insert_functype(func_name,a,n,t,nt,res2,kn_partial);	
	      state=2;					/* check it */
	      res1=exe_func(ord->next,NULL,st_make(a,n),
			    st_make(t,nt),func_name);
	      if (res1->type==res2->type)
		{
		insert_functype(func_name,a,n,t,nt,res1,kn_sure);
		st_free(w);
		st_free(a);
		st_free(t);
		ord->args.n=0;
		DBUG_RETURN(new_stelm(res1->type,res1->dat.desc));
		}
	      else
		{
		if (tp_badrecur==res1->type)
		  {
		  ord->args.n=0;
		  DBUG_RETURN(new_stelm(tp_badrecur,NULL));
		  }
		}
	      }
d588 1
a588 2
	  ord->args.n=0;
	  insert_functype(func_name,a,n,t,nt,new_stelm(tp_none,NULL),kn_sure);
d590 6
d601 1
a601 3
      int i;
      
      DBUG_PRINT("ORDERS",("freea\tw:%d, a:%d, t:%d",
d604 3
a606 1
			   (NULL==t) ? NULL : t->topofstack));
d609 1
d614 1
a614 1
      int i;
d616 1
a616 1
      DBUG_PRINT("ORDERS",("freeswt\tw:%d, a:%d, t:%d",
d619 3
a621 1
			   (NULL==t) ? NULL : t->topofstack));
d624 4
d632 2
a633 1
      STELM *res;
d635 1
a635 1
      DBUG_PRINT("ORDERS",("rtf\tw:%d, a:%d, t:%d",
d638 4
a641 2
			   (NULL==t) ? NULL : t->topofstack));
      res=st_pop(w);
d644 1
d646 33
a678 3
      ftype.type=res->type;
      ftype.dat.desc=res->dat.desc;
      stelm_free(res);
d683 4
a686 1
      DBUG_PRINT("ORDERS",("rtc_i\tw:%d, a:%d, t:%d",
d689 3
a691 1
			   (NULL==t) ? NULL : t->topofstack));
d694 1
d696 32
a727 2
      ftype.type=tp_int;
      ftype.dat.desc=NULL;
d732 4
a735 1
      DBUG_PRINT("ORDERS",("rtc_b\tw:%d, a:%d, t:%d",
d738 3
a740 1
			   (NULL==t) ? NULL : t->topofstack));
d743 1
d745 32
a776 2
      ftype.type=tp_bool;
      ftype.dat.desc=NULL;
d783 1
a783 1
      DBUG_PRINT("ORDERS",("ext\tw:%d, a:%d, t:%d",
d786 3
a788 1
			   (NULL==t) ? NULL : t->topofstack));
d797 2
a798 3
      ftype.type=res->type;
      ftype.dat.desc=res->dat.desc;
      stelm_free(res);
d803 1
d806 1
a806 1
      DBUG_PRINT("ORDERS",("end\tw:%d, a:%d, t:%d",
d809 3
a811 1
			   (NULL==t) ? NULL : t->topofstack));
a819 1
  ord=ord->next;
d821 1
a821 1
DBUG_RETURN(new_stelm(ftype.type,ftype.dat.desc));
d830 4
a833 1
STELM *goaltype;
d836 16
a851 1
goaltype=exe_func(program_start->function->order, NULL, NULL, NULL, NULL);
@


1.16
log
@first changes for type conflicts
@
text
@a11 6
char *prim_type_names[]={"none","int","real","digit","bool","string",NULL};
char *s_prim_type_names[]={"?","i","r","d","b","s"};
char *ext_type_names[]={"scalar","list","vect","tvect","matrix",NULL};
char *s_ext_type_names[]={NULL,"l","v","t","m"};
char *other_type_names[]={"prim","clos","func",NULL};
char *s_other_type_names[]={"p","c","f"};
@


1.15
log
@internal types changed
@
text
@d176 1
a176 12
  if (_db_keyword_("STACKS"))
    {
    printf("w:\t");
    if (NULL!=w)
      stelm_display(w->stack,w->topofstack);
    printf("\na:\t");
    if (NULL!=a)
      stelm_display(a->stack,a->topofstack);
    printf("\nt:\t");
    if (NULL!=t)
      stelm_display(t->stack,t->topofstack);
    printf("\n");
a177 1
    }
d590 1
a590 1
      DBUG_PRINT("ORDERS",("jfalse\tw:%d, a:%d, t:%d",
d623 1
d634 1
d652 1
d672 1
d683 1
d694 8
@


1.14
log
@types changed
@
text
@d73 2
a74 1
if (ord->args.m==0)			/* first functioncall from here */
d76 1
a76 4
  ord->args.m=1;			/* remember functioncall */
  if (NULL!=(func_res=gethash_restype(ord->prev)))	/* prototype ? */
    insert_functype(label,w,n,t,nt,func_res,kn_preset);
  if ((NULL!=func_name) && (0==(strcmp(label,func_name)))) /* localrecursion */
d78 14
a91 1
    if (NULL==(result=get_result(label,w,n,t,nt))) 	/* result unknown ? */
d101 1
a101 11
        DBUG_RETURN(new_stelm(tp_badlocrec,NULL));
      }
    else				/* result of local recursion known */
      {
      while (0!=n)
	{
	stelm_free(st_pop(w));
	n--;
	}
      w=st_push(w,result);			/* push result on stack */
      insert_restype(result,ord);
d103 1
a103 5
    }
  else						/* no local recursion */
    {
    result=exe_func(beta_fun,NULL,st_make(w,n),st_make(t,nt),label);
    switch (result->type)
d105 2
a106 12
      case tp_doagain:
	{
	ord->args.m=0;
	DBUG_RETURN(new_stelm(tp_doagain,NULL));	
	break;
	}
      case tp_badlocrec:
	{	
	DBUG_RETURN(result);
	break;
	}
      case tp_badrecur:					/* tp_badrecur problem */
d108 1
a108 4
	st_free(w);
	st_free(a);
	st_free(t);
	if (badrecord==ord)
d111 2
a112 1
	  DBUG_RETURN(new_stelm(tp_doagain,NULL));	/* tp_badrecend */
d114 1
a114 1
	else
d116 2
a117 2
	  ord->args.m=0;
	  DBUG_RETURN(new_stelm(tp_badrecur,NULL));
d119 1
a119 6
	break;
	}
      default:
	{
	insert_restype(result,ord);
	while (0!=n)
d121 14
a134 2
	  stelm_free(st_pop(w));
	  n--;
d136 12
a147 3
	w=st_push(w,result);
	break;
	}	
d150 1
a150 15
  }
else							/* I was here before! */
  {
  result=get_result(label, w, n, t, nt);
  if (NULL!=result)
    {
    while (0!=n)
      {
      stelm_free(st_pop(w));
      n--;
      }
    w=st_push(w, result);
    insert_restype(result,ord);
    }
  else							/* result unknown */
d358 8
a365 8
	  if (tp_badlocrec==result->type)
	    {	
	    stelm_free(result);
	    result=new_stelm(tp_none,NULL);
	    insert_functype(des->label,dw,des->nv,dt,des->nfv,result,kn_sure);
	    insert_restype(result,ord);
	    insert_restype(result,badrecord);
	    }
d493 7
a499 7
	{	
	stelm_free(result);
	result=new_stelm(tp_none,NULL);
	insert_functype(ord->args.label,dw,des->nv,dt,des->nfv,result,kn_sure);
	insert_restype(result,ord);
	insert_restype(result,badrecord);
	}
a593 81
    case eq:
      {
      DBUG_PRINT("ORDERS",("eq\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      exe_prim(ord,w,p_eq);
      break;
      }
    case ne:
      {
      DBUG_PRINT("ORDERS",("ne\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      exe_prim(ord,w,p_ne);
      break;
      }
    case lt:
      {
      DBUG_PRINT("ORDERS",("lt\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      exe_prim(ord,w,p_lt);
      break;
      }
    case le:
      {
      DBUG_PRINT("ORDERS",("le\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      exe_prim(ord,w,p_le);
      break;
      }
    case gt:
      {
      DBUG_PRINT("ORDERS",("gt\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      exe_prim(ord,w,p_gt);
      break;
      }
    case ge:
      {
      DBUG_PRINT("ORDERS",("ge\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      exe_prim(ord,w,p_ge);
      break;
      }
    case add:
      {
      DBUG_PRINT("ORDERS",("add\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      exe_prim(ord,w,p_plus);
      break;
      }
    case minus:
      {
      DBUG_PRINT("ORDERS",("minus\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      exe_prim(ord,w,p_minus);
      break;
      }
    case mult:
      {
      DBUG_PRINT("ORDERS",("mult\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      exe_prim(ord,w,p_mult);
      break;
      }
a594 1
    case jfalse_b:      
d613 1
a613 2
	stelm_free(res1);
	ord->command=jfalse_b;
d617 4
a620 8
	nt=des->nfv;      
	if (0==ord->args.n)			/* no recursion until now */
	  {
	  ord->args.n=1;
	  state=2;
	  res1=exe_func(ord->next,NULL,st_make(a,n),
			st_make(t,nt),func_name);
	  switch (res1->type)
d622 5
a626 1
	    case tp_badrecur:
d628 6
a633 13
	      DBUG_RETURN(res1);
	      break;
	      }
	    case tp_badlocrec:
	      {
	      printf("----> *** badlocrec **** <----\n");
	      break;
	      }
	    case tp_doagain:
	      {
	      res2=exe_func(ord_cond,NULL,st_make(a,n),
			    st_make(t,nt),func_name);
	      if (0>res2->type)				/* no result at all */
d635 23
a657 2
		res2->type=tp_none;
		DBUG_RETURN(res2);
d659 1
a659 1
	      else
d661 2
a662 2
		insert_functype(func_name,a,n,t,nt,res2,kn_partial);	
		res1=exe_func(ord->next,NULL,st_make(a,n),
d664 2
a665 1
		if (res1->type==res2->type)
d667 1
a667 1
		  insert_functype(func_name,a,n,t,nt,res1,kn_sure);
d671 4
a674 2
		  ftype.type=res1->type;
		  ftype.dat.desc=res1->dat.desc;
a675 4
		else
		  {
		  /* ungleiche Typen bei if then else */
		  }
d677 10
a686 1
	      break;
d688 1
a688 1
	    default:
d690 2
a691 2
	      insert_functype(func_name,a,n,t,nt,res1,kn_partial);
	      res2=exe_func(ord_cond,NULL,st_make(a,n),
d699 2
a700 6
		ftype.type=res1->type;
		ftype.dat.desc=res1->dat.desc;
		}
	      else
		{
		/* ungleiche Typen bei if then else !!! */
d704 2
a705 29
	  }
	else					/* once again at this position */
	  {
	  res2=exe_func(ord_cond,NULL,st_make(a,n),
			st_make(t,nt),func_name);
	  if (0>res2->type)				/* no result at all */
	    {
	    res2->type=tp_none;
	    DBUG_RETURN(res2);
	    }
	  else
	    {
	    insert_functype(func_name,a,n,t,nt,res2,kn_partial);	
	    res1=exe_func(ord->next,NULL,st_make(a,n),
			  st_make(t,nt),func_name);
	    if (res1->type==res2->type)
	      {
	      insert_functype(func_name,a,n,t,nt,res1,kn_partial);
	      st_free(w);
	      st_free(a);
	      st_free(t);
	      ftype.type=res1->type;
	      ftype.dat.desc=res1->dat.desc;
	      }
	    else
	      {
	      /* ungleiche Typen bei if then else !!! */
	      }
	    }
a707 1
      ord->args.n=0;
@


1.13
log
@plus_ii -> add_ii and working on real
@
text
@d12 6
a17 1
char *type_names[]={"none","int","bool","func","prim","real","string","clos"};
d49 1
a49 1
      strcpy(&d_str[strlen(d_str)],type_names[st_read(w,i)->type]);
d64 1
a64 1
      strcpy(&d_str[strlen(d_str)],type_names[st_read(t,i)->type]);
d607 1
a607 6
    case eq_ii:
    case ne_ii:
    case le_ii:
    case lt_ii:
    case ge_ii:
    case gt_ii:
d609 1
a609 1
      DBUG_PRINT("ORDERS",("eq//ne//le\tw:%d, a:%d, t:%d",
d613 64
a676 6
      stelm_free(st_pop(w));
      stelm_free(st_pop(w));
      d_stelm.type=tp_bool;
      d_stelm.dat.desc=NULL;
      w=st_push(w,&d_stelm);
      insert_restype(&d_stelm,ord);
d679 1
a679 3
    case add_ii:
    case minus_ii:
    case mult_ii:
d681 1
a681 1
      DBUG_PRINT("ORDERS",("add//minus//mult\tw:%d, a:%d, t:%d",
d685 1
a685 6
      stelm_free(st_pop(w));
      stelm_free(st_pop(w));
      d_stelm.type=tp_int;
      d_stelm.dat.desc=NULL;
      w=st_push(w,&d_stelm);
      insert_restype(&d_stelm,ord);
@


1.12
log
@minor bug removed
@
text
@d12 1
a12 1
char *type_names[]={"none","int","bool","func","prim","real","string","closure"};
d387 2
a388 1
	  TP_TYPES tp;
d392 2
a393 1
	  tp=func->type;
d411 1
a411 1
	    switch (tp)
d413 7
a419 21
	      case tp_func:
	        {
		res=do_func(clos->desc,ord,w,a,t,func_name,
			    clos->desc->label);
		for (j=0; j<clos->k; j++)
		  stelm_free(st_pop(t));
		i=i-clos->j;
		if (0!=i)
		  yyfail("%s","overloaded apply not yet implemented");
		break;
		}
	      case tp_prim:
		{
		/* noch viel zu tun */
		break;
		}
	      default:
		{
		yyfail("%s","unknown type for apply");
		break;
		}
d421 2
d438 1
a438 1
	  /* noch viel zu tun */
d621 1
a621 1
    case plus_ii:
d625 1
a625 1
      DBUG_PRINT("ORDERS",("plus//minus//mult\tw:%d, a:%d, t:%d",
d757 1
a757 1
	      /* ungleiche Typen bei if then else */
@


1.11
log
@stack handling with closures debugged
@
text
@d448 1
a448 4
	  switch(func->dat.prim)
	    {
	    case 
	    }
d609 1
a609 127
      switch (ord->args.primf)
	{
	case p_ge:
	case p_le:
	case p_lt:
	case p_gt:	    
	case p_eq:
	case p_ne:
	  {
	  STELM *a0, *a1;
	  
	  a0=st_pop(w);
	  a1=st_pop(w);
	  if ((tp_int==a0->type) && (tp_int==a1->type))
	    {
	    d_stelm.type=tp_bool;
	    d_stelm.dat.desc=NULL;
	    w=st_push(w,&d_stelm);
	    switch (ord->args.primf)
	      {
	      case p_ge:
		ord->command=ge_ii;
		break;
	      case p_gt:
		ord->command=gt_ii;
		break;
	      case p_le:
		ord->command=le_ii;
		break;
	      case p_lt:
		ord->command=lt_ii;
		break;
	      case p_eq:
		ord->command=eq_ii;
		break;
	      case p_ne:
		ord->command=ne_ii;
		break;
	      default:					/* not reachable */
		break;
	      }
	    insert_restype(&d_stelm,ord);
	    }
	  else
	    {
	    fprintf(stderr,"le//lt//ge//gt//ne//eq can't handle type != int!\n");
	    exit(0);
	    }
	  stelm_free(a0);
	  stelm_free(a1);
	  break;
	  }
	case p_minus:
	  {
	  STELM *a0, *a1;
	  
	  a0=st_pop(w);
	  a1=st_pop(w);
	  if ((tp_int==a0->type) && (tp_int==a1->type))
	    {
	    d_stelm.type=tp_int;
	    d_stelm.dat.desc=NULL;
	    w=st_push(w,&d_stelm);
	    ord->command=minus_ii;
	    insert_restype(&d_stelm,ord);
	    }
	  else
	    {
	    fprintf(stderr,"minus can't handle type != int!\n");
	    exit(0);
	    }
	  stelm_free(a0);
	  stelm_free(a1);
	  break;	  
	  }
	case p_plus:
	  {
	  STELM *a0, *a1;
	  
	  a0=st_pop(w);
	  a1=st_pop(w);
	  if ((tp_int==a0->type) && (tp_int==a1->type))
	    {
	    d_stelm.type=tp_int;
	    d_stelm.dat.desc=NULL;
	    w=st_push(w,&d_stelm);
	    ord->command=plus_ii;
	    insert_restype(&d_stelm,ord);
	    }
	  else
	    {
	    fprintf(stderr,"plus can't handle type != int!\n");
	    exit(0);
	    }
	  stelm_free(a0);
	  stelm_free(a1);  
	  break;	  
	  }
	case p_mult:
	  {
	  STELM *a0, *a1;
	  
	  a0=st_pop(w);
	  a1=st_pop(w);
	  if ((tp_int==a0->type) && (tp_int==a1->type))
	    {
	    d_stelm.type=tp_int;
	    d_stelm.dat.desc=NULL;
	    w=st_push(w,&d_stelm);
	    ord->command=mult_ii;
	    insert_restype(&d_stelm,ord);
	    }
	  else
	    {
	    fprintf(stderr,"mult can't handle type != int!\n");
	    exit(0);
	    }
	  stelm_free(a0);
	  stelm_free(a1);
	  break;	  
	  }
	default:
	  {
	  fprintf(stderr,"unkown primitiv function!\n");
	  exit(0);
	  }
	}
@


1.10
log
@minor bug in apply removed
@
text
@d12 1
a12 1
char *type_names[]={"none","int","bool","func","real","string","closure"};
a16 1

d91 1
a91 1
	st_pop(w);
d136 1
a136 1
	  st_pop(w);
d152 1
a152 1
      st_pop(w);
a156 2
/*    free(ftype);
    ftype=result; */
d183 15
d222 11
d270 1
a270 1
      free(arg);
d283 1
a283 1
      free(arg);
d288 2
d294 3
a296 1
      w=st_push(w,st_pop(a));
d301 2
d307 3
a309 1
      t=st_push(t,st_pop(a));
d346 1
a346 1
	      free(result);
d368 1
a368 1
	    free(result);
d379 1
a379 7
	  free(result);
      
/*	  if ((tp_doagain==result->type) || (tp_badrecur==result->type))
	    DBUG_RETURN(result);
	  ftype.type=result->type;
	  ftype.dat.desc=result->dat.desc;
	  free(result); 				*/
d385 3
a387 1
	  STELM *res;
d390 43
a432 18
	  for (i=0; i<func->dat.clos->i; i++)
	    w=st_push(w,&(func->dat.clos->w[i]));
	  if (NULL!=func->dat.clos->w)
	    free(func->dat.clos->w);
	  i=func->dat.clos->i+ord->args.n;		/* new number of args */
	  if (func->dat.clos->j<=i) 			/* got all args */
	    {
	    for (j=0; j<func->dat.clos->k; j++)
	      t=st_push(t,&(func->dat.clos->t[j]));
	    if (func->dat.clos->t)
	      free(func->dat.clos->t);
	    res=do_func(func->dat.clos->desc,ord,w,a,t,func_name,
			func->dat.clos->desc->label);
	    for (j=0; j<func->dat.clos->k; j++)
	      st_pop(t);
	    i=i-func->dat.clos->j;
	    if (0!=i)
	      yyfail("%s","overloaded apply not yet implemented");
d436 2
a437 2
	    func->dat.clos->i=i;
	    if(NULL==(func->dat.clos->w=malloc(sizeof(STELM)*i)))
d439 12
a450 1
	    memcpy(func->dat.clos->w,&(w->stack[w->topofstack-i]),i*sizeof(STELM));
d460 1
d478 1
a478 1
      da=st_make(w,(NULL==a) ? 0 : a->topofstack);
d493 1
a493 1
	  free(result);
d515 1
a515 1
	free(result);
d526 34
a559 1
      free(result);
d584 1
a584 1
	memcpy(clos->w,&(w->stack[w->topofstack-clos->i]),clos->i*sizeof(STELM));
d586 1
a586 1
	  st_pop(w);
d594 1
a594 1
	memcpy(clos->t,&(t->stack[t->topofstack-clos->k]),clos->k*sizeof(STELM));
d596 1
a596 1
	  st_pop(t);
d603 1
d660 2
d683 2
d706 2
d729 2
d752 2
a753 2
      st_pop(w);
      st_pop(w);
d768 2
a769 2
      st_pop(w);
      st_pop(w);
d796 1
d913 1
a913 1
	st_pop(a);
d925 1
a925 1
	st_pop(t);
d942 1
d989 1
@


1.9
log
@bugs removed
@
text
@d286 2
d298 3
d302 7
a308 2
	  result=do_func(func->dat.desc,ord,w,a,t,func_name,func->dat.desc->label);
	  if ((tp_doagain==result->type) || (tp_badrecur==result->type))
d310 36
d349 6
@


1.8
log
@some functions moved to tiny
@
text
@d79 3
a81 15
      if (NULL!=w)
	{
	free(w->stack);
        free(w);
	}
      if (NULL!=a)
	{
	free(a->stack);
        free(a);
	}
      if (NULL!=t)
	{
	free(t->stack);
        free(t);
	}
d83 1
a83 1
      if (0!=state)
d117 3
d123 1
a123 1
	  DBUG_RETURN(new_stelm(tp_doagain,NULL));
a128 1
	  break;
d130 1
d158 2
d163 3
a165 15
    if (NULL!=w)
      {
      free(w->stack);
      free(w);
      }
    if (NULL!=a)
      {
      free(a->stack);
      free(a);
      }
    if (NULL!=t)
      {
      free(t->stack);
      free(t);
      }
d352 1
a352 1
      STACK *dw, *dt;
d362 1
d366 5
a370 1
      if ((tp_doagain==result->type) || (tp_badrecur==result->type))
d372 25
d404 4
a407 1
	}	
d618 1
d643 1
a643 1
	if (0==ord->args.n)				/* no recursion */
d677 4
a680 16
		  insert_functype(func_name,a,n,t,nt,res1,kn_partial);
		  if (NULL!=w)
		    {
		    free(w->stack);
		    free(w);
		    }
		  if (NULL!=a)
		    {
		    free(a->stack);
		    free(a);
		    }
		  if (NULL!=t)
		    {
		    free(t->stack);
		    free(t);
		    }
d689 1
d699 3
a701 15
		if (NULL!=w)
		  {
		  free(w->stack);
		  free(w);
		  }
		if (NULL!=a)
		  {
		  free(a->stack);
		  free(a);
		  }
		if (NULL!=t)
		  {
		  free(t->stack);
		  free(t);
		  }
d729 3
a731 15
	      if (NULL!=w)
		{
		free(w->stack);
		free(w);
		}
	      if (NULL!=a)
		{
		free(a->stack);
		free(a);
		}
	      if (NULL!=t)
		{
		free(t->stack);
		free(t);
		}
d778 3
a780 15
      if (NULL!=w)
	{
	free(w->stack);
	free(w);
	}
      if (NULL!=a)
	{
	free(a->stack);
	free(a);
	}
      if (NULL!=t)
	{
	free(t->stack);
	free(t);
	}
d791 3
a793 15
      if (NULL!=w)
	{
	free(w->stack);
	free(w);
	}
      if (NULL!=a)
	{
	free(a->stack);
	free(a);
	}
      if (NULL!=t)
	{
	free(t->stack);
	free(t);
	}
d804 3
a806 15
      if (NULL!=w)
	{
	free(w->stack);
	free(w);
	}
      if (NULL!=a)
	{
	free(a->stack);
	free(a);
	}
      if (NULL!=t)
	{
	free(t->stack);
	free(t);
	}
@


1.7
log
@fixed arity orders removed
@
text
@d15 1
a15 1
char *vtis=VTIS;
d36 1
a36 1
if (hash!=beta_fun->command)
d38 1
a38 1
  if (0<n)
d53 1
a53 1
  if (0<nt)
d74 1
a74 2
  if ((NULL!=func_name) && 
      (0==(strcmp(label,func_name))))		/* recursiv */
d76 1
a76 1
    if (NULL==(result=get_result(label,w,n,t,nt))) /* result unknown ? */
d95 4
a98 1
      DBUG_RETURN(new_stelm(tp_doagain,NULL));
d100 1
a100 1
    else						/* result known */
d107 1
a107 1
      w=st_push(w,result);
d111 1
a111 1
  else						/* no single recursion */
d113 4
a116 4
    if (tp_badrecur!=((result=exe_func(beta_fun,NULL,st_make(w,n),
				       st_make(t,nt),label))->type))
      {					/* no problems (-tp_doagain) */
      if (0>result->type)
d118 3
a120 3
	result->type=tp_none;
        insert_restype(result,ord);
	insert_restype(result,badrecord);
d122 4
a125 6
      else
	insert_restype(result,ord);
      while (0!=n)
        {
        st_pop(w);
        n--;
d127 13
a139 8
      w=st_push(w,result);
      }
    else					/* tp_badrecur problem */
      {
      if (badrecord==ord)
        {
	ord->args.m=0;
	DBUG_RETURN(new_stelm(tp_doagain,NULL));
d141 1
a141 1
      else
d143 9
a151 3
	ord->args.m=0;
        DBUG_RETURN(new_stelm(tp_badrecur,NULL));
	}
d155 1
a155 1
else				/* I was here before! */
d168 1
a168 1
  else
a193 279
/* searches for object address in FUNLIST and DATA			*/
/* (used by exe_func)							*/
/************************************************************************/
STELM *find_address(void *adr)
{
STELM *res=NULL;
FUNDESC *froot;
DATANODE *data;

DBUG_ENTER("find_address");
froot=program_start->desc;
while ((NULL!=froot) && (NULL==res))
  {
  if (froot->address==(int)adr)
    res=new_stelm(tp_func,froot);
  else
    froot=froot->next;
  }
data=program_start->data;
while ((NULL!=data) && (NULL==res))
  {
  if (data->address==(int)adr)
    {
    switch (data->tag)
      {
      case d_list:
	break;
      case d_real:
	{
        res=new_stelm(tp_real,NULL);
	break;
	}
      case d_mat:
	break;
      case d_vect:
	break;
      case d_tvect:
	break;
      case d_string:
	{
        res=new_stelm(tp_string,NULL);
	break;
	}
      default:
	{
        yyfail("%s","unknown type in datanode");
	break;
	}
      }
    }
  else
    data=data->next;
  }
DBUG_RETURN(res);
}
  
/************************************************************************/
/* inserts restype as hash in orderlist					*/
/* (used by exe_func)							*/
/************************************************************************/
void insert_restype(STELM *res, ORDER *o)
{
ORDER *ord;
char str[MAX_LINE_LENGTH], *ds;

DBUG_ENTER("insert_restype");
if (hash!=o->prev->command)
  {
  sprintf(str,"#restype %s",type_names[res->type]);
  if (NULL==(ds=malloc(strlen(str)+1)))
    yyfail("%s","no memory for hash-string!");
  strcpy(ds,str);
  DBUG_PRINT("ORDERS",("%s",ds));
  ord=new_order(hash,ds);
  insert_order_list(ord,o);
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* searches for functionresult in functionresultlist and returns type	*/
/* of function.								*/
/* (used by exe_func)							*/
/************************************************************************/
STELM *get_result(char *s, STACK *a, long n, STACK *t, long nt)
{
STELM *res=NULL;
FUNLIST *flp;
FUNTYPES *ft;

DBUG_ENTER("get_result");
DBUG_PRINT("FUNLIST",("->Fun: %s Par.: %d TPar.: %d",s,n,nt));
flp=searchfunlist(s);
if (NULL!=flp)
  {
  ft=searchftypes(flp->funtypes, 
		  (0==n) ? NULL : &(a->stack[a->topofstack-n]), 
		  (0==nt) ? NULL : &(t->stack[t->topofstack-nt]),n,nt);
  if (NULL!=ft)
    res=&(ft->result);
  }
DBUG_PRINT("FUNLIST",("<-Result: %d",(NULL==res) ? tp_illegal : res->type));
DBUG_RETURN(res);
}

/************************************************************************/
/* searches for function in functionlist and returns pointer of		*/
/* function.								*/
/* (used by exe_func)							*/
/************************************************************************/
FUNTYPES *searchftypes(FUNTYPES *ft, STELM *a, STELM *t, long n, long nt)
{
char found=0;

DBUG_ENTER("searchftypes");
DBUG_PRINT("FUNLIST",("->Par.: %d TPar.: %d",n,nt));
while ((NULL!=ft) && (0==found))
  {
  if (((0==n) || (0==memcmp(a,ft->params,n))) && ((0==nt) || (0==memcmp(t,ft->tparams,nt))))
    found=1;
  else
    ft=ft->next;
  }
DBUG_PRINT("FUNLIST",("<-Res.: %s",(NULL==ft) ? "not found" : "found"));
DBUG_RETURN(ft);
}

/************************************************************************/
/* searches for function in functionlist and returns pointer of		*/
/* function.								*/
/* (used by exe_func)							*/
/************************************************************************/
FUNLIST *searchfunlist(char *name)
{
char found=0;
FUNLIST *root=flbase;

DBUG_ENTER("searchfunlist");
DBUG_PRINT("FUNLIST",("->Fun. Name: %s",name));
while ((NULL!=root) && (0==found))
  {
  if (0==strcmp(root->name,name))
    found=1;
  else
    root=root->next;
  }
DBUG_PRINT("FUNLIST",("<-Res.: %s",(NULL==root) ? "not found" : "found"));
DBUG_RETURN(root);
}

/************************************************************************/
/* checks and inserts new/old functiontype in FUNLIST			*/
/* (used by exe_func)							*/
/************************************************************************/
void insert_functype(char *name, STACK *a, long n, STACK *t, long nt, 
		     STELM *res, char kn)
{
FUNLIST *flp;
FUNTYPES *ft;

DBUG_ENTER("insert_functype");
DBUG_PRINT("FUNLIST",("->Fun. Name: %s Par.: %d TPar.: %d Res.: %d",name,n,nt,
		      (NULL==res) ? tp_illegal :res->type));
flp=searchfunlist(name);
if (NULL==flp)
  {
  if (NULL==(flp=malloc(sizeof(FUNLIST))))
    yyfail("%s","no memory for functionlist!");
  if (NULL==(flp->name=malloc(strlen(name)+1)))
    yyfail("%s","no memory for funtion name!");
  strcpy(flp->name,name);
  flp->a=n;
  flp->t=nt;
  flp->next=flbase;
  flbase=flp;
  flp->funtypes=NULL;
  }
ft=searchftypes(flp->funtypes, (NULL==a) ? NULL : &(a->stack[a->topofstack-n]),
		(NULL==t) ? NULL : &(t->stack[t->topofstack-nt]), n, nt);
if (NULL==ft)
  {
  if (NULL==(ft=malloc(sizeof(FUNTYPES))))
    yyfail("%s","no memory for function parameters!");
  ft->next=flp->funtypes;
  flp->funtypes=ft;
  if (0<n)
    {
    if (NULL==(ft->params=malloc(n*sizeof(STELM))))
      yyfail("%s","no memory for function parameters!");
    memcpy(ft->params,&(a->stack[a->topofstack-n]),n*sizeof(STELM));
    }
  else
    ft->params=NULL;
  if (0<nt)
    {
    if (NULL==(ft->tparams=malloc(nt*sizeof(STELM))))
      yyfail("%s","no memory for function parameters!");
    memcpy(ft->tparams,&(t->stack[t->topofstack-nt]),nt*sizeof(STELM));
    }
  else
    ft->tparams=NULL;
  ft->result.type=res->type;
  ft->result.dat.desc=res->dat.desc;
  ft->knowledge=kn;
  DBUG_PRINT("FUNLIST",("<-new entry in FUNLIST %s %d %d %d",name,n,nt,
			(NULL==res) ? tp_illegal : res->type));
  }
else
  {
  if (ft->result.type==res->type)			/* reassign knowledge */
    {
    switch (kn)
      {
      case kn_sure:
	{
	ft->knowledge=kn_sure;
	break;
	}
      case kn_partial:
	{
	if (kn_preset==ft->knowledge)
	  ft->knowledge=kn_partial;
        break;
	}
      case kn_preset:
	{
	break;
	}
      }
    }
  else
    {
    if (kn_preset!=ft->knowledge)    /* old restype != newrestype */
      {
      /* to be continued */
      }
    else
      {
      fprintf(stderr,"warning: type conflict with preset type!\n");
      }
    }
  }
DBUG_VOID_RETURN;
}

/************************************************************************/
/* checks for "#restype " and return position behind it			*/
/* (used by gethash_restype)						*/
/************************************************************************/
char *check_restype(char *s)
{
DBUG_ENTER("check_restype");
if (0==strncmp(s,"#restype ",9))
  s=&s[9];
else
  s=NULL;
DBUG_RETURN(s);
}

/************************************************************************/
/* if exists returns restype of function drawn from hash		*/
/* (used by execution)							*/
/************************************************************************/
STELM *gethash_restype(ORDER *ord)
{
char *s;
int i;

DBUG_ENTER("gethash_restype");
if ((hash==ord->command) && (NULL!=(s=check_restype(ord->args.hash_str))))
  {
  for (i=1; i<=tps_number; i++)
    if (0==strcmp(s, type_names[i]))
	DBUG_RETURN(new_stelm(i,NULL));
  }
DBUG_RETURN((STELM *)NULL);
}  

/************************************************************************/
d371 2
d379 5
a383 2
      result=do_func(find_desc(root->desc,ord->args.label),ord,w,a,t,
		     func_name,ord->args.label);
d386 8
d450 1
d452 2
a453 20
	  {
	  STELM *a0, *a1;
	  
	  a0=st_pop(w);
	  a1=st_pop(w);
	  if ((tp_int==a0->type) && (tp_int==a1->type))
	    {
	    d_stelm.type=tp_bool;
	    d_stelm.dat.desc=NULL;
	    w=st_push(w,&d_stelm);
	    ord->command=le_ii;
	    insert_restype(&d_stelm,ord);
	    }
	  else
	    {
	    fprintf(stderr,"le can't handle type != int!\n");
	    exit(0);
	    }
	  break;
	  }
a454 20
	  {
	  STELM *a0, *a1;
	  
	  a0=st_pop(w);
	  a1=st_pop(w);
	  if ((tp_int==a0->type) && (tp_int==a1->type))
	    {
	    d_stelm.type=tp_bool;
	    d_stelm.dat.desc=NULL;
	    w=st_push(w,&d_stelm);
	    ord->command=eq_ii;
	    insert_restype(&d_stelm,ord);
	    }
	  else
	    {
	    fprintf(stderr,"eq can't handle type != int!\n");
	    exit(0);
	    }
	  break;
	  }
d466 23
a488 1
	    ord->command=ne_ii;
d493 1
a493 1
	    fprintf(stderr,"ne can't handle type != int!\n");
d572 3
d628 1
a628 5
	res1=exe_func(ord->next,NULL,st_make(a,n),
		      st_make(t,nt),func_name);
	if (tp_badrecur==res1->type)
	  DBUG_RETURN(res1);
	if (tp_doagain!=res1->type)
d630 3
a632 2
	  insert_functype(func_name,a,n,t,nt,res1,kn_partial);
	  res2=exe_func(ord_cond,NULL,st_make(a,n),
d634 1
a634 1
	  if (res1->type==res2->type)
d636 1
a636 2
	    insert_functype(func_name,a,n,t,nt,res1,kn_sure);
	    if (NULL!=w)
d638 2
a639 2
	      free(w->stack);
	      free(w);
d641 1
a641 1
	    if (NULL!=a)
d643 2
a644 2
	      free(a->stack);
	      free(a);
d646 1
a646 1
	    if (NULL!=t)
d648 38
a685 2
	      free(t->stack);
	      free(t);
d687 31
a717 6
	    ftype.type=res1->type;
	    ftype.dat.desc=res1->dat.desc;
	    }
	  else
	    {
	    /* ungleiche Typen bei if then else */
d720 1
a720 1
	else	
d724 6
a729 4
	  insert_functype(func_name,a,n,t,nt,res2,kn_partial);	
	  res1=exe_func(ord->next,NULL,st_make(a,n),
			st_make(t,nt),func_name);
	  if (res1->type==res2->type)
d731 4
a734 7
	    insert_functype(func_name,a,n,t,nt,res1,kn_partial);
	    if (NULL!=w)
	      {
	      free(w->stack);
	      free(w);
	      }
	    if (NULL!=a)
d736 18
a753 2
	      free(a->stack);
	      free(a);
d755 1
a755 1
	    if (NULL!=t)
d757 1
a757 2
	      free(t->stack);
	      free(t);
a758 6
	    ftype.type=res1->type;
	    ftype.dat.desc=res1->dat.desc;
	    }
	  else
	    {
	    /* ungleiche Typen bei if then else */
d762 1
@


1.6
log
@minor bugs removed
@
text
@a496 9
    case pushaw0:
      {
      DBUG_PRINT("ORDERS",("pushaw0\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      w=st_push(w,st_read(a,0));
      break;
      }
a505 9
    case pushtw0:
      {
      DBUG_PRINT("ORDERS",("pushtw0\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      w=st_push(w,st_read(t,0));
      break;
      }
a523 9
    case pushar0:
      {
      DBUG_PRINT("ORDERS",("pushar0\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      t=st_push(t,st_read(a,0));
      break;
      }      
a965 9
    case free1a:
      {
      DBUG_PRINT("ORDERS",("free1a\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      st_pop(a);
      break;
      }
a987 9
      break;
      }      
    case free1swt:
      {
      DBUG_PRINT("ORDERS",("free1swt\tw:%d, a:%d, t:%d",
			   (NULL==w) ? NULL : w->topofstack,
			   (NULL==a) ? NULL : a->topofstack,
			   (NULL==t) ? NULL : t->topofstack));
      st_pop(t);
@


1.5
log
@never ending recursion bugfixed
@
text
@d12 1
a12 1
char *type_names[]={"none", "int", "bool", "func"};
d109 1
a109 1
  else					/* no single recursion */
d129 1
a129 1
    else				/* tp_badrecur problem */
d175 1
a175 1
    ftype->desc=NULL;
d190 1
d201 35
d385 1
a385 1
  ft->result.desc=res->desc;
d482 1
a482 1
      d_stelm.desc=NULL;
d493 1
a493 1
      d_stelm.desc=NULL;
d542 9
d564 13
d606 1
a606 1
      if (tp_func==func->type)
d608 50
a657 7
	ord->command=apply_f;
	result=do_func(func->desc,ord,w,a,t,func_name,func->desc->label);
        if ((tp_doagain==result->type) || (tp_badrecur==result->type))
	  DBUG_RETURN(result);
        ftype.type=result->type;
        ftype.desc=result->desc;
        free(result);
a658 2
      else
	yyfail("%s","can't handle apply without function!");
d677 1
a677 1
      ftype.desc=result->desc;
d681 43
d741 1
a741 1
	    d_stelm.desc=NULL;
d762 1
a762 1
	    d_stelm.desc=NULL;
d783 1
a783 1
	    d_stelm.desc=NULL;
d804 1
a804 1
	    d_stelm.desc=NULL;
d825 1
a825 1
	    d_stelm.desc=NULL;
d846 1
a846 1
	    d_stelm.desc=NULL;
d877 1
a877 1
      d_stelm.desc=NULL;
d893 1
a893 1
      d_stelm.desc=NULL;
d950 1
a950 1
	    ftype.desc=res1->desc;
d983 1
a983 1
	    ftype.desc=res1->desc;
d1060 1
a1060 1
      ftype.desc=res->desc;
d1085 1
a1085 1
      ftype.desc=NULL;
d1110 1
a1110 1
      ftype.desc=NULL;
d1130 1
a1130 1
      ftype.desc=res->desc;
d1151 1
a1151 1
DBUG_RETURN(new_stelm(ftype.type,ftype.desc));
@


1.4
log
@apply works with recursion
@
text
@d95 1
d114 8
a121 1
      insert_restype(result,ord);
d537 2
d550 1
@


1.3
log
@apply to not recursiv func added
@
text
@d19 1
a19 1
/* searches for object adress in FUNLIST and DATA			*/
d22 156
d187 1
a187 1
  if (froot->adress==(int)adr)
d414 1
a414 1
DBUG_RETURN(new_stelm(tp_illegal,NULL));
d531 1
a531 4
      STELM *func;
      ORDER *ap_ord,*o;
      long i,n;
      char *str, d_str[MAX_LINE_LENGTH];
d540 6
a545 28
	ap_ord=find_func(program_start->function,func->desc->label);
	n=func->desc->nv;
        if (hash!=ap_ord->command)
	  {
	  if (0<n)
	    {
	    strcpy(d_str,"#args");
	    for (i=0; i<n; i++)
	      {
	      d_str[strlen(d_str)+1]=0;
	      d_str[strlen(d_str)]=' ';
	      strcpy(&d_str[strlen(d_str)],type_names[st_read(w,i)->type]);
	      }
	    if (NULL==(str=malloc(strlen(d_str)+1)))
	      yyfail("%s","no memory for argshash!");
	    strcpy(str,d_str);
	    o=new_order(hash,str);
	    insert_order_list(o,ap_ord);
	    }
	  }
	func=exe_func(ap_ord,NULL,st_make(w,func->desc->nv),NULL,func->desc->label);
	insert_restype(func,ord);
	while (0!=n)
	  {
	  st_pop(w);
	  n--;
	  }
	w=st_push(w,func);
d555 1
a555 5
      STELM *func_res, *result;
      char d_str[MAX_LINE_LENGTH], *str;
      int n, nt, i;
      FUNDESC *des;
      ORDER *beta_fun, *o;
d562 7
a568 118
      des=find_desc(root->desc, ord->args.label);
      beta_fun=find_func(root->function,ord->args.label);
      n=des->nv;
      nt=des->nfv;
      if (hash!=beta_fun->command)
	{
	if (0<n)
	  {
	  strcpy(d_str,"#args");
	  for (i=0; i<n; i++)
	    {
	    d_str[strlen(d_str)+1]=0;
	    d_str[strlen(d_str)]=' ';
	    strcpy(&d_str[strlen(d_str)],type_names[st_read(w,i)->type]);
	    }
	  if (NULL==(str=malloc(strlen(d_str)+1)))
	    yyfail("%s","no memory for argshash!");
	  strcpy(str,d_str);
	  o=new_order(hash,str);
	  insert_order_list(o,beta_fun);
	  }
	if (0<nt)
	  {
	  strcpy(d_str,"#tildeargs");
	  for (i=0; i<nt; i++)
	    {
	    d_str[strlen(d_str)+1]=0;
	    d_str[strlen(d_str)]=' ';
	    strcpy(&d_str[strlen(d_str)],type_names[st_read(t,i)->type]);
	    }
	  if (NULL==(str=malloc(strlen(d_str)+1)))
	    yyfail("%s","no memory for tildeargshash!");
	  strcpy(str,d_str);
	  o=new_order(hash,str);
	  insert_order_list(o,beta_fun);
	  }
	}
      if (ord->args.n==0)		/* first call from here */
	{
	ord->args.n=1;
	if (tp_illegal!=(func_res=gethash_restype(ord->prev))->type)
	  insert_functype(ord->args.label,w,n,t,nt,func_res,kn_preset);
	if ((NULL!=func_name) && (0==(strcmp(ord->args.label, func_name))))	/* recursiv */
	  {
	  if (NULL==(result=get_result(ord->args.label, w, n, t, nt)))
	    {
	    ord->args.n=0;
	    if (NULL!=w)
	      free(w);
	    if (NULL!=a)
	      free(a);
	    if (NULL!=t)
	      free(t);
	    DBUG_RETURN(new_stelm(tp_illegal,NULL));
	    }
	  else
	    {
	    insert_functype(ord->args.label,w,n,t,nt,result,kn_sure);
	    while (0!=n)
	      {
	      st_pop(w);
	      n--;
	      }
	    w=st_push(w, result);
	    insert_restype(result,ord);
	    }
	  }
	else				/* no recursion */
	  {
	  if (tp_badrecur!=((result=exe_func(beta_fun,NULL,st_make(w,n),
					     st_make(t,nt),ord->args.label))->type))
	    {
	    insert_restype(result,ord);
	    while (0!=n)
	      {
	      st_pop(w);
	      n--;
	      }
	    w=st_push(w, result);
	    }
	  else
	    {
	    if (badrecord==ord)
	      {
	      ord->args.n=0;
	      DBUG_RETURN(new_stelm(tp_illegal,NULL));
	      }
	    else
	      DBUG_RETURN(new_stelm(tp_badrecur,NULL));
	    }
	  }
	}
      else				/* I was here before! */
	{
	result=get_result(ord->args.label, w, n, t, nt);
	if (NULL!=result)
	  {
	  while (0!=n)
	    {
	    st_pop(w);
	    n--;
	    }
	  w=st_push(w, result);
	  insert_restype(result,ord);
	  }
	else
	  {
	  if (NULL!=w)
	    free(w);
	  if (NULL!=a)
	    free(a);
	  if (NULL!=t)
	    free(t);
	  ftype.type=tp_badrecur;
	  ftype.desc=NULL;
	  badrecord=ord;
	  }
	}
d773 1
a773 1
	if (tp_illegal!=res1->type)
d782 2
d785 1
d787 2
d790 1
d792 2
d795 1
d815 2
d818 1
d820 2
d823 1
d825 2
d828 1
d892 2
d895 1
d897 2
d900 1
d902 2
d905 1
d917 2
d920 1
d922 2
d925 1
d927 2
d930 1
d942 2
d945 1
d947 2
d950 1
d952 2
d955 1
@


1.2
log
@*** empty log message ***
@
text
@d84 1
a84 1
DBUG_PRINT("FUNLIST",("<-Result: %d",res->type));
d144 2
a145 1
DBUG_PRINT("FUNLIST",("->Fun. Name: %s Par.: %d TPar.: %d Res.: %d",name,n,nt,res));
d187 2
a188 1
  DBUG_PRINT("FUNLIST",("<-new entry in FUNLIST %s %d %d %d",name,n,nt,res));
d352 1
d376 3
d387 28
a414 1
				/* noch viel zu tun!!! */
d813 12
@


1.1
log
@Initial revision
@
text
@d497 1
a497 1
	if (tp_illegal!=result->type)
@
