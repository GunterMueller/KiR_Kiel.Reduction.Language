head	1.79;
access;
symbols
	continuation_based_interactions:1.55
	pre_interactions:1.53
	nCUBE~:1.49
	red2:1.4
	red1:1.1;
locks; strict;
comment	@ * @;


1.79
date	2001.07.02.15.07.36;	author base;	state Exp;
branches;
next	1.78;

1.78
date	99.11.25.11.58.18;	author rs;	state Exp;
branches;
next	1.77;

1.77
date	98.09.30.08.30.41;	author rs;	state Exp;
branches;
next	1.76;

1.76
date	98.09.24.13.12.10;	author rs;	state Exp;
branches;
next	1.75;

1.75
date	98.09.13.15.30.30;	author rs;	state Exp;
branches;
next	1.74;

1.74
date	98.06.03.16.20.07;	author rs;	state Exp;
branches;
next	1.73;

1.73
date	98.03.31.09.54.42;	author rs;	state Exp;
branches;
next	1.72;

1.72
date	98.02.27.15.00.48;	author rs;	state Exp;
branches;
next	1.71;

1.71
date	98.02.18.13.34.36;	author rs;	state Exp;
branches;
next	1.70;

1.70
date	97.11.24.08.19.48;	author rs;	state Exp;
branches;
next	1.69;

1.69
date	97.06.06.09.05.59;	author rs;	state Exp;
branches;
next	1.68;

1.68
date	97.04.14.09.52.06;	author rs;	state Exp;
branches;
next	1.67;

1.67
date	97.02.17.13.18.12;	author rs;	state Exp;
branches;
next	1.66;

1.66
date	96.05.20.17.12.37;	author cr;	state Exp;
branches;
next	1.65;

1.65
date	96.05.07.09.29.53;	author cr;	state Exp;
branches;
next	1.64;

1.64
date	96.03.25.14.39.22;	author cr;	state Exp;
branches;
next	1.63;

1.63
date	96.03.19.14.16.17;	author rs;	state Exp;
branches;
next	1.62;

1.62
date	96.03.07.18.16.17;	author rs;	state Exp;
branches;
next	1.61;

1.61
date	96.02.15.15.38.24;	author cr;	state Exp;
branches;
next	1.60;

1.60
date	96.01.11.10.51.39;	author rs;	state Exp;
branches;
next	1.59;

1.59
date	96.01.10.13.00.04;	author rs;	state Exp;
branches;
next	1.58;

1.58
date	95.12.14.16.52.35;	author rs;	state Exp;
branches;
next	1.57;

1.57
date	95.11.21.14.50.11;	author stt;	state Exp;
branches;
next	1.56;

1.56
date	95.11.15.15.07.49;	author cr;	state Exp;
branches;
next	1.55;

1.55
date	95.10.27.15.37.48;	author rs;	state Exp;
branches;
next	1.54;

1.54
date	95.09.12.14.30.03;	author stt;	state Exp;
branches;
next	1.53;

1.53
date	95.07.10.14.09.40;	author rs;	state Exp;
branches;
next	1.52;

1.52
date	95.07.03.11.40.38;	author car;	state Exp;
branches;
next	1.51;

1.51
date	95.07.03.09.46.08;	author car;	state Exp;
branches;
next	1.50;

1.50
date	95.05.22.09.30.32;	author rs;	state Exp;
branches;
next	1.49;

1.49
date	95.04.06.14.25.52;	author rs;	state Exp;
branches;
next	1.48;

1.48
date	95.04.05.14.19.39;	author rs;	state Exp;
branches;
next	1.47;

1.47
date	95.03.01.16.51.02;	author rs;	state Exp;
branches;
next	1.46;

1.46
date	95.02.28.16.59.21;	author rs;	state Exp;
branches;
next	1.45;

1.45
date	95.02.28.08.51.29;	author rs;	state Exp;
branches;
next	1.44;

1.44
date	95.02.23.14.06.04;	author rs;	state Exp;
branches;
next	1.43;

1.43
date	95.02.22.15.51.20;	author rs;	state Exp;
branches;
next	1.42;

1.42
date	95.02.16.16.35.51;	author rs;	state Exp;
branches;
next	1.41;

1.41
date	95.02.15.15.51.00;	author rs;	state Exp;
branches;
next	1.40;

1.40
date	95.02.14.16.03.30;	author rs;	state Exp;
branches;
next	1.39;

1.39
date	95.02.10.14.44.22;	author rs;	state Exp;
branches;
next	1.38;

1.38
date	95.02.09.16.14.27;	author rs;	state Exp;
branches;
next	1.37;

1.37
date	95.02.08.15.34.52;	author rs;	state Exp;
branches;
next	1.36;

1.36
date	95.02.07.15.49.23;	author rs;	state Exp;
branches;
next	1.35;

1.35
date	95.01.31.14.49.12;	author rs;	state Exp;
branches;
next	1.34;

1.34
date	95.01.19.10.17.20;	author rs;	state Exp;
branches;
next	1.33;

1.33
date	95.01.13.16.42.43;	author rs;	state Exp;
branches;
next	1.32;

1.32
date	95.01.11.14.55.35;	author rs;	state Exp;
branches;
next	1.31;

1.31
date	95.01.10.16.28.13;	author rs;	state Exp;
branches;
next	1.30;

1.30
date	95.01.09.15.50.09;	author rs;	state Exp;
branches;
next	1.29;

1.29
date	95.01.06.16.32.27;	author rs;	state Exp;
branches;
next	1.28;

1.28
date	95.01.03.15.17.24;	author rs;	state Exp;
branches;
next	1.27;

1.27
date	95.01.03.11.13.47;	author rs;	state Exp;
branches;
next	1.26;

1.26
date	94.12.21.15.01.47;	author rs;	state Exp;
branches;
next	1.25;

1.25
date	94.12.02.08.45.17;	author car;	state Exp;
branches;
next	1.24;

1.24
date	94.11.02.10.01.34;	author rs;	state Exp;
branches;
next	1.23;

1.23
date	94.10.21.15.13.05;	author rs;	state Exp;
branches;
next	1.22;

1.22
date	94.10.21.13.29.56;	author rs;	state Exp;
branches;
next	1.21;

1.21
date	94.09.13.11.46.26;	author rs;	state Exp;
branches;
next	1.20;

1.20
date	94.06.16.14.24.18;	author mah;	state Exp;
branches;
next	1.19;

1.19
date	94.06.14.13.59.43;	author mah;	state Exp;
branches;
next	1.18;

1.18
date	94.05.24.13.21.30;	author ach;	state Exp;
branches;
next	1.17;

1.17
date	94.05.16.11.41.50;	author ach;	state Exp;
branches;
next	1.16;

1.16
date	94.05.06.12.23.24;	author ach;	state Exp;
branches;
next	1.15;

1.15
date	94.05.05.10.01.46;	author rs;	state Exp;
branches;
next	1.14;

1.14
date	94.05.04.07.02.52;	author ach;	state Exp;
branches;
next	1.13;

1.13
date	94.05.03.12.52.54;	author rs;	state Exp;
branches;
next	1.12;

1.12
date	94.05.03.07.30.24;	author mah;	state Exp;
branches;
next	1.11;

1.11
date	94.03.29.17.29.16;	author mah;	state Exp;
branches;
next	1.10;

1.10
date	94.03.08.18.12.23;	author mah;	state Exp;
branches;
next	1.9;

1.9
date	94.02.23.15.56.15;	author mah;	state Exp;
branches;
next	1.8;

1.8
date	94.02.09.13.43.06;	author mah;	state Exp;
branches;
next	1.7;

1.7
date	94.01.18.08.43.55;	author mah;	state Exp;
branches;
next	1.6;

1.6
date	93.12.09.08.31.54;	author mah;	state Exp;
branches;
next	1.5;

1.5
date	93.11.25.14.10.40;	author mah;	state Exp;
branches;
next	1.4;

1.4
date	93.10.28.14.07.26;	author rs;	state Exp;
branches;
next	1.3;

1.3
date	93.09.01.12.37.17;	author base;	state Exp;
branches;
next	1.2;

1.2
date	92.12.16.12.50.04;	author rs;	state Exp;
branches;
next	1.1;

1.1
date	92.11.04.18.12.30;	author base;	state Exp;
branches;
next	;


desc
@original
@


1.79
log
@compiler warnings eliminated
@
text
@/*
 * $Log: rinter.c,v $
 * Revision 1.78  1999/11/25 11:58:18  rs
 * more DEBUG output
 *
 * Revision 1.77  1998/09/30 08:30:41  rs
 * minor bugfixes in the speculative tickets version
 *
 * Revision 1.76  1998/09/24 13:12:10  rs
 * bugfixed version for SPEC_TICKETS + some more features
 *
 * Revision 1.75  1998/09/13 15:30:30  rs
 * first version supporting speculative evaluations with TICKETS
 *
 * Revision 1.74  1998/06/03 16:20:07  rs
 * speculative evaluations version 2 completed
 *
 * Revision 1.73  1998/03/31 09:54:42  rs
 * dbug-messages removed, ready for re-compilation
 *
 * Revision 1.72  1998/02/27 15:00:48  rs
 * further bugfixes on speculative evaluation (preliminary, beware of debug messages !)
 *
 * Revision 1.71  1998/02/18  13:34:36  rs
 * modifications for speculative evaluations regarding
 * meaning preserving transformations
 *
 * Revision 1.70  1997/11/24  08:19:48  rs
 * old version check-in
 *
 * Revision 1.69  1997/06/06  09:05:59  rs
 * further (unspecified ;-) modifications on speculative evaluation AND
 * another bugfix regarding pattern matching (applications to closures
 * are treated as undecidable, which may be the right decision ;-)
 *
 * Revision 1.68  1997/04/14  09:52:06  rs
 * further work on speculative evaluation
 *
 * Revision 1.67  1997/02/17  13:18:12  rs
 * some additions supporting speculative evaluation
 *
 * Revision 1.66  1996/05/20  17:12:37  cr
 * warning removed
 *
 * Revision 1.65  1996/05/07  09:29:53  cr
 * #ifndef CAF_UPDATE: ignore I_UPDATE (instead of giving an error message)
 *
 * Revision 1.64  1996/03/25  14:39:22  cr
 * #ifdef CAF_UPDATE : if the result of a beta call does not
 * depend on any environment (beta(0) and no tilde-frame), an
 * I_UPDATE-instruction is inserted after the I_BETA to update
 * the original function code with I_RTP result (I_RTC result).
 *
 * Revision 1.63  1996/03/19  14:16:17  rs
 * using ++ in macro-arguments ? AAAAARGH ;-) fixed in I_BINDSUBL
 *
 * Revision 1.62  1996/03/07  18:16:17  rs
 * C_FUNC TY_CASE ptc's might be used to indicate the number of the when-clause
 * (bugfix for the distributed version)
 *
 * Revision 1.61  1996/02/15  15:38:24  cr
 * ASM-instruction mkslot : 1 -> 0 parameters
 *
 * Revision 1.60  1996/01/11  10:51:39  rs
 * some changes in I_WAIT
 *
 * Revision 1.59  1996/01/10  13:00:04  rs
 * some ADV_SCHED (advanced scheduling) changes for the distributed version
 *
 * Revision 1.58  1995/12/14  16:52:35  rs
 * stack-access-macros moved to rstack.h (seq. and distributed version)
 *
 * Revision 1.57  1995/11/21  14:50:11  stt
 * L_apply: case ptdesc == interaction inserted
 *
 * Revision 1.56  1995/11/15  15:07:49  cr
 * introduced ASM-instructions to build frames (I_MKFRAME) and slots (I_MKSLOT)
 *
 * Revision 1.55  1995/10/27  15:37:48  rs
 * S_tilde unknown in D_SLAVE-Version
 *
 * Revision 1.54  1995/09/12  14:30:03  stt
 * interactions supported
 *
 * Revision 1.53  1995/07/10  14:09:40  rs
 * some pvm changes...
 *
 * Revision 1.52  1995/07/03  11:40:38  car
 * bug from last revision fixed
 *
 * Revision 1.51  1995/07/03  09:46:08  car
 * useless label removed
 *
 * Revision 1.50  1995/05/22  09:30:32  rs
 * changed nCUBE to D_SLAVE
 *
 * Revision 1.49  1995/04/06  14:25:52  rs
 * UH-PM "in etc. bugfix
 *
 * Revision 1.48  1995/04/05  14:19:39  rs
 * thete's something wrong with BINDSUBLIST depending on the direction of the matching :-((
 * (errr, make that THERE's ! :-)
 *
 * Revision 1.47  1995/03/01  16:51:02  rs
 * various bugfixes and new features concerning UH's patternmatching
 *
 * Revision 1.46  1995/02/28  16:59:21  rs
 * DIGIT and SCALAR added (UH-PM)
 *
 * Revision 1.45  1995/02/28  08:51:29  rs
 * removed some warnings...
 *
 * Revision 1.44  1995/02/23  14:06:04  rs
 * minor bugfix in uh's pm
 *
 * Revision 1.43  1995/02/22  15:51:20  rs
 * SELECTION-descriptors used only in preprocessing
 *
 * Revision 1.42  1995/02/16  16:35:51  rs
 * UH PM GAMMA and GAMMACASE 0 red step
 *
 * Revision 1.41  1995/02/15  15:51:00  rs
 * now MATCHLIST REALLY matches lists ! :-)
 * no more UNDECIDED matching if the argument is a
 * (unnamed) function (as in old PM)
 *
 * Revision 1.40  1995/02/14  16:03:30  rs
 * minor changes
 *
 * Revision 1.39  1995/02/10  14:44:22  rs
 * stackelem == stackelem (UH's sourcecode)
 * UARGH !
 * ...corrected...
 *
 * Revision 1.38  1995/02/09  16:14:27  rs
 * UH PM bugfix -> BINDSUBL now generates an empty string
 *
 * Revision 1.37  1995/02/08  15:34:52  rs
 * bugfix in single when
 *
 * Revision 1.36  1995/02/07  15:49:23  rs
 * UH String PM implemented
 *
 * Revision 1.35  1995/01/31  14:49:12  rs
 * MKIFRAME -> MKAFRAME
 *
 * Revision 1.34  1995/01/19  10:17:20  rs
 * UH PM using 4 stacks
 *
 * Revision 1.33  1995/01/13  16:42:43  rs
 * uh pm bugfixes
 *
 * Revision 1.32  1995/01/11  14:55:35  rs
 * uh pm changes
 *
 * Revision 1.31  1995/01/10  16:28:13  rs
 * UH PM bugfixes
 *
 * Revision 1.30  1995/01/09  15:50:09  rs
 * more UH bugfixlike changes
 *
 * Revision 1.29  1995/01/06  16:32:27  rs
 * UH patternmatch bugfixes
 *
 * Revision 1.28  1995/01/03  15:17:24  rs
 * UH PM bugfixes
 *
 * Revision 1.27  1995/01/03  11:13:47  rs
 * more UH PM stuff
 *
 * Revision 1.26  1994/12/21  15:01:47  rs
 * more UH pm stuff
 *
 * Revision 1.25  1994/12/02  08:45:17  car
 * DYADIC instruction mkdclos
 *
 * Revision 1.24  1994/11/02  10:01:34  rs
 * UH_ZF_PM + Tilde
 *
 * Revision 1.23  1994/10/21  15:13:05  rs
 * *** empty log message ***
 *
 * Revision 1.22  1994/10/21  13:29:56  rs
 * core UH_ZF_PM source integrated
 *
 * Revision 1.21  1994/09/13  11:46:26  rs
 * first time-slicing changes
 *
 * Revision 1.20  1994/06/16  14:24:18  mah
 * minor bugfix
 *
 * Revision 1.19  1994/06/14  13:59:43  mah
 * free1sw_t added
 *
 * Revision 1.18  1994/05/24  13:21:30  ach
 * PUSHH/POPH changed to R-Stack for tilde version
 *
 * Revision 1.17  1994/05/16  11:41:50  ach
 * more bug fixes
 *
 * Revision 1.16  1994/05/06  12:23:24  ach
 * support for DIST, DISTB in tilde version added
 *
 * Revision 1.15  1994/05/05  10:01:46  rs
 * compile bugfix (D_MESS ## WITHTILDE)
 *
 * Revision 1.14  1994/05/04  07:02:52  ach
 * first beta release of distributed tilde-version
 *
 * Revision 1.13  1994/05/03  12:52:54  rs
 * first beta of merged picard with tilde
 *
 * Revision 1.11  1994/03/29  17:29:16  mah
 * popfree_t generation added to apply instruction
 *
 * Revision 1.10  1994/03/08  18:12:23  mah
 * bug fixes for tilde version
 *
 * Revision 1.9  1994/02/23  15:56:15  mah
 * pattern match added to tilde version
 *
 * Revision 1.8  1994/02/09  13:43:06  mah
 * bux fix in primfunc handling of l_apply
 *
 * Revision 1.7  1994/01/18  08:43:55  mah
 * new style push and move instructions
 *
 * Revision 1.5  1993/11/25  14:10:40  mah
 * ps_i, ps_a changed to ps_a, ps_w
 *
 * Revision 1.2  1992/12/16  12:50:04  rs
 * ANSI-Version
 *
 * Revision 1.1  1992/11/04  18:12:30  base
 * Initial revision
 */
/****************************************************************************/
/* file rinter.c                                                            */
/* ------------------------------------------------------------------------ */
/*                                                                          */
/* dg 31.05.90  um diese zeit muss es angefangen haben, oder frueher?       */
/* dg xx.xx.xx  viel schweiss und blut ...                                  */
/* dg 10.08.92  multiple pattern (n-stellige cases) implementiert           */
/* ach 04/01/93 aufrufe fuer dynamische Stackverwaltung eingefuegt          */
/* mah 26.10.93 Codierung des Tail_flags als Bit 0 in der Rueckkehradresse  */
/*                                                                          */
/****************************************************************************/

#define INTER "Interpreter fuer abstrakten Code"

#include "rstdinc.h"
#if D_SLAVE
#include "rncstack.h"
#include "rncmessage.h"
#else
#include "rstackty.h"
#endif
#include "rheapty.h"
#include "rstelem.h"
#include "rextern.h"
#include "rstack.h"
#include "rmeasure.h"
#include <setjmp.h>
#include "rprimf.h"
#include "rinter.h"
#include <string.h>          /* RS 6.11.1992 */

#if D_SLAVE
#include "rncsched.h"
#endif

#include "dbug.h"

#if D_MESS
#include "d_mess_io.h"
#endif

#if (D_SLAVE && D_SPEC)
#include "spec_sched.h"
#endif

#if D_SLAVE
extern INSTR *distribute();
#endif

#if D_SPEC
extern FILE *debugger;
extern int spec_failcase;
extern makestrdesc();
/* extern void initialize_fred_fish(); */
#endif

#if  SINTRAN3
extern double tused();
#define TIMER() tused()
#else
#if (!D_SLAVE)
extern long clock();
#endif
#define TIMER() clock() 
#endif

/* --- externe variablen / routinen --- */

extern BOOLEAN _count_reductions;  /* <r>, reduktionen zaehlen? */
extern BOOLEAN _beta_count_only;   /* <r>, nur beta-reduktionen zaehlen */
extern BOOLEAN _digit_recycling;   /* <w>, fuer die ausnahmebehandlung  */
extern BOOLEAN _heap_reserved;     /* <w>, fuer die ausnahmebehandlung  */
extern T_PTD   _desc;              /* <w>, der ergebnisdeskriptor       */

extern int     LazyLists;

extern INSTR_DESCR instr_tab[];

#if D_SLAVE
extern int host;
extern PROCESS_CONTEXT* curr_pid;
extern int proc_id;
extern INSTR *code;
extern int sig_msg_flag;
#if (ADV_SCHED || D_SPEC)
extern int sig_interrupt;
extern int sig_suspend;
#endif
#if ADV_SCHED
extern int init_tickets_cond;
extern int tickets_cond;
#endif
int     _redcnt;
#if (D_SPEC && D_SLAVE)
int _spec_redcnt;
#endif
BOOLEAN _interrupt;
jmp_buf _interruptbuf;
#else
extern jmp_buf _interruptbuf;      /* <w>, fuer die ausnahmebehandlung  */
extern int     _redcnt;            /* <w>, rstate.c - reduktionszaehler */
extern BOOLEAN _interrupt;         /* <w>, fuer die ausnahmebehandlung  */
#endif

#if UH_ZF_PM
extern PTR_DESCRIPTOR  gen_ind();
extern digit_eq();
#endif /* UH_ZF_PM */

#if    DEBUG
extern FILE    *TraceFp;           /* setup.c */
extern int     OutInstr;           /* setup.c ausgabe von instruktionen */
extern int     OutLen;             /* setup.c laenge des zyklischen ausgabebereiches */
extern int     debdisplay;         /* rruntime.c */
extern char    *stelname();        /* rdesc.c */
extern void    stackname_dr();     /* debug system */
#endif /* DEBUG   auskommentiert RS 4.12.1992 */

extern int     pm_am();            /* ram.c pattern matching abstract machine */
extern T_PTD   newdesc();          /* rheap.c allocate a new descriptor */
extern T_PTD   gen_id();           /* rlstruct.c generate indirect list descriptor */
extern void    cursorxy();         /* editor: cursor motion */

/* ach 05/11/92 */
extern void stack_error();         /* rstack.c */
extern int newheap();              /* rheap.c */
extern void load_expr();           /* rhinout.c */
extern void trav_e_a();            /* rtrav.c */
extern STACKELEM st_expr();        /* rstpro.c */
extern int conv_digit_int();       /* rdig-v1.c */
/* end of ach */

/* RS 5.11.92 */
extern void test_inc_refcnt();             /* rheap.c */
extern void rel_heap();                    /* rheap.c */
extern void res_heap();                    /* rheap.c */
extern void switchstacks();                /* rruntime.c */
extern void test_dec_refcnt();             /* rheap.c */

/* ach 06/11/92 */
#if SCAVENGE
extern void enable_scav();                 /* rscavenge.c */
extern char *get_heap();                   /* rdummies.c */
extern void disable_scav();                /* rscavenge.c */
#endif
/* end of ach */

#if D_SLAVE
extern void d_pushstack();
extern STACKELEM d_popstack();
extern STACKELEM *d_ppopstack();
#else
extern STACKELEM *ppopstack();             /* rheap.c */
extern STACKELEM midstack();               /* rstack.c */
extern void updatestack();                 /* rstack.c */
#endif

#if WITHTILDE
extern void trav_a_hilf();
extern int mvheap();
#endif /* WITHTILDE */

/* --- interne variablen/routinen --- */

#if D_SLAVE                /* ach 04/01/93: Bei dynamischer Stackverwaltung werden andere Typen benutzt */

DStackDesc     *ps_w;              
DStackDesc     *ps_a;

#if WITHTILDE
DStackDesc     *ps_t;
DStackDesc     *ps_r;
#endif /* WITHTILDE */

#else

StackDesc      *ps_w;              /* zeiger auf aktuellen a-stack */
StackDesc      *ps_a;              /* zeiger auf aktuellen i-stack */
#if WITHTILDE
StackDesc      *ps_t;              /* zeiger auf aktuellen tilde-stack  mah 261093 */
StackDesc      *ps_r;              /* zeiger auf aktuellen return-stack mah 171193 */
#endif /* WITHTILDE */

#endif

static char    buf[80];            /* puffer fuer fehlermeldungen */

#if !WITHTILDE
static void    load_pmlist();
static void    load_pmilist();
#endif /* !WITHTILDE */

/* --- stackoperationen --- */

/* see rstack.h !!!! RS 14.12.1995 */  

/* --- debug: ausgabe der auszufuehrenden instruktion --- */

#if     DEBUG

static int  instrcnt = 0; /* zaehler fuer ausgefuerte instruktionen */
static int  relpos   = 0; /* zyklischer positionszahler fuer bildschirmausgabe */
static int  baserow  = 2; /* erste ausgabezeile */
static int  basecol  = 0; /* ausgabespalte */

#define NEXTINSTR()       cursorxy(baserow+(relpos=(relpos+1)%OutLen),basecol); \
                          printf("%d ",++instrcnt)
#define POST_MORTEM(mes)  {if (TraceFp) { fclose(TraceFp); TraceFp=0; } post_mortem(mes); }

#if D_SLAVE

#define SWITCHSTACKS()    {register DStackDesc *x = ps_w; ps_w = ps_a; ps_a = x;} \
                           switchstacks(ps_w,ps_a); \
                           fprintf(TraceFp,"_switchstacks();\n")
#if WITHTILDE
#define SWITCHSTACKS_T()  {register DStackDesc *x = ps_r; ps_r = ps_t; ps_t = x;} \
                           switchstacks(ps_r,ps_t); \
                           fprintf(TraceFp,"_switchstacks_t();\n")
#endif /* WITHTILDE */

#else

#define SWITCHSTACKS()    {register StackDesc *x = ps_w; ps_w = ps_a; ps_a = x;} \
                           switchstacks(ps_w,ps_a); \
                           fprintf(TraceFp,"_switchstacks();\n")

#if WITHTILDE
#define SWITCHSTACKS_T()  {register StackDesc *x = ps_r; ps_r = ps_t; ps_t = x;} \
                           switchstacks(ps_r,ps_t); \
                           fprintf(TraceFp,"_switchstacks_t();\n")
#endif /* WITHTILDE */

#endif

#define COMM0(x)          if (OutInstr && debdisplay) { \
                            NEXTINSTR(); \
                            printf("comment(\"%s\")          \n",x); \
                          } \
                          fprintf(TraceFp,"comment(\"%s\");\n",x)
#define FUNC0(x)          if (OutInstr && debdisplay) { \
                            NEXTINSTR(); \
                            printf("%s()                     \n",x); \
                          } \
                          fprintf(TraceFp,"%s();\n",x)
#define FUNC1(x)          if (OutInstr && debdisplay) { \
                            NEXTINSTR(); \
                            printf("%s(%1d)                  \n",x,*code); \
                          } \
                          fprintf(TraceFp,"%s(%1d);\n",x,*code)
#define FUNC2(x)          if (OutInstr && debdisplay) { \
                            NEXTINSTR(); \
                            printf("%s(%1d, %1d)             \n",x,*code,*(code+1)); \
                          } \
                          fprintf(TraceFp,"%s(%1d, %1d);\n",x,*code,*(code+1))

#if UH_ZF_PM
#define WAIT PUSHSTACK(S_i,DOLLAR); POPSTACK(S_i)
#endif /* UH_ZF_PM */


#if WITHTILDE
                          /* Die Closures sind im Tilde-Konzept dreistellig */
#define FUNC3(x)          if (OutInstr && debdisplay) { \
                            NEXTINSTR(); \
                            printf("%s(%1d, %1d, %1d)        \n",x,*code,*(code+1),*(code+2)); \
                          } \
                          fprintf(TraceFp,"%s(%1d, %1d, %1d);\n",x,*code,*(code+1),*(code+2))
#endif /* WITHTILDE */

#define FUNCX(x)          if (OutInstr && debdisplay) { \
                            NEXTINSTR(); \
                            printf("%s(%s)                   \n",x,stelname(*code)); \
                          } \
                          fprintf(TraceFp,"%s(%s);\n",x,stelname(*code))
#define FUNCN(x)          if (OutInstr && debdisplay) { \
                            NEXTINSTR(); \
                            printf("%s(%s)                   \n",x,stelname(*code)); \
                          } \
                          fprintf(TraceFp,"%s(%s);\n",x,stelname(*code))
#define FUNCL(x)          if (OutInstr && debdisplay) { \
                            NEXTINSTR(); \
                            printf("%s(label(0x%08x))        \n",x,*code); \
                          } \
                          fprintf(TraceFp,"%s(label(0x%08x));\n",x,*code)

#else   /* !DEBUG */

#define POST_MORTEM(mes)  post_mortem(mes)

#if D_SLAVE
#define SWITCHSTACKS()    {register DStackDesc *x = ps_w; ps_w = ps_a; ps_a = x;}
#if WITHTILDE
#define SWITCHSTACKS_T()  {register DStackDesc *x = ps_r; ps_r = ps_t; ps_t = x;}
#endif /* WITHTILDE */
#else
#define SWITCHSTACKS()    {register StackDesc *x = ps_w; ps_w = ps_a; ps_a = x;}

#if WITHTILDE
#define SWITCHSTACKS_T()  {register StackDesc *x = ps_r; ps_r = ps_t; ps_t = x;}
#endif /* WITHTILDE */

#endif

#define COMM0(x)
#define FUNC0(x)
#define FUNC1(x)
#define FUNC2(x)

#if UH_ZF_PM
#define FUNC3(x)
#define WAIT
#endif /* UH_ZF_PM */ /* I know it's a collision with withtide :-) */

#if WITHTILDE
#define FUNC3(x)
#endif /* WITHTILDE */
#define FUNCX(x)
#define FUNCN(x)
#define FUNCL(x)

#endif /* DEBUG */

/* --- makros --- */

#define TAIL_FLAG            1
#define POP_RET()            (INSTR *)(POP_R() & ~TAIL_FLAG)
#define TEST_TAIL_FLAG()     ((TOP_R() & TAIL_FLAG) == TAIL_FLAG)
#define SET_TAIL_FLAG()      WRITE_R(TOP_R() | TAIL_FLAG)
#define DEL_TAIL_FLAG()      WRITE_R(TOP_R() & ~TAIL_FLAG)
#define INVERT_TAIL_FLAG()   WRITE_R(TOP_R() ^ TAIL_FLAG)

/* In der 4-stack-version, in der der returnstack mitbenutzt wird,    */
/* um den neuen Tilde-frame aufzubauen, koennen tail-end-rekursionen  */
/* nicht optimiert werden. Deswegen wird kein tail-flag benoetigt     */
/* In einer 5-stack-version, die den returnstack nicht mitbenutzt,    */
/* waeren diese optmierungen moeglich und das tail_t-flag noetig,     */
/* aber die Goetter sind dagegen.                                     */

#if WITHTILDE
#define TAIL_FLAG_T          2
#define TEST_TAIL_FLAG_T()   ((TOP_R() & TAIL_FLAG_T) == TAIL_FLAG_T)
#define SET_TAIL_FLAG_T()    WRITE_R(TOP_R() | TAIL_FLAG_T)
#define DEL_TAIL_FLAG_T()    WRITE_R(TOP_R() & ~TAIL_FLAG_T)
#define INVERT_TAIL_FLAG_T() WRITE_R(TOP_R() ^ TAIL_FLAG_T)

#if 0
/* Ein gammabeta-Funktionsaufruf setzt das GAMMABETA-Flag und rtf  */
/* kann dann feststellen, ob zusaetzlich t und r vertauscht werden */
/* muessen. mah 301193                                             */
/* nicht mehr noetig mah 120194                                    */

#define GAMMABETA_FLAG       TAIL_FLAG_T
#define TEST_GAMMABETA()     TEST_TAIL_FLAG_T()
#define SET_GAMMABETA()      SET_TAIL_FLAG_T()
#define DEL_GAMMABETA()      DEL_TAIL_FLAG_T()
#endif /* 0 */
#endif /* WITHTILDE */


#define STACKSPACE(n)     IS_SPACE((*ps_w),(n))
/* beta,tail, cond und jtrue/jfalse: parameter sind absolute sprungziele */
#define GRAB_DESC(p)      p = ((T_PTD *)p)[-1]
#define COMB_CODE(p)      p = (T_PTD)R_COMB(*p,ptc)

/* GET_DESC(p), GET_HEAP(n,p), MAKEDESC(p,ref,cl,ty) defined in rheapty.h */

/* --- spezielle routinen --- */

static INSTR rout_rtf[]    = { I_RTF };                     /* return */
static INSTR rout_sret[]   = { I_SRET };                    /* free and return */
#if WITHTILDE
static INSTR rout_popft[]  = { I_POPFREE_T, I_RTS };
static INSTR rout_sclos[]  = { I_MKSCLOS, 0, 0, 42, I_RTF };
#endif /* WITHTILDE */
#if (D_SPEC && D_SLAVE)
INSTR rout_specmap1[] = { I_SPECWAIT, I_MKNCASE, 0, I_RTS };
INSTR rout_specmap2[] = { I_APPLY, 1, I_SPECWIN, I_SPECEND };
#endif /* D_SPEC && D_SLAVE */
static INSTR rout_sapply[] = { I_SAPPLY, I_RTS };           /* special apply */
static INSTR rout_eval0[]  = { I_EVAL0, I_RTS };            /* evaluate */
static INSTR rout_updat[]  = { I_UPDAT, I_RTS };            /* eval, update */
       INSTR Rout_Eval[]   = { I_EVAL, I_EXT };             /* eval and exit */
       INSTR Rout_Mkcnd[]  = { I_MKTHEN, I_MKELSE, I_MKCOND, I_EXT }; /* make cond */

/* -------------------------------------------------------------------- */
/* ---                         Interpreter                          --- */
/* -------------------------------------------------------------------- */

#if D_SLAVE
INTER_RESULT inter()
#else
void inter(code)
register INSTR * VOLATILE code;
#endif
{
  register T_PTD        ptdesc;          /* zeiger auf descriptor     */
  /* 4 Initialisierungen von TB, 6.11.1992, 4 volatile: ach 10/11/92 */
  register VOLATILE int          arg=0;           /* anzahl argumente          */
  register VOLATILE int          arity=0;         /* stelligkeit               */
#if WITHTILDE
  register VOLATILE int          nfv=0; /* Anzahl der relativ freien Variablen */
  register VOLATILE int          gamma_closure = 0;
#endif /* WITHTILDE */
  register VOLATILE int          func=0;          /* funktion (pf)             */
  register VOLATILE int          help=0;          /* hilfsvariable             */
  register int          delta_count;     /* delta reduktionen zaehlen */
  register PTR_HEAPELEM pth;             /* pointer to heapelement    */
  register int          beta_count;      /* beta  reduktionen zaehlen */
  register int lastcommand1, lastcommand2, lastcommand3, lastcommand4;

#if    UH_ZF_PM
  /* hier fuegt ulli noch einige definitionen dazu ! */
/*dg, 27.07.90*/    /* wenn irgendwie moeglich keine weiteren variablen einfuehren */
/*dg, 27.07.90*/    /* Aber Namen werden zugestanden:                              */
/*dg, 27.07.90*/  
/*dg, 27.07.90*/  int zb; /* debugging */
/*dg, 27.07.90*/  
#define R0 (int)ptdesc
#define R1 arg
#define R2 arity
#define R3 func
#define R4 help
#define R5 (int)pth
#endif /* UH_ZF_PM      auskommentiert RS 4.12.1992 */

DBUG_ENTER ("inter");

  /* initialisierungen */

#if (!D_SLAVE)

  ps_w = &S_a;          /* initial working  stack is mapped on S_a  */
  ps_a = &S_m1;         /* initial argument stack is mapped on S_m1 */

#if WITHTILDE
  ps_t = &S_tilde;      /* initial tilde stack is mapped on S_tilde     */
  ps_r = &S_m;          /* initial return/tilde2stack is mapped on S_m */
#endif

#endif /* !D_SLAVE */

#if (DEBUG && !D_SLAVE)

  /* rename stacks for debugging purposes (undone at return) */
  strcpy(S_e.Name,     "H"); stackname_dr(&S_e);
  strcpy(S_a.Name,     "W"); stackname_dr(&S_a);
  strcpy(S_m1.Name,    "A"); stackname_dr(&S_m1);
  strcpy(S_m.Name,     "R"); stackname_dr(&S_m);
#if WITHTILDE
  strcpy(S_tilde.Name, "T"); stackname_dr(&S_tilde); /* mah 251093 */
#endif

  /* initialize some debug variables */
  instrcnt = 0;         /* zaehler fuer ausgefuerte instruktionen */
  relpos   = 0;         /* zyklischer positionszahler fuer bildschirmausgabe */
#endif /* DEBUG  auskommentiert RS 4.12.1992 */

  _interrupt  = FALSE;
  beta_count  = _count_reductions;
  delta_count = !_beta_count_only;

  START_MODUL("inter");



#if SCAVENGE
  enable_scav();                            /* enable generation scavenging */
#endif /* SCAVENGE         auskommentiert RS 4.12.1992 */

  setjmp(_interruptbuf);                    /* vorbereitung fuer longjmp */
  if (_interrupt)                           /* falls interrupt, dann     */
    goto L_interrupt;                       /* zur interruptbehandlung   */

  /* --- interpreter loop --- */

/*
#if D_SLAVE
fprintf(stderr,"\aNode %d: interpreter, code: %x\n",proc_id,code);
#endif
*/

lastcommand1 = lastcommand2 = lastcommand3 = lastcommand4 = 0;

loop:

lastcommand4 = lastcommand3;
lastcommand3 = lastcommand2;
lastcommand2 = lastcommand1;
lastcommand1 = *code; 

#if NCDEBUG
#  if D_SLAVE
    DBNCclient();
#  endif
#endif

#if D_SLAVE
/*
DBUG_PRINT ("DUMP", (""));
DBUG_PRINT ("DUMP", ("A-Stack: (size %d)", d_stacksize(ps_w)));
DBUG_PRINT ("DUMP", ("Topaddresse: %x; Schotter: %x (class %d, type %d)",
                     ps_w->TopofStack,
                     TOP_W(),
                     ((IS_POINTER(TOP_W()))?R_DESC(*(T_PTD)TOP_W(),class):-1), 
                     ((IS_POINTER(TOP_W()))?R_DESC(*(T_PTD)TOP_W(),type):-1)));
if (d_stacksize(ps_w) > 1)
DBUG_PRINT ("DUMP", ("Unner dem liegt ey: %x (class %d, type %d)", 
                     MID_W(1),
                     ((IS_POINTER(MID_W(1)))?R_DESC(*(T_PTD)MID_W(1),class):-1),
                     ((IS_POINTER(MID_W(1)))?R_DESC(*(T_PTD)MID_W(1),type):-1)));
DBUG_PRINT ("DUMP", ("I_STACK: (size %d)", d_stacksize(ps_a)));
DBUG_PRINT ("DUMP", ("Topaddresse: %x; Schotter: %x (class %d, type %d)", 
                     ps_a->TopofStack,
                     TOP_A(),
                     ((IS_POINTER(TOP_A()))?R_DESC(*(T_PTD)TOP_A(),class):-1),
                     ((IS_POINTER(TOP_A()))?R_DESC(*(T_PTD)TOP_A(),type):-1)));
if (d_stacksize(ps_a) > 1)
DBUG_PRINT ("DUMP", ("Unner dem liegt ey: %x (class %d, type %d)", 
                     MID_A(1),
                     ((IS_POINTER(MID_A(1)))?R_DESC(*(T_PTD)MID_A(1),class):-1),
                     ((IS_POINTER(MID_A(1)))?R_DESC(*(T_PTD)MID_A(1),type):-1)));
DBUG_PRINT ("DUMP", (""));
*/
#endif

#if D_SLAVE
/* if (_redcnt <10000)
  initialize_fred_fish(); */
#endif

#if D_SLAVE 
#if D_SPEC
DBUG_PRINT("INTER",("proc %x: next instruction: %s (%d,%x),redcount: %d (start: %d) (is_spec=%d: %d)",curr_pid,instr_tab[*code].name,*code,code,_redcnt,curr_pid->start_red_count,T_SPEC_PROCESS(curr_pid),_spec_redcnt));
#else
DBUG_PRINT("INTER",("proc %x: next instruction: %s (%x),redcount: %d",curr_pid,instr_tab[*code].name,code,_redcnt));
#endif
#else
DBUG_PRINT("INTER",("next instruction: %s (%x),redcount: %d",instr_tab[*code].name,code,_redcnt));
#endif 

#if (D_SLAVE && TIME_SLICE)    /* check for timeout */
  if (SCHED_TIME_OUT) 
    DBUG_RETURN (IR_TIME_OUT);
#endif /* D_SLAVE && TIME_SLICE */

#if D_SLAVE
#if nCUBE
#if (ADV_SCHED || D_SPEC)
/* DBUG_PRINT("INTER", ("sig_interrupt: %d, sig_msg_flag: %d", sig_interrupt, sig_msg_flag)); */
  if (sig_interrupt) {
    if (sig_msg_flag) {
      msg_check();
#if D_SPEC
      if (curr_pid==NULL) {
        DBUG_PRINT("INTER", ("there's no running process any more ! :-( ;)"));
        DBUG_RETURN(IR_SCHED); }
#endif /* D_SPEC */
      }
/* DBUG_PRINT("INTER", ("sig_interrupt: %d, sig_msg_flag: %d", sig_interrupt, sig_msg_flag)); */
    sig_interrupt = 0;
    if (sig_suspend)
      DBUG_RETURN(IR_SUSPEND);  /* suspend the running process and activate another one */
    } 
#else /* ADV_SCHED */
  DBUG_PRINT("INTER", ("sig_msg_flag: %d", sig_msg_flag));
  if (sig_msg_flag)
    msg_check();
  DBUG_PRINT("INTER", ("sig_msg_flag: %d", sig_msg_flag));
#endif /* ADV_SCHED */
#endif /* nCUBE */
#endif /* D_SLAVE */

/*  hpchain_inter(); */

  switch (*code++) {
    case I_EXT:      /* === exit === */
                     FUNC0("ext");
                     break;

    case I_PUSH_W:   /* === PUSH_W p : push a pointer onto the working stack === */
		     /* mah 261193:war in 3-Stack-Version: PUSH */
                     FUNCX("push_w");
                     INC_REFCNT((T_PTD)(*code));
                     PUSH_W(*code++);
                     goto loop;
    case I_PUSHC_W:  /* === PUSHC_W c : push a constant onto the working stack === */
		     /* mah 261193:war in 3-Stack-Version: PUSHC */
                     FUNCN("pushc_w");
                     PUSH_W(*code++);
                     goto loop;
    case I_PUSH_AW:  /* === PUSH_AW n : push I-stackentry n onto the working stack === */
		     /* mah 261193:war in 3-Stack-Version: PUSHARG */
                     FUNC1("push_aw");
                     ptdesc = (T_PTD)MID_A(*code);
		     code++;                                         /* ach 08/01/93 */
                     T_INC_REFCNT(ptdesc);
                     PUSH_W(ptdesc);
                     goto loop;
    case I_PUSH_AW0: /* === PUSH_AW0 : push stackentry 0 onto the stack === */
		     /* mah 261193:war in 3-Stack-Version: PUSHARG */
                     FUNC0("push_aw0");
                     ptdesc = (T_PTD)TOP_A();
                     T_INC_REFCNT(ptdesc);
                     PUSH_W(ptdesc);
                     goto loop;
    case I_MOVE_AW:  /* === MOVE_AW : move one item from a to w === */
		     /* mah 261193:war in 3-Stack-Version: MOVE */
                     FUNC0("move_aw");
                     PUSH_W(POP_A());
                     goto loop;
    case I_DELTA1:   /* === DELTA1 pf : perform unary delta-reduction === */
                     FUNCN("delta1");
                     func = *code++;
                   L_delta1:
                     /* func: primitive funktion (stackelement) */
                     if (_redcnt >= delta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) || 
                         (_spec_redcnt >= delta_count)) {
#endif /* D_SPEC */
                       if ((*(red_func_tab[FUNC_INDEX(func)]))(TOP_W())) {
                         /* _desc: resultat der funktionsanwendung */
                         WRITE_W(_desc);
                         _desc = NULL;
                         _redcnt -= delta_count;
#if (D_SPEC && D_SLAVE)
                         _spec_redcnt -= delta_count;
#endif /* D_SPEC */
                         goto loop;
                       } 
#if (D_SPEC && D_SLAVE)
                       }
                       else SPEC_CODE_1(2,"DELTA1")
#endif /* D_SPEC */
                     } 
#if (D_SPEC && D_SLAVE)

                     else SPEC_CODE_2(2,"DELTA1")
#endif /* D_SPEC */

                     PUSH_W(func);
                     arity = arg = 1;
#if WITHTILDE
		     nfv = 0;
#endif
                     COMM0("mkdclos");
                     goto L_mkdclos;
    case I_DELTA2:   /* === DELTA2 pf : perform binary delta-reduction === */
                     FUNCN("delta2");
		     DBUG_PRINT("DELTA2",("func: %d; arg 1: %x (class %d, type %d): value %d; arg2: %x (class %d, type %d):value %d",
					  *code,
					  TOP_W(),
					  ((IS_POINTER(TOP_W()))?R_DESC(*(T_PTD)TOP_W(),class):-1),
					  ((IS_POINTER(TOP_W()))?R_DESC(*(T_PTD)TOP_W(),type):-1),
					  ((IS_POINTER(TOP_W()) && (R_DESC(*(T_PTD)TOP_W(),class) == C_DIGIT))?*R_DIGIT(*(T_PTD)TOP_W(),ptdv):TOP_W()),
					  MID_W(1),
					  ((IS_POINTER(MID_W(1)))?R_DESC(*(T_PTD)MID_W(1),class):-1),
					  ((IS_POINTER(MID_W(1)))?R_DESC(*(T_PTD)MID_W(1),type):-1),
					  ((IS_POINTER(MID_W(1)) && (R_DESC(*(T_PTD)MID_W(1),class) == C_DIGIT))?*R_DIGIT(*(T_PTD)MID_W(1),ptdv):MID_W(1))));
                     func = *code++;
                   L_delta2:
                     /* func: primitive funktion (stackelement) */
                     if (_redcnt >= delta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= delta_count)) {
#endif /* D_SPEC */
                       /* dg 30.01.92 argumente bleiben auf'm stack wg. scavenge */
                       if ((*(red_func_tab[FUNC_INDEX(func)]))(TOP_W(),MID_W(1))) {
                         /* _desc: resultat der funktionsanwendung */
                         PPOP_W();
                         WRITE_W(_desc);
                         _desc = NULL;
                         _redcnt -= delta_count;
#if (D_SPEC && D_SLAVE)
                         _spec_redcnt -= delta_count;
#endif /* D_SPEC */
                         goto loop;
                       }
#if (D_SPEC && D_SLAVE)
                       }
                       else SPEC_CODE_1(2,"DELTA2")
#endif /* D_SPEC */
                     }
#if (D_SPEC && D_SLAVE)
                     else SPEC_CODE_2(2,"DELTA2")
#endif /* D_SPEC */
                     PUSH_W(func);
                     arity = arg = 2;
#if WITHTILDE
		     nfv = 0;
#endif
                     COMM0("mkdclos");
                     goto L_mkdclos;
    case I_DELTA3:   /* === DELTA3 pf : perform ternary delta-reduction === */
                     FUNCN("delta3");
                     func = *code++;
                   L_delta3:
                     /* func: primitive funktion (stackelement) */
                     if (_redcnt >= delta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= delta_count)) {
#endif /* D_SPEC */
                       /* dg 30.01.92 argumente bleiben auf'm stack wg. scavenge */
                       if ((*(red_func_tab[FUNC_INDEX(func)]))(TOP_W(),MID_W(1),MID_W(2))) {
                         /* _desc: resultat der funktionsanwendung */
                         PPOP_W();
                         PPOP_W();
                         WRITE_W(_desc);
                         _desc = NULL;
                         _redcnt -= delta_count;
#if (D_SPEC && D_SLAVE)
                         _spec_redcnt -= delta_count;
#endif /* D_SPEC */
                         goto loop;
                       }
#if (D_SPEC && D_SLAVE)
                       }
                       else SPEC_CODE_1(2,"DELTA3")
#endif /* D_SPEC */
                     }
#if (D_SPEC && D_SLAVE)
                     else SPEC_CODE_2(2,"DELTA3")
#endif /* D_SPEC */
                     PUSH_W(func);
                     arity = arg = 3;
#if WITHTILDE
		     nfv = 0;
#endif
                     COMM0("mkdclos");
                     goto L_mkdclos;
    case I_DELTA4:   /* === DELTA4 pf : perform quaternary delta-reduction === */
                     FUNCN("delta4");
                     func = *code++;
                   L_delta4:
                     /* func: primitive funktion (stackelement) */
                     if (_redcnt >= delta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= delta_count)) {
#endif /* D_SPEC */
                       /* dg 30.01.92 argumente bleiben auf'm stack wg. scavenge */
                       if ((*(red_func_tab[FUNC_INDEX(func)]))(TOP_W(),MID_W(1),MID_W(2),MID_W(3))) {
                         /* _desc: resultat der funktionsanwendung */
                         PPOP_W();
                         PPOP_W();
                         PPOP_W();
                         WRITE_W(_desc);
                         _desc = NULL;
                         _redcnt -= delta_count;
#if (D_SPEC && D_SLAVE)
                         _spec_redcnt -= delta_count;
#endif /* D_SPEC */
                         goto loop;
                       }
#if (D_SPEC && D_SLAVE)
                       }
                       else SPEC_CODE_1(2,"DELTA4")
#endif /* D_SPEC */
                     }
#if (D_SPEC && D_SLAVE)
                     else SPEC_CODE_2(2,"DELTA4")
#endif /* D_SPEC */
                     PUSH_W(func);
                     arity = arg = 4;
#if WITHTILDE
		     nfv = 0;
#endif
                     COMM0("mkdclos");
                     goto L_mkdclos;

    case I_INTACT:   /* === INTACT : create interaction descriptor === */
                                                       /* stt 11.09.95 */
                     FUNCN("intact");
                     func = *code++;
                   L_intact:
                     /* Interaktion-Deskriptor anlegen: */
                     /* args -> (Interaktion,Argumente) */
                     arity = FUNC_ARITY(func);
                     MAKEDESC(ptdesc, 1, C_INTACT, TY_INTACT);
                     L_INTACT(*ptdesc,dim)  = arity + 1;
                     GET_HEAP(arity + 2, A_INTACT(*ptdesc,args));
                     RES_HEAP;
                     pth = R_INTACT(*ptdesc,args);
                     *pth++ = func;
                     while (arity-- > 0) {
                       *pth++ = TOP_W();
                       PPOP_W();
                     }
                     REL_HEAP;
                     PPUSH_W(ptdesc);
                     ptdesc = NULL;
                     goto loop;


/* --- shortcut : directly supported primitive functions --- */
#if WITHTILDE
#define EXEC_DFUNC(pf_test,pf_makro,pf_func,pf_stel) \
                     arg = TOP_W(); \
                     if (pf_test(arg,MID_W(1))) { \
                       PPOP_W(); \
                       WRITE_W(pf_makro(arg,TOP_W())); \
                       goto loop; \
                     } \
                     if (pf_func(arg,MID_W(1))) { \
                       PPOP_W(); \
                       WRITE_W(_desc); \
                       _desc = NULL; \
                       goto loop; \
                     } \
                     /* failure */ \
                     PUSH_W(pf_stel); \
                     arity = arg = 2; \
                     nfv = 0; \
                     COMM0("mkdclos"); \
                     goto L_mkdclos

#define EXEC_MFUNC(pf_test,pf_makro,pf_func,pf_stel) \
                     if (pf_test(TOP_W())) { \
                       WRITE_W(pf_makro(TOP_W())); \
                       goto loop; \
                     } \
                     if (pf_func(TOP_W())) { \
                       WRITE_W(_desc); \
                       _desc = NULL; \
                       goto loop; \
                     } \
                     /* failure */ \
                     PUSH_W(pf_stel); \
                     arity = arg = 1; \
                     nfv = 0; \
                     COMM0("mkdclos"); \
                     goto L_mkdclos
#else
#define EXEC_DFUNC(pf_test,pf_makro,pf_func,pf_stel) \
                     arg = TOP_W(); \
                     if (pf_test(arg,MID_W(1))) { \
                       PPOP_W(); \
                       WRITE_W(pf_makro(arg,TOP_W())); \
                       goto loop; \
                     } \
                     if (pf_func(arg,MID_W(1))) { \
                       PPOP_W(); \
                       WRITE_W(_desc); \
                       _desc = NULL; \
                       goto loop; \
                     } \
                     /* failure */ \
                     PUSH_W(pf_stel); \
                     arity = arg = 2; \
                     COMM0("mkdclos"); \
                     goto L_mkdclos

#define EXEC_MFUNC(pf_test,pf_makro,pf_func,pf_stel) \
                     if (pf_test(TOP_W())) { \
                       WRITE_W(pf_makro(TOP_W())); \
                       goto loop; \
                     } \
                     if (pf_func(TOP_W())) { \
                       WRITE_W(_desc); \
                       _desc = NULL; \
                       goto loop; \
                     } \
                     /* failure */ \
                     PUSH_W(pf_stel); \
                     arity = arg = 1; \
                     COMM0("mkdclos"); \
                     goto L_mkdclos
#endif /* WITHTILDE */
                     /* ------------------ */

    case I_ADD:      /* === ADD : addition === */
                     FUNC0("add");
                     EXEC_DFUNC(T_2INT,ADD_INT,red_plus,D_PLUS);
    case I_SUB:      /* === SUB : subtraction === */
                     FUNC0("sub");
                     EXEC_DFUNC(T_2INT,SUB_INT,red_minus,D_MINUS);
    case I_MUL:      /* === MUL : multiplication === */
                     FUNC0("mul");
                     EXEC_DFUNC(T_2INT,MUL_INT,red_mult,D_MULT);
#define I_SAY_NO(x,y) 0
    case I_DIV:      /* === DIV : division (returns real), dirty === */
                     FUNC0("div");
                     EXEC_DFUNC(I_SAY_NO,DIV_INT,red_div,D_DIV);
#undef I_SAY_NO
    case I_MOD:      /* === MOD : modulo === */
                     FUNC0("mod");
                     EXEC_DFUNC(T_2INT,MOD_INT,red_mod,D_MOD);
    case I_EQ:       /* === EQ : equal === */
                     FUNC0("eq");
                     EXEC_DFUNC(T_2INT,EQ_INT,red_eq,D_EQ);
    case I_NE:       /* === NE : not equal === */
                     FUNC0("ne");
                     EXEC_DFUNC(T_2INT,NE_INT,red_neq,D_NEQ);
    case I_LT:       /* === LT : less than === */
                     FUNC0("lt");
                     EXEC_DFUNC(T_2INT,LT_INT,red_lt,D_LESS);
    case I_LE:       /* === LE : less than or equal === */
                     FUNC0("le");
                     EXEC_DFUNC(T_2INT,LE_INT,red_le,D_LEQ);
    case I_GT:       /* === GT : greater than === */
                     FUNC0("gt");
                     EXEC_DFUNC(T_2INT,GT_INT,red_gt,D_GREAT);
    case I_GE:       /* === GE : greater than or equal === */
                     FUNC0("ge");
                     EXEC_DFUNC(T_2INT,GE_INT,red_geq,D_GEQ);
    case I_NEG:      /* === NEG : change sign === */
                     FUNC0("neg");
                     EXEC_MFUNC(T_INT,NEG_INT,red_neg,M_NEG);
    case I_NOT:      /* === NOT : boolean not === */
                     FUNC0("not");
                     EXEC_MFUNC(T_BOOLEAN,NOT_BOOL,red_not,M_NOT);
    case I_OR:       /* === OR : not exclusive or === */
                     FUNC0("or");
                     EXEC_DFUNC(T_2BOOLEAN,OR_BOOL,red_or,D_OR);
    case I_AND:      /* === AND : and === */
                     FUNC0("and");
                     EXEC_DFUNC(T_2BOOLEAN,AND_BOOL,red_and,D_AND);
    case I_XOR:      /* === XOR : exclusive or === */
                     FUNC0("xor");
                     EXEC_DFUNC(T_2BOOLEAN,XOR_BOOL,red_xor,D_XOR);

/* -------------------------------------------------------- */

    case I_PUSHRET:  /* === PUSHRET r : push return address === */
                     FUNCL("pushret");
                     PUSH_R(*code++);
                     SET_TAIL_FLAG();
                     goto loop;
    case I_JFALSE:   /* === JFALSE l : perform conditional-reduction (per jump) === */
                     FUNCL("jfalse");
                     /* offenes conditional, das praed. liegt oben auf a     */
                     /* falls pred = true/false wird zum then/else-code      */
                     /* gesprungen, ansonsten wird geschlossen.              */
                     arg = POP_W();                   /* arg:    praedikat   */
                     if (IS_TRUE(arg)) {
                       /* then-code folgt */
                       code++;
                       goto loop;
                     }
                     if (IS_FALSE(arg))  {
                       code = (INSTR *)*code;
                       goto loop;
                     }
                     /* argument nicht true/false */
                     goto L_condfail;
    case I_JTRUE:    /* === JTRUE l : perform conditional-reduction (per jump) === */
                     FUNCL("jtrue");
                     /* offenes conditional, das praed. liegt oben auf a     */
                     /* falls pred = true/false wird zum then/else-code      */
                     /* gesprungen, ansonsten wird geschlossen.              */
                     arg = POP_W();                   /* arg:    praedikat   */
                     if (IS_FALSE(arg)) {
                       /* else-code folgt */
                       code++;
                       goto loop;
                     }
                     if (IS_TRUE(arg))  {
                       code = (INSTR *)*code;
                       goto loop;
                     }
                     /* argument nicht true/false */
                     goto L_condfail;
    case I_JCOND:    /* === JCOND l : perform conditional-reduction (per jump) === */
                     FUNCL("jcond");
                     /* offenes conditional, das praed. liegt oben auf a     */
                     /* falls pred = true/false wird zum then/else-code      */
                     /* gesprungen, ansonsten wird geschlossen.              */

                  /*   arg = POP_W();   changed... */

                     if (_redcnt >= delta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= delta_count)) {
#endif /* D_SPEC */
                        arg = POP_W();                   /* arg:    praedikat   */
                       if (T_SA_TRUE(arg)) {
                         _redcnt -= delta_count;
#if (D_SPEC && D_SLAVE)
                         _spec_redcnt -= delta_count;
#endif /* D_SPEC */
                         /* then-code folgt */
                         code++;
                         goto loop;
                       }
                       if (T_SA_FALSE(arg))  {
                         _redcnt -= delta_count;
#if (D_SPEC && D_SLAVE)
                         _spec_redcnt -= delta_count;
#endif /* D_SPEC */
                         code = (INSTR *)*code;
                         goto loop;
                       }
#if (D_SPEC && D_SLAVE)
                       }
                       else SPEC_CODE_1(1,"JCOND")
#endif /* D_SPEC */
                     }
#if (D_SPEC && D_SLAVE)
                     else SPEC_CODE_2(1,"JCOND")
#endif /* D_SPEC */

                     DBUG_PRINT("INTER", ("JCOND: _redcnt: %d, delta_count: %d", _redcnt, delta_count));

                     if (_redcnt < delta_count)  {
                        DBUG_PRINT("INTER", ("Popping..."));
                        arg = POP_W();                   /* arg:    praedikat   */
                       }
                     /* conditional nicht reduzierbar, schliessen */
                   L_condfail:

                     DBUG_PRINT("INTER", ("L_condfail reached..."));

                     PPUSH_W(arg);                        /* praedikat */
                     ptdesc = (T_PTD)*code++;             /* ptdesc: zeiger auf cond-code */

                     DBUG_PRINT("INTER", ("ptdesc is %x..."));

                     GRAB_DESC(ptdesc);                   /* ptdesc: conditional-descriptor */

                     DBUG_PRINT("INTER", ("ptdesc is now %x..."));

                     INC_REFCNT(ptdesc);                  /* refcount */
                     PPUSH_W(ptdesc);                     /* conditional */
                     arity = R_CONDI(*ptdesc,nargs);      /* anzahl argumente (incl. praedikat) */
#if WITHTILDE
		     nfv = (R_CONDI(*ptdesc,args) >> 2);
#endif /* WITHTILDE */
                     MAKEDESC(_desc,1,C_FUNC,TY_CLOS);    /* descriptor holen und initialisieren */
#if WITHTILDE
		     GET_HEAP(arity+nfv+1,A_CLOS(*_desc,pta));
#else
                     GET_HEAP(arity+1,A_CLOS(*_desc,pta)); /* heap holen und einhaengen */
#endif /* WITHTILDE */
                     L_CLOS(*_desc,args) = arity;         /* descriptor fuellen */
                     L_CLOS(*_desc,nargs) = 0;
#if WITHTILDE
		     L_CLOS(*_desc,nfv) = nfv;
#endif /* WITHTILDE */
                     L_CLOS(*_desc,ftype) = TY_CONDI;
                     RES_HEAP;
                     pth = (PTR_HEAPELEM)R_CLOS(*_desc,pta);
                     *pth++ = (T_HEAPELEM)TOP_W();        /* conditional */
#if WITHTILDE
		     if (R_CONDI(*(T_PTD)TOP_W(),args) & 0x3) { /* nur die unteren 2 bit */
#else
                     if (R_CONDI(*(T_PTD)TOP_W(),args)) {
#endif /* WITHTILDE */
                      /* argumente duerfen nicht aufgebraucht werden */
                       register T_PTD ptd;
                       for (help = 0; --arity > 0 ; help++) {
                         ptd = (T_PTD)MID_A(help);
                         T_INC_REFCNT(ptd);
                         *pth++ = (T_HEAPELEM)ptd;
                       }
                     }
                     else {
                       /* argumente duerfen aufgebraucht werden */
                       while (--arity > 0) {
                         *pth++ = (T_HEAPELEM)POP_A();
                       }
                     }
#if WITHTILDE
		     for ( help = 0; nfv > 0; nfv--,help++) { /* Tildeframe einsammeln */
		       register T_PTD ptd;

		       ptd = (T_PTD)MID_T(help);
		       T_INC_REFCNT(ptd);
		       *pth++ = (T_HEAPELEM)ptd;
		     }
#endif /* WITHTILDE */
                     PPOP_W();                            /* conditional */
                     *pth = (T_HEAPELEM)TOP_W();          /* praedikat   */
                     REL_HEAP;
                     WRITE_W(_desc);
                     _desc = NULL;
                     goto L_rtf;
    case I_BETA:     /* === BETA f : perform n-ary function call === */
                     FUNCL("beta");
                     ptdesc = (T_PTD)*code++;
                   L_beta:
                     /* ptdesc: funktion (zeiger auf descriptor/code) */
                     if (_redcnt >= beta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= beta_count)) {
#endif /* D_SPEC */
                       _redcnt -= beta_count;        /* count reduction   */
#if (D_SPEC && D_SLAVE)
                       _spec_redcnt -= beta_count;
#endif /* D_SPEC */
                       SWITCHSTACKS();
                       PUSH_R(code);                 /* return address    */
                       code = (INSTR *)ptdesc;       /* subroutine call   */
                       goto loop;
                     }
#if (D_SPEC && D_SLAVE)
                       else SPEC_CODE_1(2,"BETA")
                     }
                       else SPEC_CODE_2(2,"BETA")
#endif /* D_SPEC */
                     /* descriptor holen */
                   L_betafail:
                     GRAB_DESC(ptdesc);              /* descriptor holen */
                     INC_REFCNT(ptdesc);             /* prepare for push */
                     PUSH_W(ptdesc);                 /* push function    */
                     arg = R_COMB(*ptdesc,nargs);    /* args needed      */
#if WITHTILDE
		     nfv = R_COMB(*ptdesc,args);     /* free variables   */
		     if ((arg == 0) && (nfv == 0))
		       goto loop;
#else
                     if (arg == 0) goto loop;        /* keine closure    */
#endif /* WITHTILDE */
                     arity = arg;                    /* number of args   */
                     COMM0("mkbclos");
                     goto L_mkbclos;
    case I_BETA0:    /* === BETA0 f : perform 0-ary function call === */
                     FUNCL("beta0");
                     /* ptdesc: funktion (zeiger auf descriptor/code) */
                     if (_redcnt >= beta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= beta_count)) {
#endif /* D_SPEC */
                       _redcnt -= beta_count;        /* count reduction   */
#if (D_SPEC && D_SLAVE)
                       _spec_redcnt -= beta_count;
#endif /* D_SPEC */
                       PUSH_R(code+1);               /* return address    */
                       SET_TAIL_FLAG();
                       code = (INSTR *)*code;        /* subroutine call   */
                       goto loop;
                     }
#if (D_SPEC && D_SLAVE)
                       else SPEC_CODE_1(1,"BETA0")
                     }
                       else SPEC_CODE_2(1,"BETA0")
#endif /* D_SPEC */

                     ptdesc = (T_PTD)*code++;
                     goto L_betafail;
    case I_BETA1:    /* === BETA1 f : perform 1-ary function call === */
                     FUNCL("beta1");
                     /* ptdesc: funktion (zeiger auf descriptor/code) */
                     if (_redcnt >= beta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= beta_count)) {
#endif /* D_SPEC */
                       _redcnt -= beta_count;        /* count reduction   */
#if (D_SPEC && D_SLAVE)
                       _spec_redcnt -= beta_count;
#endif /* D_SPEC */
                       PUSH_A(POP_W());              /* move argument */
                       PUSH_R(code+1);               /* return address    */
                       SET_TAIL_FLAG();
                       code = (INSTR *)*code;        /* subroutine call   */
                       goto loop;
                     }
#if (D_SPEC && D_SLAVE)
                       else SPEC_CODE_1(1,"BETA1")
                     }
                       else SPEC_CODE_2(1,"BETA1")
#endif /* D_SPEC */

                     ptdesc = (T_PTD)*code++;
                     goto L_betafail;
    case I_JTAIL:    /* === JTAIL f : n-ary tail end recursion === */
                     FUNCL("jtail");
                     /* vorsicht: tail-aufrufe sind sensibel wegen dem */
                     /* stackswitch. anhand eines TAIL_FLAGS auf dem   */
                     /* r-stack wird bei rtf entschieden ob ein stack- */
                     /* switch gemacht wird oder nicht.                */
                     if (_redcnt >= beta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= beta_count)) {
#endif /* D_SPEC */
                       _redcnt -= beta_count;
#if (D_SPEC && D_SLAVE)
                       _spec_redcnt -= beta_count;
#endif /* D_SPEC */
                       SWITCHSTACKS();
                       INVERT_TAIL_FLAG();
                       code = (INSTR *)*code;
                       goto loop;
                     }
#if (D_SPEC && D_SLAVE)
                       else SPEC_CODE_1(1,"JTAIL")
                     }
                       else SPEC_CODE_2(1,"JTAIL")
#endif /* D_SPEC */

                     ptdesc = (T_PTD)*code++;
                     goto L_betafail;
    case I_JTAIL0:   /* === JTAIL0 f : 0-ary tail end recursion === */
                     FUNCL("jtail0");
                     /* ptdesc: funktion (zeiger auf descriptor/code) */
                     if (_redcnt >= beta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= beta_count)) {
#endif /* D_SPEC */
                       _redcnt -= beta_count;
#if (D_SPEC && D_SLAVE)
                       _spec_redcnt -= beta_count;
#endif /* D_SPEC */
                       code = (INSTR *)*code;
                       goto loop;
                     }
#if (D_SPEC && D_SLAVE)
                       else SPEC_CODE_1(1,"JTAIL0")
                     }
                       else SPEC_CODE_2(1,"JTAIL0")
#endif /* D_SPEC */

                     ptdesc = (T_PTD)*code++;
                     goto L_betafail;
    case I_JTAIL1:   /* === JTAIL1 f : 1-ary tail end recursion === */
                     FUNCL("jtail1");
                     /* ptdesc: funktion (zeiger auf descriptor/code) */
                     if (_redcnt >= beta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= beta_count)) {
#endif /* D_SPEC */
                       _redcnt -= beta_count;
#if (D_SPEC && D_SLAVE)
                       _spec_redcnt -= beta_count;
#endif /* D_SPEC */
                       PUSH_A(POP_W());
                       code = (INSTR *)*code;
                       goto loop;
                     }
#if (D_SPEC && D_SLAVE)
                       else SPEC_CODE_1(1,"JTAIL1")
                     }
                       else SPEC_CODE_2(1,"JTAIL1")
#endif /* D_SPEC */

                     ptdesc = (T_PTD)*code++;
                     goto L_betafail;
    case I_BETAQ:    /* === BETAQ f : perform quick n-ary function call === */
                     FUNCL("betaq");
                     SWITCHSTACKS();
                     PUSH_R(code+1);               /* return address    */
                     code = (INSTR *)*code;        /* subroutine call   */
                     goto loop;
    case I_BETAQ0:   /* === BETAQ0 f : perform quick 0-ary function call === */
                     FUNCL("betaq0");
                     PUSH_R(code+1);               /* return address    */
                     SET_TAIL_FLAG();
                     code = (INSTR *)*code;        /* subroutine call   */
                     goto loop;
    case I_UPDATE:   /* === UPDATE f : update function code (CAFs only) === */
                     FUNCL("update");
#ifdef CAF_UPDATE
                     help = TOP_W();    /* function result, just computed by beta0 */
                     ptdesc = (PTR_DESCRIPTOR)*code;    /* ptc */
                     if (ptdesc)                        /* update only once */
                     {
                       DBUG_PRINT("INTER",("ptdesc %x code %x",ptdesc,code));
                       if (T_POINTER(help))
                       {
                        INC_REFCNT((T_PTD)help);         /* will never be freed! */
                        *(INSTR*)ptdesc = I_RTP;
                       }
                       else
                        *(INSTR*)ptdesc = I_RTC;
                       ((INSTR*)ptdesc)++;
                       *(INSTR*)ptdesc = help;
                       for (((INSTR*)ptdesc)++; *(INSTR*)ptdesc != I_END ; )
                        { 
                          DBUG_PRINT("INTER",("I_END %x %d",ptdesc,*(INSTR*)ptdesc));
                          *(INSTR*)ptdesc = I_END;
                          ((INSTR*)ptdesc)++;
                        }
                       *code = 0;       /* update only once */
                     }
#endif /* CAF_UPDATE */
                     code++;
                     goto loop;
    case I_BETAQ1:   /* === BETAQ1 f : perform quick 1-ary function call === */
                     FUNCL("betaq1");
                     PUSH_A(POP_W());
                     PUSH_R(code+1);               /* return address    */
                     SET_TAIL_FLAG();
                     code = (INSTR *)*code;        /* subroutine call   */
                     goto loop;
    case I_JTAILQ:   /* === JTAILQ f : perform quick n-ary tail call === */
                     FUNCL("jtailq");
                     SWITCHSTACKS();
                     INVERT_TAIL_FLAG();
                     code = (INSTR *)*code;
                     goto loop;
    case I_JTAILQ0:  /* === JTAILQ0 f : perform quick 0-ary tail call === */
                     FUNCL("jtailq0");
                     code = (INSTR *)*code;
                     goto loop;
    case I_JTAILQ1:  /* === JTAILQ1 f : perform quick 1-ary tail call === */
                     FUNCL("jtailq1");
                     PUSH_A(POP_W());
                     code = (INSTR *)*code;
                     goto loop;
    case I_MKLIST:   /* === MKLIST n : make n-ary list === */
                     FUNC1("mklist");
                     arity = *code++;
                     /* arity: anzahl der listenelemente (>0!) */
                     /* store list, vgl. store_l in rstpro.c */
                     /* dg 30.01.92 verwendung des globalen _desc wg. scavenge */
                     GET_DESC(_desc);
                     LI_DESC_MASK(_desc,1,C_LIST,TY_UNDEF);
                     GET_HEAP(arity,A_LIST(*_desc,ptdv));
                     L_LIST(*_desc,dim) = arity;
                     RES_HEAP;
                     pth = R_LIST(*_desc,ptdv);
                     while (--arity > 0) {
                       pth[arity] = (T_HEAPELEM)POP_W(); 
                       DBUG_PRINT("INTER", ("adding 0x%x (INT: %d)", pth[arity], VAL_INT(pth[arity])));
                       }
                     pth[arity] = (T_HEAPELEM)TOP_W();
                     DBUG_PRINT("INTER", ("adding 0x%x (INT: %d)", pth[arity], VAL_INT(pth[arity])));
                     REL_HEAP;
                     WRITE_W(_desc);
                     _desc = NULL;
                     goto loop;
    case I_MKSLOT:   /* === MKSLOT : make slot === , cr 09.11.95 */
                     FUNC0("mkslot");
                     /* arity = *code++; */
                     /* arity: anzahl der felder im slot (>0!), z.Z. =2 */
                     /* store list, vgl. store_l in rstpro.c */
                     /* dg 30.01.92 verwendung des globalen _desc wg. scavenge */
                     GET_DESC(_desc);
                     DESC_MASK(_desc,1,C_FRAME,TY_SLOT);
                     L_SLOT(*_desc,value) = (T_HEAPELEM)POP_W();
                     L_SLOT(*_desc,name) = (PTR_DESCRIPTOR)TOP_W();
                     WRITE_W(_desc);
                     _desc = NULL;
                     goto loop;
    case I_MKFRAME:  /* === MKFRAME n : make n-ary frame === , cr 09.11.95 */
                     FUNC1("mkframe");
                     arity = *code++;
                     /* arity: anzahl der slots (>0!) */
                     /* store list, vgl. store_l in rstpro.c */
                     /* dg 30.01.92 verwendung des globalen _desc wg. scavenge */
                     GET_DESC(_desc);
                     DESC_MASK(_desc,1,C_FRAME,TY_FRAME);
                     GET_HEAP(arity,A_FRAME(*_desc,slots));
                     L_FRAME(*_desc,dim) = arity;
                     RES_HEAP;
                     pth = R_FRAME(*_desc,slots);
                     while (--arity > 0)
                       pth[arity] = (T_HEAPELEM)POP_W();
                     pth[arity] = (T_HEAPELEM)TOP_W();
                     REL_HEAP;
                     WRITE_W(_desc);
                     _desc = NULL;
                     goto loop;
    case I_FREE_A:   /* === FREE_A n : free an n-size argument frame === */
                     FUNC1("free_a");
                     arg = *code++;
                     /* arg: anzahl der von i freizugebenden argumente (>0!) */
                     do {
                       ptdesc = (T_PTD)POP_A();
                       T_DEC_REFCNT(ptdesc);
                     } while (--arg > 0);
                     goto loop;
    case I_FREE1_A:  /* === FREE1_A : free one argument === */
                     FUNC0("free1_a");
                     ptdesc = (T_PTD)POP_A();
                     T_DEC_REFCNT(ptdesc);
                     goto loop;
    case I_RTF:      /* === RTF : return function value === */
                     FUNC0("rtf");
                   L_rtf:
                     if (TEST_TAIL_FLAG()) {
                       DEL_TAIL_FLAG();
                     }
		     else {
		       SWITCHSTACKS();
		       PUSH_W(POP_A());                /* move result */
		     }
                     code = POP_RET();             /* returnadresse */
                     goto loop;
    case I_RTM:      /* === RTM : move conditionally from a to w and return === */
                     FUNC0("rtm");
                     if (TEST_TAIL_FLAG()) {
                       DEL_TAIL_FLAG();
                       PUSH_W(POP_A());                /* move */
                     }
                     else {
                       SWITCHSTACKS();
                     }
                     code = POP_RET();             /* returnadresse */
                     goto loop;
    case I_RTP:      /* === RTP p : return pointer === */
                     FUNCX("rtp");
                     ptdesc = (T_PTD)*code;
                     if (TEST_TAIL_FLAG()) {
                       DEL_TAIL_FLAG();
                     }
                     else {
                       SWITCHSTACKS();
                     }
                     INC_REFCNT(ptdesc);
                     PUSH_W(ptdesc);
                     code = POP_RET();             /* returnadresse */
                     goto loop;
    case I_RTC:      /* === RTC c : return constant === */
                     FUNCN("rtc");
                     ptdesc = (T_PTD)*code;
                     if (TEST_TAIL_FLAG()) {
                       DEL_TAIL_FLAG();
                     }
                     else {
                       SWITCHSTACKS();
                     }
                     PUSH_W(ptdesc);
                     code = POP_RET();             /* returnadresse */
                     goto loop;
    case I_RTS:      /* === RTS : return from subroutine === */
                     FUNC0("rts");
                     code = POP_RET();             /* returnadresse */
                     goto loop;
    case I_MKGCLOS:  /* === MKGCLOS n : make general-closure === */
                     FUNC1("mkgclos");
                     arity = *code++;       /* vorhandene argumente */
                   L_mkgclos:
                     arg = arity;
                     func = TY_CLOS;        /* CLOS-flag      */
                     goto L_mkclos;

    case I_MKBCLOS:  /* === MKBCLOS n m : make beta-closure === */
#if WITHTILDE
		     FUNC3("mkbclos");
#else
                     FUNC2("mkbclos");
#endif /* WITHTILDE */
                     arity = *code++;       /* vorhandene argumente */
                     arg   = *code++;       /* benoetigte argumente */
#if WITHTILDE
		     nfv   = *code++;       /* relativ freie Variablen */
#endif /* WITHTILDE */
                   L_mkbclos:
                     func = TY_COMB;        /* COMB-flag  */
                     goto L_mkclos;
    case I_MKCCLOS:  /* === MKCCLOS n m : make cond-closure === */
#if WITHTILDE
		     FUNC3("mkcclos");
#else
                     FUNC2("mkcclos");
#endif /* WITHTILDE */
                     arity = *code++;       /* vorhandene argumente */
                     arg   = *code++;       /* benoetigte argumente */
#if WITHTILDE
		     nfv   = *code++;
#endif /* WITHTILDE */
                   L_mkcclos:
                     func = TY_CONDI;       /* COND-flag */
                     goto L_mkclos;
    case I_MKSCLOS:  /* === MKSCLOS n m : make switch/case-closure === */
#if WITHTILDE
		     FUNC3("mksclos");
#else
                     FUNC2("mksclos");

                     DBUG_PRINT ("INTER", ("MKSCLOS reached..."));
#endif /* WITHTILDE */
                     arity = *code++;       /* vorhandene argumente */
                     arg   = *code++;       /* benoetigte argumente */
#if WITHTILDE
		     nfv   = *code++;
#endif /* WITHTILDE */
                   L_mksclos:
                     func = TY_CASE;        /* CASE-flag */
                     DBUG_PRINT ("INTER", ("L_mksclos reached..."));
                     goto L_mkclos;
    case I_MKDCLOS:  /* === MKDCLOS n m : make delta-closure === */
                     FUNC2("mkdclos");
                     arity = *code++;       /* vorhandene argumente */
                     arg   = *code++;       /* benoetigte argumente */
#if WITHTILDE
		     nfv   = 0;
#endif /* WITHTILDE */                   
		   L_mkdclos:
                     func = TY_PRIM;        /* PRIM(FUNC)-flag */
                     goto L_mkclos;
                     
    case I_MKICLOS:  /* === MKICLOS n m : make interaction-closure === */
                                                       /* stt 11.09.95 */
                     FUNC2("mkiclos");
                     arity = *code++;       /* vorhandene argumente */
                     arg   = *code++;       /* benoetigte argumente */
#if WITHTILDE
                     nfv   = 0;
#endif /* WITHTILDE */
                     func = TY_INTACT;

                   L_mkclos:
                     /* stack w: oben die funktion, darunter die argumente */
                     /* arity: anzahl der argumente auf'm stack (>0!)      */
                     /* arg: anzahl der von der fkt. benoetigten argumente */
		     /* nfv: anzahl der relativ freien Variablen der fkt   */
		     /*      Sollten an dieser Stelle alle vorhanden sein! */
                     /* func: flag das den typ der funktion angibt         */

                   DBUG_PRINT ("INTER", ("L_mkclos reached..."));
#if WITHTILDE
		     if ((arity == 0) && (nfv == 0)) goto loop;
#else
                     if (arity == 0) goto loop;
#endif /* WITHTILDE */
                     /* dg 30.01.92 verwendung des globalen _desc wg. scavenge */
                     MAKEDESC(_desc,1,C_FUNC,TY_CLOS);
#if WITHTILDE
		     GET_HEAP(nfv+arg+1,A_CLOS(*_desc,pta));
#else
                     GET_HEAP(arg+1,A_CLOS(*_desc,pta));
#endif
                     L_CLOS(*_desc,args) = arity;
                     L_CLOS(*_desc,nargs) = arg - arity;
#if WITHTILDE
		     L_CLOS(*_desc,nfv) = nfv;
#endif /* WITHTILDE */
                     L_CLOS(*_desc,ftype) = func;      /* flag */
                     RES_HEAP;
                     pth = (PTR_HEAPELEM)R_CLOS(*_desc,pta);
#if WITHTILDE
                     DBUG_PRINT ("INTER", ("building closure..."));

		     /* Die closure sieht aus:                               */
		     /*                                                      */
		     /* Funktionspointer | DeBruinvariablen | Tildevariablen */
		     /*                                                      */
		     /* Die Anzahl der DeBruinvariablen oder die Zahl der    */
		     /* Tildevariablen kann Null sein, nicht jedoch beide    */

		     if (gamma_closure > 0) {
                       DBUG_PRINT ("INTER", ("gamma_closure"));
		       *pth++ = (T_HEAPELEM)POP_R(); /* Funktionszeiger liegt auf R */

		       while (arity-- > 0) {
			 *pth++ = (T_HEAPELEM)POP_W(); /* DeBruinvariablen */
		       }
		       {
			 if (gamma_closure == 1) {
			   while (nfv > 0) {
			     /* gammaclosures poppen ihre argumente von r */
			     /* da free_r direkt folgt                    */
			     *pth++ = (T_HEAPELEM)POP_R();
			     nfv--;
			   }
			 }
			 else { /* gamma_closure = 2 */
			   int old_nfv = nfv;

			   while (nfv > 0) {
			     /* tildevariablen werden vom freesw_t */
			     /* freigegeben                        */
			     *pth++ = (T_HEAPELEM)MID_R(old_nfv-nfv);
			     T_INC_REFCNT((PTR_DESCRIPTOR)MID_R(old_nfv-nfv));
			     nfv--;
			   }
			   SWITCHSTACKS_T(); /* for freesw_t */
			 }
		       }
		       gamma_closure = 0;
		     }
		     else { /* gamma_closure = 0 */
                       DBUG_PRINT ("INTER", ("no gamma_closure")); 
		       *pth++ = (T_HEAPELEM)POP_W(); /* Funktionszeiger liegt auf W */
                       DBUG_PRINT ("INTER", ("arity: %i, nfv: %i", arity, nfv));

		       while (arity-- > 0) {
			 *pth++ = (T_HEAPELEM)POP_W(); /* DeBruinvariablen */
		       }
		       {
			 int old_nfv = nfv;

			 while (nfv > 0) {
			   /* tildevariablen werden in der aufrufenden */
			   /* funktion freigegeben                     */

/* fprintf(debugger, "0x%x: INTER test, stacksize T = %d, old_nfv-nfv = %d\n", curr_pid, d_stacksize(ps_t), old_nfv-nfv); fflush(debugger); */

			   *pth++ = (T_HEAPELEM)MID_T(old_nfv-nfv);
			   T_INC_REFCNT((PTR_DESCRIPTOR)MID_T(old_nfv-nfv));
			   nfv--;
			 }
		       }
                       DBUG_PRINT("INTER", ("where's the problem ?"));
		     }
#else
                     do {
                       *pth++ = (T_HEAPELEM)POP_W();
                     } while (--arity >= 0);
#endif
                     REL_HEAP;

                     DBUG_PRINT ("INTER", ("refcnt: %d", (((T_PTD)_desc)->u.sc.ref_count)));

                     DBUG_PRINT("INTER", ("closure ready..."));

                     PPUSH_W(_desc);
                     _desc = NULL;
                     goto loop;
    case I_MKAP:     /* === MKAP n : make application (not reducible at all) === */
                     FUNC1("mkap");
                     arity = *code++;
                     /* arity: anzahl der argumente (>0!)                   */
                     /* stack a: oben die "funktion" darunter die argumente */
                     goto L_mkap;
    case I_APPLY:    /* === APPLY n : perform application === */
                     FUNC1("apply");

                     arity = *code++;
#if (D_SPEC && D_SLAVE)
                     /* the problem is, if there are no more reduction steps left, */
                     /* nothing should be done right here, because L_apply is where */
                     /* the action takes place. So we have to insert a workaround here. */

                     if (_redcnt >= beta_count) {
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= beta_count)) { /* is this a problem ?! */
                         /* if beta_count is 0, and apply jumps to L_case, where */
                         /* delta_count is compared, THEN we've got a problem ! */
                      }
                      else SPEC_CODE_1(2,"APPLY")
                     }
                     else SPEC_CODE_2(2,"APPLY")
#endif
                     goto L_apply;

                     /* --- specials --- */

    case I_SAPPLY:   /* === SAPPLY : special apply === */
                     FUNC0("sapply");

#if (D_SPEC && D_SLAVE)
                     /* same thing as in I_APPLY */

                     if (_redcnt >= beta_count) {
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= beta_count)) { /* is this a problem ?! */
                         /* if beta_count is 0, and sapply jumps to L_case, where */
                         /* delta_count is compared, THEN we've got a problem ! */
                      }
                      else SPEC_CODE_1(1,"SAPPLY")
                     }
                     else SPEC_CODE_2(1,"SAPPLY")
#endif
                     arity = POP_R();       /* anz. der arg. vom stack r */
                     COMM0("sapply");
                     goto L_apply;
    case I_SRET:     /* === SRET : special free and return === */
                     FUNC0("sret");
                     arity = POP_E(); /* POP_M() */ /* anz. der arg. vom stack e */
                     for ( ; --arity >= 0 ; ) {
                       ptdesc = (T_PTD)POP_A();
                       T_DEC_REFCNT(ptdesc);
                     }
                     code = POP_RET();             /* returnadresse */
                     goto loop;

#if NotUsed
                     /* --- specials for postprocessing --- */

    case I_MKTHEN:   /* === MKTHEN : close then-expression === */
                     /* stack a |.. arg_n .. arg_1 ptcond */
                     FUNC0("mkthen");
                     PUSH_R(_redcnt);                         /* save redcnt */
                     _redcnt = delta_count;                   /* reset       */
                     ptdesc = (T_PTD)POP_W();                 /* conditional */
                     PUSH_R(ptdesc);                          /* conditional */
                     if (R_CONDI(*ptdesc,args) == 0) {        /* jtrue       */
                       /* conditional gibt die argumente frei */
                       register T_PTD ptd;
                       arity = R_CONDI(*ptdesc,nargs)-2;
                       /* copy arguments */
                       for (arg = arity ; arg >= 0 ; arg-- ) {
                         ptd = (T_PTD)MID_W(arity);
                         T_INC_REFCNT(ptd);
                         PUSH_W(ptd);
                       }
                     }
                     SWITCHSTACKS();
                     PUSH_W(SA_TRUE);
                     PUSH_R(code);                            /* return addr */
                     code = R_CONDI(*ptdesc,ptc);
                     goto loop;
    case I_MKELSE:   /* === MKELSE : close else-expression === */
                     /* stack r |.. _redcnt ptcond, stack a |.. then  */
                     FUNC0("mkelse");
                     _redcnt = delta_count;                   /* reset       */
                     ptdesc = (T_PTD)TOP_R();                 /* conditional */
                     PUSH_R(POP_W());                         /* then-expr   */
                     if (R_CONDI(*ptdesc,args) == 0) {        /* jtrue       */
                       /* conditional gibt die argumente frei */
                       register T_PTD ptd;
                       arity = R_CONDI(*ptdesc,nargs)-2;
                       for (arg = arity ; arg >= 0 ; arg-- ) {
                         ptd = (T_PTD)MID_W(arity);
                         T_INC_REFCNT(ptd);
                         PUSH_W(ptd);
                       }
                     }
                     SWITCHSTACKS();
                     PUSH_W(SA_FALSE);
                     PUSH_R(code);                            /* return addr */
                     code = R_CONDI(*ptdesc,ptc);
                     goto loop;
    case I_MKCOND:   /* === MKCOND : make conditional === */
                     /* stack r |.. _redcnt ptcond then, stack a: |.. else */
                     FUNC0("mkcond");
                     arg = POP_W();                  /* else-expr      */
                     arity = POP_R();                /* then-expr      */
                     ptdesc = (T_PTD)POP_R();        /* conditional    */
                     DEC_REFCNT(ptdesc);             /* wird nicht frei */
                     PUSH_W(arity);                  /* then-expr      */
                     PUSH_W(arg);                    /* else-expr      */
                     PUSH_W(SET_ARITY(COND,2));      /* cond-constr    */
                     _redcnt = POP_R();              /* alter _redcnt  */
                     goto loop;

#endif /* NotUsed : mah 010294 */

/* #if !UH_ZF_PM */

    case I_CASE:     /* === CASE f : execute case === */
                     FUNCL("case");

                     ptdesc = (T_PTD)*code++;
                   L_case:
                     if (_redcnt >= delta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= delta_count)) {
#endif /* D_SPEC */
                       _redcnt -= delta_count;
#if (D_SPEC && D_SLAVE)
                         _spec_redcnt -= delta_count;
#endif /* D_SPEC */
                       PUSH_R(code);
                       SET_TAIL_FLAG();   
                       code = (INSTR *)ptdesc;       /* subroutine call   */
                       goto loop;
                     }
#if (D_SPEC && D_SLAVE)
                       else SPEC_CODE_1(2,"CASE")
                     }
                       else SPEC_CODE_2(2,"CASE")
#endif /* D_SPEC */
                     /* case schliessen */
#if UH_ZF_PM
         /*            post_mortem ("UH_PM: no _redcounting yet !"); NOW IT's THERE ! :-) */
#endif /* UH_ZF_PM */

#if WITHTILDE
		   L_casefail:
                     GRAB_DESC(ptdesc);         /* descriptor holen */
		     INC_REFCNT(ptdesc);
		     if (gamma_closure)
		       PUSH_R(ptdesc);
		     else
		       PUSH_W(ptdesc);
		     arg = R_CASE(*ptdesc,nargs); /* args needed      */
		     nfv = R_CASE(*ptdesc,args);  /* tilde frame size */
		     if ((arg == 0) && (nfv == 0))
		       goto loop;
		     arity = arg;
		     COMM0("mksclos");
		     goto L_mksclos;
#else
                     GRAB_DESC(ptdesc);         /* descriptor holen */
                     func = TY_CASE;
                     COMM0("nomatch");
                     goto L_nomatch;
#endif /* WITHTILDE */
    case I_WHEN:     /* === WHEN f : execute pattern match === */
                     FUNCX("when");
                     ptdesc = (T_PTD)*code++;
                     RES_HEAP;       /* heap wird in pm_am freigegeben !!! */
                     pm_am(R_MATCH(*ptdesc,code),TOP_W());
                     /* pm_am hinterlaesst auf stack w SA_TRUE (DOLLAR auf m) */
                     /* falls das pattern passt, HASH falls das pattern nicht */
                     /* passt und KLAA falls das matching nicht entscheidbar */
                     goto loop;
    case I_GUARD:    /* === GUARD f : reduce guard === */
                     FUNCL("guard");
                     ptdesc = (T_PTD)*code++;
                     if (T_HASH(TOP_W())) {
                       /* pattern passt nicht, body instr. folgt */
                       goto loop;
                     }
                     if (T_SA_TRUE(TOP_W())) {
                       /* pattern passt */
                       PPOP_W();                   /* SA_TRUE */
                       PUSH_R(code);               /* return adresse */
                       SET_TAIL_FLAG();            /* TAIL-call */
                       code = (INSTR *)ptdesc;     /* subroutine jump */
                       goto loop;
                     }
                     /* matching unentscheidbar */
                     GRAB_DESC(ptdesc);            /* GUARD descriptor holen */
                     goto L_undecided;
    case I_BODY:     /* === BODY f : reduce body === */
                     FUNCL("body");
                     ptdesc = (T_PTD)*code++;
                     if (T_HASH(TOP_W())) {
                       /* pattern passt nicht */
                       PPOP_W();                   /* hash symbol */
                       goto loop;
                     }
                     if (T_SA_TRUE(TOP_W())) {
                       /* pattern passt und guard true */
                       register T_PTD ptd;
                       PPOP_W();                   /* SA_TRUE */
                       if (T_DOLLAR(TOP_R()))
                         PPOP_R();                 /* anzahl der patternvariablen */
                       ptd = (T_PTD)POP_W();       /* das zu matchende argument */
                       if (T_POINTER((int)ptd))
                         DEC_REFCNT(ptd);
                       code = (INSTR *)ptdesc;     /* jump   */
                       goto loop;
                     }
                     if (T_SA_FALSE(TOP_W())) {
                       /* pattern passt aber guard false */
                       register T_PTD ptd;
                       PPOP_W();                   /* SA_FALSE */
                       arg = VALUE(POP_R());       /* anzahl der patternvariablen */
                       /* variableninstanzen freigeben */
                       for (; arg > 0 ; arg--) {
                         ptd = (T_PTD)POP_A();
                         if (T_POINTER((int)ptd))
                           DEC_REFCNT(ptd);
                       }
                       goto loop;
                     }
                     /* guard weder true noch false */
                     GRAB_DESC(ptdesc);              /* BODY descriptor holen */
                   L_undecided:

#if D_SLAVE
/* fprintf(debugger, "L_undecided reached !\n"); fflush(debugger); */
/* fprintf(stderr, "******************SUCKER undecided !!!\n*\n*\n*\n"); fflush(stderr); sleep(1); */
/* initialize_fred_fish();*/
#endif

                   DBUG_PRINT("inter",("bei L_undecided angekommen !"));
                     {
                       register T_PTD ptd;
#if !WITHTILDE
                       register int i;
#endif /* !WITHTILDE */
                       /* NOMAT descriptor anlegen */
                       MAKEDESC(ptd,1,C_EXPRESSION,TY_NOMAT);
                       /* nr. des fehlgeschlagenen when eintragen */
#if UH_ZF_PM
                       L_NOMAT(*ptd,act_nomat) = VAL_INT((int)R_CASE(*ptdesc,ptc));
#else
                       L_NOMAT(*ptd,act_nomat) = R_CASE(*ptdesc,args);
#endif

#if !UH_ZF_PM
                       ptdesc = R_CASE(*ptdesc,ptd);        /* CASE descriptor */
#endif
                       DBUG_PRINT("INTER",("hier hinweg gekommen !"));
#if WITHTILDE
		       nfv = R_CASE(*ptdesc,args);           /* relativly free vars */
#endif
                       arity = R_CASE(*ptdesc,nargs);       /* gesamtanzahl argumente des CASE*/
                       ptdesc = R_CASE(*ptdesc,ptd);        /* SWITCH descriptor */
#if WITHTILDE
                       arg  = R_SWITCH(*ptdesc,anz_args);    /* Stelligkeit des SWITCH */
#else
                       arg  = R_SWITCH(*ptdesc,case_type);  /* NCASE: stelligkeit des SWITCH */
#endif /* WITHTILDE */
                       INC_REFCNT(ptdesc);
                       L_NOMAT(*ptd,ptsdes) = ptdesc;       /* SWITCH descriptor */
  
                       DBUG_PRINT("INTER", ("before if..."));

                       if (T_KLAA(TOP_W())) {
                         /* match nicht entscheidbar */
                         COMM0("match undecided");
                         DBUG_PRINT ("INTER", ("match undecided"));
#if WITHTILDE
			 GET_HEAP(4,A_NOMAT(*ptd,guard_body));
			 L_NOMAT(*ptd,guard_body)[0] = 3;          /* length   */
                         L_NOMAT(*ptd,guard_body)[1] = 0;          /* guard    */
                         L_NOMAT(*ptd,guard_body)[2] = 0;          /* body     */
                         PPOP_W();                                 /* KLAA     */
                         L_NOMAT(*ptd,guard_body)[3] = POP_W();    /* argument */

			 L_NOMAT(*ptd,reason) = 2;          /* match undecided */

#else
			 L_NOMAT(*ptd,guard_body) = 0;        /* no GUARD/BODY */
                         PPOP_W();                            /* KLAA */
#endif /* WITHTILDE */
                       }
                       else {

#if WITHTILDE
			 int top_r;
#endif /* WITHTILDE */

                         /* pattern passte, aber guard weder true noch false */
                         COMM0("guard undecided"); 
                         DBUG_PRINT("INTER", ("guard undecided"));
                         /* MATCH descriptor holen */
                         ptdesc = (T_PTD)R_SWITCH(*ptdesc,ptse)[R_NOMAT(*ptd,act_nomat)];
#if WITHTILDE
			 /* build closure around body expression */

			 /* [ closure -> comb -> sub [patvars] -> body ] */

			 top_r = VALUE(TOP_R());

			 MAKEDESC(_desc,1,C_FUNC,TY_CLOS);

			 GET_HEAP(nfv+top_r+1,A_CLOS(*_desc,pta));

			 L_CLOS(*_desc,args) = top_r;
			 L_CLOS(*_desc,nargs) = 0;
			 L_CLOS(*_desc,nfv) = nfv;
			 L_CLOS(*_desc,ftype) = TY_NOMATBODY;

			 pth = (PTR_HEAPELEM)R_CLOS(*_desc,pta);			 

			 *pth++ = (T_HEAPELEM)0; /* dummy, pointer to body is entered later */

			 while (top_r-- > 0) {
			   *pth++ = (T_HEAPELEM)POP_A(); /* DeBruinvariablen */
			 }
			 {
			   int dec_nfv = nfv;

			   while (dec_nfv > 0) {
			     /* tildevariablen werden in der aufrufenden */
			     /* funktion freigegeben                     */
			     *pth++ = (T_HEAPELEM)MID_T(nfv-dec_nfv);
			     T_INC_REFCNT((PTR_DESCRIPTOR)MID_T(nfv-dec_nfv));
			     dec_nfv--;
			   }
			 }

                         DBUG_PRINT("INTER", ("vor dem load_expr"));
			 load_expr(A_MATCH(*ptdesc,body));
                         DBUG_PRINT("INTER", ("nach dem load_expr"));

#else
                         /* das ist ein gewuerge hier! */
                         load_expr(A_MATCH(*ptdesc,body));  /* body (auf e) einlagern */
                         if (T_SNAP(TOP_E())) {
                           /* nummernvariablen ersetzen */
                           /* VALUE(TOP_R(): anzahl der pm-bindungen auf a */
                           /* arity-arg: anzahl der freien variablen des case */
                           help = arity-arg-1+VALUE(TOP_R());
                           /* help ist der index der untersten variablenbindung auf i */
                           for (i = ARITY(TOP_E()); i > 0 ; i-- ) {
                             if (T_NUM(MID_E(i))) {
                               ptdesc = (T_PTD)MID_A(help-VALUE(MID_E(i))); /* adressierung "von unten" */
                               T_INC_REFCNT(ptdesc);
                               UPDATE_E(i,ptdesc);
                             }
                           }
                         }

                         if ((i = VALUE(POP_R())) > 0 ) {
                           /* i: anz pm-bindungen >0 also body schliessen */
                           help = T_SNAP(TOP_E()) ? ARITY(POP_E())+i : i+1;
                           for (; i > 0 ; i--)
                             PUSH_E(POP_A());
                           PUSH_E(SET_ARITY(SNAP,help));
                         }
#endif /* WITHTILDE */
                         trav_e_a();
#if WITHTILDE
			 /* hier bekommt der ausdruck keinen expr-descriptor, */
			 /* sondern einen sub-descriptor, der die variablen   */
			 /* bindet, die auch das match bindet.==> nomat-post  */

			 trav_a_hilf();

			 {
			   register T_PTD ptd2;

			   MAKEDESC(ptd2,1,C_EXPRESSION,TY_SUB);

			   L_FUNC(*ptd2,nargs)    = VALUE(TOP_R()); /* bound variables */
			   L_FUNC(*ptd2,special)  = 0;
			   L_FUNC(*ptd2,namelist) = 0;

			   if (mvheap(A_FUNC((*ptd2),pte)) == NULL)       /* Auslagern */
			     POST_MORTEM("inter: Heap out of space");

			   L_CLOS(*_desc,pta)[0] = (T_HEAPELEM)ptd2;      /* sub */

			 }
			 /* and now number one:  the comb descriptor */

			 {
			   register T_PTD ptd2;

			   MAKEDESC(ptd2,1,C_FUNC,TY_COMB);

			   L_COMB((*ptd2),args)  = 0;       /* tildeargs */
			   L_COMB((*ptd2),nargs) = VALUE(POP_R());
			   L_COMB((*ptd2),ptd)   = (T_PTD)R_CLOS(*_desc,pta)[0]; /* sub */
			   L_COMB((*ptd2),ptc)   = (INSTR *)0;

			   L_CLOS(*_desc,pta)[0] = (T_HEAPELEM)ptd2;      /* comb */
			 }
#else
                         if ((ptdesc = (T_PTD)st_expr()) == NULL)
                           POST_MORTEM("inter: heap overflow (body)");
#endif /* WITHTILDE */

                         /* NOMAT-descriptor anlegen */
#if WITHTILDE
			 GET_HEAP(4,A_NOMAT(*ptd,guard_body));
                         L_NOMAT(*ptd,guard_body)[0] = 3;            /* length          */
                         L_NOMAT(*ptd,guard_body)[1] = POP_W();      /* guard           */
                         L_NOMAT(*ptd,guard_body)[2] = (int)_desc;   /* body in closure */
			 L_NOMAT(*ptd,guard_body)[3] = POP_W();      /* argument        */

			 L_NOMAT(*ptd,reason) = 3; /* guard undecided (not true nor false) */

			 _desc = NULL;
#else
                         GET_HEAP(3,A_NOMAT(*ptd,guard_body));
                         L_NOMAT(*ptd,guard_body)[0] = 2;            /* laenge */
                         L_NOMAT(*ptd,guard_body)[1] = POP_W();      /* guard */
                         L_NOMAT(*ptd,guard_body)[2] = (int)ptdesc;  /* body */
#endif /* WITHTILDE */
                       }
                       /* ptd: NOMAT descriptor */
                       /* arity : anzahl argumente des CASE */
                       /* arg : stelligkeit des SWITCH (NCASE) */

#if !WITHTILDE
                       if (arg > 1) {
                         /* NCASE: multiple pattern, load argument list onto the stack */
                         load_pmlist(ps_w,POP_W());
                       }
                       /* close NOMAT-descriptor */
                       MAKEDESC(ptdesc,1,C_EXPRESSION,TY_EXPR);
                       arity += (arity > arg) ? 4 : 3;
                       GET_HEAP(arity,A_EXPR(*ptdesc,pte));
                       RES_HEAP;
                       pth    = (PTR_HEAPELEM)R_EXPR(*ptdesc,pte); /* heap vector */
                       *pth++ = (T_HEAPELEM)(--arity);             /* groesse     */
                       *pth++ = (T_HEAPELEM)SET_ARITY(AP,arg+1);   /* AP */
                       for (i = arg; --i >=0 ; --arity)
                         *pth++ = (T_HEAPELEM)POP_W();             /* argument */
                       arity -= 2;
                       if (arity > 0) {
                         *pth++ = SET_ARITY(SNAP,arity);
                         for (--arity ; --arity >= 0 ;) {
                           if (T_POINTER(MID_A(arity)))
                             INC_REFCNT((T_PTD)MID_A(arity));
                           *pth++ = (T_HEAPELEM)MID_A(arity);
                         }
                       }
                       *pth++ = (T_HEAPELEM)ptd;          /* NOMAT descr */
                       REL_HEAP;
                       PPUSH_W(ptdesc);                   /* EXPR descriptor */
#else
		       PUSH_W(ptd);                       /* NOMAT descriptor */

		       if (nfv > 0) {
			 /* build closure */
			 COMM0("mksclos");
			 code = rout_sclos;
                         DBUG_PRINT ("INTER", ("nfv for rout_sclos prepared !"));
			 *(code + 3) = nfv;
			 goto loop;
		       }

#endif /* !WITHTILDE */
                       code = rout_rtf;                   /* nachher return */
                       goto loop;
                     }
    case I_NOMATCH:  /* === NOMATCH f : handle nomatch === */
                     FUNCX("nomatch");
                     ptdesc = (T_PTD)*code++;
#if    UH_ZF_PM
L_real_nomatch:

#if D_SLAVE
/*  fprintf(debugger, "L_real_nomatch reached !\n"); fflush(debugger); 
 fprintf(stderr, "*******SUCKER real unmatch!\n*\n*\n*\n*\n"); fflush(stderr); */
/* initialize_fred_fish();*/
#endif

#endif /* UH_ZF_PM */
                     _redcnt += delta_count;
#if (D_SPEC && D_SLAVE)
                      if ((T_SPEC_PROCESS(curr_pid)==1) && !T_SPEC_FOLD(curr_pid)) {
                        _spec_redcnt += delta_count;
                        }
#endif

L_real_nomatch2:

                     DBUG_PRINT("INTER", ("Daten von ptdesc:"));
                     DBUG_PRINT("INTER", ("R_CASE(*ptdesc,nargs) = %d", R_CASE(*ptdesc,nargs)));
                     DBUG_PRINT("INTER", ("R_CASE(*ptdesc,args) = %d", R_CASE(*ptdesc,args)));
                     DBUG_PRINT("INTER", ("R_CASE(*ptdesc,ptc) = %x", R_CASE(*ptdesc,ptc)));
                     DBUG_PRINT("INTER", ("R_CASE(*ptdesc,ptd) = %x", R_CASE(*ptdesc,ptd)));
                     DBUG_PRINT("INTER", ("R_CASE(*ptdesc,ref_count) = %d", R_CASE(*ptdesc,ref_count)));


#if WITHTILDE
		     {
		       register T_PTD ptd;

		       nfv = R_CASE(*ptdesc,args);

                       DBUG_PRINT("INTER", ("nfv: %d", nfv));

		       /* NOMAT descriptor anlegen */
                       MAKEDESC(ptd,1,C_EXPRESSION,TY_NOMAT);
                       /* nr. des fehlgeschlagenen when eintragen */
                       L_NOMAT(*ptd,act_nomat) = 0;

		       INC_REFCNT(ptdesc);
                       L_NOMAT(*ptd,ptsdes) = R_CASE(*ptdesc,ptd);   /* SWITCH descriptor */

                       DBUG_PRINT("INTER", ("pdsdes is %x !", R_NOMAT(*ptd,ptsdes)));

		       GET_HEAP(4,A_NOMAT(*ptd,guard_body));
		       L_NOMAT(*ptd,guard_body)[0] = 3;          /* length   */
		       L_NOMAT(*ptd,guard_body)[1] = 0;          /* guard    */
		       L_NOMAT(*ptd,guard_body)[2] = 0;          /* body     */

                       DBUG_PRINT("INTER", ("is this the relevant POP ? ..."));

		       L_NOMAT(*ptd,guard_body)[3] = POP_W();    /* argument */

                       DBUG_PRINT("INTER", ("... it was not."));

		       L_NOMAT(*ptd,reason) = 1;                  /* nomatch */
		       PUSH_W(ptd);                      /* NOMAT descriptor */

		       if (nfv > 0) {
			 /* build closure */
			 COMM0("mksclos");
                         DBUG_PRINT ("INTER", ("nfv for rout_sclos prepared !"));
			 code = rout_sclos;
			 *(code + 3) = nfv;                 /* replace dummy */
			 goto loop;
		       }
		       goto loop;
		     }
#else
                     func = TY_CASE;

                     /* NCASE */
                     if ((int)R_SWITCH(*R_CASE(*ptdesc,ptd),case_type) > 1) {
                       /* multiple pattern, load argument list onto the stack */
                       load_pmilist(ps_w,POP_W());
                     }
                   L_nomatch:
                     /* ptdesc: case (nicht auf'm stack) */
                     /* func:   function type (TY_COMB, TY_CASE ...) */
                     INC_REFCNT(ptdesc);
                     arity = R_CASE(*ptdesc,nargs);   /* anz. arg. */
                     /* NCASE: stelligkeit des original SWITCH ermitteln */
                     arg = R_SWITCH(*R_CASE(*ptdesc,ptd),case_type);
                     help = (int)ptdesc;              /* case */
                     MAKEDESC(ptdesc,1,C_FUNC,TY_CLOS);
                     GET_HEAP(arity+1,A_CLOS(*ptdesc,pta));
                     L_CLOS(*ptdesc,args) = arity;
                     L_CLOS(*ptdesc,nargs) = 0;
                     L_CLOS(*ptdesc,ftype) = func;
                     RES_HEAP;
                     pth = (PTR_HEAPELEM)R_CLOS(*ptdesc,pta);
                     *pth++ = (T_HEAPELEM)help;    /* case */
                     /* NCASE: anzahl der freien variablen ermitteln und auf a pushen */
                     { int i = arity-arg;
                       for (arg = 0 ; --i >= 0 ; arg++, arity--) {
                         help = MID_A(arg);
                         if (T_POINTER(help))
                           INC_REFCNT((T_PTD)help);
                         *pth++ = (T_HEAPELEM)help;
                       }
                     }
                     /* NCASE: argumente in die closure packen */
                     for ( ; --arity >= 0 ; ) {
                       *pth++ = POP_W();          /* argument */
                     }
                     REL_HEAP;
                     PPUSH_W(ptdesc);
                     goto loop;
#endif /* WITHTILDE */

/* #endif UH_ZF_PM */

    case I_DUPARG:   /* === DUPARG n : duplicate argument n (on stack i) === */
                     FUNC1("duparg");
                     arg = *code++;
                     ptdesc = (T_PTD)MID_A(arg);
                     T_INC_REFCNT(ptdesc);
                     PUSH_A(ptdesc);
                     goto loop;
    case I_LSEL:     /* === LSEL : select list element (inline) === */
                   L_lsel:
                     FUNC0("lsel");
                     if (_redcnt >= delta_count) {
                       /* red_lselect inline (vgl. rlstruct.c) */
                       arg = POP_W();         /* index */
                       arity = TOP_W();       /* list/string */
                       if (T_POINTER(arity)) {
                         register T_PTD ptd1 = (T_PTD)arg;
                         register T_PTD ptd2 = (T_PTD)arity;
                         int index;
                         if (R_DESC(*ptd2,class) == C_LIST) {
                           /* index extrahieren */
                           if (T_INT(arg))
                             index = VAL_INT(arg);
                           else
                           if (T_POINTER(arg))
                             if (R_DESC(*ptd1,class) == C_SCALAR) {
                               index = R_SCALAR(*ptd1,valr);
                               if (index != R_SCALAR(*ptd1,valr))
                                 index = 0; /* weil nicht ganzzahlig! */
                             }
                             else
                             if (R_DESC(*ptd1,class) == C_DIGIT
                              && conv_digit_int(arg,&index))
                               ; /* konvertierung hat geklappt */
                             else index = 0;
                           else index = 0;
                           /* damit ist der index extrahiert */
                           if (0 < index && index <= (int) R_LIST(*ptd2,dim)) {
              /* int gecastet von RS 5.11.1992 */
                             /* element aus der liste rausholen */
                             ptdesc = (T_PTD)R_LIST(*ptd2,ptdv)[--index];
                             T_DEC_REFCNT(ptd1);       /* parameter freigeben */
                             _redcnt -= delta_count;
                             if (T_POINTER((int)ptdesc)) {
                               INC_REFCNT(ptdesc);
                               WRITE_W(ptdesc);
                               /* LAZY LISTS */
                               if (LazyLists
                                && R_DESC(*ptdesc,class) == C_FUNC
                                && R_UNIV(*ptdesc,nargs) == 0) {
                                 if (R_DESC(*ptd2,ref_count) > 1) {
                                   /* eval und update */
                                   PUSH_A(index);
                                   PUSH_A(ptd2);              /* liste */
                                   PUSH_R(code);
                                   code = rout_updat;
                                 }
                                 else {
                                   DEC_REFCNT(ptd2);   /* liste freigeben */
                                 }
                                 COMM0("eval");
                                 goto L_eval;
                               } /* end LAZY LISTS */
                             } /* end T_POINTER */
                             else {
                               /* kein pointer, character? */
                               if (T_STR_CHAR((int)ptdesc)) {
                                 /* indirekten descriptor fuer char anlegen */
                                 ++index;
                                 ptdesc = gen_id(index,index,ptd2);
                               }
                               WRITE_W(ptdesc);
                             }
                             DEC_REFCNT(ptd2);       /* liste freigeben */
                             goto loop;
                           }
                           /* index nicht im bereich */
                         }
                         /* keine liste */
                       }
                       /* argumente sind nicht pointer, lselect klappt nie! */
                       PPUSH_W(arg);
                     }
                     PUSH_W(LSELECT);
                     arity = arg = 2;
#if WITHTILDE
		     nfv = 0;
#endif /* WITHTILDE */
                     COMM0("mkdclos");
                     goto L_mkdclos;

/* #ifdef LAZY */
                     /* --- lazy specials --- */

    case I_EVAL:     /* === EVAL : evaluate === */
                     FUNC0("eval");
                     /* hier wird vorausgesetzt, dass auf a eine */
                     /* closure oder eine 0-stellige funktion liegt */
                   L_eval:
                     ptdesc = (T_PTD)POP_W();
                     if (R_DESC(*ptdesc,type) == TY_CLOS) {
                       /* (gesaettigte?) closure auf a */
                       register PTR_HEAPELEM pth;
                       arity = R_CLOS(*ptdesc,args); /* anzahl argumente */
                       PUSH_A(arity);                /* anzahl argumente */
                       PUSH_A(0);                    /* bottomsymbol */
                       RES_HEAP;
                       pth = R_CLOS(*ptdesc,pta);
                       /* argumente und funktion auf stack i */
                       do {
                         T_INC_REFCNT((T_PTD)*pth);
                         PUSH_A(*pth++);
                       } while (--arity >= 0);
                       REL_HEAP;
                       DEC_REFCNT(ptdesc);           /* closure freigeben */
                       COMM0("eval0");
                       goto L_eval0;
                     }
                  /* if (R_DESC(*ptdesc,type) == TY_COMB) */
                     /* 0-stellige funktion auf a */
                     DEC_REFCNT(ptdesc);             /* wird nicht frei! */
                     COMB_CODE(ptdesc);              /* zeiger auf code holen */
                     COMM0("beta");

#if D_SLAVE
/*fprintf(debugger, "%x: ** jumping to beta (eval), redcnt: %d\n", curr_pid, _redcnt); fflush(debugger);*/
#endif

                     goto L_beta;
    case I_EVAL0:    /* === EVAL0 : auxiliary eval === */
                     FUNC0("eval0");
                   L_eval0:
                     /* argumente und funktion von i nach a schaufeln */
                     /* und gegebenenfalls auswerten                  */
                     while ((ptdesc = (T_PTD)POP_A()) != 0) {
                       PUSH_W(ptdesc);
                       if (T_POINTER((int)ptdesc)
                        && R_DESC(*ptdesc,class) == C_FUNC
                        && R_UNIV(*ptdesc,nargs) == 0) {
                         /* closure oder 0-stellige funktion */
                         PUSH_R(code);
                         code = rout_eval0;
                         goto L_eval;
                       }
                     }
                     /* das bottomsymbol (0) ist erreicht */
                     /* argumente und funktion sind auf a */
                     arity = POP_A();                /* anzahl argumente */
                     COMM0("apply");
                     goto L_apply;
/* dg 02.05.91 cons-listen */
    case I_CONS:     /* === CONS : cons list (constructor) === */
                     FUNC0("cons");
                     MAKEDESC(ptdesc,1,C_CONS,TY_CONS);
                     L_CONS(*ptdesc,tl) = (T_PTD)POP_W();
                     L_CONS(*ptdesc,hd) = (T_PTD)TOP_W();
                     WRITE_W(ptdesc);
                     goto loop;
    case I_FCONS:    /* === FCONS : cons lists (primfunc)  === */
                     FUNC0("fcons");
                     MAKEDESC(ptdesc,1,C_CONS,TY_CONS);
                     L_CONS(*ptdesc,hd) = (T_PTD)POP_W();
                     L_CONS(*ptdesc,tl) = (T_PTD)TOP_W();
                     WRITE_W(ptdesc);
                     goto loop;
    case I_FIRST:    /* === FIRST : list head === */
                     FUNC0("first");
                     ptdesc = (T_PTD)TOP_W();
                     if (T_POINTER(ptdesc) && R_DESC(*ptdesc,class) == C_CONS) {
                       arg = (int)R_CONS(*ptdesc,hd);
                       T_INC_REFCNT((T_PTD)arg);
                       WRITE_W(arg);
                       DEC_REFCNT(ptdesc);
                       goto loop;
                     }
                     if (T_POINTER(ptdesc) && R_DESC(*ptdesc,class) == C_LIST) {
                       PUSH_W(TAG_INT(1));
                       goto L_lsel;
                     }
                     /* failure */
                     PUSH_W(M_FIRST);
                     arity = arg = 1;
#if WITHTILDE
		     nfv = 0;
#endif /* WITHTILDE */
                     COMM0("mkdclos");
                     goto L_mkdclos;
    case I_REST:     /* === REST : list tail === */
                     FUNC0("rest");
                     ptdesc = (T_PTD)TOP_W();
                     if (T_POINTER(ptdesc) && R_DESC(*ptdesc,class) == C_CONS) {
                       arg = (int)R_CONS(*ptdesc,tl);
                       T_INC_REFCNT((T_PTD)arg);
                       WRITE_W(arg);
                       DEC_REFCNT(ptdesc);
                       goto loop;
                     }
                     if (T_POINTER(ptdesc) && R_DESC(*ptdesc,class) == C_LIST) {
                       PUSH_W(TAG_INT(1));
                       func = LCUT;
                       goto L_delta2;
                     }
                     PUSH_W(M_FIRST);
                     arity = arg = 1;
#if WITHTILDE
		     nfv = 0;
#endif /* WITHTILDE */
                     COMM0("mkdclos");
                     goto L_mkdclos;
    case I_UPDAT:    /* === UPDAT : update list element === */
                     FUNC0("updat");
                     ptdesc = (T_PTD)POP_A();        /* liste */
                     arg = POP_A();                  /* index */
                     arity = TOP_W();                /* element */
                     if (T_POINTER(arity))
                       INC_REFCNT((T_PTD)arity);
                     RES_HEAP;
                     help = R_LIST(*ptdesc,ptdv)[arg];
                     R_LIST(*ptdesc,ptdv)[arg] = arity;
                     REL_HEAP;
                     if (T_POINTER(help))
                       DEC_REFCNT((T_PTD)help);
                     DEC_REFCNT(ptdesc);             /* liste freigeben */
                     goto loop;
    case I_MKILIST:  /* === MKILIST n : make inverse n-ary list === */
                     FUNC1("mkilist");
                     arity = *code++;
                     /* arity: anzahl der listenelemente (>0!) */
                     /* store list, vgl. store_l in rstpro.c */
                     /* dg 30.01.92 verwendung des globalen _desc wg. scavenge */
                     GET_DESC(_desc);
                     LI_DESC_MASK(_desc,1,C_LIST,TY_UNDEF);
                     GET_HEAP(arity,A_LIST(*_desc,ptdv));
                     L_LIST(*_desc,dim) = arity;
                     RES_HEAP;
                     pth = R_LIST(*_desc,ptdv);
                     while (--arity > 0)
                       *pth++ = (T_HEAPELEM)POP_W();
                     *pth = (T_HEAPELEM)TOP_W();
                     REL_HEAP;
                     WRITE_W(_desc);
                     _desc = NULL;
                     goto loop;
/* #endif LAZY */
#ifdef TESTSPACE
    case I_SPACE:    /* === SPACE n : test stackspace === */   /* ifdef TESTSPACE */
                     FUNC1("space");
                     arg = *code++;
                     STACKSPACE(arg);
                     goto loop;
#endif /* TESTSPACE      auskommentiert RS 4.12.1992 */

/* Hier kommt der Verteilungs- und Messkram       RS ab 1.1.1993 */

#if D_DIST

    case I_PUSHH:    /* === PUSHH x : push x in H-Stack === */
                     FUNC1("pushh");
                     arity = *code++;
#if D_SLAVE
#if ADV_SCHED
                     curr_pid->letpar_level++;
                     DBUG_PRINT ("ADV_SCHED", ("updated letpar-level: %i", curr_pid->letpar_level));
#endif /* ADV_SCHED */

#if WITHTILDE
		     PUSH_R(arity);
#else
		     PUSH_E(arity);
#endif
#endif
                     goto loop;

    case I_DIST:     /* === DIST l1 l2 a b: starts distribution === */
#if DEBUG            /* HIER NOCH KEIN WITHTILDE */
                     if (OutInstr && debdisplay) { 
                       NEXTINSTR(); 
                       printf("%s(%1x, %1x, %1d, %1d)             \n","dist",*code,*(code+1),*(code+2),*(code+3)); 
                       } 
                     fprintf(TraceFp,"%s(%1x, %1x, %1d, %1d);\n","dist",*code,*(code+1),*(code+2),*(code+3));
#endif
#if D_SLAVE
#if (D_SLAVE && D_MESS && D_MSCHED)  /*** HIER MUSS RS VIELLEICHT NOCH WAS AENDERN!!! ***/
#if WITHTILDE
		     code = (*d_m_distribute)((INSTR *)*code,(INSTR *)*(code+1),*(code+2),*(code+3),*(code+4),*(code+5),DIST_N);
#else
		     code = (*d_m_distribute)((INSTR *)*code,(INSTR *)*(code+1),*(code+2),*(code+3),DIST_N);
#endif /* WITHTILDE */
#else
#if WITHTILDE
		     code = distribute((INSTR *)*code,(INSTR *)*(code+1),*(code+2),*(code+3),*(code+4),*(code+5),DIST_N);
#else
		     code = distribute((INSTR *)*code,(INSTR *)*(code+1),*(code+2),*(code+3),DIST_N);
#endif /* WITHTILDE */
#endif /* ...MESS... */
#else
                     code+=4;
#endif /* D_SLAVE */
                     goto loop;

    case I_DISTEND:  /* === DIST_END : Ende der Berechnung eines vert. Ausdrucks === */
                     FUNC0("dist_end");
#if D_SLAVE
#if NCDEBUG
		     DBNCsetdistlevel(-1);
#endif /* NCDEBUG */
#if WITHTILDE
		     arg = (POP_R() >> 1);
#else
		     arg = POP_R();
#endif
		     if (arg>= 0)

#if (D_SLAVE && D_MESS && D_MCOMMU)
                       {(*d_m_msg_send)(arg,MT_RESULT);
#else
		       {msg_send(arg,MT_RESULT);
#endif

/* #if D_MESS      was sollte das denn hier ?????
      fflush(d_mess_dat);
#endif */

			DBUG_RETURN (IR_DIST_END);}
		     else
#if WITHTILDE
		       WRITE_R(TOP_R()-1);
#else
		       WRITE_E(TOP_E()-1);
#endif
#endif
                     goto loop;

    case I_WAIT:     /* === WAIT : wartet auf vert. Ergebnisse === */
                     FUNC1("wait");
                     arity = *code++;
#if D_SLAVE

#if ADV_SCHED
                     curr_pid->letpar_level--;
                     DBUG_PRINT("ADV_SCHED", ("updated letpar_level: %i", curr_pid->letpar_level));

                     tickets_cond = init_tickets_cond;
#endif /* ADV_SCHED */

#if WITHTILDE
		     WRITE_R(TOP_R()-arity);
		     if (TOP_R()>0)
#else
		     WRITE_E(TOP_E()-arity);
		     if (TOP_E()>0)
#endif
/* #if D_MESS      was sollte das denn hier ?
        { fflush(d_mess_dat);
#endif */
		       DBUG_RETURN (IR_WAIT);
/* #if D_MESS
	}
#endif */

#endif
                     goto loop;

    case I_POPH:     /* === POPH : entfernt das oberste H-Stack-Element === */
                     FUNC0("poph");
#if D_SLAVE
#if WITHTILDE
		     PPOP_R();
#else
		     PPOP_E();
#endif
#endif
                     goto loop;

    case I_DISTB:     /* === DISTB l1 l2 a b: starts distribution  a bitmap === */
#if DEBUG             /* HIER NOCH KEIN WITHTILDE */
                     if (OutInstr && debdisplay) {
                       NEXTINSTR();
                       printf("%s(%1x, %1x, %1d, %1d)             \n","distb",*code,*(code+1),*(code+2),*(code+3));
                       }
                     fprintf(TraceFp,"%s(%1x, %1x, %1d, %1d);\n","distb",*code,*(code+1),*(code+2),*(code+3));
#endif
#if D_SLAVE
#if (D_SLAVE && D_MESS && D_MSCHED) /*** HIER MUSS RS VIELLEICHT NOCH WAS AENDERN!!! ***/
#if WITHTILDE
                     code = (*d_m_distribute)((INSTR *)*code,(INSTR *)*(code+1),*(code+2),*(code+3),*(code+4),*(code+5),DIST_B);
#else
                     code = (*d_m_distribute)((INSTR *)*code,(INSTR *)*(code+1),*(code+2),*(code+3),DIST_B);
#endif /* WITHTILDE */
#else
#if WITHTILDE
		     code = distribute((INSTR *)*code,(INSTR *)*(code+1),*(code+2),*(code+3),*(code+4),*(code+5),DIST_B);
#else
		     code = distribute((INSTR *)*code,(INSTR *)*(code+1),*(code+2),*(code+3),DIST_B);
#endif /* WITHTILDE */
#endif
#else
                     code+=4;                 
#endif  /* D_SLAVE */
                     goto loop;

/* hier kommt der Kram fuer spekulative Prozesse... */

#endif /* D_DIST */

   case I_SPECDIST: /* spawning speculative process */
                    FUNC0("specdist");

                    /* first arg: code where to proceed, second: code where the spec expression starts, size a-frame, size t-frame */

#if (D_SLAVE && D_SPEC)

/* fprintf(debugger, "%x: used %d redsteps 'til the next SPECDIST\n", curr_pid, curr_pid->start_red_count-_redcnt); fflush(debugger); */

#if D_SPEC_TICKETS

                    ptdesc = create_spec_frame(*(code+1), *(code+3), *(code+2));


/* fprintf(debugger, "0x%x: LISTDEC allocates 0x%x as descriptor !\n", curr_pid, ptdesc); fflush(debugger);  */

                    DBUG_PRINT("INTER", ("specmask1 is 0x%x", curr_pid->specmask1));

                    SPEC_SF_GUARD(*ptdesc) = curr_pid->son_status[0];

                    DBUG_PRINT("INTER", ("GUARD grabbed, it is 0x%x !", SPEC_SF_GUARD(*ptdesc)));

                    curr_pid->son_results[PC_GET_SPEC_SPAWNED(curr_pid)] = ptdesc;
                    PC_SET_SPEC_SPAWNED(curr_pid, PC_GET_SPEC_SPAWNED(curr_pid)+1);

                    DBUG_PRINT("INTER", ("new spec-frame %x generated, %d frames stored altogether", ptdesc, PC_GET_SPEC_SPAWNED(curr_pid)));

                    curr_pid->son_status[0] = NULL; /* push the flag for TGUARD */
                    
#else
                    spec_distribute ((INSTR *)*(code+1), *(code+2), *(code+3));
#endif /* D_SPEC_TICKETS */

#else
                    post_mortem("1 sorry, no speculative evaluation in this version !");
#endif
                    DBUG_PRINT("INTER", ("jetzt bei %x, springe zu %x", code, (INSTR *)*code));
                    code = (INSTR *)*code;
                    goto loop;

   case I_SPECWIN: /* returning from speculative process */
                   FUNC0("specwin");

#if D_SLAVE
/* initialize_fred_fish();*/
#endif

#if (D_SLAVE && D_SPEC)

                   DBUG_PRINT("INTER", ("T_SPEC_INSYNC(0x%x)=%d", curr_pid, T_SPEC_INSYNC(curr_pid)));

                   if (T_SPEC_INSYNC(curr_pid)!=1) {
                     DBUG_PRINT("INTER", ("process is folding up, no sync, just return the result..."));

/* fprintf(debugger, "0x%x: SPECWIN reached, just folding up\n", curr_pid); fflush(debugger);  */
 
                     goto loop;
                     }

/* fprintf(debugger, "%x reached SPECWIN; start: %d, redcnt: %d, spec_redcnt: %d (GUARD: %d, FAIL: %d, NO_STEPS: %d, NO_BSTEPS: %d, UNR_GUARD: %d)\n", 
curr_pid, curr_pid->start_red_count,_redcnt, _spec_redcnt, T_SPEC_GUARD_SON(curr_pid), T_SPEC_FAIL(curr_pid), T_SPEC_NO_STEPS(curr_pid),
T_SPEC_NO_BSTEPS(curr_pid), T_SPEC_UNRED_GUARD(curr_pid)); fflush(debugger);  */

                   PC_SET_SPEC_FOLD(curr_pid);

                   help = 0;

#if D_SPEC_TICKETS
#if WITHTILDE
                   arg = (TOP_R() >> 1);
#else
                   arg = TOP_R();
#endif
                   if (arg > 0 ) {
                     DBUG_PRINT("INTER", ("this process is remote, so sign off !"));
                     help = 0;
                     } else {
                       if (curr_pid->spec_postpone_start != NULL) {
                         DBUG_PRINT("INTER", ("there are expressions postponed, so DON'T remove the pid out of the pipe"));
                         help = 1;
                         } else {
                         DBUG_PRINT("INTER", ("seq. branch, no more expressions postponed, remove the pid out of the pipe !"));
                         help = 0;
                         }
                     }
#endif

                   if ((T_SPEC_GUARD_SON(curr_pid)==1) ||
                       (T_SPEC_FAIL(curr_pid)==1) ||
                       (T_SPEC_NO_STEPS(curr_pid)==1)) {

                     DBUG_PRINT("INTER", ("no regular result found (GUARD: %d, FAIL: %d, NO_STEPS: %d) !",
                                T_SPEC_GUARD_SON(curr_pid), T_SPEC_FAIL(curr_pid), T_SPEC_NO_STEPS(curr_pid)));

/* fprintf(debugger, "0x%x: SPECWIN reached, no result (GUARD_SON=%d,FAIL=%d,NO_STEPS=%d)\n", curr_pid, T_SPEC_GUARD_SON(curr_pid), T_SPEC_FAIL(curr_pid), T_SPEC_NO_STEPS(curr_pid)); fflush(debugger); */

#if D_SPEC_TICKETS
                   if (help != 1) {
#endif /* D_SPEC_TICKETS */

#if D_SPEC_TICKETS
                     PC_SET_SPEC_WAIT_WIN(curr_pid);
/* fprintf(debugger, "WWn\n"); fflush(debugger); */
#endif
                     spec_send_winner(curr_pid->control_node, curr_pid->control_pid, curr_pid, 0, 1, help);

                     /* maybe we already have the result... : */
                     if (T_SPEC_CONF_WIN(curr_pid)==1) {
                       DBUG_PRINT("INTER", ("already confirmed, goon processing !"));
                       } else {
                       DBUG_PRINT("INTER", ("no confirmation yet, let's sleep !"));

/* fprintf(debugger, "0x%x: SPECWIN, suspending process to wait for acknowledge...\n", curr_pid); fflush(debugger);*/

/* fprintf(debugger, "0x%x: sleep 1\n", curr_pid); fflush(debugger);*/

                       DBUG_RETURN (IR_WAIT); 
                     }

#if D_SPEC_TICKETS
                       }
#endif


                   } else {

                     DBUG_PRINT("INTER", ("regular result found, set WINNER."));

                     PC_SET_SPEC_WINNER(curr_pid);

/* fprintf(debugger, "0x%x: SPECWIN reached, RESULT FOUND!\n", curr_pid); fflush(debugger);   */

#if D_SPEC_TICKETS
                     PC_SET_SPEC_WAIT_WIN(curr_pid);
/* fprintf(debugger, "WWy\n"); fflush(debugger); */
#endif
                     spec_send_winner(curr_pid->control_node, curr_pid->control_pid, curr_pid, 1, 1, help);

                     /* maybe we already have the result... : */
                     if (T_SPEC_CONF_WIN(curr_pid)==1) {
                       DBUG_PRINT("INTER", ("already confirmed, goon processing !"));
                       } else {
                       DBUG_PRINT("INTER", ("no confirmation yet, let's sleep !"));

/*fprintf(debugger, "0x%x: SPECWIN, suspending process to wait for acknowledge...\n", curr_pid); fflush(debugger);*/

/* fprintf(debugger, "0x%x: sleep 2\n", curr_pid); fflush(debugger); */

                       DBUG_RETURN (IR_WAIT); }
                     }

#else
                   post_mortem("2 sorry, no speculative evaluation in this version !");
#endif
                   goto loop;

   case I_SPECEND: /* (really) returning from speculative process */
                   FUNC0("specend");
#if (D_SLAVE && D_SPEC)
                   /* same thing as DISTEND */
#if WITHTILDE
                   arg = (POP_R() >> 1);
#else
                   arg = POP_R();
#endif

#if D_SPEC_TICKETS
                   if (arg>= 0) {
                     DBUG_PRINT("INTER", ("I'm a remote process, returning to node %d!", arg));

/* fprintf(debugger, "0x%x: SPECEND reached, I'm remote, return result\n", curr_pid); fflush(debugger); */
                     
#if (D_SLAVE && D_MESS && D_MCOMMU)
                     (*d_m_msg_send)(arg,MT_RESULT);
#else
                     msg_send(arg,MT_RESULT);
#endif
                     DBUG_RETURN (IR_DIST_END);

                     } else {
                     DBUG_PRINT("INTER", ("I'm not remote... storing result"));

/* fprintf(debugger, "0x%x: SPECEND reached, NOT remote, storing result\n", curr_pid); fflush(debugger); */

                     /* store result */
                     ptdesc = POP_R(); /* list-descriptor */
                     SPEC_SF_FIRSTF(*ptdesc) = POP_W(); /* RESULT */ 

                     if (SPEC_SF_ASMADDR(*ptdesc) == 0) {
                       DBUG_PRINT("INTER", ("spawned by specmap !"));

/* fprintf(debugger, "0x%x: SPECEND: switching back...\n", curr_pid); */

                       SWITCHSTACKS();
                       }

                     SPEC_SF_REDSTEPS(*ptdesc) = PC_GET_SREDCNT(curr_pid)-_redcnt;
                     SPEC_SF_PSTATUS(*ptdesc) = curr_pid->specmask1;

                     if (SPEC_SF_ASMMKNC(*ptdesc) == 0) {
                       DBUG_PRINT("INTER", ("(sub-) process was generated by specmap, so switch stacks !"));
                       }

/* fprintf(debugger, "0x%x: LISTDEC storing result at 0x%x\n", curr_pid, ptdesc); fflush(debugger); */
                       
                     DBUG_PRINT("INTER", ("result: 0x%x, redsteps: %d, status: 0x%x", SPEC_SF_FIRSTF(*ptdesc), SPEC_SF_REDSTEPS(*ptdesc), SPEC_SF_PSTATUS(*ptdesc)));
                     
                     DBUG_PRINT("INTER", ("popping %d elements off stack T", SPEC_SF_NUMB_T(*ptdesc)));

                     for (help = 0; help<SPEC_SF_NUMB_T(*ptdesc); help++)
                       POP_T();

                     PC_CLEAR_SPEC_GUARD(curr_pid);
                     PC_CLEAR_SPEC_CONF_FAIL(curr_pid);
                     PC_CLEAR_SPEC_NO_STEPS(curr_pid);
                     PC_CLEAR_SPEC_CONF_WIN(curr_pid);
                     PC_CLEAR_SPEC_SIGNOFF(curr_pid);
                     PC_CLEAR_SPEC_GUARD_SON(curr_pid);
 
                     if (--(*(int*)SPEC_SF_ADDRCOUNT(*ptdesc)) == 0) {
                       DBUG_PRINT("INTER", ("counter is down to zero !"));

/* fprintf(debugger, "0x%x: SPECEND, counter down to 0, continuing at MKNCASE...\n", curr_pid); fflush(debugger);  */

                       PC_CLEAR_SPEC_NO_BSTEPS(curr_pid);
                       PC_CLEAR_SPEC_FAIL(curr_pid);
                       PC_CLEAR_SPEC_FOLD(curr_pid);
                       PC_CLEAR_SPEC_WINNER(curr_pid);

                       code = SPEC_SF_ASMMKNC(*ptdesc);
                       goto loop;
                       } else {
                       DBUG_PRINT("INTER", ("counter is at %d, checking for next expression", *(int*)SPEC_SF_ADDRCOUNT(*ptdesc)));

/* fprintf(debugger, "0x%x: SPECEND, COUNTER at %x is down to %d !\n", curr_pid, SPEC_SF_ADDRCOUNT(*ptdesc), *(int*)SPEC_SF_ADDRCOUNT(*ptdesc)); fflush(debugger);  */

                       if (curr_pid->spec_postpone_start == NULL) {
                         DBUG_PRINT("INTER", ("no more postponed expressions... go to sleep"));

/* fprintf(debugger, "0x%x: SPECEND, no more postponed expressions, going to sleep...\n", curr_pid); fflush(debugger); */

                         PC_CLEAR_SPEC_NO_BSTEPS(curr_pid);
                         PC_CLEAR_SPEC_FAIL(curr_pid);
                         PC_CLEAR_SPEC_FOLD(curr_pid);
                         PC_CLEAR_SPEC_WINNER(curr_pid);

                         PC_SET_SPEC_WAIT_WIN(curr_pid);

/* fprintf(debugger, "0x%x: sleep 3\n", curr_pid); fflush(debugger); */

                         DBUG_RETURN(IR_WAIT);
                         } else {
                         DBUG_PRINT("INTER", ("more postponed expressions... initialize the next one"));

/* fprintf(debugger, "0x%x: SPECEND, initialize next expression...\n", curr_pid); fflush(debugger);  */
 
                         ptdesc = dequeue_postpone(1, curr_pid);
                         spec_insert_frame(ptdesc);
                         code = SPEC_SF_ASMADDR(*ptdesc);

                         if (code == 0) {
                           DBUG_PRINT("INTER", ("spawned by specmap !"));
                           code = rout_specmap2;
                           SWITCHSTACKS();
                           }

                         curr_pid->nesting = SPEC_SF_NESTING(*ptdesc);
                         curr_pid->start_red_count = SPEC_SF_REDSTEPS(*ptdesc);
                         _redcnt = SPEC_SF_REDSTEPS(*ptdesc);

                         PUSH_R(ptdesc);
                         PUSH_R(-1 << 1);

                         if (T_S_GUARD(*(int*)SPEC_SF_PSTATUS(*ptdesc)) == 1) {
                           DBUG_PRINT("INTER", ("initialize NEW thread with SPEC_GUARD_SON..."));
                           PC_SET_SPEC_GUARD_SON(curr_pid);
                           _redcnt = 0;
                           curr_pid->start_red_count = 0;
                           PC_SET_SPEC_FOLD(curr_pid);
                           }

                         /* MKNCASE cleares SPEC_PROCESS if it's the control process, dunno why, but thats how it's done */
                         if (curr_pid->control != NULL) {

/* fprintf(debugger, "0x%x: re-setting SPEC_PROCESS for the seq-control !\n", curr_pid), fflush(debugger); */

                           PC_SET_SPEC_PROCESS(curr_pid);
                           }

                         PC_SET_SPEC_INSYNC(curr_pid);

                         if ((spec_multi_results == 0) && (curr_pid->ffound == 1) && !T_S_GUARD(*(int*)SPEC_SF_PSTATUS(*ptdesc))) {
                           DBUG_PRINT("INTER", ("a solution was found already, terminate the following thread..."));

/* fprintf(debugger, "0x%x: SPECEND: ffound is set, setting the following process to FAIL\n", curr_pid); fflush(debugger); */
                           
                           PC_SET_SPEC_FAIL(curr_pid);
                           PC_SET_SPEC_FOLD(curr_pid);
                           _redcnt = 0;
                           curr_pid->start_red_count = 0;
                           } else {
                           DBUG_PRINT("INTER", ("everything ;-) is OK, let the next thread run as hell ! ;-)"));

                           PC_CLEAR_SPEC_FAIL(curr_pid);
                           if (T_SPEC_GUARD_SON(curr_pid)!=1) 
                             PC_CLEAR_SPEC_FOLD(curr_pid);
                           }

/* fprintf(debugger, "0x%x: SPECEND, FAIL is %d\n", curr_pid, T_SPEC_FAIL(curr_pid)); fflush(debugger);  */

                         PC_CLEAR_SPEC_WINNER(curr_pid);
                         }
                       }
                     }
#else

                   DBUG_PRINT("INTER", ("returning the result to node %d", arg));

                   /* if (arg>= 0) */ /* it's clear that there were distributions */

/*                   fprintf(debugger, "\narg: %d\n\n", arg); fflush(debugger); */

#if (D_SLAVE && D_MESS && D_MCOMMU)
                   (*d_m_msg_send)(arg,MT_RESULT);
#else
                   msg_send(arg,MT_RESULT);
#endif
                   /* pop the result... */

                   /* POP_W(); */  /* will be done by msg_send */

                   DBUG_PRINT("INTER", ("d_stacksize(ps_w) = %d", d_stacksize(ps_w)));
                   DBUG_PRINT("INTER", ("d_stacksize(ps_a) = %d", d_stacksize(ps_a)));
                   DBUG_PRINT("INTER", ("d_stacksize(ps_t) = %d", d_stacksize(ps_t)));
                   DBUG_PRINT("INTER", ("d_stacksize(ps_r) = %d", d_stacksize(ps_r)));

                  /*  arg = curr_pid;     WHAT'S THIS GOOD FOR ?!?! FOR THE DBUG-MESSAGES ?!?!?!?
                   process_sleep(curr_pid);
                   curr_pid = arg; */

/* DBUG_PRINT("SCHED", ("d_stacksize(&(curr_pid->D_S_H)): %d, TopofStack: %x", d_stacksize(&(curr_pid->D_S_H)), curr_pid->D_S_H.TopofStack));
DBUG_PRINT("SCHED", ("d_stacksize(&(curr_pid->D_S_A)): %d, TopofStack: %x", d_stacksize(&(curr_pid->D_S_A)), curr_pid->D_S_A.TopofStack));
DBUG_PRINT("SCHED", ("d_stacksize(&(curr_pid->D_S_R)): %d, TopofStack: %x", d_stacksize(&(curr_pid->D_S_R)), curr_pid->D_S_R.TopofStack));
DBUG_PRINT("SCHED", ("d_stacksize(&(curr_pid->D_S_I)): %d, TopofStack: %x", d_stacksize(&(curr_pid->D_S_I)), curr_pid->D_S_I.TopofStack)); */

                   DBUG_RETURN (IR_DIST_END);

#endif /*D_SPEC_TICKETS */

#else
                   post_mortem("3 sorry, no speculative evaluation in this version !");
#endif
                   goto loop;



   case I_SPECWAIT: /* sync processes and wait for results */
                    FUNC0("specwait");
#if (D_SLAVE && D_SPEC)

/*   fprintf(debugger, "0x%x: SPECWAIT reached, used %d redsteps\n", curr_pid, curr_pid->start_red_count-_redcnt); fflush(debugger);  */

                    PC_SET_SPECWAIT(curr_pid);

                    if (T_SPEC_GUARD(curr_pid)==1) {
                      DBUG_PRINT("INTER", ("SPEC_GUARD was set ! Constructors will be built !"));
                      }

#if D_SPEC_TICKETS
                    if (PC_GET_SPEC_SPAWNED(curr_pid)==0) {
                      DBUG_PRINT("INTER", ("no matching clauses !"));

/* fprintf(debugger, "0x%x: SPECWAIT, no matching clauses were found ! setting FAIL...\n", curr_pid); fflush(debugger); */
 
                      PC_SET_SPEC_FAIL(curr_pid);
                      PC_SET_SPEC_FOLD(curr_pid);
 
                      goto loop;
                      }
                    else {

/* fprintf(debugger, "0x%x: SPECWAIT, %d matching clauses were found ! (nospecnr = %d)\n", curr_pid, PC_GET_SPEC_SPAWNED(curr_pid), nospecnr); fflush(debugger);  */

                      POP_W(); /* remove argument which is not removed during the speculative matching */

                      /**********************************************/
                      /* tag and initialize father process !        */
                      /* copied from old version of spec_distribute */ /* except changes of course */

                      if (!T_SPEC_PROCESS(curr_pid) && !T_SPEC_GRANDDAD(curr_pid)) {
                        /**************************/
                        DBUG_PRINT("INTER", ("formerly vital process goes granddad-speculative"));
                        PC_SET_SPEC_GRANDDAD(curr_pid);
 
                        PC_SET_SPEC_SUM(curr_pid,0);
 
                        /* allocate space for the son processes */
                        if (!(curr_pid->processes = malloc(2*sizeof(int)*max_spec_sons)))
                          post_mortem ("could not allocate space for speculative son processes...");
 
                        if (curr_pid->son_results == NULL) {
 
                          /* allocate space for the son results */
                          if (!(curr_pid->son_results = malloc(sizeof(int)*max_spec_sons)))
                            post_mortem ("could not allocate space for speculative son results...");
 
                          /* allocate space for the son redcnts */
                          if (!(curr_pid->son_redcnts = malloc(sizeof(int)*max_spec_sons)))
                            post_mortem ("could not allocate space for speculative son redcnts...");
 
                          /* allocate space for the son status */
                          if (!(curr_pid->son_status = malloc(sizeof(int)*max_spec_sons)))
                            post_mortem ("could not allocate space for speculative son status...");
 
                          }
 
                        /* allocate space for the controller */
                        if (!(curr_pid->control = malloc(sizeof(SPEC_CONTROL_STRUC))))
                          post_mortem ("could not allocate space for speculative control...");
 
                        if (!(curr_pid->control->data = malloc(sizeof(int)*2*max_spec_procs)))
                          post_mortem ("could not allocate space for speculative control data...");

/****** changes ! *********/

                        /* initialize pipe control with first process */

                        curr_pid->control->leaves = 1;
                        curr_pid->control->data[0] = curr_pid;
                        curr_pid->control->data[1] = proc_id;

/****** end of changes ! *****/

                        curr_pid->control->have_ack = 0;
                        curr_pid->control->result = 0;
 
                        curr_pid->control_pid = curr_pid;
                        curr_pid->control_node = proc_id;
 
                        DBUG_PRINT("INTER", ("space allocated..."));
                        }
                       else if (T_SPEC_GRANDDAD(curr_pid)==1){
                         DBUG_PRINT("INTER", ("granddad spawns another process"));
                         }
                       else if (T_SPEC_LEAF(curr_pid)==1) {
 
                       /* fprintf (debugger, "Hey bastards ! Evolving !\n"); fflush(debugger); */
 
                       DBUG_PRINT("SPEC_DIST", ("leaf spec process evolves to dad spec"));
                       PC_CLEAR_SPEC_LEAF(curr_pid);
                       PC_SET_SPEC_DAD(curr_pid);
                       PC_SET_SPEC_SUM(curr_pid,0);
                       }

                      /********************* end of copied stuff **********************/

                      DBUG_PRINT("INTER", ("there were %d matching clauses !", PC_GET_SPEC_SPAWNED(curr_pid)));
 
                      /* copy descriptors to stack R */
  
                      for (nfv = 0; nfv < PC_GET_SPEC_SPAWNED(curr_pid); nfv++) {
                        DBUG_PRINT("INTER", ("copy entry %d (0x%x) to the stack", nfv, curr_pid->son_results[nfv]));
                        PUSH_R(curr_pid->son_results[nfv]);
                        curr_pid->son_results[nfv] = NULL;
                        }

                      pth = nfv = PC_GET_SPEC_SPAWNED(curr_pid); /* counter */

                      PC_SET_SPEC_SPAWNED(curr_pid,0); /* clear */

/* fprintf(debugger, "0x%x: SPECWAIT; %d matching clauses\n", curr_pid, nfv); fflush(debugger);  */

/* fprintf(debugger, "0x%x: stack R is %x %x %x %x %x\n", MID_R(0), MID_R(1), MID_R(2), MID_R(3), MID_R(4)); fflush(debugger); */

                      PUSH_R(curr_pid->specmask1); /* store father's status onstack */
                      func = &TOP_R();
                      PUSH_R(nfv);

                      for (help = 0; help<nfv; help++) {
                        DBUG_PRINT("INTER", ("initialize entry %d !", help));

/* fprintf(debugger, "0x%x: ptdesc is 0x%x\n", curr_pid, MID_R(2+help)); fflush(debugger); */

                        ptdesc = MID_R(2+help);
                        SPEC_SF_ASMMKNC(*ptdesc) = code;
                        SPEC_SF_PSTATUS(*ptdesc) = func;
                        SPEC_SF_ADDRCOUNT(*ptdesc) = &TOP_R();
                        SPEC_SF_REDSTEPS(*ptdesc) = _redcnt;
                        SPEC_SF_NESTING(*ptdesc) = curr_pid->nesting;
                        }

/* fprintf(debugger, "0x%x: SPECWAIT, establishing COUNTER at %x (initial value = %d)!\n", curr_pid, SPEC_SF_ADDRCOUNT(*ptdesc), *(int*)SPEC_SF_ADDRCOUNT(*ptdesc)); fflush(debugger); */


/*                      DBUG_PRINT("INTER", ("R-STACK: %x %x %x %x %x %x", MID_R(0), MID_R(1), MID_R(2), MID_R(3), MID_R(4), MID_R(5))); */
                      
                      DBUG_PRINT("INTER", ("mkncase code: %x, redsteps %d, nesting %d", code, _redcnt, curr_pid->nesting));
                  
                      help = 1+nfv;
                      nfv = 0;       /* will be set to 1 if the loop has to be stopped */
                      arity = -1;    /* holds the first index for a seq. distribution */

                      PC_SET_SPEC_SPAWNED(curr_pid,0); /* use old structures here */

                      DBUG_PRINT("INTER", ("counting down from %d.", help));

                      if (T_SPEC_GUARD(curr_pid)==1) {
                        DBUG_PRINT("INTER", ("SPEC_GUARD was set, don't distribute any expression !"));
                        nfv=1;
                        arity = help;
                        }

                      DBUG_PRINT("INTER", ("matching clauses %d, nospecnr %d", (help-1), nospecnr));

/* fprintf(debugger, "0x%x: help = %d (this is the index on the stack...)\n", curr_pid, help); fflush(debugger);  */

                      if ((help-1) > nospecnr)  /* nospecnr tells how much speculative expressions MUST be evaluated sequentially ! */

                      while (!nfv) {
                        DBUG_PRINT("INTER", ("checking stack entry #%d, desc pointer 0x%x", help, MID_R(help)));
                        if ((func = spec_get_distribute()) != -1) {
                          DBUG_PRINT("INTER", ("distribute to node %d, descriptor #%d is %x", func, help, MID_R(help)));

/* fprintf(debugger, "0x%x: SPECWAIT spawning one expression to node %d (help = %d)\n", curr_pid, func, help); fflush(debugger);   */

                          spec_tickets_distribute(func, MID_R(help), 0);
                          PC_SET_SPEC_SPAWNED(curr_pid, PC_GET_SPEC_SPAWNED(curr_pid)+1);
                          } else {
                          DBUG_PRINT("INTER", ("no distribution for entry %d, first seq was %d!", help, arity));

/* fprintf(debugger, "0x%x: SPECWAIT; cannot distribute (help = %d, arity = %d)\n", curr_pid, help, arity); fflush(debugger);  */
      
                          if (help > arity) {
                            arity = help;
                            DBUG_PRINT("INTER", ("set the first entry to %d !", arity));
                            }
                          }
                       
                        if (--help == (1+nospecnr)) { /* no more processes, stop ! */
                          if ((help != 1) && (arity == -1)) {
                            DBUG_PRINT("INTER", ("still tickets, but nospecnr !"));

/* fprintf(debugger, "0x%x: SPECWAIT; nospecnr reached, (help = %d, arity = %d)\n", curr_pid, help, arity); fflush(debugger);  */

                            arity = help;
                            }
                          nfv = 1; 
                          }
                        }

                      /* now enqueue the processes */

                      if (PC_GET_SPEC_SPAWNED(curr_pid)>0) {
                        DBUG_PRINT("INTER", ("there are remote processes, set SIGNOFF-Flag"));

                        PC_SET_SIGNOFF(curr_pid);

/* fprintf(debugger, "0x%x: SPECWAIT setting SIGNOFF (%d, %d)\n", curr_pid, T_SPEC_SIGNOFF(curr_pid), !T_SPEC_SIGNOFF(curr_pid)); fflush(debugger); */

                        }

                      if (arity != -1) {
                        DBUG_PRINT("INTER", ("enqueue some postponed expressions, clear SIGNOFF-Flag"));

                        PC_CLEAR_SPEC_SIGNOFF(curr_pid);

/* fprintf(debugger, "0x%x: SPECWAIT enqueuing some expressions, clear SIGNOFF\n", curr_pid); fflush(debugger); */

                        /* change the sorting if you want REAL breadth first *******/

                        for (help = 2; help <=arity; help++) { /* keep one */
                          DBUG_PRINT("INTER", ("enqueue'ing entry #%d, desc pointer 0x%x", help, MID_R(help)));

/* fprintf(debugger, "0x%x: SPECWAIT enqueuing expressions of stackelement %d \n", curr_pid, help); fflush(debugger);  */

                          enqueue_postpone(MID_R(help), curr_pid->nesting);
                          }

                        ptdesc = dequeue_postpone(1, curr_pid); /* take the last entry */
                        spec_insert_frame(ptdesc);

                        curr_pid->nesting = SPEC_SF_NESTING(*ptdesc);
                        code = SPEC_SF_ASMADDR(*ptdesc);

                        if (code == 0) {
                          DBUG_PRINT("INTER", ("spawned by specmap !"));
                          code = rout_specmap2;
                          SWITCHSTACKS();
                          }

                        /* push some more constants (as in ELSE case !) */

                        PUSH_R(_redcnt);
                        PUSH_R(curr_pid->start_red_count);
                        PUSH_R(pth); /* push as constant ************/

 
                        PUSH_R(ptdesc);
                        PUSH_R(-1 << 1);

                        if (curr_pid->spec_red_count == -1) {
                          DBUG_PRINT("INTER", ("barrier is not yet initialized, do it now..."));
                          curr_pid->spec_red_count = ack_red_count; 
                          _spec_redcnt = ack_red_count;
                          }

                        PC_CLEAR_SPEC_CONF_FAIL(curr_pid);
                        PC_CLEAR_SPEC_FAIL(curr_pid);
                        PC_CLEAR_SPEC_FOLD(curr_pid);
                        PC_CLEAR_SPEC_NO_STEPS(curr_pid);
                        PC_CLEAR_SPEC_CONF_WIN(curr_pid);
                        PC_CLEAR_SPEC_WINNER(curr_pid);
                        PC_CLEAR_SPEC_GUARD_SON(curr_pid);

                        if (curr_pid->control != NULL) { /* it's the central control */
                          DBUG_PRINT("INTER", ("it's the central control process, set SPEC_PROCESS"));
                          PC_SET_SPEC_PROCESS(curr_pid);
                          }
 
                        if (T_S_GUARD(*(int*)SPEC_SF_PSTATUS(*ptdesc)) == 1) {
                          DBUG_PRINT("INTER", ("initialize NEW thread with SPEC_GUARD_SON..."));
                          PC_SET_SPEC_GUARD_SON(curr_pid);
                          _redcnt = 0;
                          curr_pid->start_red_count = 0;
                          PC_SET_SPEC_FOLD(curr_pid);
                          } else
                          curr_pid->start_red_count = _redcnt; /* initialize redcnt for this thread... */

                        if ((spec_multi_results == 0) && (curr_pid->ffound == 1) && !T_S_GUARD(*(int*)SPEC_SF_PSTATUS(*ptdesc))) {
                          DBUG_PRINT("INTER", ("one solution was found already, terminate the following thread..."));

/*fprintf(debugger, "0x%x: SPECWAIT ffound is set, setting the next seq. subexpression to fail\n", curr_pid); fflush(debugger); */

                          PC_SET_SPEC_FAIL(curr_pid);
                          PC_SET_SPEC_FOLD(curr_pid);
                          _redcnt = 0;
                          curr_pid->start_red_count = 0;
                          } 

/* fprintf(debugger, "0x%x: SPECWAIT initialize next/first seq expression, no result yet, so set INSYNC\n", curr_pid), fflush(debugger);    */

                        PC_SET_SPEC_INSYNC(curr_pid);


                        DBUG_PRINT("INTER", ("Starting thread (desc 0x%x) with _redcnt %d and start_red_count %d", ptdesc, _redcnt, curr_pid->start_red_count));
                        } else {

                        PUSH_R(_redcnt);
                        PUSH_R(curr_pid->start_red_count);
                        PUSH_R(pth); /* push as constant ************/
                        }

                      if (PC_GET_SPEC_SPAWNED(curr_pid)>0) {
                        DBUG_PRINT("INTER", ("remote processes started, suspend the father"));
 
/* fprintf(debugger, "0x%x: SPECWAIT, waiting for HEREAMIs, SPAWNED %d, ACKS %d, SUM %d\n", curr_pid, PC_GET_SPEC_SPAWNED(curr_pid), PC_GET_SPEC_ACKS(curr_pid), PC_GET_SPEC_SUM(curr_pid)); fflush(debugger); */

                        PC_SET_SPEC_ACKS(curr_pid,0);

/*fprintf(debugger, "0x%x: SPECWAIT, suspend and wait for HEREAMIs, ACKS %d\n", curr_pid, PC_GET_SPEC_ACKS(curr_pid)); fflush(debugger); */

/* fprintf(debugger, "0x%x: sleep 4\n", curr_pid); fflush(debugger); */

                        DBUG_RETURN (IR_WAIT);
                        } else {
                        DBUG_PRINT("INTER", ("no remote processes started, start sons sequentially"));

                        /* don't forget to clear SPEC_GUARD and SPECWAIT ! */
                        PC_CLEAR_SPEC_GUARD(curr_pid);
                        PC_CLEAR_SPECWAIT(curr_pid);

                        goto loop;

                        }  
                      }
#else
                    /* are there any sons ? */

                    /* if there's no SPECDIST-Command, nobody knows if this is */
                    /* a GRANDDAD or a DAD-speculative process... does this even matter ?! */
                    /* well, we can test if there's a dad process id given ! or processes ! */
                    /* no, that's too uncertain. What matters ? */
                    /* if it's a LEAF-speculative process, SPEC_LEAF would (still) be set and */
                    /* thereby could be detected */

                    if (PC_GET_SPEC_SPAWNED(curr_pid)==0) {
                      DBUG_PRINT("INTER", ("no son's spawned... set SPECFAIL"));

/* fprintf(debugger, "0x%x: SPECWAIT, no matching clauses were found ! setting FAIL...\n", curr_pid); fflush(debugger); */

                      PC_SET_SPEC_FAIL(curr_pid);
                      PC_SET_SPEC_FOLD(curr_pid);
  
                      goto loop;
                      }

                    POP_W(); /* remove argument which is not removed during the speculative matching */

                    /* first we have to check whether all sons have acknowledged yet */

                    if (PC_GET_SPEC_SPAWNED(curr_pid)==PC_GET_SPEC_ACKS(curr_pid)) {
                      /* okey, all sons are known already, so let's register them */
                      DBUG_PRINT("INTER", ("let's send the stuff away"));
                      DBUG_PRINT("INTER", ("control_node is %d, control_pid is %x", curr_pid->control_node, curr_pid->control_pid));
                      spec_send_acknowledge(curr_pid->control_node, curr_pid->control_pid, curr_pid);
                      }

/* fprintf(debugger, "0x%x: sleep 5\n", curr_pid); fflush(debugger); */

                    DBUG_RETURN (IR_WAIT);

#endif /* D_SPEC_TICKETS */

#else
                    post_mortem("4 sorry, no speculative evaluation in this version !");
#endif
                    goto loop;

   case I_SPECGUARD: /* signal evaluation of a guard expression */
                    FUNC0("specguard");

#if (D_SLAVE && D_SPEC)
                    post_mortem("specguard: not yet implemented...");
#else
                    post_mortem("5 sorry, no speculative evaluation in this version !");
#endif
                    goto loop;

   case I_SPECINIT: /* stop process for barrier extraction */
                    FUNC0("specinit");
 
/* fprintf(debugger, "0x%x: SPECINIT, having %d steps left !\n", curr_pid, _redcnt); fflush(debugger); */

#if (D_SLAVE && D_SPEC)
                    /* let's see if results_*-pointer are initialized */
                    /* if not, just do it ! */

                    PC_SET_SPEC_INBETWEEN(curr_pid);
                   
#if D_SPEC_TICKETS          
                    curr_pid->nesting++;
#endif

                    if (curr_pid->son_results == NULL) {

                    DBUG_PRINT("INTER", ("initialize ->son_* pointers !"));
 
                    /* allocate space for the son results */
                    if (!(curr_pid->son_results = malloc(sizeof(int)*max_spec_sons)))
                      post_mortem ("could not allocate space for speculative son results...");
 
                    /* allocate space for the son redcnts */
                    if (!(curr_pid->son_redcnts = malloc(sizeof(int)*max_spec_sons)))
                      post_mortem ("could not allocate space for speculative son redcnts...");
 
                    /* allocate space for the son status */
                    if (!(curr_pid->son_status = malloc(sizeof(int)*max_spec_sons)))
                      post_mortem ("could not allocate space for speculative son status...");

                    }

                    for (nfv = 0; nfv<max_spec_sons; nfv++)
                      curr_pid->son_redcnts[nfv] = 0; /* initialize */

#if D_SPEC_TICKETS
                    PC_SET_SPEC_SPAWNED(curr_pid,0);
                    curr_pid->son_status[0] = NULL;
#endif                    

#else
                    post_mortem("6 sorry, no speculative evaluation in this version !");
#endif
                    goto loop;

   case I_MKNCASE: /* recover from speculative processes if there's no result */
                   FUNC1("mkncase");
                   ptdesc = (T_PTD)*code++;
#if (D_SLAVE && D_SPEC)

/* fprintf(debugger, "0x%x: MKNCASE reached, I'm working again !\n", curr_pid); fflush (debugger);  */

                   /* clear GUARD flag */

                   PC_CLEAR_SPEC_INBETWEEN(curr_pid); /* S_CASE code ends */
 
                   PC_CLEAR_SPECWAIT(curr_pid);

#if D_SPEC_TICKETS
                 if (T_SPEC_FAIL(curr_pid)!=1)
                   PC_CLEAR_SPEC_INSYNC(curr_pid);

                   if (curr_pid->control != NULL) { /* its the central control */
                     DBUG_PRINT("INTER", ("it's the central control, clear SPEC_PROCESS-flag !"));
                     PC_CLEAR_SPEC_PROCESS(curr_pid);
                     }
#endif   

                   PC_CLEAR_SPEC_GUARD(curr_pid);

                   PC_SET_SPEC_FOLD(curr_pid);

/*  fprintf(debugger, "0x%x: MKNCASE reached, FAIL: %d, WINNER: %d, NO_BSTEPS: %d, FOLD: %d\n", curr_pid, T_SPEC_FAIL(curr_pid), T_SPEC_WINNER(curr_pid), T_SPEC_NO_BSTEPS(curr_pid), T_SPEC_FOLD(curr_pid)); fflush(debugger);  */

#if D_SPEC_TICKETS
/*                   DBUG_PRINT("INTER", ("R-STACK: %x %x %x %x %x %x", MID_R(0), MID_R(1), MID_R(2), MID_R(3), MID_R(4), MID_R(5))); */

                 if (T_SPEC_FAIL(curr_pid)!=1) { /* no spawned expressions, no stuff on the R-stack ! */
                   nfv = POP_R(); /* remove counter */
                   DBUG_PRINT("INTER", ("copying results of %d speculative expression...", nfv));
 
/* fprintf(debugger, "0x%x: start...\n", curr_pid); fflush(debugger);
fprintf(debugger, "0x%x: stacksize(R) = %d\n", curr_pid, D_SIZEOFSTACK(*ps_r)); fflush(debugger);
fprintf(debugger, "0x%x: done...\n", curr_pid); fflush(debugger); */

                   curr_pid->start_red_count = POP_R();
                   _redcnt = POP_R();

                   DBUG_PRINT("INTER", ("popping: start_red_count %d, _redcnt %d", curr_pid->start_red_count, _redcnt));
 
                   POP_R(); /* can we throw this counter away ?! make that YES */

                   help = T_S_ACKNOWLEDGE(curr_pid->specmask1);

/* fprintf(debugger, "0x%x: comparing ACKNOWLEDGE-status: stored is %d, current is/was %d\n", curr_pid, T_S_ACKNOWLEDGE(TOP_R()), T_S_ACKNOWLEDGE(curr_pid->specmask1)); fflush(debugger); */
 
                   curr_pid->specmask1 = POP_R(); /* can we throw this STATUS away ?! I don't think so, wait and see ! */
                                                  /* either re-establish this counter or clear the flags */

                   if (help == 1) {
                     SET_ACKNOWLEDGE(curr_pid);

/* fprintf(debugger, "0x%x: MKNCASE setting ACKNOWLEDGE !\n", curr_pid); fflush(debugger); */

                     } else {
                     CLEAR_ACKNOWLEDGE(curr_pid);

/* fprintf(debugger, "0x%x: MKNCASE clearing ACKNOWLEDGE !\n", curr_pid); fflush(debugger); */

                     }

                   PC_SET_SPEC_FOLD(curr_pid);

                   PC_CLEAR_SPEC_INSYNC(curr_pid);
               
                   PC_CLEAR_SPEC_INBETWEEN(curr_pid); /* S_CASE code ends */        /* do this just again */
                   PC_CLEAR_SPECWAIT(curr_pid);
                   }
#endif

                   if (T_SPEC_FAIL(curr_pid)==1) {
                     DBUG_PRINT("INTER", ("specwait has passed... no speculative processes were generated"));
                     /* no distinction between GRANDDAD and DAD necessary, or is it ?! */
                     /* oh yes, the handling of the reduction steps ! */
                     /* NO ! It doesn't matter that the GRANDDAD cannot continue ... ! */

                     DBUG_PRINT("INTER", ("it's a leaf speculative process..."));
                     /* so restore original CASE, set FAIL (already), set reduction */
                     /* steps to 0. First, cheat in the following way: to use the same formula, */
                     /* we adjust start_red_count in a way that denotes how many */
                     /* steps have been used, so that the subtraction will yield the */
                     /* correct result */

                     if (_redcnt != 0) {
                       DBUG_PRINT("INTER", ("modify redcnt: old start_red_count: %d", curr_pid->start_red_count));
                       curr_pid->start_red_count = curr_pid->start_red_count - _redcnt;
                       _redcnt = 0;
                       DBUG_PRINT("INTER", ("modified start_red_count: %d", curr_pid->start_red_count));
                       }

                     PC_SET_SPEC_FOLD(curr_pid);       /*  adding this also to the non TICKETS version... */
                      
                     if (ptdesc == 0 ) {
                       DBUG_PRINT("INTER", ("whoooopsie, no CASE pointer. Ok, Build pseudo-constructor !"));

                       GET_DESC(ptdesc);
                       LI_DESC_MASK(ptdesc,1,C_LIST,TY_UNDEF);
                       GET_HEAP(2,A_LIST(*ptdesc,ptdv));
                       RES_HEAP;
                       L_LIST(*ptdesc,dim) = 2;
                       nfv = R_LIST((*ptdesc),ptdv); /* pointer to heap */
                       *((int *)nfv)++ = makestrdesc(SPEC_CONSTRUCTOR);
                       GET_DESC(_desc);
                       LI_DESC_MASK(_desc,1,C_LIST,TY_UNDEF);
                       GET_HEAP(3,A_LIST(*_desc,ptdv));
                       L_LIST(*_desc,dim) = 3;
                       help = R_LIST((*_desc),ptdv); /* pointer to heap */
                       *((int *)help)++ = makestrdesc(SPEC_GUARD_CONSTRUCTOR);
                       *((int *)help)++ = SA_FALSE;
                       *((int *)help)++ = SA_FALSE;
                       *((int *)nfv)++ = _desc;
                       REL_HEAP;

                       POP_W();  /* remove the argument of stack W */

                       PUSH_W(ptdesc);

/* fprintf(debugger, "0x%x: MKNCASE leaving through door 1 !\n", curr_pid); fflush (debugger); */

                       goto loop;

                       } else {
                       DBUG_PRINT("INTER", ("prepare to build closure..."));

/* fprintf(debugger, "0x%x: MKNCASE leaving through door 2 !\n", curr_pid); fflush (debugger); */

                       goto L_real_nomatch2;
                       }

                   } else {
                     DBUG_PRINT("INTER", ("speculative results have to be interpreted"));

#if D_SPEC_TICKETS
                     /* now (nfv) stackframes lie on the stack */

                     DBUG_PRINT("INTER", ("process %d pointers on the stack", nfv));

                     for (help = nfv-1; help>=0; help--) {
                       ptdesc = POP_R();
                       DBUG_PRINT("INTER", ("copying data contained in 0x%x to frame %d !", ptdesc, help));
  
                       curr_pid->son_results[help] = SPEC_SF_FIRSTF(*ptdesc);
                       curr_pid->son_redcnts[help] = SPEC_SF_REDSTEPS(*ptdesc);
                       if (SPEC_SF_GUARD(*ptdesc) != NULL) {
                         DBUG_PRINT("INTER", ("there was a guard stored, copy it !"));
                         curr_pid->son_redcnts[help] = SPEC_SF_GUARD(*ptdesc);
                         }
                       curr_pid->son_status[help] = SPEC_SF_PSTATUS(*ptdesc);

                       DBUG_PRINT("INTER", ("result: 0x%x, redcnts: %d, status: 0x%x", curr_pid->son_results[help], curr_pid->son_redcnts[help], curr_pid->son_status[help]));
                       }

                     PC_SET_SPEC_SUM(curr_pid, nfv); 
                     PC_SET_SPEC_SPAWNED(curr_pid, nfv);
#endif

                     if (spec_multi_results > 0) {
                       DBUG_PRINT("INTER", ("multiple results !"));

                       /* the semantics slighty changes in multi_results. Here, ONE NO_STEPS */
                       /* UNRED_GUARD and GUARD_SON  overrules anything, so first check if there's a NO_STEPS or UNRED_GUARD/SON included, */
                       /* and count the results (if there are any), so that the arity of the */
                       /* resulting list is known */

                       DBUG_PRINT("INTER", ("_redcnt: %d, PC_GET_SPEC_SUM: %d", _redcnt, PC_GET_SPEC_SUM(curr_pid)));

                       help = 0; /* number of WINNER results */
                       func = 0; /* will be set to 1 if there's a NO_STEP or GUARD result, because of which a constructor would be generated */
                       for (arity=0; arity<PC_GET_SPEC_SUM(curr_pid); arity++) {
                         DBUG_PRINT("INTER", ("curr_pid redcnt: %d; result no %d: result: %x, redcnt: %d, status: %x", _redcnt, arity,
                              curr_pid->son_results[arity], curr_pid->son_redcnts[arity], curr_pid->son_status[arity]));

                         if (!T_S_GUARD_SON(curr_pid->son_status[arity])) {

/* fprintf(debugger, "MKNCASE: !T_S_GUARD_SON \n"); fflush(debugger); */

                           _redcnt -= curr_pid->son_redcnts[arity];

                           DBUG_PRINT("INTER", ("GUARD_SON NOT set, calculate redsteps..."));

                           if (T_S_UNRED_GUARD(curr_pid->son_status[arity])==1) {
                             DBUG_PRINT("INTER", ("number %d: unreducible guard (UNRED_GUARD)", arity));
                             func = 1;
                             } else {
                             DBUG_PRINT("INTER", ("number %d: no unreducible guard (UNRED_GUARD), ok !", arity));
                             }
                           }
                         else {

/* fprintf(debugger, "MKNCASE: T_S_GUARD_SON !!!\n"); fflush(debugger); */

                           DBUG_PRINT("INTER", ("number %d: unreduced guard (GUARD)", arity));
                           func = 1;
                           }

                         if (T_S_WINNER(curr_pid->son_status[arity])==1) {
                           DBUG_PRINT("INTER", ("number %d is a winner", arity));
                           _desc = curr_pid->son_results[arity];
                           if (!T_POINTER((PTR_DESCRIPTOR)_desc) || (R_DESC(*(PTR_DESCRIPTOR)_desc, class) != C_LIST))
                             post_mortem("speculative evaluation: program not suited for multi results !");
                           help += R_LIST(*(PTR_DESCRIPTOR)curr_pid->son_results[arity],dim);
                           DBUG_PRINT("INTER", ("length of list %d: %d", arity, R_LIST(*(PTR_DESCRIPTOR)curr_pid->son_results[arity],dim)));
                           } else
                         if (T_S_NO_STEPS(curr_pid->son_status[arity])==1) {
                           DBUG_PRINT("INTER", ("number %d has run out of steps", arity));
                           func = 1;
                           } else
                         if (T_S_FAIL(curr_pid->son_status[arity])==1) {
                           DBUG_PRINT("INTER", ("number %d has failed", arity));
                           } else
                         if (T_S_NO_BSTEPS(curr_pid->son_status[arity])==1) {
                           DBUG_PRINT("INTER", ("number %d has run out of bsteps", arity));
                           } else {
                           DBUG_PRINT("INTER", ("NO FLAG was set... strange !"));
                           }

                         }

                       DBUG_PRINT("INTER", ("number of valid results: %d, OUT_OF_STEPS results: %d", help, func));

                       if (!func && (help>0)) {
                         DBUG_PRINT("INTER", ("some results were gathered ! Generate LIST..."));

                         GET_DESC(_desc);
                         LI_DESC_MASK(_desc,1,C_LIST,TY_UNDEF);
                         GET_HEAP(help,A_LIST(*_desc,ptdv)); 
                         L_LIST(*_desc,dim) = help;
                         RES_HEAP;
                         help = R_LIST((*_desc),ptdv); /* target "array" */

                         for (arity=0; arity<PC_GET_SPEC_SUM(curr_pid); arity++) {
                           if (T_S_WINNER(curr_pid->son_status[arity])) {
                             DBUG_PRINT("INTER", ("fill in number %d", arity));
                             for (nfv=0; nfv<R_LIST(*(PTR_DESCRIPTOR)curr_pid->son_results[arity],dim); nfv++) {
                               *((int *)help)++ = ptdesc = *(((int *) R_LIST(*(PTR_DESCRIPTOR)curr_pid->son_results[arity],ptdv))+nfv);
                               if (T_POINTER(ptdesc)) {
                                 DBUG_PRINT("INTER", ("increasing reference count for %x", ptdesc));
                                 INC_REFCNT((PTR_DESCRIPTOR)ptdesc);
                                 } else {
                                 DBUG_PRINT("INTER", ("non-pointer value: %x (VAL_INT = %d)", ptdesc, VAL_INT((int)ptdesc)));
                                 }
                               }
                             }
                           }

                         REL_HEAP;

                         PC_SET_SPEC_WINNER(curr_pid);

                         } else {
                         DBUG_PRINT("INTER", ("no results, build constructor !"));

                         GET_DESC(_desc);
                         LI_DESC_MASK(_desc,1,C_LIST,TY_UNDEF);
                         GET_HEAP(PC_GET_SPEC_SUM(curr_pid)+1,A_LIST(*_desc,ptdv)); 
                         L_LIST(*_desc,dim) = PC_GET_SPEC_SUM(curr_pid)+1;
                         RES_HEAP;
                         help = R_LIST((*_desc),ptdv); /* pointer to heap */

                         *((int *)help)++ = makestrdesc(SPEC_CONSTRUCTOR);
 
                         for (arity=0; arity<PC_GET_SPEC_SUM(curr_pid); arity++) {
                           if (spec_retrans != 1) {
                             DBUG_PRINT("INTER", ("ignore retransformed results..."));
                             *((int *)help)++ = TAG_INT(42);
                             } else {
                           if (!T_S_GUARD_SON(curr_pid->son_status[arity])) {

/* fprintf(debugger, "MKNCASE: generate constructor, no GUARD !\n"); fflush(debugger);  */

                             DBUG_PRINT("INTER", ("create entry %d", arity));
                             *((int *)help)++ = curr_pid->son_results[arity];
                             } else {

                             if (curr_pid->son_redcnts[arity] != NULL) { /* is there really a guard expression ??? */

/* fprintf(debugger, "MKNCASE: generate constructor including GUARD !\n"); fflush(debugger);  */

                             DBUG_PRINT("INTER", ("guard was not reduced... create another constructor..."));
                             GET_DESC(ptdesc);
                             LI_DESC_MASK(ptdesc,1,C_LIST,TY_UNDEF);
                             GET_HEAP(3,A_LIST(*ptdesc,ptdv));
                             L_LIST(*ptdesc,dim) = 3;
                             nfv = R_LIST((*ptdesc),ptdv); /* pointer to heap */
                             *((int *)nfv)++ = makestrdesc(SPEC_GUARD_CONSTRUCTOR);
                             *((int *)nfv)++ = curr_pid->son_redcnts[arity];
                             *((int *)nfv)++ = curr_pid->son_results[arity]; 
                             *((int *)help)++ = ptdesc;

                             PC_SET_SPEC_UNRED_GUARD(curr_pid);

                             }
              
                             else {
                               DBUG_PRINT("INTER", ("guard was not reduced (in this s_case), but TRUE"));
                               *((int *)help)++ = curr_pid->son_results[arity];
                             }

                             }

                             if (T_S_UNRED_GUARD(curr_pid->son_status[arity])==1) {
 
/* fprintf(debugger, "MKNCASE: set UNRED_GUARD...\n"); fflush(debugger); */
 
                               DBUG_PRINT("INTER", ("set UNRED_GUARD..."));
                               PC_SET_SPEC_UNRED_GUARD(curr_pid);
                               }

                             }
                           }

                         REL_HEAP;

                         if (!T_SPEC_UNRED_GUARD(curr_pid)) {

/* fprintf(debugger, "MKNCASE: T_SPEC_UNRED_GUARD NOT set !\n"); fflush(debugger); */

                           if (func) {
                             DBUG_PRINT("INTER", ("set NO_STEPS..."));
                             PC_SET_SPEC_NO_STEPS(curr_pid);

/* fprintf(debugger, "0x%x: MKNCASE: set SPEC_NO_STEPS set !\n", curr_pid); fflush(debugger); */

                             } else {
                             DBUG_PRINT("INTER", ("set FAIL..."));
                             PC_SET_SPEC_FAIL(curr_pid);
                             } 
                           }

                         /* set redcount to 0 */
                         DBUG_PRINT("INTER", ("old start_red_count: %d", curr_pid->start_red_count));
                         curr_pid->start_red_count = curr_pid->start_red_count - _redcnt;
                         _redcnt = 0;
                         DBUG_PRINT("INTER", ("modified start_red_count: %d", curr_pid->start_red_count));

                         }

                       PUSH_W(_desc);

                       } else {
                       DBUG_PRINT("INTER", ("no multiple results, choose one !"));

/*                       fprintf(debugger, "* %x: gathering results !\n", curr_pid); */

                       /* if there's a WINNING result, choose the one with least reduction steps */
                       /* variables available: arity arg nfv help func */

                       help = -1; /* this is the index of the chosen result */
                       func = 0; /* this is the number of reduction steps used */
                       nfv = 0; /* signals if there's a GUARD problem */
                       DBUG_PRINT("INTER", ("_redcnt: %d, PC_GET_SPEC_SUM: %d", _redcnt, PC_GET_SPEC_SUM(curr_pid)));


                       for (arity=0; arity<PC_GET_SPEC_SUM(curr_pid); arity++) {
                         DBUG_PRINT("INTER", ("curr_pid redcnt: %d; result no %d: result: %x, redcnt: %d, status: %x", _redcnt, arity,
                              curr_pid->son_results[arity], curr_pid->son_redcnts[arity], curr_pid->son_status[arity]));
                         if (T_S_GUARD_SON(curr_pid->son_status[arity])==1) {
                           DBUG_PRINT("INTER", ("number %d: unreducible guard", arity));
                           nfv = 1;
                           }

/* fprintf(debugger, "0x%x: MKNCASE, result number %x: %d steps used, winner: %d, no_bsteps: %d, fail: %d no_steps: %d!\n", curr_pid, arity, curr_pid->son_redcnts[arity], T_S_WINNER(curr_pid->son_status[arity]), T_S_NO_BSTEPS(curr_pid->son_status[arity]), T_S_FAIL(curr_pid->son_status[arity]), T_S_NO_STEPS(curr_pid->son_status[arity]));  fflush(debugger); */

                         if (T_S_WINNER(curr_pid->son_status[arity])==1) {
                           DBUG_PRINT("INTER", ("number %d is a winner", arity));

/* fprintf(debugger, "0x%x: MKNCASE, result number %x: %d steps used, winner: %d, no_bsteps: %d, fail: %d no_steps: %d!\n", curr_pid, arity, curr_pid->son_redcnts[arity], T_S_WINNER(curr_pid->son_status[arity]), T_S_NO_BSTEPS(curr_pid->son_status[arity]), T_S_FAIL(curr_pid->son_status[arity]), T_S_NO_STEPS(curr_pid->son_status[arity]));  fflush(debugger);  */
                         
                           if (help == -1) {
                             DBUG_PRINT("INTER", ("no winner registered yet"));
                             help = arity;
                             func = curr_pid->son_redcnts[arity];
                             } 
                           else if (curr_pid->son_redcnts[arity] < func) {
                             DBUG_PRINT("INTER", ("number %d has used less steps: %d", arity, curr_pid->son_redcnts[arity]));
                             help = arity;
                             func = curr_pid->son_redcnts[arity];
                             }
                           DBUG_PRINT("INTER", ("still chosen: number %d which used %d steps", help, func));
                           }
                         }


                       if ((help == -1) || (nfv==1)) {
                         DBUG_PRINT("INTER", ("no winning process or unreducible guard found..."));
                         DBUG_PRINT("INTER", ("generate constructor..."));
                         
                         GET_DESC(_desc);
                         LI_DESC_MASK(_desc,1,C_LIST,TY_UNDEF);
                         GET_HEAP(PC_GET_SPEC_SUM(curr_pid)+1,A_LIST(*_desc,ptdv)); /* now arity can be reused */
                         L_LIST(*_desc,dim) = PC_GET_SPEC_SUM(curr_pid)+1;
                         RES_HEAP;
                         help = R_LIST((*_desc),ptdv);

                         /* generate constructor name */

                         *((int *)help)++ = makestrdesc(SPEC_CONSTRUCTOR);

                         for (nfv = 0; nfv<PC_GET_SPEC_SUM(curr_pid); nfv++) {
                           if (spec_retrans != 1) {
                             DBUG_PRINT("INTER", ("ignore retransformed results..."));
                             *((int *)help)++ = TAG_INT(42);
                             } else {
                           if (!T_S_GUARD_SON(curr_pid->son_status[nfv])) {
 
/* fprintf(debugger, "MKNCASE: !T_S_GUARD_SON set... calculate Redsteps !\n"); fflush(debugger);  */
 
                             _redcnt -= curr_pid->son_redcnts[nfv];
                             }

                           if ((T_S_GUARD_SON(curr_pid->son_status[nfv]) == 1) && (curr_pid->son_redcnts[nfv] != NULL)) {

/* fprintf(debugger, "MKNCASE: generate constructor with GUARD !\n"); fflush(debugger);  */

                             DBUG_PRINT("INTER", ("guard was not reduced... create another constructor..."));
                             GET_DESC(ptdesc);
                             LI_DESC_MASK(ptdesc,1,C_LIST,TY_UNDEF);
                             GET_HEAP(3,A_LIST(*ptdesc,ptdv));
                             L_LIST(*ptdesc,dim) = 3;
                             arity = R_LIST((*ptdesc),ptdv); /* pointer to heap */
                             *((int *)arity)++ = makestrdesc(SPEC_GUARD_CONSTRUCTOR);
                             *((int *)arity)++ = curr_pid->son_redcnts[nfv];
                             *((int *)arity)++ = curr_pid->son_results[nfv];
                             *((int *)help)++ = ptdesc;
                             } 
                           else {

/* fprintf(debugger, "MKNCASE: generate constructor, no GUARD !\n"); fflush(debugger);  */

                             *((int *)help)++ = curr_pid->son_results[nfv];

                             } }

                           if ((T_S_GUARD_SON(curr_pid->son_status[nfv]) == 1) ||
                               (T_S_UNRED_GUARD(curr_pid->son_status[nfv]) == 1)) {
                             DBUG_PRINT("INTER", ("GUARD_SON or UNRED_GUARD result, set the flag..."));

/* fprintf(debugger, "MKNCASE: GUARD_SON or UNRED_GUARD result, set the flag...\n"); fflush(debugger); */

                             PC_SET_SPEC_UNRED_GUARD(curr_pid);
                             } else /* if there's one NO_STEPS, tag whole process as NO_STEPS */
                           if ((curr_pid->son_status[nfv] & SPEC_NO_STEPS) != 0 ) {
                             DBUG_PRINT("INTER", ("NO_STEPS result, set the flag..."));

/* fprintf(debugger, "0x%x: MKNCASE: NO_STEPS result, set the flag...\n", curr_pid); fflush(debugger);   */

                             PC_SET_SPEC_NO_STEPS(curr_pid);
                             }
                           } 
                         REL_HEAP;

                         if (!T_SPEC_NO_STEPS(curr_pid) && !T_SPEC_UNRED_GUARD(curr_pid)) { /* so set fail */
                           DBUG_PRINT("INTER", ("no NO_STEPS result found, setting FAIL..."));

/* fprintf(debugger, "MKNCASE: no NO_STEPS result found, setting FAIL...\n"); fflush(debugger); */

                           PC_SET_SPEC_FAIL(curr_pid);
                           }

                         PUSH_W(_desc);

                         /* set redcount to 0 */
                         DBUG_PRINT("INTER", ("old start_red_count: %d", curr_pid->start_red_count));
                         curr_pid->start_red_count = curr_pid->start_red_count - _redcnt;
                         _redcnt = 0;
                         DBUG_PRINT("INTER", ("modified start_red_count: %d", curr_pid->start_red_count));

/* fprintf(debugger, "0x%x: MKNCASE leaving through door 3 !\n", curr_pid); fflush (debugger); */

                         goto loop;
                         }

                       _redcnt -= curr_pid->son_redcnts[help];

/*                       fprintf(debugger, "* number %x was chosen ! _redcount now %d\n", help, _redcnt); fflush(debugger);  */

                       PUSH_W(curr_pid->son_results[help]);
                       PC_SET_SPEC_WINNER(curr_pid);
                       
                       }
                     }

/* fprintf(debugger, "0x%x: MKNCASE leaving through door 4 !\n", curr_pid); fflush (debugger); */

                   goto loop;
#else
                   post_mortem("7 sorry, no speculative evaluation in this version !");
#endif
                   goto loop;

  /* hier faengt der Mess-Kram an ! */

#if D_MESS

   case I_COUNT  :  /* === COUNT n : count command n === */

                    FUNC1("count");
                    arity = *code++;
                    /* arity: Nr. des auszufuehrenden und somit
                       zu zaehlenden ASM-Befehls */

 DBUG_PRINT ("inter", ("*** ich counte...: arity %d", arity)); 
#if D_SLAVE
                    MPRINT_COUNT (D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, arity);
#endif
/* DBUG_PRINT("inter", ("*** ich habe gecountet...")); */

                    goto loop;

#if D_MHEAP

   case I_MHPALLON :  /* === MHPALLON : turn on heap alloc measure === */
                    
                      FUNC0("mhpallon");
       
#if D_SLAVE
                      DBUG_PRINT ("inter", ("*** ich schalte HEAP ALLOC an !!"));
                      d_m_newheap = m_newheap;
#endif
 
                      goto loop;

   case I_MHFREEON :  /* === MHFREEON : turn on heap free measure === */

                      FUNC0("mhfreeon");
      
#if D_SLAVE
                      DBUG_PRINT ("inter", ("*** ich schalte HEAP FREE an !!"));
                      d_m_freeheap = m_freeheap;
#endif

                      goto loop;

   case I_MHPCMPON :  /* === MHPCMPON : turn on heap compaction measure === */

                      FUNC0("mhpcmpon");

#if D_SLAVE
                      DBUG_PRINT ("inter", ("*** ich schalte HEAP COMPACT an !!"));
                      d_m_compheap = m_compheap;
#endif

                      goto loop;

   case I_MDESCALLON :  /* === MDESCALLON : turn on descriptor alloc measure === */

                        FUNC0("mdescallon");

#if D_SLAVE
                        DBUG_PRINT ("inter", ("*** ich schalte DESC ALLOC an !!"));
                        d_m_newdesc = m_newdesc;
#endif

                        goto loop;

   case I_MDESCFREON :  /* === MDESCFREON : turn on descriptor free measure === */

                        FUNC0("mdescfreon");
 
#if D_SLAVE
                        DBUG_PRINT ("inter", ("*** ich schalte DESC FREE an !!"));
                        d_m_freedesc = m_freedesc;
#endif

                        goto loop;

#endif /* D_MHEAP */

#if D_MSCHED

   case I_MSDISTON  :  /* === MSDISTON : turn on proc-distribute measure === */

                       FUNC0("msdiston");

#if D_SLAVE
                       DBUG_PRINT ("INTER", ("PROCESS DISTRIBUTION measure enabled !"));
                       d_m_distribute = m_distribute;
#endif

                       goto loop;

   case I_MSNODIST  : /* === MSNODIST : seperate exprs not to distribute === */

                      FUNC0("msnodist");

#if D_SLAVE
                      MPRINT_PROC_NODIST (D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID);
#endif

                      goto loop;

   case I_MSDISTCK  : /* === MSDISTCK : print lenght of stackframe === */

                      FUNC1("msdistck");
                      arity = *code++;


#if D_SLAVE
                      MPRINT_PROC_DISTSTACKS(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, arity);
#endif

                      goto loop;

   case I_MPROCREON :  /* === MPROCREON : turn on process creation measure === */

                       FUNC0("mprocreon");

#if D_SLAVE
                       DBUG_PRINT ("INTER", ("PROCESS CREATE measure enabled !"));
                       d_m_process_create = m_process_create;
#endif

                       goto loop;

#endif /* D_MSCHED */

   case I_MSDISTEND :  /* === MSDISTEND : process distend measure === */

                       FUNC0("msdistend");

#if D_SLAVE
                       if (TOP_R() >= 0) {
                         DBUG_PRINT ("INTER", ("DISTEND zurueck an Prozessor %d !", TOP_R()));
                         MPRINT_PROC_DISTEND(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, (int)curr_pid->ppid, (int)TOP_R());
                         }
#endif

                       goto loop;

#if D_MSCHED

   case I_MPRSLEEON :  /* === MPRSLEEON : turn on process suspend measure === */

                       FUNC0("mprsleeon");

#if D_SLAVE
                       DBUG_PRINT ("RINTER", ("PROCESS SLEEP measure enabled !"));
                       d_m_process_sleep = m_process_sleep;
#endif
   
                       goto loop;

   case I_MPRORUNON :  /* === MPRORUNON : turn on process run measure === */

                       FUNC0("mprorunon");

#if D_SLAVE
                       DBUG_PRINT ("RINTER", ("PROCESS RUN measure enabled !"));
                       d_m_process_run = m_process_run;
#endif

                       goto loop;

   case I_MPROWAKON :  /* === MPROWAKON : turn on process wake up measure === */

                       FUNC0("mprowakon");

#if D_SLAVE
                       DBUG_PRINT ("RINTER", ("PROCESS WAKE UP measure enabled !"));
                       d_m_process_wakeup = m_process_wakeup;
#endif

                       goto loop;

     case I_MPROTERON :  /* === MPROTERON : turn on process run measure === */

                       FUNC0("mproteron");

#if D_SLAVE
                       DBUG_PRINT ("RINTER", ("PROCESS TERMINATE measure enabled !"));
                       d_m_process_terminate = m_process_terminate;
#endif

                       goto loop;

#endif /* D_MSCHED */

#if D_MCOMMU

   case I_MCOMSEBON :  /* === MCOMSEBON : turn on communication send begin measure === */

                       FUNC0("mcomsebon");

#if D_SLAVE
                       DBUG_PRINT ("INTER", ("SEND BEGIN measure enabled !"));
                       d_m_msg_send = m_msg_send;
                       m_msg_send_begin = 1;
#endif

                       goto loop;

   case I_MCOMSEEON :  /* === MCOMSEEON : turn on communication send end measure === */

                       FUNC0("mcomseeon");

#if D_SLAVE
                       DBUG_PRINT ("INTER", ("SEND END measure enabled !"));
                       d_m_msg_send = m_msg_send;
                       m_msg_send_end = 1;
#endif

                       goto loop;

   case I_MCOMREBON :  /* === MCOMREBON : turn on communication receive begin measure === */

                       FUNC0("mcomrebon");

#if D_SLAVE
                       DBUG_PRINT ("INTER", ("RECEIVE BEGIN measure enabled !"));
                       d_m_msg_receive = m_msg_receive;
                       m_msg_receive_begin = 1;
#endif

                       goto loop;

   case I_MCOMREEON :  /* === MCOMREEON : turn on communication receive measure === */

                       FUNC0("mcomreeon");

#if D_SLAVE
                       DBUG_PRINT ("INTER", ("RECEIVE measure enabled !"));
                       d_m_msg_receive = m_msg_receive;
                       m_msg_receive_end = 1;
#endif

                       goto loop;

#endif /* D_MCOMMU */

#if D_MSTACK

   case I_MSTCKPUON :  /* === MSTCKPUON : turn on stack-push measure === */

                       FUNC0("mstckpuon");

#if D_SLAVE
                       DBUG_PRINT ("RINTER", ("STACK PUSH measure enabled !"));
                       d_m_stack_push = m_stack_push;
#endif

                       goto loop;

   case I_MSTCKPPON :  /* === MSTCKPPON : turn on stack-pop measure === */

                       FUNC0("mstckppon");

#if D_SLAVE
                       DBUG_PRINT ("RINTER", ("STACK POP measure enabled !"));
                       d_m_stack_pop = m_stack_pop;
#endif 

                       goto loop;

   case I_MSTKSEGAL :  /* === MSTKSEGAL : turn on stack-seg alloc measure === */

                       FUNC0("mstksegal");

#if D_SLAVE
                       DBUG_PRINT ("inter", ("*** ich schalte STACK SEG ALLOC an !!"));
                       d_m_allocate_d_stack_segment = m_allocate_d_stack_segment;
#endif

                       goto loop;

   case I_MSTKSEGFR :  /* === MSTKSEGFR : turn on stack-seg free measure === */

                       FUNC0("mstksegfr");

#if D_SLAVE
                       DBUG_PRINT ("inter", ("*** ich schalte STACK SEG FREE an !!"));
                       d_m_free_d_stack_segment = m_free_d_stack_segment;
#endif

                       goto loop;

#endif /* D_MSTACK */

#endif /* D_MESS */

   case I_CHKFRAME  :  /* === CHKFRAME : check for enough stackspace === */

                       FUNC1("chkframe");
                       arity = *code++;

#if D_CHECKFRAME

#endif
                       goto loop;

/* hier endet der Verteilungs- und Messkram       RS ab 1.1.1993 */

#if    UH_ZF_PM
    /* hier klinkt sich ulli ein ! */
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/  case I_APPEND:     /* ( W l -- ) ( E e1 ... en n -- e1 ... en en+1 n+1 ) */
/*dguh, 27.07.90*/                FUNC0("append");
/*dguh, 27.07.90*/                arity = TOP_E();
/*dguh, 27.07.90*/                WRITE_E(POP_W());
/*dguh, 27.07.90*/                PUSH_E(INC(arity));
/*dguh, 27.07.90*/                goto loop;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/  case I_BEGINZF:   /* ( E -- nil 0)  */
/*dguh, 27.07.90*/                FUNC0("zf{");
/*dguh, 27.07.90*/                PUSH_E(_nil);
/*dguh, 27.07.90*/                INC_REFCNT(_nil);
/*dguh, 27.07.90*/                PUSH_E(SET_ARITY(ZF_UH,0));
/*dguh, 27.07.90*/                goto loop;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/  case I_ENDZF:    /* ( E list e1 ... en n -- ) ( W -- list++[e1..en] ) */
/*dguh, 27.07.90*/                   /* Verwendung der Register:   */
/*dguh, 27.07.90*/                   /* arity:               Anzahl der (noch) erzeugten Elemente */
/*dguh, 27.07.90*/                   /* ptdesc:              Descriptor der Liste ausgelagerten Elemente */
/*dguh, 27.07.90*/                   /* pth:                 Zum Durchlaufen von Heapbereichen */
/*dguh, 27.07.90*/                   /* arg:                 Zeiger auf Resultat               */
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                FUNC0("}zf");
/*dguh, 27.07.90*/                arity = ARITY(POP_E());
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                /* Liste erzeugen und Zeiger in ptdesc ablegen. */
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                if (arity) {  /* Ueberhaupt noch Elemente erzeugt. */
/*dguh, 27.07.90*/                  /* Elemente in den Heap auslagern */
/*dguh, 27.07.90*/                  /* Listendescriptor anfordern */
/*dguh, 27.07.90*/                  NEWDESC(ptdesc);
/*dguh, 27.07.90*/                  LI_DESC_MASK(ptdesc,1,C_LIST,TY_UNDEF);
/*dguh, 27.07.90*/                  L_LIST(*ptdesc,dim) = arity;
/*dguh, 27.07.90*/                  /* entsprechend grossen Heapblock anfordern */
/*dguh, 27.07.90*/                  GET_HEAP(arity,A_LIST(*ptdesc,ptdv));
/*dguh, 27.07.90*/                  RES_HEAP;
/*dguh, 27.07.90*/                  /* Heapblock mit Elementen fuellen */
/*dguh, 27.07.90*/                  pth = (PTR_HEAPELEM)R_LIST(*ptdesc,ptdv);
/*dguh, 27.07.90*/                  for ( ; --arity >= 0; ) {
/*dguh, 27.07.90*/                     pth[arity] = POP_E();
/*dguh, 27.07.90*/                  }
/*dguh, 27.07.90*/                  REL_HEAP;
/*dguh, 27.07.90*/                }
/*dguh, 27.07.90*/                else { /* keine (weiteren) Elemente erzeugt */
/*dguh, 27.07.90*/                  INC_REFCNT(_nil);
/*dguh, 27.07.90*/                  ptdesc = _nil;
/*dguh, 27.07.90*/                }
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                /* Anfangsstueck testen. */
/*dguh, 27.07.90*/                if (TOP_E() != (STACKELEM)_nil) {  /* Anfangsstueck nicht leer */
/*dguh, 27.07.90*/                  /* Ergebnisliste erzeugen und Zeiger in arg ablegen */
/*dguh, 27.07.90*/                  if (ptdesc==_nil) {  /* und keine weiteren Elemente erzeugt */
/*dguh, 27.07.90*/                    arg=POP_E();
/*dguh, 27.07.90*/                    /* ptdesc enthaelt _nil, das nicht mehr benoetigt wird. */
/*dguh, 27.07.90*/                    DEC_REFCNT(_nil);
/*dguh, 27.07.90*/                    PUSH_W((T_PTD)arg);
/*dguh, 27.07.90*/                    goto loop;
/*dguh, 27.07.90*/                  } else {  /* nicht leeres Anfangsstueck und  noch Elemente erzeugt */
/*dguh, 27.07.90*/                            /* AP Anfang Liste UNITE erzeugen */
/*dguh, 27.07.90*/                    /* Expression-Descriptor erzeugen */
/*dguh, 27.07.90*/                    MAKE_DESC(arg,1,C_EXPRESSION,TY_EXPR); /* for PCS */
/*dguh, 27.07.90*/                    /* Heapblock fuer Ausdruck anfordern */
/*dguh, 27.07.90*/                    GET_HEAP(5,A_EXPR(*(T_PTD)arg,pte)); /* Platz fuer @@ x y z */
/*dguh, 27.07.90*/                    /* Heapblock fuellen */
/*dguh, 27.07.90*/                    RES_HEAP;
/*dguh, 27.07.90*/                    pth = (PTR_HEAPELEM)R_EXPR(*(T_PTD)arg,pte);
/*dguh, 27.07.90*/                    *pth++ = 4;
/*dguh, 27.07.90*/                    *pth++ = SET_ARITY(AP,3);
/*dguh, 27.07.90*/                    *pth++ = (int)ptdesc;        /* Liste */
/*dguh, 27.07.90*/                    *pth++ = POP_E();            /* Anfang */
/*dguh, 27.07.90*/                    *pth   = LUNI;
/*dguh, 27.07.90*/                    REL_HEAP;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                    /* Resultat ablegen */
/*dguh, 27.07.90*/                    PUSH_W((T_PTD)arg);
/*dguh, 27.07.90*/                    goto loop;
/*dguh, 27.07.90*/                  }
/*dguh, 27.07.90*/                }
/*dguh, 27.07.90*/                /* Anfangsstueck leer, noch erzeugte Elemente in ptdesc */
/*dguh, 27.07.90*/                PPOP_E();                  /* nil */
/*dguh, 27.07.90*/                DEC_REFCNT(_nil);
/*dguh, 27.07.90*/                PUSH_W(ptdesc);
/*dguh, 27.07.90*/                goto loop;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/  case I_DROPP:       /* ( W ptr -- ) */
/*dguh, 27.07.90*/                FUNC0("dropp");
/*dguh, 27.07.90*/                ptdesc = (T_PTD)POP_W();
/*dguh, 27.07.90*/                DEC_REFCNT(ptdesc);
/*dguh, 27.07.90*/                goto loop;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/  case I_JUMP:      /* Jump unconditionally */
/*dguh, 27.07.90*/                FUNC1("jump");
/*dguh, 27.07.90*/                code = (INSTR *)*code;
/*dguh, 27.07.90*/                goto loop;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/  case I_EXTRACT:    /* ( W listdesc n -- listdesc n-1 )  ( A -- el )  */
/*dguh, 27.07.90*/                FUNC0("extract");
/*dguh, 27.07.90*/                arity = TOP_W();
/*dguh, 27.07.90*/                ptdesc = (T_PTD)MID_W(1);
/*dguh, 27.07.90*/                pth = R_LIST(*ptdesc,ptdv);
/*dguh, 27.07.90*/                arg = pth[ R_LIST(*ptdesc,dim) - VAL_INT(arity) ];
/*dguh, 27.07.90*/                if (T_POINTER(arg))
/*dguh, 27.07.90*/                  INC_REFCNT((T_PTD)arg);
/*dguh, 27.07.90*/                PUSH_A(arg);
/*dguh, 27.07.90*/                WRITE_W(TAG_INT(VAL_INT(arity)-1));
/*dguh, 27.07.90*/                goto loop;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/  case I_DIM:        /* ( W listdesc -- dim ) */
/*dguh, 27.07.90*/                FUNC0("Dimension");
/*dguh, 27.07.90*/                ptdesc = (T_PTD)TOP_W();
/*dguh, 27.07.90*/                PUSH_W( TAG_INT(R_LIST(*ptdesc,dim)) );
/*dguh, 27.07.90*/                goto loop;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/  case I_TZERO:      /* ( W n -- n ) ( 0 -- )  */
/*dguh, 27.07.90*/                FUNC1("testzero");
/*dguh, 27.07.90*/                if (VAL_INT(TOP_W())) {
/*dguh, 27.07.90*/                  code++;
/*dguh, 27.07.90*/                  goto loop;
/*dguh, 27.07.90*/                }
/*dguh, 27.07.90*/                PPOP_W();
/*dguh, 27.07.90*/                code = (INSTR *)*code;
/*dguh, 27.07.90*/                goto loop;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/  case I_TFALSE:    /* ( W f -- f )  ( ff -- ) */
/*dguh, 27.07.90*/                FUNC1("testfalse");
/*dguh, 27.07.90*/                arg = TOP_W();
/*dguh, 27.07.90*/                if (IS_FALSE(arg)) {
/*dguh, 27.07.90*/                   PPOP_W();
/*dguh, 27.07.90*/                   code = (INSTR *)*code;
/*dguh, 27.07.90*/                   goto loop;
/*dguh, 27.07.90*/                }
/*dguh, 27.07.90*/                code++;
/*dguh, 27.07.90*/                goto loop;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/  case I_TTRUE:    /* ( W f -- f )  ( tf -- ) */
/*dguh, 27.07.90*/                FUNC1("testtrue");
/*dguh, 27.07.90*/                arg = TOP_W();
/*dguh, 27.07.90*/                if (IS_TRUE(arg)) {
/*dguh, 27.07.90*/                   PPOP_W();
/*dguh, 27.07.90*/                   code = (INSTR *)*code;
/*dguh, 27.07.90*/                   goto loop;
/*dguh, 27.07.90*/                }
/*dguh, 27.07.90*/                code++;
/*dguh, 27.07.90*/                goto loop;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/  case I_TLIST:      /* ( W desc -- flag ) */
/*dguh, 27.07.90*/                FUNC1("testlist");
/*dguh, 27.07.90*/                ptdesc = (T_PTD)TOP_W();
/*dguh, 27.07.90*/                if (T_POINTER((int)ptdesc) && R_DESC(*ptdesc,class)==C_LIST) {
/*dguh, 27.07.90*/                   code++;
/*dguh, 27.07.90*/                   goto loop;
/*dguh, 27.07.90*/                }
/*dguh, 27.07.90*/                code = (INSTR *)*code;
/*dguh, 27.07.90*/                goto loop;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/  case I_MAKEZF:     /* ( W ??? -- closure )  */
/*dguh, 27.07.90*/                FUNC1("makezflist");
/*dguh, 27.07.90*/                /* Auf Stack E liegen die bisher generierten Elemente der */
/*dguh, 27.07.90*/                /* Comprehension zusammen mit einer evtl. schon erzeugten */
/*dguh, 27.07.90*/                /* Closure (Anfangsstueck).  */
/*dguh, 27.07.90*/                /* Sie muessen nun zusammengefasst werden, und mit */
/*dguh, 27.07.90*/                /* Hilfe des Code-Descriptors zu einer weiteren Closure verarbeitet */
/*dguh, 27.07.90*/                /* werden. */
/*dguh, 27.07.90*/                arity=ARITY(TOP_E());     /* Anzahl der erzeugten Elemente */
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                /* ptdesc auf Liste der erzeugten Elemente setzen */
/*dguh, 27.07.90*/                if (arity) { /* Elemente erzeugt */
/*dguh, 27.07.90*/                  /* Platz fuer genuegend Elemente anfordern und Elemente wegschreiben */
/*dguh, 27.07.90*/                  /* vgl. END ZF */
/*dguh, 27.07.90*/                  PPOP_E();
/*dguh, 27.07.90*/                  NEWDESC(ptdesc);
/*dguh, 27.07.90*/                  LI_DESC_MASK(ptdesc,1,C_LIST,TY_UNDEF);
/*dguh, 27.07.90*/                  L_LIST(*ptdesc,dim) = arity;
/*dguh, 27.07.90*/                  GET_HEAP(arity,A_LIST(*ptdesc,ptdv));
/*dguh, 27.07.90*/                  RES_HEAP;
/*dguh, 27.07.90*/                  pth = (PTR_HEAPELEM)R_LIST(*ptdesc,ptdv);
/*dguh, 27.07.90*/                  for ( ; --arity >= 0; ) {
/*dguh, 27.07.90*/                     pth[arity] = POP_E();
/*dguh, 27.07.90*/                  }
/*dguh, 27.07.90*/                  REL_HEAP;
/*dguh, 27.07.90*/                } else { /* keine Elemente erzeugt. */
/*dguh, 27.07.90*/                  PPOP_E();
/*dguh, 27.07.90*/                  ptdesc= _nil;
/*dguh, 27.07.90*/                  INC_REFCNT(_nil);
/*dguh, 27.07.90*/                }
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                /* Diese Liste mit dem bisherigen Anfang vereinigen Ergebnis nach ptdesc*/
/*dguh, 27.07.90*/                if (TOP_E() != (STACKELEM)_nil) { /* bisheriger Anfang nicht leer */
/*dguh, 27.07.90*/                   /* erzeuge evtl. "AP Anfang Liste UNITE" */
/*dguh, 27.07.90*/                   if (ptdesc==_nil) { /* keine weiteren erzeugten Elemente */
/*dguh, 27.07.90*/                      /*  AP Anfang Liste UNITE  ist dann gleich   Anfang  */
/*dguh, 27.07.90*/                      ptdesc=(T_PTD)TOP_E();
/*dguh, 27.07.90*/                      /* in ptdesc stand _nil, das nicht mehr gebraucht wird. */
/*dguh, 27.07.90*/                      DEC_REFCNT(_nil);
/*dguh, 27.07.90*/                   } else {  /* weitere Elemente erzeugt */
/*dguh, 27.07.90*/                      /* AP Anfang Liste UNITE erzeugen */
/*dguh, 27.07.90*/                      MAKE_DESC(arg,1,C_EXPRESSION,TY_EXPR); /* For PCS */
/*dguh, 27.07.90*/                      GET_HEAP(5,A_EXPR(*(T_PTD)arg,pte)); /* Platz fuer @@ x y z */
/*dguh, 27.07.90*/                      RES_HEAP;
/*dguh, 27.07.90*/                      /* Heapbereich fuellen */
/*dguh, 27.07.90*/                      pth = (PTR_HEAPELEM)R_EXPR(*(T_PTD)arg,pte);
/*dguh, 27.07.90*/                      *pth++ = 4;
/*dguh, 27.07.90*/                      *pth++ = SET_ARITY(AP,3);
/*dguh, 27.07.90*/                      *pth++ = (int)ptdesc;
/*dguh, 27.07.90*/                      *pth++ = TOP_E();
/*dguh, 27.07.90*/                      *pth   = LUNI;
/*dguh, 27.07.90*/                      REL_HEAP;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                      ptdesc = (T_PTD)arg;
/*dguh, 27.07.90*/                   }
/*dguh, 27.07.90*/                }
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                /* Closure erzeugen --> func */
/*dguh, 27.07.90*/                   arg = *code++;  /* Codedescriptor holen */
/*dguh, 27.07.90*/                   arity = R_ZFCODE(*(T_PTD)arg,nargs); /* Anzahl der bisher erz. ZF-Var */
/*dguh, 27.07.90*/                zb=R_ZFCODE(*(T_PTD)arg,zfbound);
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                   /* ZF-Descriptor fuer Closure erzeugen. */
/*dguh, 27.07.90*/                   MAKE_DESC(help,1,C_EXPRESSION,TY_ZF); /* For PCS */
/*dguh, 27.07.90*/                   L_ZF(*(T_PTD)help,special)=ZF_START; /* markiere als ZF-Start */
/*dguh, 27.07.90*/                   L_ZF(*(T_PTD)help,nargs)=arity;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                   /* Hier darf NICHT auf den gleichen HEAP-Block verwiesen werden! */
/*dguh, 27.07.90*/                   L_ZF(*(T_PTD)help,namelist)=R_ZFCODE(*(T_PTD)arg,varnames);
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                   /* Heap-block fuer ZF-Applikation erzeugen */
/*dguh, 27.07.90*/                   GET_HEAP(4,A_ZF(*(T_PTD)help,pte));
/*dguh, 27.07.90*/                   pth=(PTR_HEAPELEM)R_ZF(*(T_PTD)help,pte);
/*dguh, 27.07.90*/                   *pth++ = 3;
/*dguh, 27.07.90*/                   *pth++ = SET_ARITY(AP,2);
/*dguh, 27.07.90*/                   *pth++ = POP_W();           /* Listen-Closure */
/*dguh, 27.07.90*/                   *pth++ = (int)R_ZFCODE(*(T_PTD)arg,ptd);
/*dguh, 27.07.90*/                            /* Zeiger auf folgenden Descr. */
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                   /* SNAPplikation der aktuellen Belegung erzeugen */
/*dguh, 27.07.90*/                   MAKE_DESC(func,1,C_EXPRESSION,TY_EXPR); /* For PCS */
/*dguh, 27.07.90*/                   GET_HEAP(arity+3,A_EXPR(*(T_PTD)func,pte)); /* SNAP erzeugen */
/*dguh, 27.07.90*/                   pth=(PTR_HEAPELEM)R_EXPR(*(T_PTD)func,pte);
/*dguh, 27.07.90*/                   RES_HEAP;
/*dguh, 27.07.90*/                   printf("Arity hat in MAKEZF den Wert %d\nEs sind %d ZF Variablen gebunden.\n",arity,zb);
/*dguh, 27.07.90*/                   *pth++ = arity+2;
/*dguh, 27.07.90*/                   *pth++ = SET_ARITY(SNAP,arity+1);
/*dguh, 27.07.90*/                   *(pth+arity)=help;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                   /* Werte der freie Variablen aufsammeln. */
/*dguh, 27.07.90*/                   help=R_ZFCODE(*(T_PTD)arg,zfbound); /* Anzahl der gebundenen ZF-Variablen */
/*dguh, 27.07.90*/                   while (help) {
/*dguh, 27.07.90*/                      help--;
/*dguh, 27.07.90*/                      if (T_POINTER(MID_A(help))) INC_REFCNT((T_PTD)MID_A(help)); /* uh 04Okt 91 */
/*dguh, 27.07.90*/                      *pth++=MID_A(help);   /* ZF-Variablen */
/*dguh, 27.07.90*/                   }
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                   help=R_ZFCODE(*(T_PTD)arg,zfbound);
/*dguh, 27.07.90*/                   while (arity>help) {
/*dguh, 27.07.90*/                      arity--;
/*dguh, 27.07.90*/                      if (T_POINTER(MID_A(arity))) INC_REFCNT((T_PTD)MID_A(arity)); /* uh 04Okt91 */
/*dguh, 27.07.90*/                      *pth++=MID_A(arity);  /* lambda Variablen */
/*dguh, 27.07.90*/                   }
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                   REL_HEAP;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                /* Neues Anfangsstueck mit boolescher Closure vereinigen:  -> Stack E */
/*dguh, 27.07.90*/                if (ptdesc == _nil) {  /* Kein altes Anfangsstueck */
/*dguh, 27.07.90*/                   WRITE_E(func);       /* Closure ist neues Anfangsstueck */
/*dguh, 27.07.90*/                   /* ptdesc enthalet _nil, das nicht mehr gebraucht wird */
/*dguh, 27.07.90*/                   DEC_REFCNT(_nil);
/*dguh, 27.07.90*/                } else { /* Anfangsstueck vereinigen */
/*dguh, 27.07.90*/                   /* jetzt "@@ unite Anfang Closure" erzeugen */
/*dguh, 27.07.90*/                   MAKE_DESC(arg,1,C_EXPRESSION,TY_EXPR); /* For PCS */
/*dguh, 27.07.90*/                   GET_HEAP(5,A_EXPR(*(T_PTD)arg,pte)); /* Platz fuer @@ x y z */
/*dguh, 27.07.90*/                   RES_HEAP;
/*dguh, 27.07.90*/                   pth = (PTR_HEAPELEM)R_EXPR(*(T_PTD)arg,pte);
/*dguh, 27.07.90*/                   *pth++ = 4;
/*dguh, 27.07.90*/                   *pth++ = SET_ARITY(AP,3);
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                   *pth++ = func;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                   *pth++ = (int)ptdesc;        /* Anfang */
/*dguh, 27.07.90*/                   *pth   = LUNI;
/*dguh, 27.07.90*/                   REL_HEAP;
/*dguh, 27.07.90*/                   WRITE_E((T_PTD)arg);
/*dguh, 27.07.90*/                }
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                /* Zaehler fuer weitere Elemente drauf */
/*dguh, 27.07.90*/                PUSH_E(SET_ARITY(ZF_UH,0));
/*dguh, 27.07.90*/                goto loop;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/  case I_MAKEBOOL:   /*  ( w ??? -- closure ) */
/*dguh, 27.07.90*/                FUNC1("makebool");
/*dguh, 27.07.90*/                /* Auf Stack E liegen die bisher generierten Elemente der */
/*dguh, 27.07.90*/                /* Comprehension zusammen mit einer evtl. schon erzeugten */
/*dguh, 27.07.90*/                /* Closure (Anfangsstueck).  */
/*dguh, 27.07.90*/                /* Sie muessen nun zusammengefasst werden, und mit */
/*dguh, 27.07.90*/                /* Hilfe des Code-Descriptors zu einer weiteren Closure verarbeitet */
/*dguh, 27.07.90*/                /* werden. */
/*dguh, 27.07.90*/                arity=ARITY(TOP_E());     /* Anzahl der erzeugten Elemente */
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                /* ptdesc auf Liste der erzeugten Elemente setzen */
/*dguh, 27.07.90*/                if (arity) { /* Elemente erzeugt */
/*dguh, 27.07.90*/                  /* Platz fuer genuegend Elemente anfordern und Elemente wegschreiben */
/*dguh, 27.07.90*/                  /* vgl. END ZF */
/*dguh, 27.07.90*/                  PPOP_E();
/*dguh, 27.07.90*/                  NEWDESC(ptdesc);
/*dguh, 27.07.90*/                  LI_DESC_MASK(ptdesc,1,C_LIST,TY_UNDEF);
/*dguh, 27.07.90*/                  L_LIST(*ptdesc,dim) = arity;
/*dguh, 27.07.90*/                  GET_HEAP(arity,A_LIST(*ptdesc,ptdv));
/*dguh, 27.07.90*/                  RES_HEAP;
/*dguh, 27.07.90*/                  pth = (PTR_HEAPELEM)R_LIST(*ptdesc,ptdv);
/*dguh, 27.07.90*/                  for ( ; --arity >= 0; ) {
/*dguh, 27.07.90*/                     pth[arity] = POP_E();
/*dguh, 27.07.90*/                  }
/*dguh, 27.07.90*/                  REL_HEAP;
/*dguh, 27.07.90*/                } else { /* keine Elemente erzeugt. */
/*dguh, 27.07.90*/                  PPOP_E();
/*dguh, 27.07.90*/                  ptdesc= _nil;
/*dguh, 27.07.90*/                  INC_REFCNT(_nil);
/*dguh, 27.07.90*/                }
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                /* Diese Liste mit dem bisherigen Anfang vereinigen Ergebnis nach ptdesc*/
/*dguh, 27.07.90*/                if (TOP_E() != (STACKELEM)_nil) { /* bisheriger Anfang nicht leer */
/*dguh, 27.07.90*/                   /* erzeuge "@@ unite Anfang Liste" */
/*dguh, 27.07.90*/                   if (ptdesc==_nil) { /* keine erzeugten Elemente */
/*dguh, 27.07.90*/                      ptdesc=(T_PTD)TOP_E();
/*dguh, 27.07.90*/                      DEC_REFCNT(_nil);
/*dguh, 27.07.90*/                   } else {
/*dguh, 27.07.90*/                      MAKE_DESC(arg,1,C_EXPRESSION,TY_EXPR); /* For PCS */
/*dguh, 27.07.90*/                      GET_HEAP(5,A_EXPR(*(T_PTD)arg,pte)); /* Platz fuer @@ x y z */
/*dguh, 27.07.90*/                      RES_HEAP;
/*dguh, 27.07.90*/                      pth = (PTR_HEAPELEM)R_EXPR(*(T_PTD)arg,pte);
/*dguh, 27.07.90*/                      *pth++ = 4;
/*dguh, 27.07.90*/                      *pth++ = SET_ARITY(AP,3);
/*dguh, 27.07.90*/                      *pth++ = (int)ptdesc;
/*dguh, 27.07.90*/                      *pth++ = TOP_E();
/*dguh, 27.07.90*/                      *pth   = LUNI;
/*dguh, 27.07.90*/                      REL_HEAP;
/*dguh, 27.07.90*/                      ptdesc = (T_PTD)arg;
/*dguh, 27.07.90*/                   }
/*dguh, 27.07.90*/                }
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                /* Closure erzeugen --> func */
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                   arg = *code++;  /* Codedescriptor holen */
/*dguh, 27.07.90*/                   arity = R_ZFCODE(*(T_PTD)arg,nargs); /* Anzahl der bisher erz. ZF-Var */
/*dguh, 27.07.90*/                 zb= R_ZFCODE(*(T_PTD)arg,zfbound);
/*dguh, 27.07.90*/                printf("In MAKEBOOL hat arity den Wert %d\n Es sind %d ZF-VAriablen gebunden\n",arity, zb);
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                   MAKE_DESC(help,1,C_EXPRESSION,TY_ZF); /* For PCS */
/*dguh, 27.07.90*/                   L_ZF(*(T_PTD)help,special)=ZF_START; /* markiere als ZF-Start */
/*dguh, 27.07.90*/                   L_ZF(*(T_PTD)help,nargs)=arity;
/*dguh, 27.07.90*/                   L_ZF(*(T_PTD)help,namelist)=R_ZFCODE(*(T_PTD)arg,varnames);
/*dguh, 27.07.90*/                   GET_HEAP(4,A_ZF(*(T_PTD)help,pte));
/*dguh, 27.07.90*/                   /* L_ZF(*(T_PTD)help,pte)=R_ZFCODE(*(T_PTD)arg,pte); */
/*dguh, 27.07.90*/                   pth=(PTR_HEAPELEM)R_ZF(*(T_PTD)help,pte);
/*dguh, 27.07.90*/                   *pth++ = 3;
/*dguh, 27.07.90*/                   *pth++ = SET_ARITY(AP,2);
/*dguh, 27.07.90*/                   *pth++ = POP_W();
/*dguh, 27.07.90*/                   *pth++ = (int)R_ZFCODE(*(T_PTD)arg,ptd);
/*dguh, 27.07.90*/                              /* Zeiger auf folgenden Descr. */
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                     MAKE_DESC(func,1,C_EXPRESSION,TY_EXPR); /* For PCS */
/*dguh, 27.07.90*/                     GET_HEAP(arity+3,A_EXPR(*(T_PTD)func,pte)); /* SNAP erzeugen */
/*dguh, 27.07.90*/                     pth=(PTR_HEAPELEM)R_EXPR(*(T_PTD)func,pte);
/*dguh, 27.07.90*/                     RES_HEAP;
/*dguh, 27.07.90*/                     *pth++ = arity+2;
/*dguh, 27.07.90*/                     *pth++ = SET_ARITY(SNAP,arity+1);
/*dguh, 27.07.90*/                     *(pth+arity)=help;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                     help=R_ZFCODE(*(T_PTD)arg,zfbound); /* Anzahl der gebundenen ZF-Variablen */
/*dguh, 27.07.90*/                     while (help) {
/*dguh, 27.07.90*/                        help--;
/*dguh, 27.07.90*/                        if (T_POINTER(MID_A(help))) INC_REFCNT((T_PTD)MID_A(help)); /* uh 04Okt91 */
/*dguh, 27.07.90*/                        *pth++=MID_A(help);   /* ZF-Variablen */
/*dguh, 27.07.90*/                     }
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                     help=R_ZFCODE(*(T_PTD)arg,zfbound);
/*dguh, 27.07.90*/                     while (arity>help) {
/*dguh, 27.07.90*/                        arity--;
/*dguh, 27.07.90*/                        if (T_POINTER(MID_A(arity))) INC_REFCNT((T_PTD)MID_A(arity)); /* uh 04Okt91 */
/*dguh, 27.07.90*/                        *pth++=MID_A(arity);  /* lambda Variablen */
/*dguh, 27.07.90*/                     }
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                     REL_HEAP;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                /* Neues Anfangsstueck mit boolescher Closure vereinigen:  -> Stack E */
/*dguh, 27.07.90*/                if (ptdesc == _nil) {  /* Kein altes Anfangsstueck */
/*dguh, 27.07.90*/                   WRITE_E(func);       /* Closure ist neues Anfangsstueck */
/*dguh, 27.07.90*/                } else { /* Anfangsstueck vereinigen */
/*dguh, 27.07.90*/                   /* jetzt "@@ unite Anfang Closure" erzeugen */
/*dguh, 27.07.90*/                   MAKE_DESC(arg,1,C_EXPRESSION,TY_EXPR); /* FOR PCS */
/*dguh, 27.07.90*/                   GET_HEAP(5,A_EXPR(*(T_PTD)arg,pte)); /* Platz fuer @@ x y z */
/*dguh, 27.07.90*/                   RES_HEAP;
/*dguh, 27.07.90*/                   pth = (PTR_HEAPELEM)R_EXPR(*(T_PTD)arg,pte);
/*dguh, 27.07.90*/                   *pth++ = 4;
/*dguh, 27.07.90*/                   *pth++ = SET_ARITY(AP,3);
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                   *pth++ = func;
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                   *pth++ = (int)ptdesc;        /* Anfang */
/*dguh, 27.07.90*/                   *pth   = LUNI;
/*dguh, 27.07.90*/                   REL_HEAP;
/*dguh, 27.07.90*/                   WRITE_E((T_PTD)arg);
/*dguh, 27.07.90*/                }
/*dguh, 27.07.90*/  
/*dguh, 27.07.90*/                /* Zaehler fuer weitere Elemente drauf */
/*dguh, 27.07.90*/                PUSH_E(SET_ARITY(ZF_UH,0));
/*dguh, 27.07.90*/                goto loop;
/*dguh, 27.07.90*/  
/*uh, 16.10.90*/
/*uh, 16.10.90*/  /* Pattern Matching Instruktionen */
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_MKWFRAME:  /* size ( W x -- x 0(1) 0(2) ... 0(size) x ) */
/*uh, 16.10.90*/     /* MKWFRAME "MaKeWorkFRAME"  */
/*uh, 16.10.90*/     /* legt auf dem W_Stack ein Work-Frame der Groesse SIZE+1 an. In ihm werden bei */
/*uh, 16.10.90*/     /* geschachtelten Listen-Pattern die Zeiger und Zaehler der umfassenden Listen  */
/*uh, 16.10.90*/     /* abgelegt. X ist ein Zeiger auf das Argument. */
/*uh, 16.10.90*/     /* Es bleibt unter dem Stack-Frame liegen, */
/*uh, 16.10.90*/     /* damit es moeglich ist, das gesamte Argument zu erreichen.  */
/*uh, 16.10.90*/     /* Zusaetzlich wird das Argument auf das oberste Element des Frames kopiert.  */
/*uh, 16.10.90*/     /* Hier liegen waehrend des gesamten Matchens der Matchzeiger (second W) und das  */
/*uh, 16.10.90*/     /* aktuelle Argument (top W), das gematcht werden soll. */
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  FUNC1("makewframe");
/*uh, 16.10.90*/                  arg = TOP_W();
/*uh, 16.10.90*/                  for (help=(int)(*code++);help>0; help--) {
/*uh, 16.10.90*/                     PUSH_W(0);
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/                  PUSH_W(arg);   /* Refcount Behandlung???? */
#if D_SLAVE
                                  if (isdesc(arg)) INC_REFCNT((T_PTD)arg);
#endif
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_MKBTFRAME:  /* size ( E x -- x 1(1) 1(2) ... 1(size) ) */
/*uh, 16.10.90*/     /* BTFRAME "MaKeBackTrackFRAME"   */
/*uh, 16.10.90*/     /* legt auf dem E-Stack ein Frame der Groesse SIZE an, indem im Backtrackfall */
/*uh, 16.10.90*/     /* der Matchzeiger gesichert wird.  */
/*uh, 16.10.90*/                  FUNC1("makebtframe");
/*uh, 16.10.90*/                  for (help=(int)(*code++);help>0; help--) {
/*uh, 16.10.90*/                     PUSH_R(1); /* 1 wegen RefCount Behandlung (eg. kein Pointer) */
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_MKAFRAME:  /* size ( I x -- x 1(1) 1(2) ... 1(size) ) */
/*uh, 16.10.90*/    /* MKAFRAME "MaKeInkanationFrame" */
/*uh, 16.10.90*/    /* legt auf dem Inkarnations-Stack A ein Frame der Groesse SIZE an, in das die */
/*uh, 16.10.90*/    /* Bindungen der Variablen des Patterns aufgenommen werden koennen. */
/*uh, 16.10.90*/                  FUNC1("makeiframe");
/*uh, 16.10.90*/                  for (help=(int)(*code++);help>0; help--) {
/*uh, 16.10.90*/                     PUSH_A(TAG_INT(42));  /* 1 wegen Refcount-Behandlung (kein Pointer) */
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_RMWFRAME: /* size ( W e1 e2 ... esize -- ) */
/*uh, 16.10.90*/      /* RMWFRAME "ReMoveWorkFRAME"  */
/*uh, 16.10.90*/      /* Entfernt das Frame der Groesse SIZE vom Work-Stack. */
/*uh, 16.10.90*/                  FUNC1("remwframe");
/*uh, 16.10.90*/                  for (help=(int)(*code++); help>0; help--) {
#if D_SLAVE
                                     arg = POP_W(); if (isdesc(arg)) DEC_REFCNT((T_PTD)arg);
#else
/*uh, 16.10.90*/                     PPOP_W() ;   /* Refcount-Behandlung???? */
#endif
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_RMBTFRAME: /* size ( E e1 e2 ... esize -- ) */
/*uh, 16.10.90*/      /* RMBTFRAME "ReMoveBackTrackFRAME" */
/*uh, 16.10.90*/      /* Entfernt das Frame der Groesse SIZE vom Backtrack-Stack E */
/*uh, 16.10.90*/                  FUNC1("rembtframe");
/*uh, 16.10.90*/                  for (help=(int)(*code++); help>0; help--) {
#if D_SLAVE
                                     arg = POP_R(); if (isdesc(arg)) DEC_REFCNT((T_PTD)arg);
#else
/*uh, 16.10.90*/                     PPOP_R() ;   /* Refcount-Behandlung???? */
#endif
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_BIND: /* index ( W: x -- x ) ( I: bindings -- bindings' )  */
/*uh, 16.10.90*/    /* BIND */
/*uh, 16.10.90*/    /* Bindet die durch INDEX referenzierte Variable des Patterns an den Wert X,  */
/*uh, 16.10.90*/    /* der oben auf dem Work-Stack steht, indem X an die Stelle INDEX in das Frame */
/*uh, 16.10.90*/    /* auf dem Inkarnations-Stack geschrieben wird. */
/*uh, 16.10.90*/                  FUNC1("bind");
/*uh, 16.10.90*/                  arg = *code++;
/*uh, 16.10.90*/                  ptdesc = (T_PTD)TOP_W();
                                  if (T_POINTER(MID_A(arg)))
                                     DEC_REFCNT((T_PTD)MID_A(arg));
/*uh, 16.10.90*/                  if (T_POINTER((int)ptdesc))
/*uh, 16.10.90*/                     INC_REFCNT(ptdesc);
/*uh, 16.10.90*/                  UPDATE_A(arg,(STACKELEM)ptdesc);
/*uh, 16.10.90*/                  goto loop;

/*uh, 16.10.90*/  case I_BINDS: /* match't ein Element eines strings, neuen Stringdeskripter drumherum bauen... */
/*uh, 16.10.90*/                  FUNC1("binds"); 
/*uh, 16.10.90*/                  arg = *code++;
/*uh, 16.10.90*/                  ptdesc = (T_PTD)TOP_W();
                                  if (T_POINTER(MID_A(arg)))
                                     DEC_REFCNT((T_PTD)MID_A(arg));
/*uh, 16.10.90*/                  if (T_POINTER((int)ptdesc))
/*uh, 16.10.90*/                     INC_REFCNT(ptdesc);
                                  if ((_desc = newdesc()) == NULL)
                                     post_mortem("rinter: BINDS heap out of space");
                                  LI_DESC_MASK(_desc,1,C_LIST,TY_STRING);
                                  GET_HEAP(1,A_LIST(*(T_PTD)_desc,ptdv));
                                  L_LIST(*(T_PTD)_desc,dim) = 1;  
                                  pth = R_LIST(*(T_PTD)_desc,ptdv); 
                                  RES_HEAP;
                                  *pth = (int) ptdesc; 
                                  REL_HEAP;
/*uh, 16.10.90*/                  UPDATE_A(arg,(STACKELEM)_desc);
/*uh, 16.10.90*/                  goto loop;

/*uh, 16.10.90*/
#define LEN arg
#define ARG1 arg
/*
#define ARG2 ((int)func)
#define FAIL ((int)func)
#define UNDECIDED ((int)ptdesc) */
#define ARG2 func
#define FAIL func
#define UNDECIDED ptdesc
#define ARGUMENT help
#define IS_VAR_OR_CLOS_DESC(x)  ( (x)==C_EXPRESSION || (x)==C_CONSTANT || (x)==C_FUNC) 

/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_MATCHC:  /* Constant, FAIL-Addr, UNDECIDED-Addr ( W x -- x ) */
/*uh, 16.10.90*/      /* MATCHC "MATCH-Constant" */
/*uh, 16.10.90*/      /* Vergleicht das oberste Element X des Work-Stacks mit der Konstanten CONSTANT */
/*uh, 16.10.90*/      /* Sind sie gleich, so wird die Ausfuehrung mit der Instruktion forgesetzt, die */
/*uh, 16.10.90*/      /* unmittelbar auf MATCHC folgt. */
/*uh, 16.10.90*/      /* Sind sie ungleich, so wird die Ausfuehrung an der Adresse FAIL-Addr fortgesetzt.*/
/*uh, 16.10.90*/      /* Ist der Vergleich nicht entscheidbar, so wird die Ausfuehrung an der Adresse */
/*uh, 16.10.90*/      /* UNDECIDED-Addr fortgesetzt. */
/*uh, 16.10.90*/                  FUNC3("matchc");
/*uh, 16.10.90*/  /* printf("\n refcnt(_nil)=%d",R_DESC(*_nil,ref_count)); */
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  ARG1=*code++;
/*uh, 16.10.90*/                  ARG2=TOP_W();
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (ARG1==ARG2) goto matchc_succeed;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_POINTER(ARG2)) {
/*uh, 16.10.90*/                    help = R_DESC(*(T_PTD)ARG2,class);
/*uh, 16.10.90*/                    if IS_VAR_OR_CLOS_DESC(help)
/*uh, 16.10.90*/                        goto matchc_undecided;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                     /* Behandlung von TOP_W == C_SCALAR-Descriptor */
/*uh, 16.10.90*/
/*uh, 16.10.90*/                     goto matchc_fail;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  /* if (T_CON(ARG2)) goto matchc_undecided; AP oder SNAP */
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchc_fail:
/*uh, 16.10.90*/                  code = (int *)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchc_undecided:
                                  PUSH_T (KLAA);
/*uh, 16.10.90*/                  code+=1;
/*uh, 16.10.90*/                  code = (int*)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchc_succeed:
/*uh, 16.10.90*/                  code+=2;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_MATCHINT:  /* intConstant, FAIL-Addr, UNDECIDED-Addr ( W x -- x ) */
/*uh, 16.10.90*/      /* MATCHINT "MATCH-Integer" */
/*uh, 16.10.90*/      /* Vergleicht das oberste Element X des Work-Stacks mit der Integer */
/*uh, 16.10.90*/      /* Konstanten INTCONSTANT */
/*uh, 16.10.90*/      /* Sind sie gleich, so wird die Ausfuehrung mit der Instruktion forgesetzt, die */
/*uh, 16.10.90*/      /* unmittelbar auf MATCHINT folgt. */
/*uh, 16.10.90*/      /* Sind sie ungleich, so wird die Ausfuehrung an der Adresse FAIL-Addr fortgesetzt.*/
/*uh, 16.10.90*/      /* Ist der Vergleich nicht entscheidbar, so wird die Ausfuehrung an der Adresse */
/*uh, 16.10.90*/      /* UNDECIDED-Addr fortgesetzt. */
/*uh, 16.10.90*/                  FUNC3("matchint");
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  ARG1=*code++;
/*uh, 16.10.90*/                  ARG2=TOP_W();
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_INT(ARG2)) { /* Argument auch mit Tag versehen */
/*uh, 16.10.90*/                     if (EQ_INT(ARG1,ARG2)==SA_TRUE)  /* gleich */
/*uh, 16.10.90*/                    /*   if (VAL_INT(ARG2)==ARG1) */  /* gleich */
/*uh, 16.10.90*/                        goto matchint_succeed;
/*uh, 16.10.90*/                     goto matchint_fail;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_POINTER(ARG2)) {
/*uh, 16.10.90*/                    help = R_DESC(*(T_PTD)ARG2,class);
/*uh, 16.10.90*/                    if  (IS_VAR_OR_CLOS_DESC(help))
/*uh, 16.10.90*/                          goto matchint_undecided;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                     goto matchint_fail;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchint_fail:
/*uh, 16.10.90*/                  code = (int *)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchint_undecided:
                                  PUSH_T (KLAA);
/*uh, 16.10.90*/                  code+=1;
/*uh, 16.10.90*/                  code = (int*)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchint_succeed:
/*uh, 16.10.90*/                  code+=2;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/

/*uh, 16.10.90*/  case I_MATCHREAL:  
/*uh, 16.10.90*/      /* Vergleicht das oberste Element X des Work-Stacks mit der Integer */
/*uh, 16.10.90*/      /* Konstanten INTCONSTANT */
/*uh, 16.10.90*/                  FUNC3("matchreal");
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  ARG1=*code++;
/*uh, 16.10.90*/                  ARG2=TOP_W();
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_POINTER(ARG2) && (R_DESC(*(T_PTD)ARG2,class)==C_SCALAR) && (R_DESC(*(T_PTD)ARG2,type)==TY_REAL)) {
/*uh, 16.10.90*/                     if (R_SCALAR(*(T_PTD)ARG1,valr) == R_SCALAR(*(T_PTD)ARG2,valr))
/*uh, 16.10.90*/                        goto matchreal_succeed;
/*uh, 16.10.90*/                     goto matchreal_fail;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_POINTER(ARG2)) {
/*uh, 16.10.90*/                    help = R_DESC(*(T_PTD)ARG2,class);
/*uh, 16.10.90*/                    if  (IS_VAR_OR_CLOS_DESC(help))
/*uh, 16.10.90*/                          goto matchreal_undecided;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                     goto matchreal_fail;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchreal_fail:
/*uh, 16.10.90*/                  code = (int *)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchreal_undecided:
                                  PUSH_T (KLAA);
/*uh, 16.10.90*/                  code+=1;
/*uh, 16.10.90*/                  code = (int*)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchreal_succeed:
/*uh, 16.10.90*/                  code+=2;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/

/*uh, 16.10.90*/  case I_MATCHDIGIT:
/*uh, 16.10.90*/                  FUNC3("matchdigit");
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  ARG1=*code++;
/*uh, 16.10.90*/                  ARG2=TOP_W();
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_POINTER(ARG2) && (R_DESC(*(T_PTD)ARG2,class)==C_DIGIT)) {
/*uh, 16.10.90*/                     if (digit_eq(ARG1,ARG2))
/*uh, 16.10.90*/                        goto matchdigit_succeed;
/*uh, 16.10.90*/                     goto matchdigit_fail;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_POINTER(ARG2)) {
/*uh, 16.10.90*/                    help = R_DESC(*(T_PTD)ARG2,class);
/*uh, 16.10.90*/                    if  (IS_VAR_OR_CLOS_DESC(help))
/*uh, 16.10.90*/                          goto matchdigit_undecided;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                     goto matchdigit_fail;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchdigit_fail:
/*uh, 16.10.90*/                  code = (int *)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchdigit_undecided:
                                  PUSH_T (KLAA);
/*uh, 16.10.90*/                  code+=1;
/*uh, 16.10.90*/                  code = (int*)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchdigit_succeed:
/*uh, 16.10.90*/                  code+=2;
/*uh, 16.10.90*/                  goto loop;


/*uh, 16.10.90*/  case I_MATCHTRUE:  /* FAIL-Addr, UNDECIDED-Addr ( W x -- x ) */
/*uh, 16.10.90*/      /* MATCHTRUE "MATCH-true */
/*uh, 16.10.90*/      /* Vergleicht das oberste Element X des Work-Stacks mit der booleschen*/
/*uh, 16.10.90*/      /* Konstanten TRUE */
/*uh, 16.10.90*/      /* Sind sie gleich, so wird die Ausfuehrung mit der Instruktion forgesetzt, die */
/*uh, 16.10.90*/      /* unmittelbar auf MATCHTRUE folgt. */
/*uh, 16.10.90*/      /* Sind sie ungleich, so wird die Ausfuehrung an der Adresse FAIL-Addr fortgesetzt.*/
/*uh, 16.10.90*/      /* Ist der Vergleich nicht entscheidbar, so wird die Ausfuehrung an der Adresse */
/*uh, 16.10.90*/      /* UNDECIDED-Addr fortgesetzt. */
/*uh, 16.10.90*/                  FUNC2("matchtrue");
/*uh, 16.10.90*/  /* printf("\n refcnt(_nil)=%d",R_DESC(*_nil,ref_count)); */
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  ARG2=TOP_W();
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_BOOLEAN(ARG2)) {
/*uh, 16.10.90*/                    if (T_SA_TRUE(ARG2)) goto matchtrue_succeed;
/*uh, 16.10.90*/                    goto matchtrue_fail;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_POINTER(ARG2)) {
/*uh, 16.10.90*/                    help = R_DESC(*(T_PTD)ARG2,class);
/*uh, 16.10.90*/                    if (IS_VAR_OR_CLOS_DESC(help))
/*uh, 16.10.90*/                       goto matchtrue_undecided;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                    goto matchtrue_fail;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchtrue_fail:
/*uh, 16.10.90*/                  code = (int *)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchtrue_undecided:
                                  PUSH_T (KLAA);
/*uh, 16.10.90*/                  code+=1;
/*uh, 16.10.90*/                  code = (int*)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchtrue_succeed:
/*uh, 16.10.90*/                  code+=2;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_MATCHFALSE:  /* FAIL-Addr, UNDECIDED-Addr ( W x -- x ) */
/*uh, 16.10.90*/      /* MATCHFALSE "MATCH-false" */
/*uh, 16.10.90*/      /* Vergleicht das oberste Element X des Work-Stacks mit der booleschen*/
/*uh, 16.10.90*/      /* Konstanten FALSE */
/*uh, 16.10.90*/      /* Sind sie gleich, so wird die Ausfuehrung mit der Instruktion forgesetzt, die */
/*uh, 16.10.90*/      /* unmittelbar auf MATCHFALSE folgt. */
/*uh, 16.10.90*/      /* Sind sie ungleich, so wird die Ausfuehrung an der Adresse FAIL-Addr fortgesetzt.*/
/*uh, 16.10.90*/      /* Ist der Vergleich nicht entscheidbar, so wird die Ausfuehrung an der Adresse */
/*uh, 16.10.90*/      /* UNDECIDED-Addr fortgesetzt. */
/*uh, 16.10.90*/                  FUNC2("matchfalse");
/*uh, 16.10.90*/  /* printf("\n refcnt(_nil)=%d",R_DESC(*_nil,ref_count)); */
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  ARG2=TOP_W();
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_BOOLEAN(ARG2)) {
/*uh, 16.10.90*/                    if (T_SA_FALSE(ARG2)) goto matchfalse_succeed;
/*uh, 16.10.90*/                    goto matchfalse_fail;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_POINTER(ARG2)) {
/*uh, 16.10.90*/                    help = R_DESC(*(T_PTD)ARG2,class);
/*uh, 16.10.90*/                    if (IS_VAR_OR_CLOS_DESC(help))
/*uh, 16.10.90*/                       goto matchfalse_undecided;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                     goto matchfalse_fail;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchfalse_fail:
/*uh, 16.10.90*/                  code = (int *)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchfalse_undecided:
                                  PUSH_T (KLAA);
/*uh, 16.10.90*/                  code+=1;
/*uh, 16.10.90*/                  code = (int*)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchfalse_succeed:
/*uh, 16.10.90*/                  code+=2;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_MATCHBOOL:  /* boolConstant, FAIL-Addr, UNDECIDED-Addr ( W x -- x ) */
/*uh, 16.10.90*/      /* MATCHBOOL "MATCH-bool" */
/*uh, 16.10.90*/      /* Vergleicht das oberste Element X des Work-Stacks mit der booleschen*/
/*uh, 16.10.90*/      /* Konstanten BOOLCONSTANT */
/*uh, 16.10.90*/      /* Sind sie gleich, so wird die Ausfuehrung mit der Instruktion forgesetzt, die */
/*uh, 16.10.90*/      /* unmittelbar auf MATCHBOOL folgt. */
/*uh, 16.10.90*/      /* Sind sie ungleich, so wird die Ausfuehrung an der Adresse FAIL-Addr fortgesetzt.*/
/*uh, 16.10.90*/      /* Ist der Vergleich nicht entscheidbar, so wird die Ausfuehrung an der Adresse */
/*uh, 16.10.90*/      /* UNDECIDED-Addr fortgesetzt. */
/*uh, 16.10.90*/                  FUNC3("matchbool");
/*uh, 16.10.90*/  /* printf("\n refcnt(_nil)=%d",R_DESC(*_nil,ref_count)); */
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  ARG1=*code++;
/*uh, 16.10.90*/                  ARG2=TOP_W();
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_BOOLEAN(ARG2)) {
/*uh, 16.10.90*/                    if (EQ_BOOL(ARG1,ARG2)==SA_TRUE) goto matchbool_succeed;
/*uh, 16.10.90*/                    goto matchbool_fail;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_POINTER(ARG2)) {
/*uh, 16.10.90*/                    help = R_DESC(*(T_PTD)ARG2,class);
/*uh, 16.10.90*/                    if (IS_VAR_OR_CLOS_DESC(help))
/*uh, 16.10.90*/                       goto matchbool_undecided;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                     goto matchbool_fail;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchbool_fail:
/*uh, 16.10.90*/                  code = (int *)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchbool_undecided:
                                  PUSH_T (KLAA);
/*uh, 16.10.90*/                  code+=1;
/*uh, 16.10.90*/                  code = (int*)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchbool_succeed:
/*uh, 16.10.90*/                  code+=2;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_MATCHNIL:  /* FAIL-Addr, UNDECIDED-Addr ( W x -- x ) */
/*uh, 16.10.90*/      /* MATCHNIL "MATCH-NIL" */
/*uh, 16.10.90*/      /* Vergleicht das oberste Element X des Work-Stacks mit der Konstanten NIL */
/*uh, 16.10.90*/      /* Sind sie gleich, so wird die Ausfuehrung mit der Instruktion forgesetzt, die */
/*uh, 16.10.90*/      /* unmittelbar auf MATCHNIL folgt. */
/*uh, 16.10.90*/      /* Sind sie ungleich, so wird die Ausfuehrung an der Adresse FAIL-Addr fortgesetzt.*/
/*uh, 16.10.90*/      /* Ist der Vergleich nicht entscheidbar, so wird die Ausfuehrung an der Adresse */
/*uh, 16.10.90*/      /* UNDECIDED-Addr fortgesetzt. */
/*uh, 16.10.90*/                  FUNC2("matchnil");
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  ARG2=TOP_W();
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_POINTER(ARG2)) {
/*uh, 16.10.90*/                    help = R_DESC(*(T_PTD)ARG2,class);
/*uh, 16.10.90*/                    if (IS_VAR_OR_CLOS_DESC(help)) goto matchnil_undecided;
/*uh, 16.10.90*/                    if ((T_PTD)ARG2==_nil) goto matchnil_succeed;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/      /*       matchnil_fail: */
/*uh, 16.10.90*/                  code = (int *)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchnil_undecided:
                                  PUSH_T (KLAA);
/*uh, 16.10.90*/                  code+=1;
/*uh, 16.10.90*/                  code = (int*)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchnil_succeed:
/*uh, 16.10.90*/                  code+=2;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/

/*uh, 16.10.90*/  case I_MATCHPRIM:  /* Constant, FAIL-Addr, UNDECIDED-Addr ( W x -- x ) */
/*uh, 16.10.90*/      /* MATCHPRIM "MATCH-Constant" */
/*uh, 16.10.90*/      /* Vergleicht das oberste Element X des Work-Stacks mit der Konstanten CONSTANT */
/*uh, 16.10.90*/      /* Sind sie gleich, so wird die Ausfuehrung mit der Instruktion forgesetzt, die */
/*uh, 16.10.90*/      /* unmittelbar auf MATCHC folgt. */
/*uh, 16.10.90*/      /* Sind sie ungleich, so wird die Ausfuehrung an der Adresse FAIL-Addr fortgesetzt.*/
/*uh, 16.10.90*/      /* Ist der Vergleich nicht entscheidbar, so wird die Ausfuehrung an der Adresse */
/*uh, 16.10.90*/      /* UNDECIDED-Addr fortgesetzt. */
/*uh, 16.10.90*/                  FUNC3("matchprim");
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  ARG1=*code++;
/*uh, 16.10.90*/                  ARG2=TOP_W() & ~F_EDIT;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_POINTER(ARG2)) {
/*uh, 16.10.90*/                    help = R_DESC(*(T_PTD)ARG2,class);
/*uh, 16.10.90*/                    if (IS_VAR_OR_CLOS_DESC(help)) goto matchprim_undecided;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (ARG1==ARG2) goto matchprim_succeed;
/*uh, 16.10.90*/            /*  if (T_FUNC(ARG2) && (ARG1==FUNC_INDEX(ARG2))) goto matchprim_succeed; */
/*uh, 16.10.90*/
/*uh, 16.10.90*/ /*            matchprim_fail: */
/*uh, 16.10.90*/                  code = (int *)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchprim_undecided:
                                  PUSH_T (KLAA);
/*uh, 16.10.90*/                  code+=1;
/*uh, 16.10.90*/                  code = (int*)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchprim_succeed:
/*uh, 16.10.90*/                  code+=2;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_BACKUP: /* range ( W p *p -- p-range *p )  */
/*uh, 16.10.90*/      /* Vermindert den Zeiger, der als zweites Element auf dem Work-Stack steht, */
/*uh, 16.10.90*/      /* um RANGE.  Ist RANGE 1, so zeigt er dann auf das vorangehende Element. */
/*uh, 16.10.90*/                  FUNC1("backup");
/*uh, 16.10.90*/                  help = *code++;
/*uh, 16.10.90*/                  arg = (int) (((PTR_HEAPELEM)MID_W(1)) - help);
/*uh, 16.10.90*/                  UPDATE_W(1,arg); /* uh 04 Okt 91 */
/*uh, 16.10.90*/                  /* MID_W(1)= (STACKELEM)arg; */
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_ADVANCE: /* range ( W p *p -- p+range *p )  */
/*uh, 16.10.90*/      /* Erhoeht den Zeiger, der als zweites Element auf dem Work-Stack steht, um RANGE. */
/*uh, 16.10.90*/      /* Ist RANGE 1, so zeigt er dann auf das naechste Element. */
/*uh, 16.10.90*/                  FUNC1("advance");
/*uh, 16.10.90*/                  help = *code++;
/*uh, 16.10.90*/                  arg = (int) (((PTR_HEAPELEM)MID_W(1)) + help);
/*uh, 16.10.90*/                  UPDATE_W(1,arg);  /* uh 04 Okt 91 */
/*uh, 16.10.90*/                  /* MID_W(1)= (STACKELEM)arg; */
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_DEREF:   /* ( W p x -- p p* ) */
/*uh, 16.10.90*/    /* "DEREFerence" */
/*uh, 16.10.90*/    /* Dereferenziert den aktuellen Matchzeiger (second W) und schreibt das so gewonnene */
/*uh, 16.10.90*/    /* aktuelle Match-Element auf das oberste Element des Work-Stacks. */
/*uh, 16.10.90*/                  FUNC0("deref");
/*uh, 16.10.90*/                  ptdesc = (T_PTD)(*((PTR_HEAPELEM)MID_W(1)));
/*uh, 16.10.90*/                  WRITE_W((STACKELEM)ptdesc);
#if D_SLAVE
                                  if (isdesc(ptdesc)) INC_REFCNT((T_PTD)ptdesc);
#endif
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_DROP:    /* ( W p -- ) */
/*uh, 16.10.90*/     /* DROP */
/*uh, 16.10.90*/     /* entfernt das oberste Element P des Work-Stacks. Ist dieses Element ein Zeiger */
/*uh, 16.10.90*/     /* auf einen Descriptor, so wird der Refcount behandelt. */
/*uh, 16.10.90*/                  FUNC0("drop");
/*uh, 16.10.90*/                  ptdesc= (T_PTD)POP_W();
#if D_SLAVE
                                  if (isdesc(ptdesc)) DEC_REFCNT((T_PTD)ptdesc);
#else
/*uh, 16.10.90*/                  if (ptdesc && T_POINTER(ptdesc)) DEC_REFCNT(ptdesc);
#endif
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_PICK:    /* depth  ( W e(depth) ... e(1) e(0) -- e(depth) ... e(1) e(depth) ) */
/*uh, 16.10.90*/      /* PICK */
/*uh, 16.10.90*/      /* Ueberschreibt das oberste Elements des Work-Stacks durch das DEPTHte Element */
/*uh, 16.10.90*/      /* des Work-Stacks (gezaehlt von 0). */
/*uh, 16.10.90*/                  FUNC1("pick");
/*uh, 16.10.90*/                  arg = *code++;
/*uh, 16.10.90*/                  arg = (int) (MID_W(arg));
#if D_SLAVE
                                  ptdesc = TOP_W();
                                  if (isdesc(ptdesc)) DEC_REFCNT((T_PTD)ptdesc);
                                  if (isdesc(arg)) INC_REFCNT((T_PTD)arg);
#endif
/*uh, 16.10.90*/                  WRITE_W(arg);   /* Refcount */
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_RESTOREBT: /* depth  ( W ptr x -- ptr' x ) */
/*uh, 16.10.90*/     /* "RESTOREBackTrack"  */
/*uh, 16.10.90*/     /* Kopiert den im Backtrackframe an Position DEPTH gesicherten Wert des Matchzeigers */
/*uh, 16.10.90*/     /* ueber den aktuellen Zeiger (second W). */
/*uh, 16.10.90*/                  FUNC1("restorebt");
/*uh, 16.10.90*/                  arg = *code++;
/*uh, 16.10.90*/                  ptdesc = (T_PTD)MID_R(arg+BTPTR);
/*uh, 16.10.90*/                  UPDATE_W(1,(STACKELEM)ptdesc); /* Refcount!!! */ /* der Matchzeiger ist doch kein 
                                                                                      Descriptor, Du Dussel ! */
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_SAVEBT: /* depth ( E: frame -- frame ) ( W ptr x -- ptr x )  */
/*uh, 16.10.90*/     /* SAVEBT "SAVEBackTrack" */
/*uh, 16.10.90*/     /* Nimmt den aktuellen Matchzeiger (zweites Element vom Work-Stack) und sichert */
/*uh, 16.10.90*/     /* diesen Wert auf dem Backtrack-Stack an die Stelle DEPTH. */ /* bzgl. REFCOUNT siehe oben */
/*uh, 16.10.90*/                  FUNC1("savebt");
/*uh, 16.10.90*/                  arg = *code++;  /* depth */
/*uh, 16.10.90*/                  UPDATE_R(arg+BTPTR,MID_W(1));
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_SAVEPTR: /* depth ( W e(depth-1) ... e(1) e(0) -- e(1) ... e(1) e(0) ) */
/*uh, 16.10.90*/     /*    Sichert den aktuellen Matchzeiger im Stackframe an der Stelle DEPTH-1. */
/*uh, 16.10.90*/                  FUNC1("saveptr");
/*uh, 16.10.90*/                  /* WAIT; */
/*uh, 16.10.90*/                  arg = *code++;
/*uh, 16.10.90*/                  ptdesc = (T_PTD)MID_W(1);
/*uh, 16.10.90*/                  UPDATE_W(arg,(STACKELEM)ptdesc); /* Refcount */ /* ist das ein Pointer auf einen
                                                                                     Deskriptor, Du Idiot ? ;-) */
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_RESTPTR: /* depth ( W e(depth-1) ... e(1) e(0) -- e(depth-1) ... e(depth-1) e(0) ) */
/*uh, 16.10.90*/     /* Setzt den Matchpointer E(1) auf den frueher im Stackframe gesicherten Wert */
/*uh, 16.10.90*/     /* E(DEPTHI-1).  */
/*uh, 16.10.90*/                  FUNC1("restptr");
/*uh, 16.10.90*/                  arg = *code++;
/*uh, 16.10.90*/                  ptdesc = (T_PTD)MID_W(arg);
/*uh, 16.10.90*/                  UPDATE_W(1,(STACKELEM)ptdesc); /* Refcount!!! */
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_ENDLIST: /* ( W p x -- p~ x ) */
/*uh, 16.10.90*/     /* Setzt den Matchzeiger P auf des Ende der Liste (P~), die durch den */
/*uh, 16.10.90*/     /* Listen-Descriptor X beschrieben wird. */
/*uh, 16.10.90*/                  FUNC0("endlist");
/*uh, 16.10.90*/                  ptdesc = (T_PTD) (TOP_W());
#ifdef DEBUG
/*uh, 16.10.90*/                  if (!ptdesc || !T_POINTER(ptdesc) || !(R_DESC(*ptdesc,class)==C_LIST)) {
/*uh, 16.10.90*/                     post_mortem("rinter: ENDLIST expects LIST on top of W-Stack");
/*uh, 16.10.90*/                  }
#endif
/*uh, 16.10.90*/                  arg = (int) (R_LIST(*ptdesc,ptdv)+R_LIST(*ptdesc,dim));
/*uh, 16.10.90*/                  UPDATE_W(1,(STACKELEM)arg);
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_NESTLIST: /* ( W p x -- p~ x ) */
/*uh, 16.10.90*/     /* Setzt den Matchzeiger P auf das Anfang P~ der Liste, die durch den */
/*uh, 16.10.90*/     /* Listen-Descriptor X beschrieben wird. */
/*uh, 16.10.90*/                  FUNC0("nestlist");
/*uh, 16.10.90*/                  /* WAIT; */
/*uh, 16.10.90*/                  ptdesc = (T_PTD) (TOP_W());
#ifdef DEBUG
/*uh, 16.10.90*/                  if (!ptdesc || !T_POINTER(ptdesc) || !(R_DESC(*ptdesc,class)==C_LIST)) {
/*uh, 16.10.90*/                     post_mortem("rinter: NESTLIST expects LIST on top of W-Stack");
/*uh, 16.10.90*/                  }
#endif
/*uh, 16.10.90*/                  if (R_LIST(*ptdesc,dim))
/*uh, 16.10.90*/                    arg = (int) R_LIST(*ptdesc,ptdv);
/*uh, 16.10.90*/                  else
/*uh, 16.10.90*/                    arg = (int) _nil;  /* sth to deref */
/*uh, 16.10.90*/                  UPDATE_W(1,(STACKELEM)arg);
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_MATCHARB: /* len, FAIL, UNDECIDED ( W x -- x ) */
/*uh, 16.10.90*/  /*  Prueft, ob das oberste Element des Work-Stacks X eine Liste ist, die */
/*uh, 16.10.90*/  /*  mindestens die Stelligkeit LEN besitzt. */
/*uh, 16.10.90*/  /*  Ist dies der Fall, so wird die Ausfuehrung mit der Instruktion forgesetzt, die */
/*uh, 16.10.90*/  /*  unmittelbar auf MATCHARB folgt.  */
/*uh, 16.10.90*/  /*  Sonst wird die Ausfuehrung an der Adresse FAIL fortgesetzt. */
/*uh, 16.10.90*/  /*  Ist der Vergleich nicht entscheidbar, so wird die Ausfuehrung an der Adresse */
/*uh, 16.10.90*/  /*  UNDECIDED fortgesetzt.  */
/*uh, 16.10.90*/                  FUNC3("matcharb");
/*uh, 16.10.90*/                  LEN = *code++;
/*uh, 16.10.90*/                  FAIL = *code++;
/*uh, 16.10.90*/                  UNDECIDED = *code++;
/*uh, 16.10.90*/                  ARGUMENT=TOP_W();
/*uh, 16.10.90*/                  if (T_POINTER(ARGUMENT)) {
/*uh, 16.10.90*/                    /* Argument ist Pointer ... */
/*uh, 16.10.90*/                    if ((R_DESC(*(T_PTD)ARGUMENT,class)== C_LIST) &&
                                        (R_DESC(*(T_PTD)ARGUMENT,type)== TY_UNDEF) &&
/*uh, 16.10.90*/                        (R_LIST(*(T_PTD)ARGUMENT,dim) >= LEN)) goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                    /* ... aber keine Liste */
/*uh, 16.10.90*/                    ARGUMENT=R_DESC(*(T_PTD)ARGUMENT,class);
/*uh, 16.10.90*/                    if (IS_VAR_OR_CLOS_DESC(ARGUMENT)) {
                                       PUSH_T (KLAA);
/*uh, 16.10.90*/                       code = (int*)UNDECIDED;
/*uh, 16.10.90*/                       goto loop;
/*uh, 16.10.90*/                    }
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/                  code = (int*)FAIL;
/*uh, 16.10.90*/                  goto loop;

/*uh, 16.10.90*/  case I_MATCHARBS: /* matcharb fuer strings, neu von rs 1995 */
/*uh, 16.10.90*/                  FUNC3("matcharbs");
/*uh, 16.10.90*/                  LEN = *code++;
/*uh, 16.10.90*/                  FAIL = *code++;
/*uh, 16.10.90*/                  UNDECIDED = *code++;
/*uh, 16.10.90*/                  ARGUMENT=TOP_W();
/*uh, 16.10.90*/                  if (T_POINTER(ARGUMENT)) {
/*uh, 16.10.90*/                    /* Argument ist Pointer ... */
/*uh, 16.10.90*/                    if ((R_DESC(*(T_PTD)ARGUMENT,class)== C_LIST) &&
                                        (R_DESC(*(T_PTD)ARGUMENT,type)== TY_STRING) &&
/*uh, 16.10.90*/                        (R_LIST(*(T_PTD)ARGUMENT,dim) >= LEN)) goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                    /* ... aber keine Liste */
/*uh, 16.10.90*/                    ARGUMENT=R_DESC(*(T_PTD)ARGUMENT,class);
/*uh, 16.10.90*/                    if (IS_VAR_OR_CLOS_DESC(ARGUMENT)) {
                                       PUSH_T (KLAA);
/*uh, 16.10.90*/                       code = (int*)UNDECIDED;
/*uh, 16.10.90*/                       goto loop;
/*uh, 16.10.90*/                    }
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/                  code = (int*)FAIL;
/*uh, 16.10.90*/                  goto loop;

/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_MATCHLIST: /* len, FAIL, UNDECIDED ( W x -- x ) */
/*uh, 16.10.90*/  /* Prueft, ob das oberste Element des Work-Stacks X eine Liste mit der Stelligkeit */
/*uh, 16.10.90*/  /* LEN ist. */
/*uh, 16.10.90*/  /* Ist dies der Fall, so wird die Ausfuehrung mit der Instruktion forgesetzt, die */
/*uh, 16.10.90*/  /* unmittelbar auf MATCHLIST folgt. */
/*uh, 16.10.90*/  /* Sonst wird die Ausfuehrung an der Adresse FAIL fortgesetzt. */
/*uh, 16.10.90*/  /* Ist der Vergleich nicht entscheidbar, so wird die Ausfuehrung an der Adresse */
/*uh, 16.10.90*/  /* UNDECIDED fortgesetzt.  */
/*uh, 16.10.90*/                  FUNC3("matchlist");
/*uh, 16.10.90*/                  LEN = *code++;
/*uh, 16.10.90*/                  FAIL = *code++;
/*uh, 16.10.90*/                  UNDECIDED = *code++;
/*uh, 16.10.90*/                  ARGUMENT=TOP_W();
/*uh, 16.10.90*/                  if (T_POINTER(ARGUMENT)) {
/*uh, 16.10.90*/                    /* Argument ist Pointer ... */
/*uh, 16.10.90*/                    if (R_DESC(*(T_PTD)ARGUMENT,class)== C_LIST &&
                                        (R_DESC(*(T_PTD)ARGUMENT,type)== TY_UNDEF) &&
/*uh, 16.10.90*/                        R_LIST(*(T_PTD)ARGUMENT,dim) == LEN) goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                    /* ... aber keine Liste */
/*uh, 16.10.90*/                    ARGUMENT=R_DESC(*(T_PTD)ARGUMENT,class);
/*uh, 16.10.90*/                    if (IS_VAR_OR_CLOS_DESC(ARGUMENT)) {
                                       PUSH_T (KLAA);
/*uh, 16.10.90*/                       code = (int*)UNDECIDED;
/*uh, 16.10.90*/                       goto loop;
/*uh, 16.10.90*/                    }
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/                  code = (int*)FAIL;
/*uh, 16.10.90*/                  goto loop;

/*uh, 16.10.90*/  case I_MATCHSTR: /* matching auf strings, neu von rs */
/*uh, 16.10.90*/                  FUNC3("matchstr");
/*uh, 16.10.90*/                  LEN = *code++;
/*uh, 16.10.90*/                  FAIL = *code++;
/*uh, 16.10.90*/                  UNDECIDED = *code++;
/*uh, 16.10.90*/                  ARGUMENT=TOP_W();
/*uh, 16.10.90*/                  if (T_POINTER(ARGUMENT)) {
/*uh, 16.10.90*/                    /* Argument ist Pointer ... */
/*uh, 16.10.90*/                    if ((R_DESC(*(T_PTD)ARGUMENT,class)== C_LIST) &&
                                        (R_DESC(*(T_PTD)ARGUMENT,type)== TY_STRING) &&
/*uh, 16.10.90*/                        R_LIST(*(T_PTD)ARGUMENT,dim) == LEN) goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                    /* ... aber keine Liste */
/*uh, 16.10.90*/                    ARGUMENT=R_DESC(*(T_PTD)ARGUMENT,class);
/*uh, 16.10.90*/                    if (IS_VAR_OR_CLOS_DESC(ARGUMENT)) {
                                       PUSH_T (KLAA);
/*uh, 16.10.90*/                       code = (int*)UNDECIDED;
/*uh, 16.10.90*/                       goto loop;
/*uh, 16.10.90*/                    }
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/                  code = (int*)FAIL;
/*uh, 16.10.90*/                  goto loop;

/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_MKCASE:  {
/*uh, 16.10.90*/         FUNCX("mkcase");
/*uh, 16.10.90*/         /* Ein CASE-Konstrukt soll geschlossen werden. */
/*uh, 16.10.90*/         /* Dh. es soll ein Paket geschnuert werden, dass neben der */
/*uh, 16.10.90*/         /* Struktur des Ergebnisses auch die aktuellen Werte der */
/*uh, 16.10.90*/         /* relativ freien Variablen enthaelt. */
/*uh, 16.10.90*/
/*uh, 16.10.90*/         /* Zunaechst die Struktur des Ergebnisausdrucks aufbauen */
/*uh, 16.10.90*/
                         DBUG_PRINT ("INTER", ("MKCASE occured !"));

#if (D_SPEC && D_SLAVE)
                         /* MKCASE means a matching was undecided or failed completely */
                         /* in the speculative case (not the... case construct ;) */
                         /* this should not happen, lets configure it ! */

                         if (spec_failcase && (T_SPEC_PROCESS(curr_pid)==1)) {
                           DBUG_PRINT("INTER", ("this process is failed !"));
                           PC_SET_SPEC_FAIL(curr_pid);
                           PC_SET_SPEC_FOLD(curr_pid);
                           curr_pid->start_red_count = curr_pid->start_red_count - _redcnt;
                           _redcnt = 0;
                           }

/*                         if (spec_failcase)
                           post_mortem("MKCASE occured in spec dad process..."); */

#endif /* D_SPEC */

                                      ptdesc = (T_PTD)*code++;

/* fprintf(stderr, "****** MKCASE reached !!! :-(\n*\n*\n*\n*\n"); fflush(stderr); sleep(1); */

#if D_SLAVE
                                      DBUG_PRINT("INTER", ("D_SIZEOFSTACK(*ps_t): %d, T_KLAA(TOP_T()): %d", D_SIZEOFSTACK(*ps_t), T_KLAA(TOP_T())));
                                      if ((D_SIZEOFSTACK(*ps_t)>0)&& (T_KLAA(TOP_T()))) 
#else
                                      DBUG_PRINT("INTER", ("SIZEOFSTACK(S_tilde): %d", SIZEOFSTACK(S_tilde)));
                                      if ((SIZEOFSTACK(S_tilde)>0)&& (T_KLAA(TOP_T()))) 
#endif
                                        {
                                        PPOP_T();
                                        PUSH_W(KLAA);
                                        DBUG_PRINT("INTER", ("goto L_undecided1"));
                                        goto L_undecided; }
                                      else if (T_HASH(TOP_W())) {
                                        PPOP_W();
                                        DBUG_PRINT("INTER", ("goto L_undecided2"));
                                        goto L_undecided; }
                                      DBUG_PRINT("INTER", ("goto L_real_nomatch"));
                                      goto L_real_nomatch;
                                         
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_TGUARD:   /* FAIL UNDECIDED ( W: value -- ) */

/* das war hier einmal JBOOL, jetzt ist es TGUARD ! */   /* RS 1.3.1995 */
/* Argumente: fail-Label, Original-Switch-Deskriptor, Anzahl PM-bound-variables, Groesse W-Frame,  */
/* Groesse BT-Frame (auf R) zwecks Abraeumung, weil bei undecided direkt nach L_undecided (alter */
/* code) gesprungen wird und nicht etwa zum undecided Label (da wuerden die pm-gebundenen Variablen */
/* freigegeben werden also verloren...nix ruecktrans.! Moment, sollte der Kommentar nicht in */
/* englisch sein ? ;-) */
/* ok, Anzahl PM-bound-variables ist jetzt das letzte Argument wg. der Benutzung von (Interpreter-) lokalen */
/* Variablen...*/

/*uh, 16.10.90*/    /* "JumpBOOL" */
/*uh, 16.10.90*/    /* Testet den obersten Wert VALUE des Work-Stacks. Ist er TRUE, so wird  */
/*uh, 16.10.90*/    /* mit der Ausfuehrung an der Instruktion, die JBOOL unmittelbar folgt, forgefahren.*/
/*uh, 16.10.90*/    /* Ist VALUE FALSE, so wird zur Adresse FAIL gesprungen. */
/*uh, 16.10.90*/    /* Ist VALUE weder FALSE noch TRUE, so wird zur Adresse UNDECIDED gesprungen. */
/*uh, 16.10.90*/                  FUNC0("tguard(no args available)");
/*uh, 16.10.90*/                  FAIL = *code++;
/*uh, 16.10.90*/                  ptdesc = (T_PTD) *code++;
/*uh, 16.10.90*/                  arg = POP_W(); /* maybe here's some Problem for D_SLAVE left... */

#if  (D_SLAVE && D_SPEC)
/* fprintf(debugger, "TGUARD reached...!\n"); fflush(debugger); */
#endif

/*uh, 16.10.90*/                  if (IS_TRUE(arg)) { code+=4; 

#if  (D_SLAVE && D_SPEC)
/* fprintf(debugger, "TGUARD reached: arg is true.\n"); fflush(debugger); */
#endif

                                    goto loop;}
/*uh, 16.10.90*/                  if (IS_FALSE(arg)) {
                                     DBUG_PRINT("inter",("GUARD false..."));

#if  (D_SLAVE && D_SPEC)
/* fprintf(debugger, "TGUARD reached: arg is false.!\n"); fflush(debugger); */
#endif

/*uh, 16.10.90*/                     code = (int*)FAIL; }
/*uh, 16.10.90*/                  else {
#if (D_SLAVE && D_SPEC)

/* fprintf(debugger, "TGUARD reached: arg is neither true nor false.!\n"); fflush(debugger);  */

                                 DBUG_PRINT("INTER", ("Check whether it's an s_case: %d", *(int*)(code+3)));

                                 if (*(int*)(code+3)) {

/* fprintf(debugger, "TGUARD reached: speculative process !\n"); fflush(debugger);  */

                                   DBUG_PRINT("INTER", ("GUARD not true/false in a speculative process :-( !"));

                                   DBUG_PRINT("INTER", ("T_SPEC_NO_BSTEPS: %x, _spec_redcnt: %d", T_SPEC_NO_BSTEPS(curr_pid), _spec_redcnt));

                                   if ((_redcnt > 0) && !((T_SPEC_NO_BSTEPS(curr_pid)==1) && (_spec_redcnt==0))) {

/* fprintf(debugger, "TGUARD reached: _redcnt > 0 !\n"); fflush(debugger); */

                                     DBUG_PRINT("INTER", ("GUARD not true/false and still steps left !!!! => false"));
                                     code = (int*)FAIL;
                                     goto loop;
                                     }

                                   PC_SET_SPEC_GUARD(curr_pid);

                                   DBUG_PRINT("INTER", ("SPEC_GUARD set !"));

/* fprintf(debugger, "TGUARD reached: PC_SET_SPEC_GUARD \n"); fflush(debugger); */

                                   DBUG_PRINT("INTER", ("arg is %x, PC_GET_SPEC_SPAWNED is %d", arg, PC_GET_SPEC_SPAWNED(curr_pid)));

#if D_SPEC_TICKETS
                                   DBUG_PRINT("INTER", ("stored arg in son_status[0] (0x%x)", arg));
                                   curr_pid->son_status[0] = arg;
#else
                                   curr_pid->son_redcnts[PC_GET_SPEC_SPAWNED(curr_pid)] = arg; /* store GUARD expression */
#endif


/*                                   if (PC_GET_SPEC_SPAWNED(curr_pid)>0) { */

/* fprintf(debugger, "TGUARD reached: PC_GET_SPEC_SPAWNED(curr_pid)>0\n"); fflush(debugger); */

/*                                     DBUG_PRINT("INTER", ("%d sons already spawned, set TRUE for their guard-expressions !", PC_GET_SPEC_SPAWNED(curr_pid)));
                                     for (arity = 0; arity < PC_GET_SPEC_SPAWNED(curr_pid); arity++) {
                                       DBUG_PRINT("INTER", ("setting guard of clause %d to TRUE !", arity));
                                       curr_pid->son_redcnts[arity] = SA_TRUE;
                                       }  */
                                     /* } */
                                   code+=4;
                                   goto loop;
                                   }
#endif
                                    for (help=(int)(*code++); help>0; help--) {
#if D_SLAVE
                                      arity = POP_W(); if (isdesc(arity)) DEC_REFCNT((T_PTD)arity);
#else
/*uh, 16.10.90*/                      PPOP_W(); 
#endif
/*uh, 16.10.90*/                      }
                                    for (help=(int)(*code++); help>0; help--) {
#if D_SLAVE
                                      arity = POP_R(); if (isdesc(arity)) DEC_REFCNT((T_PTD)arity);
#else
/*uh, 16.10.90*/                      PPOP_R();
#endif
/*uh, 16.10.90*/                      }
                                     PUSH_R(SET_VALUE(DOLLAR,(int)(*code++)));
                                     PUSH_W(arg);
                                     goto L_undecided;
/*uh, 16.10.90*/                     /* code = (int*)UNDECIDED; */ }
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_STARTSUBL: /* level ( W: Startindex ListDesc -- Startindex ListDesc )  */
/*uh, 16.10.90*/    /* "STARTSUBList"  */
/*uh, 16.10.90*/    /* Schreibt den Listendescriptor LISTDESC und den aktuellen Matchpointer STARTINDEX */
/*uh, 16.10.90*/    /* in das Backtrack-Frame an der Stelle LEVEL. */
/*uh, 16.10.90*/                  FUNC1("startsublist");
/*uh, 16.10.90*/                  arg = *code++;
/*uh, 16.10.90*/                  help = TOP_W();
#if D_SLAVE
                                  ptdesc = MID_R(arg); if (isdesc(ptdesc)) DEC_REFCNT((T_PTD)ptdesc);
                                  if (isdesc(help)) INC_REFCNT((T_PTD)help);
#endif
/*uh, 16.10.90*/                  UPDATE_R(arg,help);
/*uh, 16.10.90*/                  arg = *code++;
/*uh, 16.10.90*/                  help = MID_W(1);
/*uh, 16.10.90*/                  UPDATE_R(arg,help);
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_ENDSUBL: /* level ( E: ptr x -- ptr x ) */
/*uh, 16.10.90*/  /* "ENDSUBList" */
/*uh, 16.10.90*/  /*  Traegt das Ende der gematchten Teilliste in das Backtrack-Frame an der Stelle   */
/*uh, 16.10.90*/  /*  LEVEL ein.  Dort ist dann die gesamte Information vorhanden, damit spaeter eine */
/*uh, 16.10.90*/  /*  Bindung an dieses Teilliste gemacht werden kann.  */
/*uh, 16.10.90*/                  FUNC1("endsublist");
/*uh, 16.10.90*/                  arg = *code++;
/*uh, 16.10.90*/                  help = MID_W(1);      /* Zeiger auf noch gematchtes Element */
/*uh, 16.10.90*/                  UPDATE_R(arg,help);
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_BINDSUBL: /*level bindlevel ( E: frames -- frames ) ( I: bindings -- bindings' ) */
/*uh, 16.10.90*/     /* Erzeugt fuer die Teilliste, die im Backtrackframe an der Stelle LEVEL eingetragen */
/*uh, 16.10.90*/     /* ist, einen Listendescriptor und schreibt ihn in das Frame auf dem Inkarnations- */
/*uh, 16.10.90*/     /* Stack an die Stelle BINDLEVEL. Dadurch wird die Variable */
/*uh, 16.10.90*/     /* mit dem Index BINDLEVEL an die gematchte Teilliste gebunden.  */
/*uh, 16.10.90*/                  FUNC2("bindsublist");
                                  ptdesc = *code++;
/*uh, 16.10.90*/                  ptdesc     = (T_PTD)MID_R((int)ptdesc);
                                  func = *code++;
/*uh, 16.10.90*/                  func  = (PTR_HEAPELEM)MID_R((int)func) - R_LIST(*ptdesc,ptdv); /* Start */
                                  DBUG_PRINT ("INTER", ("R_LIST(*ptdesc,ptdv) = %x", R_LIST(*ptdesc,ptdv)));
                                  help = *code++;
                                  help       = (int) MID_R(help);
                                  DBUG_PRINT ("INTER", ("(PTR_HEAPELEM)MID_R(help) = %x", help));
/*uh, 16.10.90*/                  help       = (PTR_HEAPELEM) help - R_LIST(*ptdesc,ptdv) - 1; /* ende */
                                  DBUG_PRINT ("INTER", ("limits are: func=%i (start), help=%i (end)", (int)func, (int) help));
/*uh, 16.10.90*/   /* printf("\n\nbindsubl: from=%d; to=%d\n",(int)func,help); */
/*uh, 16.10.90*/                  if (help < (int)func) {
/*uh, 16.10.90*/  /* printf("bindsubl: take nil"); */

DBUG_PRINT("INTER", ("BULLSHITTY-Warning !"));

                                     if (R_DESC(*ptdesc, type) == TY_STRING) {
                                       ptdesc = _nilstring;
/*uh, 16.10.90*/                       INC_REFCNT(_nilstring); }
                                     else {
/*uh, 16.10.90*/                       ptdesc = _nil;
/*uh, 16.10.90*/                       INC_REFCNT(_nil); }
/*uh, 16.10.90*/                  } else {
/*uh, 16.10.90*/                     ptdesc = (T_PTD)gen_ind((int)func,help,ptdesc);
/*uh, 16.10.90*/  /* printf("bindsubl: take sublist"); */
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/                  arg = *code++;
                                  DBUG_PRINT ("INTER", ("check: arg=%d", arg));
/*uh, 16.10.90*/                  UPDATE_A(arg,(STACKELEM)ptdesc);    /* no refcount handling successfull*/
/*uh, 16.10.90*/                  goto loop;

/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_INITBT: /* level ( E: frames -- ) ( W:  ptr listdesc -- ptr listdesc ) */
/*uh, 16.10.90*/     /* "INITBackTrackframe" */
/*uh, 16.10.90*/     /* Initialisiert das Backtrack-Stackframe der Tiefe LEVEL. */
/*uh, 16.10.90*/     /* PTR zeigt auf den Anfang der noch zu matchenden Teilliste und gibt so */
/*uh, 16.10.90*/     /* die Stelle an, an der der Backtrack das erste Mal wieder aufsetzten muss. */
/*uh, 16.10.90*/     /* LISTDESC ist der Listendescriptor der Liste, in der gerade gematcht wird.   */
/*uh, 16.10.90*/     /* RESTLEN gibt an, wieviele Listenelemente das nun folgende Pattern maximal  */
/*uh, 16.10.90*/     /* ueberdecken kann. Daraus wird das Ende der vom folgenden Pattern zu matchenden  */
/*uh, 16.10.90*/     /* Teilliste berechnet und in das Frame eingetragen. Die Grenzen fuer die   */
/*uh, 16.10.90*/     /* Aufsetzpunkte des Backtracks sind damit bestimmt. */
/*uh, 16.10.90*/                  FUNC3("initbt");
/*uh, 16.10.90*/                  help = *code++;  /* rest */
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  ptdesc = (T_PTD)MID_W(1);      /* Zeiger auf noch gematchtes Element */
/*uh, 16.10.90*/                  arg = *code++;  /* level1 */
/*uh, 16.10.90*/                  UPDATE_R(arg,ptdesc);   /* Start */
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  arg = *code++;  /* level2 */
/*uh, 16.10.90*/                  UPDATE_R(arg,ptdesc);     /* Ptr */
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  ptdesc = (T_PTD)TOP_W();
#if D_SLAVE
                                  if (isdesc(ptdesc)) INC_REFCNT((T_PTD)ptdesc);
#endif
/*uh, 16.10.90*/                  arg = *code++;  /* level3 */
#if D_SLAVE
                                  arity = MID_R(arg); if (isdesc(arity)) DEC_REFCNT((T_PTD)arity);
#endif
/*uh, 16.10.90*/                  UPDATE_R(arg,(STACKELEM)ptdesc);   /* Descriptor */
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  help = (int) ((PTR_HEAPELEM)R_LIST(*ptdesc,ptdv)
/*uh, 16.10.90*/                                +R_LIST(*ptdesc,dim)-help);
/*uh, 16.10.90*/                  arg = *code++;  /* level4 */
/*uh, 16.10.90*/                  UPDATE_R(arg,help);     /* End */
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_MATCHIN: /* indesc FAIL-addr UNDECIDED-addr ( W: x -- x ) */
/*uh, 16.10.90*/    /* Prueft, ob das oberste Element des Work-Stacks X unter den Elementen ist, */
/*uh, 16.10.90*/    /* die in der durch den Listendescriptor INDESC beschriebenen Liste sind.  */
/*uh, 16.10.90*/    /* Ist dies der Fall, so wird die Ausfuehrung mit der Instruktion forgesetzt, die */
/*uh, 16.10.90*/    /* unmittelbar auf MATCHIN folgt. */
/*uh, 16.10.90*/    /* Sonst wird die Ausfuehrung an der Adresse FAIL-Addr fortgesetzt. */
/*uh, 16.10.90*/    /* Ist der Vergleich nicht entscheidbar, so wird die Ausfuehrung an der Adresse */
/*uh, 16.10.90*/    /* UNDECIDED-Addr fortgesetzt.  */
/*uh, 16.10.90*/                  FUNC3("matchin");
/*uh, 16.10.90*/                  arg=*code++;  /* In Descriptor is Listendescriptor */
/*uh, 16.10.90*/                  FAIL = *code++;
/*uh, 16.10.90*/                  UNDECIDED= *code++;
/*uh, 16.10.90*/                  ARGUMENT=TOP_W();
/*uh, 16.10.90*/                  /* Test auf undecided durchfuehren */
/*uh, 16.10.90*/                  if (T_POINTER(ARGUMENT) &&
/*uh, 16.10.90*/                      ((R_DESC(*(T_PTD)ARGUMENT,type)==TY_EXPR) ||
/*uh, 16.10.90*/                       (R_DESC(*(T_PTD)ARGUMENT,type)==TY_NAME))) {
                                       PUSH_T (KLAA);
/*uh, 16.10.90*/                       code = (int*)UNDECIDED;
/*uh, 16.10.90*/                       goto loop;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/                  /* Ergebnis wird True oder False */
                                  if (T_LETTER(ARGUMENT)) {
/*uh, 16.10.90*/                  (PTR_HEAPELEM)ptdesc = R_LIST(*(T_PTD)arg,ptdv);
/*uh, 16.10.90*/                  for (LEN=R_LIST(*(T_PTD)arg,dim); LEN>0; LEN--) {
/*uh, 16.10.90*/                     if ((ARGUMENT&F_VALUE) == (*((PTR_HEAPELEM)ptdesc)++&F_VALUE)) goto loop;
/*uh, 16.10.90*/                  }  } 
/*uh, 16.10.90*/                  code=(int*)FAIL;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_ATEND: /* btlevel hit-label  ( E: frames -- frames ) (W: addr x -- addr x )*/
/*uh, 16.10.90*/    /* Prueft, ob der aktuelle Matchzeiger ADDR groesser ist als das  */
/*uh, 16.10.90*/    /* im FRAME der Tiefe LEVEL vermerkte Ende der Teilliste.   Ist dies der Fall, */
/*uh, 16.10.90*/    /*  so wird zur Adresse HIT-LABEL gesprungen. Ist dies nicht der Fall, so wird */
/*uh, 16.10.90*/    /* die Ausfuehrung mit dem Befehl fortgesetzt, der unmittelbar auf ATEND folgt. */
/*uh, 16.10.90*/                  FUNC2("atstart");
/*uh, 16.10.90*/                  arg=*code++;
/*uh, 16.10.90*/                  if (MID_R(arg)<MID_W(1)) { /* running pointer at start */
/*uh, 16.10.90*/                      code = (int*)*code;
/*uh, 16.10.90*/                      goto loop;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/                  code++;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_ATSTART: /* btlevel hit-label  ( E: frames -- frames ) (W: addr x -- addr x )*/
/*uh, 16.10.90*/   /*  Prueft, ob der aktuelle Matchzeiger ADDR kleiner ist als der */
/*uh, 16.10.90*/   /*  im FRAME der Tiefe LEVEL vermerkte Start der Teilliste.  Ist dies der Fall, */
/*uh, 16.10.90*/   /*  so wird zur Adresse HIT-LABEL gesprungen. Ist dies nicht der Fall, so wird */
/*uh, 16.10.90*/   /*  die Ausfuehrung mit dem Befehl fortgesetzt, der unmittelbar auf ATSTART folgt. */
/*uh, 16.10.90*/                  FUNC2("atstart");
/*uh, 16.10.90*/                  arg=*code++;
/*uh, 16.10.90*/                  if (MID_R(arg)>MID_W(1)) { /* running pointer at start */
                             /*     help = (int) (((PTR_HEAPELEM)MID_R(arg)) + 1); */
/*uh, 16.10.90*/             /*     UPDATE_R(arg,help);       */
/*uh, 16.10.90*/                      code = (int*)*code;
/*uh, 16.10.90*/                      goto loop;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/                  code++;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_FETCH:  /* ( W: heapptr -- val ) */
/*uh, 16.10.90*/   /* Ersetzt den auf dem Work-Stack stehenden Zeiger in den Heap (HEAPPTR) durch  */
/*uh, 16.10.90*/   /* den Wert, der an dieser Stelle im Heap steht.  */
/*uh, 16.10.90*/                  FUNC1("fetch");
/*uh, 16.10.90*/                  arg = TOP_W();
/*uh, 16.10.90*/                  help = (int)*(PTR_HEAPELEM)arg;  /* Zugriff */
/*uh, 16.10.90*/                  if ( (T_PTD)help && T_POINTER(help)) INC_REFCNT((T_PTD)help);
#if D_SLAVE
                                  if (isdesc(arg)) DEC_REFCNT((T_PTD)arg);
#endif
/*uh, 16.10.90*/                  WRITE_W(help);
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/  case I_DESC:  /* desc  */
/*uh, 16.10.90*/  /* ueberliest den folgenden Descriptor */
/*uh, 16.10.90*/                  FUNC1("desc");
/*uh, 16.10.90*/                  code++;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/  /* VVVVVVVVVVVVVVVVVVVVVVVVVVVVV alter Code VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV */
/*uh, 16.10.90*/
#endif /* UH_ZF_PM       auskommentiert RS 4.12.1992 */


/******************************************/
/* Die neuen Befehle fuer den Tilde-Stack */
/******************************************/

/* In der 4-stackversion (W A R T) wird vor dem Aufruf einer Funktion der */
/* neue Argumentframe auf dem aktuellen Workspacestack ( W ) aufgebaut    */
/* Analog dazu wird der neue Tildeframe auf dem aktuellen R-stack         */
/* aufgebaut. Mit dem Sprung in die neue Funktion werden dann die Stacks  */
/* W und A sowie T und R ge'switched'                                     */
/* Das Ergebnis einer Funktion liegt vor dem Ruecksprung oben auf dem     */
/* A-Stack.                                                               */

#if WITHTILDE

     case I_PUSH_R:  /* === PUSH_R p : push pointer onto stack r */
		     FUNCX("push_r");
                     INC_REFCNT((T_PTD)(*code));
                     PUSH_R(*code++);
                     goto loop;
    case I_PUSHC_R:  /* === PUSHC_R c : push constant onto stack r */
		     FUNCN("pushc_r");
                     PUSH_R(*code++);
                     goto loop;
    case I_PUSH_TW:  /* === PUSH_TW n : 
			push T-stackentry n onto the w stack === */
                     FUNC1("push_tw");
                     ptdesc = (T_PTD)MID_T(*code);
		     code++;
                     T_INC_REFCNT(ptdesc);
                     PUSH_W(ptdesc);
                     goto loop;
    case I_PUSH_TW0: /* === PUSH_TW0 :
			push T-stackentry 0 onto the a (Workspace) stack === */
                     FUNC0("push_tw0");
                     ptdesc = (T_PTD)TOP_T();
                     T_INC_REFCNT(ptdesc);
                     PUSH_W(ptdesc);
                     goto loop;
    case I_PUSH_TR:  /* === PUSH_TR n : 
			push T-stackentry n onto the r (Return) stack === */
                     FUNC1("push_tr");
                     ptdesc = (T_PTD)MID_T(*code);
		     code++;
                     T_INC_REFCNT(ptdesc);
                     PUSH_R(ptdesc);
                     goto loop;
    case I_PUSH_TR0: /* === PUSH_TR0 :
			push T-stackentry 0 onto the r (Return) stack === */
                     FUNC0("push_tr0");
                     ptdesc = (T_PTD)TOP_T();
                     T_INC_REFCNT(ptdesc);
                     PUSH_R(ptdesc);
                     goto loop;
    case I_PUSH_AR:  /* === PUSH_AR n : 
			push A-stackentry n onto the r (Return) stack === */
                     FUNC1("push_ar");
                     ptdesc = (T_PTD)MID_A(*code);
		     code++;
                     T_INC_REFCNT(ptdesc);
                     PUSH_R(ptdesc);
                     goto loop;
    case I_PUSH_AR0: /* === PUSH_AR0 :
			push A-stackentry 0 onto the r (Return) stack === */
                     FUNC0("push_ar0");
                     ptdesc = (T_PTD)TOP_A();
                     T_INC_REFCNT(ptdesc);
                     PUSH_R(ptdesc);
                     goto loop;

    /* push_aw wird als pusharg weiter oben behandelt */

    case I_MOVE_TW:  /* === MOVE_TW i : move one item from T to W === */
                     FUNC0("move_tw");
                     PUSH_W(POP_T());
                     goto loop;
    case I_MOVE_TR:  /* === MOVE_TR i : move one item from T to R === */
                     FUNC0("move_tr");
                     PUSH_R(POP_T());
                     goto loop;
    case I_MOVE_AR:  /* === MOVE_AR i : move one item from A to R === */
                     FUNC0("move_ar");
                     PUSH_R(POP_A());
                     goto loop;
    case I_MOVE_WR:  /* === MOVE_WR i : move one item from W to R === */
		     FUNC0("move_wr");
		     PUSH_R(POP_W());
		     goto loop;

    /* move_aw wird als move weiter oben behandelt */

    case I_FREE_R:     /* === FREE_R n : free an n-size tilde frame === */
                     FUNC1("free_r");
                     arg = *code++;
                     /* arg: anzahl der von r freizugebenden argumente (>0!) */
                     do {
                       ptdesc = (T_PTD)POP_R();
                       T_DEC_REFCNT(ptdesc);
                     } while (--arg > 0);
                     goto loop;
    case I_FREE1_R:  /* === FREE1_R : free one argument === */
                     FUNC0("free1_r");
                     ptdesc = (T_PTD)POP_R();
                     T_DEC_REFCNT(ptdesc);
                     goto loop;
    case I_RTM_T:    /* === RTM_T : move conditionally from a to i and return ===  */
                     /* mah 171193 nicht mehr conditionally, da kein tail_t-flag   */
                     FUNC0("rtm_t");
		     PUSH_W(POP_T());
                     code = POP_RET();             /* returnadresse */
		     SWITCHSTACKS_T();
                     goto loop;
    case I_RTT:    /* === RTT : return function value === */
                     FUNC0("rtt");
		     /* Tail-end-rekursionen beim Tildestack werden nicht optimiert */
		     /* Das Ergebnis muss nicht gemoved werden                      */
                     code = POP_RET();             /* returnadresse */
		     SWITCHSTACKS_T();
                     goto loop;
    case I_RTC_T:    /* === RTC_T c : return constant === */
                     FUNCN("rtc_t");
                     ptdesc = (T_PTD)*code;
		     SWITCHSTACKS_T();
                     PUSH_W(ptdesc);
                     code = POP_RET();             /* returnadresse */
                     goto loop;
    case I_FREESW_T: /* === FREESW_T n : pop n element off stack t and switch t,r === */
		     /* used only following a GAMMABETA or GAMMACASE instruction      */
		     FUNC1("freesw_t");
                     arg = *code++;
                     /* arg: anzahl der von t freizugebenden argumente (>0!) */
                     do {
                       ptdesc = (T_PTD)POP_T();
                       T_DEC_REFCNT(ptdesc);
                     } while (--arg > 0);
		     SWITCHSTACKS_T();
                     goto loop;
    case I_FREE1SW_T:/* === FREE1SW_T : pop one element off stack t and switch t,r === */
		     /* used only following a GAMMABETA or GAMMACASE instruction      */
		     FUNC0("free1sw_t");
		     ptdesc = (T_PTD)POP_T();
                     T_DEC_REFCNT(ptdesc);
		     SWITCHSTACKS_T();
                     goto loop;
    case I_GAMMA:    /* === GAMMA f : perform n-ary function call using tilde-stack === */
                     FUNCL("gamma");
                     ptdesc = (T_PTD)*code++;
                     /* ptdesc: funktion (zeiger auf descriptor/code) */
                       SWITCHSTACKS_T();
                       PUSH_R(code);                 /* return address    */
                       code = (INSTR *)ptdesc;       /* subroutine call   */
                       goto loop;
                     /* descriptor holen */
                   L_gammafail:
                     GRAB_DESC(ptdesc);              /* descriptor holen */
                     INC_REFCNT(ptdesc);             /* prepare for push */
                     PUSH_R(ptdesc);                 /* push function    */
                     arg = R_COMB(*ptdesc,nargs);    /* args needed      */
		     nfv = R_COMB(*ptdesc,args);     /* free variables   */
                     if ((arg == 0) && (nfv == 0))
		       goto loop;                    /* keine closure    */
                     arity = arg;                    /* number of args   */
		     gamma_closure = 2;              /* function on R    */
		     COMM0("mkgaclos"); 
                     goto L_mkbclos;
    case I_GAMMABETA:/* GAMMABETA f :
			perform n-ary function call using tilde and workspace stack */
		     FUNCL("gammabeta");

		     ptdesc = (T_PTD)*code++;
		     if (_redcnt >= beta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= beta_count)) {
#endif /* D_SPEC */
                       _redcnt -= beta_count;        /* count reduction   */
#if (D_SPEC && D_SLAVE)
                       _spec_redcnt -= beta_count;
#endif /* D_SPEC */
                       SWITCHSTACKS_T();
		       SWITCHSTACKS();
                       PUSH_R(code);                 /* return address    */
                       code = (INSTR *)ptdesc;       /* subroutine call   */
                       goto loop;
                     }
#if (D_SPEC && D_SLAVE)
                       else SPEC_CODE_1(2,"GAMMABETA")
                     }
                       else SPEC_CODE_2(2,"GAMMABETA")
#endif /* D_SPEC */

		     goto L_gammafail;


    case I_GAMMACASE:/* GAMMACASE c :
			execute closed case */
		     FUNCL("gammacase");

		     ptdesc = (T_PTD)*code++;
		     if (_redcnt >= delta_count) {
#if (D_SPEC && D_SLAVE)
                     if ((T_SPEC_FOLD(curr_pid)==1) || !T_SPEC_PROCESS(curr_pid) ||
                         (_spec_redcnt >= delta_count)) {
#endif /* D_SPEC */
		       _redcnt -= delta_count;
#if (D_SPEC && D_SLAVE)
                         _spec_redcnt -= delta_count;
#endif /* D_SPEC */
		       SWITCHSTACKS_T();
		       PUSH_R(code);
		       SET_TAIL_FLAG();
		       code = (INSTR *)ptdesc;       /* subroutine call   */
		       goto loop;
		     }
#if (D_SPEC && D_SLAVE)
                       else SPEC_CODE_1(2,"GAMMACASE")
                     }
                       else SPEC_CODE_2(2,"GAMMACASE")
#endif /* D_SPEC */

		     /* case schliessen */
#if UH_ZF_PM
         /*           post_mortem ("UH_PM: no _redcounting yet !"); it should be possible by now ! */
#endif /* UH_ZF_PM */
#if 1
		     gamma_closure = 2;
		     goto L_casefail;
#else
                     GRAB_DESC(ptdesc);         /* descriptor holen */
                     func = TY_CASE;
                     COMM0("nomatch");
                     goto L_nomatch;
#endif /* 1 */
    case I_MKGACLOS: /* === MKGACLOS n m : make gamma-closure === */
                     FUNC3("mkgaclos");
                     arity = *code++;       /* vorhandene argumente */
                     arg   = *code++;       /* benoetigte argumente */
		     nfv   = *code++;       /* relativ freie Variablen */
		     gamma_closure = 1;     /* hole Funktionszeiger von R statt von W */
                     func = TY_COMB;        /* COMB-flag  */
                     goto L_mkclos;
    case I_MKGSCLOS: /* === MKGSCLOS n m : make gammaswitch-closure === */
                     FUNC3("mkgsclos");
                     arity = *code++;       /* vorhandene argumente */
                     arg   = *code++;       /* benoetigte argumente */
		     nfv   = *code++;       /* relativ freie Variablen */
		     gamma_closure = 1;     /* hole Funktionszeiger von R statt von W */
                     func = TY_CASE;        /* CASE-flag  */
                     goto L_mkclos;
    case I_POPFREE_T: /* === POPFREE_T :
			 pop argument n off stack r to free n elements from stack t */
		     FUNC0("popfree_t");
                     {
		       int tofree;
		       
		       tofree = POP_R(); /* number of args to pop from t */
		       while (tofree>0) {
			 ptdesc = (T_PTD)POP_T();
			 T_DEC_REFCNT(ptdesc);
			 tofree--;
		       }
		     }
		     goto loop;
    case I_PUSHRET_T:/* === PUSHRET_T r : push return address and switch t,r === */
                     FUNCL("pushret_t");
		     SWITCHSTACKS_T();
                     PUSH_R(*code++);
                     SET_TAIL_FLAG();
                     goto loop;
/* mah 171193: in der 4stackversion koennen keine gamma-tail-end-rekursionen */
/*             optimiert werden, da moeglicherweise die Return-adresse, die  */
/*             die Tail-bits enthielte, zugedeckt waere von einem neuen      */
/*             Tilde-frame. Also entfallen alle JTAIL-instruktionen          */

#endif /* WITHTILDE */

    default:         sprintf(buf,"inter: invalid instruction (%d), %d %d %d %d",code[-1], lastcommand1, lastcommand2, lastcommand3, lastcommand4);
                     POST_MORTEM(buf);
  } /* end switch */

#if    DEBUG
/* if (TraceFp) fclose(TraceFp); */
/* TraceFp = Null; */

#if !D_SLAVE

  strcpy(S_e.Name,     "e");  stackname_dr(&S_e);
  strcpy(S_a.Name,     "a");  stackname_dr(&S_a);
  strcpy(S_m1.Name,    "m1"); stackname_dr(&S_m1);
  strcpy(S_m.Name,     "m");  stackname_dr(&S_m);
#if WITHTILDE
  strcpy(S_tilde.Name, "tilde"); stackname_dr(&S_tilde); /* mah 251093 */
#endif

#endif /* !D_SLAVE */
#endif /* DEBUG    auskommentiert RS 4.12.1992 */
  /* terminieren */
  END_MODUL("inter");
#if D_SLAVE
#if (D_SLAVE && D_MESS && D_MCOMMU)
  (*d_m_msg_send)(host,MT_END_RESULT);
#else
  msg_send(host,MT_END_RESULT);
#endif

#if D_MESS
  fflush(d_mess_dat);
#endif

  DBUG_RETURN (IR_EXT);
#else
  DBUG_VOID_RETURN;
#endif
/* code fuer I_APPLY aus dem case rausgenommen, weil zu lang 27.02.91 */

L_apply:

  /* stack w: | .. arg_arity .. arg_1 func */
  /* arity: anzahl der argumente auf'm stack (>0!!!) */
  ptdesc = (T_PTD)TOP_W();

  DBUG_PRINT ("INTER", ("TOP_W descriptor: %x", (int) ptdesc));
  DBUG_PRINT ("INTER", ("TOP_A descriptor: %x", (int) TOP_A()));

  /* ptdesc: (pointer auf) die funktion oben auf w */
  if (T_POINTER((int)ptdesc) && R_DESC(*ptdesc,class) == C_FUNC) {
    /* funktionsdescriptor (COMB,CASE,CLOS,CONDI) auf w */

    DBUG_PRINT ("INTER", (" funktionsdescriptor (COMB,CASE,CLOS,CONDI) auf w"));

    arg = R_UNIV(*ptdesc,nargs);
#if WITHTILDE
    nfv = (R_DESC(*ptdesc,type) == TY_CLOS) ? R_CLOS(*ptdesc,nfv) : R_UNIV(*ptdesc,args);
#endif /* WITHTILDE */
    /* arg: anzahl der benoetigten argumente    */
    /* nfv: anzahl der relativ freien Variablen */
    if (arity == arg) {
      
      DBUG_PRINT ("INTER", (" passend viele argumente (>0!) "));

      /* passend viele argumente (>0!) */
      if (R_DESC(*ptdesc,type) == TY_COMB) {

        DBUG_PRINT ("INTER", ("(R_DESC(*ptdesc,type) == TY_COMB)"));

        PPOP_W();                 /* funktion weg von w */
        DEC_REFCNT(ptdesc);       /* wird nicht frei! */
        ptdesc = (T_PTD)R_COMB(*ptdesc,ptc); /* pc holen */
        COMM0("beta");

#if D_SLAVE
/*fprintf(debugger, "%x: ** jumping to beta (L_apply), redcnt: %d\n", curr_pid, _redcnt); fflush(debugger);*/
#endif

        goto L_beta;
      } /* end TY_COMB */
      else
      if (R_DESC(*ptdesc,type) == TY_CASE) {

        DBUG_PRINT ("INTER", ("(R_DESC(*ptdesc,type) == TY_CASE)"));
        PPOP_W();                 /* case weg von w */
        DEC_REFCNT(ptdesc);       /* wird nicht frei! */
        ptdesc = (T_PTD)R_CASE(*ptdesc,ptc); /* pc holen */
        COMM0("case");
        goto L_case;
      }
      else
      if (R_DESC(*ptdesc,type) == TY_CLOS) {

        DBUG_PRINT ("INTER", ("(R_DESC(*ptdesc,type) == TY_CLOS)"));

        PPOP_W();                 /* closure weg von w */
        /* ptdesc: zeiger auf die closure (weg von w) */
        /* arity: anzahl der argumente auf'm stack (>0!) */
        arg = R_CLOS(*ptdesc,args);
#if WITHTILDE
	nfv = R_CLOS(*ptdesc,nfv);
#if 0
	PUSH_R(nfv); /* fuer popfree_t */
#endif
#endif /* WITHTILDE */

        /* arg: anzahl der argumente der closure (>0!) */
	/*      bei WITHTILDE >=0                      */
	/* nfv: anzahl der relativ freien variablen der closure (>=0) */

        if (R_CLOS(*ptdesc,ftype) == TY_COMB) {
          /* geschlossener combinator, einlagern */
          register PTR_HEAPELEM pth;

          DBUG_PRINT ("INTER", ("(R_CLOS(*ptdesc,ftype) == TY_COMB)"));

          COMM0("beta clos");
          RES_HEAP;
#if WITHTILDE
	  pth = R_CLOS(*ptdesc,pta) + arg + nfv;
#else
          pth = R_CLOS(*ptdesc,pta) + arg;
#endif /* WITHTILDE */
          help = (int)ptdesc;              /* closure */

#if WITHTILDE
	  {
	    int dummy = nfv;

	    while (dummy-- > 0) { /* tilde frame */
	      ptdesc = (T_PTD)*pth--;
	      T_INC_REFCNT(ptdesc);
	      PUSH_T(ptdesc);
	    }
	  }
	  while (arg-- > 0) { /* argument frame */
	    ptdesc = (T_PTD)*pth--;
	    T_INC_REFCNT(ptdesc);
	    PUSH_W(ptdesc);
	  }	    
#else
          do {
            ptdesc = (T_PTD)*pth--;
            T_INC_REFCNT(ptdesc);
            PUSH_W(ptdesc);
          } while (--arg > 0);
#endif /* WITHTILDE */

          ptdesc = (T_PTD)*pth;              /* funktion */ 
          REL_HEAP;

          DBUG_PRINT ("INTER", ("refcnt: %d", (((T_PTD)help)->u.sc.ref_count)));

          DEC_REFCNT((T_PTD)help);         /* closure */ 

          DBUG_PRINT ("INTER", ("refcnt: %d", (((T_PTD)help)->u.sc.ref_count)));

          COMB_CODE(ptdesc);      /* zeiger auf code holen */
#if WITHTILDE
	  if (nfv > 0) {
	    PUSH_R(code);
	    PUSH_R(nfv);        /* fuer popfree_t */
	    code = rout_popft;
	  }
#endif /* WITHTILDE */

          COMM0("beta");

#if D_SLAVE
/*fprintf(debugger, "%x: ** jumping to beta (L_apply2), redcnt: %d\n", curr_pid, _redcnt); fflush(debugger);*/
#endif

          goto L_beta;
        }
        else
        if (R_CLOS(*ptdesc,ftype) == TY_PRIM) {
          /* geschlossene primitive funktion, einlagern */
          register PTR_HEAPELEM pth;

          DBUG_PRINT ("INTER", ("geschlossene primitive funktion, einlagern "));

          COMM0("primf clos");
          RES_HEAP;
          /* arg: anzahl der argumente der closure (>0!) */
	  /* mah 291293:                                 */
	  /* delta closures tragen keine tildevariablen! */
	  /* also kein popfree_t noetig                  */
          pth = R_CLOS(*ptdesc,pta) + arg;
          help = (int)ptdesc;              /* closure */
          do {
            ptdesc = (T_PTD)*pth--;
            T_INC_REFCNT(ptdesc);
            PUSH_W(ptdesc);
          } while (--arg > 0);
          func = (int)*pth;                  /* primfunc */
          REL_HEAP;
          DEC_REFCNT((T_PTD)help);         /* closure */ 
          arg = FUNC_ARITY(func);
          COMM0("delta");

#if D_SLAVE
/*fprintf(debugger, "%x: ** jumping to delta, redcnt: %d\n", curr_pid, _redcnt); fflush(debugger);*/
#endif

          if (func == LSELECT) goto L_lsel;
          if (arg == 2) goto L_delta2;
          if (arg == 1) goto L_delta1;
          if (arg == 3) goto L_delta3;
          if (arg == 4) goto L_delta4;
          POST_MORTEM("inter: pf_arity out of range (apply)");
        }
        else
        if (R_CLOS(*ptdesc,ftype) == TY_INTACT) {
          /* geschlossene Interaktion, einlagern    stt 11.09.95 */
          register PTR_HEAPELEM pth;

          DBUG_PRINT ("INTER", ("geschlossene Interaktion, einlagern "));

          COMM0("intact clos");
          RES_HEAP;
          /* arg: anzahl der argumente der closure (>0!) */
          pth = R_CLOS(*ptdesc,pta) + arg;
          help = (int)ptdesc;              /* closure */
          do {
            ptdesc = (T_PTD)*pth--;
            T_INC_REFCNT(ptdesc);
            PUSH_W(ptdesc);
          } while (--arg > 0);
          func = (int)*pth;                  /* interaction */
          REL_HEAP;
          DEC_REFCNT((T_PTD)help);         /* closure */
          COMM0("intact");
          goto L_intact;
        }
        else
        if (R_CLOS(*ptdesc,ftype) == TY_CONDI) {

          DBUG_PRINT ("INTER", ("geschlossenes conditional"));

          /* geschlossenes conditional */
          /* ptdesc: zeiger auf die closure */
          /* arity: anzahl der argumente auf'm stack */
          /* arg: anzahl der argumente der closure */
          /* vorsicht, hier wird arity=1 unterstellt !! */
          COMM0("cond clos");
          help = POP_W();                 /* praedikat */
          if (T_BOOLEAN(help)) {
            /* conditional ausfuehrbar, argumente einlagern */
            register PTR_HEAPELEM pth;

            DBUG_PRINT ("INTER", ("conditional ausfuehrbar, argumente einlagern"));

            arity = (int)ptdesc;           /* closure   */
            RES_HEAP;
#if WITHTILDE
	    pth = R_CLOS(*ptdesc,pta) + arg + nfv;
	    {
	      int dummy=nfv;

	      while (dummy > 0) { /* tilde frame */
		ptdesc = (T_PTD)*pth--;
		T_INC_REFCNT(ptdesc);
		PUSH_T(ptdesc);
		dummy--;
	      }
	    }
	    while (arg > 0) { /* argument frame */
	      ptdesc = (T_PTD)*pth--;
              T_INC_REFCNT(ptdesc);
              PUSH_A(ptdesc);
	      arg--;
	    }
#else
            pth = R_CLOS(*ptdesc,pta) + arg;
            do {
              ptdesc = (T_PTD)*pth--;
              T_INC_REFCNT(ptdesc);
              PUSH_A(ptdesc);
            } while (--arg > 0);
#endif /* WITHTILDE */
            ptdesc = (T_PTD)*pth;       /* conditional       */
            REL_HEAP;
            PUSH_W(help);             /* praedikat */
            DEC_REFCNT((T_PTD)arity); /* closure freigeben */
            PUSH_R(code);             /* returnadresse     */
#if !WITHTILDE
            SET_TAIL_FLAG();          /* SWITCH vermeiden  */
#endif /* !WITHTILDE */
#if WITHTILDE
	    if (nfv > 0) {
	      PUSH_R(nfv);        
	      PUSH_R(rout_popft);       /* POPFREE_T */
	    }
	    SET_TAIL_FLAG();          /* SWITCH vermeiden  */
#endif /* WITHTILDE */
            code = R_CONDI(*ptdesc,ptc);
            goto loop;
          }
          else {

            DBUG_PRINT ("INTER", ("conditional nicht ausfuehrbar, schliessen"));

            /* conditional nicht ausfuehrbar, schliessen */
            /* ptdesc: zeiger auf die closure (weg von a) */
            /* arg: anzahl der argumente der closure */
            /* help: praedikat (liegt nicht mehr auf w) */
            if (R_DESC(*ptdesc,ref_count) == 1) {

              DBUG_PRINT ("INTER", ("closure mit refcnt 1 wird erweitert"));

              /* closure mit refcnt 1 wird erweitert */
              COMM0("expand clos");
              L_CLOS(*ptdesc,nargs) = 0;
              L_CLOS(*ptdesc,args)  = ++arg;
              RES_HEAP;
#if WITHTILDE
	      L_CLOS(*ptdesc,pta)[arg + nfv] = help; /* besser ganz hinten an */
#else
              L_CLOS(*ptdesc,pta)[arg] = help; /* pred */
#endif /* WITHTILDE */
              REL_HEAP;
              PPUSH_W(ptdesc);             /* closure */
              goto loop;
            }
            else {

              DBUG_PRINT ("INTER", ("neue, erweiterte closure bilden"));

              /* neue, erweiterte closure bilden */
              /* ptdesc: zeiger auf die closure (weg von w) */
              /* arg: anzahl der argumente der closure */
              /* help: praedikat (weg von a) */
              COMM0("new expanded clos");
              func = (int)ptdesc;
              MAKEDESC(ptdesc,1,C_FUNC,TY_CLOS);
#if 1
	      /* bug fix: mah 050193                                     */
              /* dies ist ein zusaetzliches argument zu den vorhandenen  */
	      /* nicht zu irgendwas (args ist nicht vorinitialisiert)    */
	      L_CLOS(*ptdesc,args) = R_CLOS(*((T_PTD)func),args) + 1;
#else
              L_CLOS(*ptdesc,args) += 1;   /* zusaetzliches argument  */
#endif /* 1 */

#if WITHTILDE
	      L_CLOS(*ptdesc,nfv)   = nfv; /* relativ freie variablen */
#endif /* WITHTILDE */
              L_CLOS(*ptdesc,nargs) = 0;   /* braucht keine args mehr */
              L_CLOS(*ptdesc,ftype) = TY_CONDI;
#if (D_SLAVE && D_MESS && D_MHEAP)
#if WITHTILDE
              /* auch relativ freie variablen brauchen platz zum leben */
              if ((*d_m_newheap)(arg+2+nfv,A_CLOS(*ptdesc,pta))) {
                int lauf; /* zaehler fuer die kopierschleife */
#else
              if ((*d_m_newheap)(arg+2,A_CLOS(*ptdesc,pta))) {
#endif /* WITHTILDE */
#else
#if WITHTILDE
	      /* auch relativ freie variablen brauchen platz zum leben */
	      if (newheap(arg+2+nfv,A_CLOS(*ptdesc,pta))) {
		int lauf; /* zaehler fuer die kopierschleife */
#else
              if (newheap(arg+2,A_CLOS(*ptdesc,pta))) {
#endif /* WITHTILDE */
#endif
                register PTR_HEAPELEM p1,p2;
                RES_HEAP;
                p1 = (PTR_HEAPELEM)R_CLOS(*(T_PTD)func,pta);
                p2 = (PTR_HEAPELEM)R_CLOS(*ptdesc,pta);
#if WITHTILDE
		for (lauf = arg+nfv; lauf >= 0; lauf--) {
#else
                for ( ; arg-- >= 0 ; ) {
#endif /* WITHTILDE */
                  T_INC_REFCNT((T_PTD)*p1);
                  *p2++ = *p1++;
                }
                *p2 = (T_HEAPELEM)help;  /* praedikat */
                REL_HEAP;
                DEC_REFCNT((T_PTD)func); /* alte clos */
                PPUSH_W(ptdesc);         /* closure   */
                goto loop;
              }
              /* descriptor freigeben? */
              POST_MORTEM("inter: heap overflow (mkclos)");
            }
          } /* end else */
        } /* end TY_CONDI */
        else
        if (R_CLOS(*ptdesc,ftype) == TY_CASE) {
          /* geschlossenes case */
          /* ptdesc: zeiger auf die closure */
          /* arity: anzahl der argumente auf'm stack  */
          /* arg: anzahl der argumente der closure    */
	  /* nfv: anzahl der relativ freien variablen */
          /* vorsicht, hier wird arity=1 unterstellt !! */
          /* DAS IST NICHT GUT wg. NCASE !!! */
          register PTR_HEAPELEM pth;

          DBUG_PRINT ("INTER", ("geschlossenes case"));

          func = (int)ptdesc;       /* closure   */
          PUSH_R(code);             /* next instruction */
/* dg 09.09.92 ---- rumgemacht bis */
          /* argumente einlagern */
          RES_HEAP;
          pth = R_CLOS(*ptdesc,pta);  /* pth: --> f a_1 ... a_arg */
          /* anzahl der freien variablen ermitteln */
          ptdesc = *(T_PTD *)pth;     /* CASE */
#if WITHTILDE
/* #if UH_ZF_PM */
      /*    arity = R_CASE(*ptdesc,nargs) - R_SWITCH(*(T_PTD)R_CLAUSE(*(T_PTD)R_SELECTION(*R_CASE(*ptdesc,ptd),clauses),sons)[3],anz_args); */
/* #else */
          arity = R_CASE(*ptdesc,nargs) - R_SWITCH(*R_CASE(*ptdesc,ptd),anz_args);
/* #endif */ /* UH_ZF_PM */
#else
          arity = R_CASE(*ptdesc,nargs) - R_SWITCH(*R_CASE(*ptdesc,ptd),case_type);
#endif /* WITHTILDE */
          /* anzahl der durch SRET freizugebenden argumente nach case auf e pushen */
#if WITHTILDE
	  pth += arg + nfv;

	  {
	    int dummy=nfv;

	    while (dummy > 0) { /* tilde frame */
	      ptdesc = (T_PTD)*pth--;
	      T_INC_REFCNT(ptdesc);
	      PUSH_T(ptdesc);
	      dummy--;
	    }
	  }
	  while (arg > 0) { /* argument frame */
	    ptdesc = (T_PTD)*pth--;
	    T_INC_REFCNT(ptdesc);
	    PUSH_W(ptdesc);
	    arg--;
	  }
	  arity = 0;

	  if (nfv > 0) {
	    PUSH_R(nfv);
	    PUSH_R(rout_popft);
	  }
#else
          PUSH_E(arity);
          /* substitute fuer freie variablen auf a */
          for (pth += arg ; --arity >= 0 ; arg--) {
            ptdesc = (T_PTD)*pth--;
            T_INC_REFCNT(ptdesc);
            PUSH_A(ptdesc);
          }
          /* und nun argument(e) auf w */
          for ( ; --arg >= 0 ; ) {
            ptdesc = (T_PTD)*pth--;
            T_INC_REFCNT(ptdesc);
            PUSH_W(ptdesc);
          }
#endif /* WITHTILDE */
/* dg 09.09.92 --- her */
          ptdesc = (T_PTD)*pth;       /* case */
          REL_HEAP;
          DEC_REFCNT((T_PTD)func);    /* closure freigeben */
#if !WITHTILDE
          PUSH_R(rout_sret);          /* special return */
#endif /* !WITHTILDE */
          SET_TAIL_FLAG();            /* SWITCH vermeiden  */
          code = R_CASE(*ptdesc,ptc);
          goto loop;
        }
        else {
          sprintf(buf,"inter (apply): invalid CLOS ftype (%d)",R_CLOS(*ptdesc,ftype));
          POST_MORTEM(buf);
        }
      } /* end TY_CLOS */
      else
      if (R_DESC(*ptdesc,type) == TY_CONDI) {

        DBUG_PRINT ("INTER", ("(R_DESC(*ptdesc,type) == TY_CONDI)"));

        /* stack a | .. pred arg_arity-1 .. arg_1 ptcond */
        /* ptdesc: zeiger auf's conditional (auf w) */
        /* arity: anzahl der argumente auf'm stack (>0!) */
        /* arg: anzahl der benoetigten argumente (=arity) */
        COMM0("cond");

        help = MID_W(arg);           /* praedikat  */
        if (T_BOOLEAN(help)) {
          /* argumente auf a schaufeln */
          for (; --arg > 0 ;)
            PUSH_A(MID_W(arg));
          PPOP_W();                  /* conditional */
          DEC_REFCNT(ptdesc);        /* wird nicht frei! */
          /* argumente von w poppen */
          for (; --arity > 0 ;)
            PPOP_W();
          /* vorsicht hier: falls der then/else-code die */
          /* argumente nicht freigibt muss das anschliessend */
          /* geschehen !!! */ 
#if WITHTILDE
	  if (R_CONDI(*ptdesc,args) & 0x3) { /* nur die unteren 2 bit */
#else
          if (R_CONDI(*ptdesc,args)) {
#endif /* WITHTILDE */
            /* conditional gibt argumente nicht frei! */
#if D_SLAVE
            post_mortem ("rout_sret ? NOT ALLOWED ! (E Stack used...)");
#endif
            PUSH_E(R_CONDI(*ptdesc,nargs-1)); /* nr. args */
            PUSH_R(code);            /* returnadresse    */
            code = rout_sret;        /* special return */
          }
          PUSH_R(code);              /* returnadresse    */
          SET_TAIL_FLAG();           /* SWITCH vermeiden */
          code = R_CONDI(*ptdesc,ptc);
          goto loop;
        }
        COMM0("mkcclos");
        goto L_mkcclos;
      } /* end TY_CONDI */
      else {
        sprintf(buf,"inter (apply): invalid FUNC type (%d)",R_DESC(*ptdesc,type)); 
        POST_MORTEM(buf);
      }
    } /* end if (arity == arg) */
    else
    if (arity < arg) {

      DBUG_PRINT ("INTER", ("zuwenige argumente"));

      /* zuwenige argumente */
      if (R_DESC(*ptdesc,type) == TY_CLOS) {

        DBUG_PRINT ("INTER", ("(R_DESC(*ptdesc,type) == TY_CLOS)"));

        if (R_DESC(*ptdesc,ref_count) == 1) {
          /* closure mit refcount 1 wird erweitert! */
          /* stack w: | .. arg_arity .. arg_1 clos */
          /* ptdesc: zeiger auf die closure auf'm stack */
          /* arity: anzahl der argumente auf'm stack (>0!) */
          /* arg: anzahl der benoetigten argumente (>1!) */
          register PTR_HEAPELEM pth;

          DBUG_PRINT ("INTER", ("closure mit refcount 1 wird erweitert"));

          COMM0("expand clos");
          RES_HEAP;
#if WITHTILDE
	  {
	    /* erst den tilde frame in sicherheit bringen */

	    pth = (PTR_HEAPELEM)R_CLOS(*ptdesc,pta);
	    pth += R_CLOS(*ptdesc,args);
	    pth += R_CLOS(*ptdesc,nfv);

	    for (arg = R_CLOS(*ptdesc,nfv) ; arg >= 0 ; arg--, pth--) {
	      *(pth + arity) = *pth;
	    }
	  }
#endif /* WITHTILDE */
          pth = (PTR_HEAPELEM)R_CLOS(*ptdesc,pta);
          pth += R_CLOS(*ptdesc,args);
          for (arg = arity ; --arg >= 0 ; ) {
            PPOP_W();
            *++pth = TOP_W();
          }
          REL_HEAP;
          L_CLOS(*ptdesc,args) += arity;  /* mehr args */
          L_CLOS(*ptdesc,nargs) -= arity; /* braucht weniger */
          WRITE_W(ptdesc);                /* die closure */
          goto loop;
        }
        else {

          DBUG_PRINT ("INTER", ("neue, erweiterte closure bilden"));

          /* neue, erweiterte closure bilden */
          COMM0("new clos");
          help = R_CLOS(*ptdesc,args);
          /* stack w: | .. arg_arity .. arg_1 clos */
          /* ptdesc: zeiger auf die closure auf'm stack */
          /* arity: anzahl der argumente auf'm stack */
          /* arg: anzahl der benoetigten argumente */
          /* help: anzahl der closure argumente */
          func = (int)ptdesc;              /* closure */
          MAKEDESC(ptdesc,1,C_FUNC,TY_CLOS);
          L_CLOS(*ptdesc,args) = help+arity; /* mehr args */
#if WITHTILDE
	  nfv = R_CLOS(*(T_PTD)func,nfv);
	  L_CLOS(*ptdesc,nfv) = nfv;
#endif /* WITHTILDE */
          L_CLOS(*ptdesc,nargs) = arg-arity;/* weniger nargs */
          L_CLOS(*ptdesc,ftype) = R_CLOS(*(T_PTD)func,ftype);
          arg += help + 1;      /* laenge der arg.liste */
#if (D_SLAVE && D_MESS && D_MHEAP)
          if ((*d_m_newheap)(arg,A_CLOS(*ptdesc,pta))) {
#else
#if WITHTILDE
	  if (newheap(arg+nfv,A_CLOS(*ptdesc,pta))) {
#else
          if (newheap(arg,A_CLOS(*ptdesc,pta))) {
#endif /* WITHTILDE */
#endif
            register PTR_HEAPELEM p1,p2;
            RES_HEAP;
            p1 = (PTR_HEAPELEM)R_CLOS(*(T_PTD)func,pta);
            p2 = (PTR_HEAPELEM)R_CLOS(*ptdesc,pta);
            do {                   /* altes argument frame */
              T_INC_REFCNT((T_PTD)*p1);
              *p2++ = *p1++;
            } while (--help >= 0);
            PPOP_W();                    /* alte closure */
            do {                   /* zusaetzliche argumente */
              *p2++ = (T_HEAPELEM)POP_W();
            } while (--arity > 0);
#if WITHTILDE
	    while (nfv-- > 0) {   /* tilde frame */
	      T_INC_REFCNT((T_PTD)*p1);
	      *p2++ = *p1++;
	    }
#endif /* WITHTILDE */
            REL_HEAP;
            DEC_REFCNT((T_PTD)func);     /* alte closure */
            PPUSH_W(ptdesc);             /* neue closure */
            goto loop;
          }
          /* descriptor freigeben? */
          POST_MORTEM("inter: heap overflow (mkclos)");
        } /* end else */
      } /* end TY_CLOS */
      else
      if (R_DESC(*ptdesc,type) == TY_COMB) {

        DBUG_PRINT ("INTER", ("COMM0('mkbclos')"));

        COMM0("mkbclos");
        goto L_mkbclos;             /* make closure    */
      }
      else
      if (R_DESC(*ptdesc,type) == TY_CASE) {

        DBUG_PRINT ("INTER", ("goto L_mksclos"));

        COMM0("mksclos");
        goto L_mksclos;             /* make closure    */
      }
      else {
        sprintf(buf,"inter: invalid FUNC type (%d)",R_DESC(*ptdesc,type));
        POST_MORTEM(buf);
      }
    } /* end arity < arg */
    /* sonst zuviele argumente, behandlung unten! */
  }
  else
  if (T_FUNC((int)ptdesc)) {

    DBUG_PRINT ("INTER", ("T_FUNC((int)ptdesc)"));

    /* primitive funktion oben auf w */
    /* arity: anzahl der argumente auf'm stack */
    func = TOP_W();               /* primfunc */ 
    arg = FUNC_ARITY(func);       /* args needed */
    if (arity == arg) {
      /* passend viele argumente */
      COMM0("delta");
      PPOP_W();                   /* primfunc */

#if D_SLAVE
/*fprintf(debugger, "%x: ** jumping to delta (2), redcnt: %d\n", curr_pid, _redcnt); fflush(debugger);*/
#endif

      if (func == LSELECT) goto L_lsel;
      if (arg == 2) goto L_delta2;       /* 2-stellig */
      if (arg == 1) goto L_delta1;       /* 1-stellig */
      if (arg == 3) goto L_delta3;       /* 3-stellig */
      if (arg == 4) goto L_delta4;       /* 4-stellig */
      POST_MORTEM("inter: pf_arity out of range (apply)");
    }
    else
    if (arity < arg) {
      /* zuwenig argumente */
      COMM0("mkdclos");
      goto L_mkdclos;             /* delta-closure bilden  */
    } /* end arity < arg */
    /* sonst zuviele argumente, behandlung unten */
  } /* end T_FUNC */
  else
  if (T_IAFUNC((int)ptdesc)) {  /* stt 21.11.95 */

    DBUG_PRINT ("INTER", ("T_IAFUNC((int)ptdesc)"));

    /* interaktion oben auf w */
    /* arity: anzahl der argumente auf'm stack */
    func = TOP_W();               /* interaktion */
    arg = FUNC_ARITY(func);       /* args needed */
    if (arity == arg) {
      /* passend viele argumente */
      COMM0("intact");
      PPOP_W();                   /* primfunc */
      goto L_intact;
    }
    else
    if (arity < arg) {
      /* zuwenig argumente */
      COMM0("mkiclos");
#if WITHTILDE
      nfv   = 0;
#endif /* WITHTILDE */
      func = TY_INTACT;
      goto L_mkclos;             /* interaktion-closure bilden  */
    } /* end arity < arg */
    /* sonst zuviele argumente, behandlung unten */
  } /* end T_IAFUNC */
  else {
    /* sonstige pointer oder stackelemente oben auf w */

    DBUG_PRINT ("INTER", ("goto L_mkap;  applikation auslagern"));

    COMM0("mkap");
    goto L_mkap;                  /* applikation auslagern */
  }
  /* sonst arity > arg d.h. zuviele argumente              */

#if WITHTILDE
#if 0
  if ((arg == 0) && (nfv == 0)) {
    PUSH_R(0);
    goto L_mkgclos;
  }
#else
  if (arg == 0) {
    nfv = 0;
    goto L_mkgclos;
  }
#endif /* 0 */
#else
  if (arg == 0) goto L_mkgclos;   /* universelle closure   */
#endif

  /* das apply muss in zwei apply's aufgespalten werden,   */
  /* dieses geschieht mithilfe der routine rout_sapply.    */
  /* arity: anzahl der argumente auf'm stack */
  /* arg: anzahl der benoetigten argumente */

  DBUG_PRINT ("INTER", ("universelle closure"));

  PUSH_R(code);                   /* returnadresse         */
  PUSH_R(arity-arg);              /* anz. ueberfl. arg.    */
  arity = arg;                    /* passend viele arg.    */
  code = rout_sapply;             /* special apply routine */
  goto L_apply;

L_interrupt:

  /* eine primitive funktion war nicht durchfuehrbar */
/*#if D_SLAVE
  post_mortem("interrupt in primitive function");
#endif*/
  END_MODUL("?");                           /* welches ist ja nicht bekannt */
#if DEBUG
  if (_heap_reserved) REL_HEAP;
#endif
  /* evtl. halb erstellte descriptoren freigeben */
  if (_desc != NULL) DEC_REFCNT(_desc);
  _interrupt = FALSE;
  _digit_recycling = TRUE;
  /* wiederherstellen der applikation (func enthaelt die funktion) */
/*  switch (FUNC_ARITY(func)) {
    case 4: PPUSH_W(help);
    case 3: PPUSH_W(arity);
    case 2: PPUSH_W(arg);
    case 1: PUSH_W(func);
            arity = FUNC_ARITY(func);
            break;
  } *//* end switch */
      PUSH_W(func);
      arity = FUNC_ARITY(func);
  /* CONTINUE! */

L_mkap:

  /* auslagern einer applikation vgl. store_e in rstpro.c */
  MAKEDESC(ptdesc,1,C_EXPRESSION,TY_EXPR);
  GET_HEAP(arity+3,A_EXPR(*ptdesc,pte));
  RES_HEAP;
  pth    = (PTR_HEAPELEM)R_EXPR(*ptdesc,pte);
  *pth++ = (T_HEAPELEM)(arity+2);             /* groesse     */
  *pth++ = (T_HEAPELEM)SET_ARITY(AP,(arity+1)); /* konstruktor */
  pth += arity;
  do {
    *pth-- = (T_HEAPELEM)POP_W();
  } while (--arity >= 0);
  REL_HEAP;
  PPUSH_W(ptdesc);
  goto loop;

} /* end inter */


#if !WITHTILDE
/* --- load_pmlist : load pm argument list --- */

static void load_pmlist(st,p)
#if D_SLAVE
DStackDesc *st;
#else
StackDesc *st;
#endif

T_PTD     p;
{
  int i;
  for (i = 0 ; i < (int) R_LIST(*p,dim); i++ ) {
            /* int gecastet von RS 5.11.1992 */ 
#if D_SLAVE
    D_PUSHSTACK(*st,(R_LIST(*p,ptdv))[i]);
    T_INC_REFCNT((T_PTD)D_READSTACK(*st));
#else
    PUSHSTACK(*st,(R_LIST(*p,ptdv))[i]);
    T_INC_REFCNT((T_PTD)READSTACK(*st));
#endif

  }
  DEC_REFCNT(p);
}

/* --- load_pmilist : load inverse pm argument list --- */

static void load_pmilist(st,p)
#if D_SLAVE
DStackDesc *st;
#else
StackDesc *st;
#endif

T_PTD     p;
{
  int i;
  for (i = R_LIST(*p,dim); --i >= 0; ) {
#if D_SLAVE
    D_PUSHSTACK(*st,(R_LIST(*p,ptdv))[i]);
    T_INC_REFCNT((T_PTD)D_READSTACK(*st));
#else
    PUSHSTACK(*st,(R_LIST(*p,ptdv))[i]);
    T_INC_REFCNT((T_PTD)READSTACK(*st));
#endif
  }
  DEC_REFCNT(p);
}

/* end of file */

#endif /* !WITHTILDE */
@


1.78
log
@more DEBUG output
@
text
@d1 5
a5 1
/* $Log: rinter.c,v $
a212 3
 * Revision 1.12  1994/05/03  07:30:24  mah
 * *** empty log message ***
 *
a227 3
 * Revision 1.6  1993/12/09  08:31:54  mah
 * *** empty log message ***
 *
d236 1
a236 1
 * */
d5737 1
a5737 1
/*uh, 16.10.90*/                  (int)func  = (PTR_HEAPELEM)MID_R((int)func) - R_LIST(*ptdesc,ptdv); /* Start */
@


1.77
log
@minor bugfixes in the speculative tickets version
@
text
@d2 3
d2976 1
a2976 1
/* fprintf(debugger, "0x%x: SPECWIN reached, RESULT FOUND!\n", curr_pid); fflush(debugger);  */
d3206 1
a3206 1
/*  fprintf(debugger, "0x%x: SPECWAIT reached, used %d redsteps\n", curr_pid, curr_pid->start_red_count-_redcnt); fflush(debugger); */
d3534 2
d3577 2
d3990 2
@


1.76
log
@bugfixed version for SPEC_TICKETS + some more features
@
text
@d2 3
d2877 1
a2877 1
                    post_mortem("sorry, no speculative evaluation in this version !");
d2995 1
a2995 1
                   post_mortem("sorry, no speculative evaluation in this version !");
d3030 9
d3082 1
a3082 1
/*fprintf(debugger, "0x%x: SPECEND, no more postponed expressions, going to sleep...\n", curr_pid); fflush(debugger); */
d3193 1
a3193 1
                   post_mortem("sorry, no speculative evaluation in this version !");
d3555 1
a3555 1
                    post_mortem("sorry, no speculative evaluation in this version !");
d3565 1
a3565 1
                    post_mortem("sorry, no speculative evaluation in this version !");
d3609 1
a3609 1
                    post_mortem("sorry, no speculative evaluation in this version !");
d4102 1
a4102 1
                   post_mortem("sorry, no speculative evaluation in this version !");
@


1.75
log
@first version supporting speculative evaluations with TICKETS
@
text
@d2 3
d2942 1
d2954 2
d2970 1
a2970 1
/*fprintf(debugger, "0x%x: SPECWIN reached, RESULT FOUND!\n", curr_pid); fflush(debugger); */
d2974 1
d2986 2
d3030 4
d3079 2
d3085 1
a3085 1
/*fprintf(debugger, "0x%x: SPECEND, initialize next expression...\n", curr_pid); fflush(debugger); */
d3091 6
d3125 1
a3125 1
/*fprintf(debugger, "0x%x: SPECEND: ffound is set, setting the following process to FAIL\n", curr_pid); fflush(debugger); */
d3139 1
a3139 1
/* fprintf(debugger, "0x%x: SPECEND, FAIL is %d\n", curr_pid, T_SPEC_FAIL(curr_pid)); fflush(debugger); */
d3212 1
a3212 1
/* fprintf(debugger, "0x%x: SPECWAIT, %d matching clauses were found !\n", curr_pid, PC_GET_SPEC_SPAWNED(curr_pid)); fflush(debugger); */
d3345 2
d3354 1
a3354 1
/* fprintf(debugger, "0x%x: SPECWAIT spawning one expression to node %d\n", curr_pid, func); fflush(debugger); */
d3360 2
d3370 1
a3370 1
                          if (help != 1) {
d3372 3
d3397 1
a3397 1
/*fprintf(debugger, "0x%x: SPECWAIT enqueuing some expressions, clear SIGNOFF\n", curr_pid); fflush(debugger);*/
d3404 2
d3415 6
d3492 2
d3535 3
d3637 4
d3868 4
d3904 2
d3913 1
d4003 4
a4006 1

d4035 1
a4035 1
                             }
d4045 1
a4045 1
                           if ((curr_pid->son_status[nfv] & SPEC_NO_STEPS) > 0 ) {
@


1.74
log
@speculative evaluations version 2 completed
@
text
@d2 3
d762 1
a762 1
DBUG_PRINT("INTER",("proc %x: next instruction: %s (%d,%x),redcount: %d (is_spec=%d: %d)",curr_pid,instr_tab[*code].name,*code,code,_redcnt,T_SPEC_PROCESS(curr_pid),_spec_redcnt));
d1549 4
a1552 2
                     while (--arity > 0)
                       pth[arity] = (T_HEAPELEM)POP_W();
d1554 1
d1815 3
d2839 3
d2846 21
d2868 2
d2886 3
a2888 1
                   if (!T_SPEC_INSYNC(curr_pid)) {
d2891 1
a2891 1
/*   fprintf(debugger, "0x%x: process has reached a SPECWIN command, just folding.\n", curr_pid); fflush(debugger);*/
d2902 22
d2931 1
a2931 1
/*   fprintf(debugger, "0x%x: SPECWIN reached (GS=%d,F=%d,NS=%d)\n", curr_pid, T_SPEC_GUARD_SON(curr_pid), T_SPEC_FAIL(curr_pid), T_SPEC_NO_STEPS(curr_pid)); fflush(debugger);*/
d2933 8
a2940 1
                     spec_send_winner(curr_pid->control_node, curr_pid->control_pid, curr_pid, 0);
d2947 3
d2953 5
d2964 1
a2964 1
/*   fprintf(debugger, "0x%x: SPECWIN reached, GO !\n", curr_pid); fflush(debugger);*/
d2966 4
a2969 1
                     spec_send_winner(curr_pid->control_node, curr_pid->control_pid, curr_pid, 1);
d2976 3
d2996 130
d3129 1
a3129 1
 
d3156 3
d3165 1
d3170 1
a3170 1
/*  fprintf(debugger, "%x: used %d redsteps 'til reaching SPECWAIT\n", curr_pid, curr_pid->start_red_count-_redcnt); fflush(debugger); */
d3178 291
d3498 3
d3524 4
d3550 5
d3565 1
a3565 1
          /*         fprintf(debugger, "%x: I'm working again !\n", curr_pid); fflush (debugger); */
d3573 10
d3585 35
a3619 3
                   if (!T_SPEC_FOLD(curr_pid)) {
                     DBUG_PRINT("INTER", ("FOLD was not set, setting... ;)"));
                     PC_SET_SPEC_FOLD(curr_pid);
d3622 9
d3650 2
d3678 2
d3684 3
d3692 25
d3874 3
d3915 1
a3915 1
/* fprintf(debugger, "* number %x: %d steps, w: %x, b: %x, f: %x s: %x!\n", arity, curr_pid->son_redcnts[arity], T_S_WINNER(curr_pid->son_status[arity]), T_S_NO_BSTEPS(curr_pid->son_status[arity]), T_S_FAIL(curr_pid->son_status[arity]), T_S_NO_STEPS(curr_pid->son_status[arity])); */
d3935 1
a3935 1
                       if (help == -1) {
d3982 2
a3983 2
                           if ((T_S_GUARD_SON(curr_pid->son_results[nfv]) == 1) ||
                               (T_S_UNRED_GUARD(curr_pid->son_results[nfv]) == 1)) {
d3990 1
a3990 1
                           if ((curr_pid->son_results[nfv] & SPEC_NO_BSTEPS) > 0 ) {
d3993 1
a3993 1
/* fprintf(debugger, "MKNCASE: NO_STEPS result, set the flag...\n"); fflush(debugger); */
d4016 2
d4031 2
d5583 5
d5589 3
d5673 3
@


1.73
log
@dbug-messages removed, ready for re-compilation
@
text
@d2 3
d2360 3
d2365 2
d2853 3
d2872 2
d2890 2
a2957 2
                    POP_W(); /* remove argument which is not removed during the speculative matching */

d2982 2
d3104 2
d3349 1
a3349 1
                           if (!T_S_GUARD_SON(curr_pid->son_status[arity])) {
@


1.72
log
@further bugfixes on speculative evaluation (preliminary, beware of debug messages !)
@
text
@d2 3
d2312 2
a2313 2
 fprintf(debugger, "L_real_nomatch reached !\n"); fflush(debugger); 
 fprintf(stderr, "*******SUCKER real unmatch!\n*\n*\n*\n*\n"); fflush(stderr); 
d2848 1
a2848 1
 fprintf(debugger, "%x reached SPECWIN; start: %d, redcnt: %d, spec_redcnt: %d (GUARD: %d, FAIL: %d, NO_STEPS: %d, NO_BSTEPS: %d, UNR_GUARD: %d)\n", 
d2850 1
a2850 1
T_SPEC_NO_BSTEPS(curr_pid), T_SPEC_UNRED_GUARD(curr_pid)); fflush(debugger);  
d2941 1
a2941 1
 fprintf(debugger, "%x: used %d redsteps 'til reaching SPECWAIT\n", curr_pid, curr_pid->start_red_count-_redcnt); fflush(debugger); 
@


1.71
log
@modifications for speculative evaluations regarding
meaning preserving transformations
@
text
@d2 4
d2309 2
a2310 2
/* fprintf(debugger, "L_real_nomatch reached !\n"); fflush(debugger); */
/* fprintf(stderr, "*******SUCKER real unmatch!\n*\n*\n*\n*\n"); fflush(stderr); sleep(1); */
d2820 3
a2838 9
                   if (!T_SPEC_FOLD(curr_pid)) {

                   if (T_SPEC_GUARD_SON(curr_pid)==1) {

/* fprintf(debugger, "GUARD was set in son process !\n"); fflush(debugger); */

                     DBUG_PRINT("INTER", ("SPECWIN: SPEC_GUARD_SON was set !"));

                     PC_SET_SPEC_FOLD(curr_pid);
d2840 2
a2841 12
                     if (T_SPEC_NO_BSTEPS(curr_pid)==1) {
                       DBUG_PRINT("INTER", ("already NO_BSTEPS, so don't signal anything..."));
                       } else {
                       DBUG_PRINT("INTER", ("It's a SON process, so signal terminate..."));
                       spec_send_fail_control(curr_pid->control_node, curr_pid->control_pid, curr_pid);
                       if (T_SPEC_CONF_FAIL(curr_pid)==1) {
                         DBUG_PRINT("INTER", ("already confirmed, goon processing !"));
                       } else {
                         DBUG_PRINT("INTER", ("no confirmation yet, let's sleep !"));
                         DBUG_RETURN (IR_WAIT);
                         }
                       } 
d2845 3
a2847 1
/* fprintf(debugger, "SPECWIN: noch kein WINNER...\n"); fflush(debugger); */
d2849 1
a2849 1
                     DBUG_PRINT("INTER", ("THIS is a result !"));
d2851 3
a2853 2
                     PC_SET_SPEC_WINNER(curr_pid);
                     PC_SET_SPEC_FOLD(curr_pid);
d2855 2
a2856 1
                     if (T_SPEC_NO_BSTEPS(curr_pid)==1) {
d2858 1
a2858 1
                      DBUG_PRINT("INTER", ("NO_BSTEPS is set, don't freeze the process !"));
d2860 3
d2864 3
d2868 1
a2868 1
                     /* hey, it might be a (newly) GRANDDAD process ! */
d2870 1
a2870 1
/* fprintf(debugger, "SPECWIN: spec_multi_results = %d\n", spec_multi_results); fflush(debugger); */
d2872 1
a2872 8
                     if (T_SPEC_GRANDDAD(curr_pid)==1) {
                       /* this means it's the only one process around, redcounter is OK */
                       DBUG_PRINT("INTER", ("it's a granddad !"));

/* fprintf(debugger, "SPECWIN: GRANDDAD\n"); fflush(debugger); */

                       /* just goon and return the result... */
                       } else {
d2874 1
a2874 6
/* fprintf(debugger, "SPECWIN: no GRANDDAD\n"); fflush(debugger); */
                     spec_send_winner(curr_pid->control_node, curr_pid->control_pid, curr_pid);
                     /* calculating reduction steps */
                     DBUG_PRINT("INTER", ("this process has %d steps left and did use %d steps", _redcnt, curr_pid->start_red_count - _redcnt));
                     
/* fprintf(debugger, "SPECWIN: this process has %d steps left and did use %d steps\n", _redcnt, curr_pid->start_red_count - _redcnt); fflush(debugger); */
a2883 7
                     }  } else {
                     DBUG_PRINT("INTER", ("already a folding thread, just return the result with SPECEND..."));

/* fprintf(debugger, "SPECWIN: already WINNER...\n"); fflush(debugger); */

                     }  

d2938 4
a2962 13
                      if (T_SPEC_LEAF(curr_pid)==1) {
                        DBUG_PRINT("INTER", ("It's a SON process, so signal terminate..."));
                        spec_send_fail_control(curr_pid->control_node, curr_pid->control_pid, curr_pid); 
                       if (T_SPEC_CONF_FAIL(curr_pid)==1) {
                         DBUG_PRINT("INTER", ("already confirmed, goon processing !"));
                       } else {
                         DBUG_PRINT("INTER", ("no confirmation yet, let's sleep !"));
                         DBUG_RETURN (IR_WAIT); 
                         }
                        } else {
                        DBUG_PRINT("INTER", ("mkncase will do the rest if it's a granddad... ;)"));
                        }

d2967 1
d3030 2
d3035 2
d3089 1
d3273 2
d3282 2
d3287 3
a3289 7
                         if (!T_S_GUARD_SON(curr_pid->son_status[arity])) {

/* fprintf(debugger, "MKNCASE: !T_S_GUARD_SON set...\n"); fflush(debugger);  */

                           _redcnt -= curr_pid->son_redcnts[arity];
                           if (T_S_UNRED_GUARD(curr_pid->son_status[arity]) == 1) 
                             nfv = 1;
a3290 1
                         else {
d3292 1
a3292 1
/* fprintf(debugger, "MKNCASE: T_S_GUARD_SON is set !\n"); fflush(debugger); */
d3294 1
a3294 4
                           DBUG_PRINT("INTER", ("number %d: unreducible guard", arity));
                           nfv = 1;
                           }
                         if (T_S_WINNER(curr_pid->son_status[arity])) {
d3296 1
d3310 2
d3329 7
d3396 4
d4231 1
d4234 4
a4237 1
#define UNDECIDED ((int)ptdesc)
d4848 5
a4852 7
                           DBUG_PRINT("INTER", ("this process dies !"));
                           PC_SET_SPEC_TERM(curr_pid);
                           spec_send_fail_control(curr_pid->control_node, curr_pid->control_pid, curr_pid);
                           if (curr_pid == 0)
                             DBUG_RETURN(IR_SCHED);
                           else
                             DBUG_RETURN (IR_WAIT);
@


1.70
log
@old version check-in
@
text
@d2 3
d269 1
d310 3
d748 3
d752 1
d833 4
d842 3
d846 2
d849 3
a851 1
                     }
d853 2
a854 1
                     SPEC_COUNTER_CODE(2,"DELTA1")
d856 1
d880 4
d891 3
d896 4
d902 1
a902 1
                     SPEC_COUNTER_CODE(2, "DELTA2")
d917 4
d929 3
d934 4
d940 1
a940 1
                     SPEC_COUNTER_CODE(2, "DELTA3")
d955 4
d968 3
d973 4
d979 1
a979 1
                     SPEC_COUNTER_CODE(2, "DELTA4")
d1186 3
d1190 5
a1194 1
                       arg = POP_W();                   /* arg:    praedikat   */
d1197 3
d1206 3
d1212 4
d1218 1
a1218 1
                     SPEC_COUNTER_CODE(1, "JCOND")
d1221 4
a1224 1
                     if (_redcnt < delta_count) 
d1226 1
d1229 3
d1234 3
d1238 3
d1302 4
d1307 3
d1316 3
a1318 1
                     SPEC_COUNTER_CODE(2, "BETA")
d1340 4
d1345 3
d1354 3
a1356 1
                     SPEC_COUNTER_CODE(1, "BETA0")
d1358 1
d1365 4
d1370 3
d1380 3
a1382 1
                     SPEC_COUNTER_CODE(1, "BETA1")
d1384 1
d1394 4
d1399 3
d1408 3
a1410 1
                     SPEC_COUNTER_CODE(1, "JTAIL")
d1412 1
d1419 4
d1424 3
d1431 3
a1433 1
                     SPEC_COUNTER_CODE(1, "JTAIL0")
d1435 1
d1442 4
d1447 3
d1455 3
a1457 1
                     SPEC_COUNTER_CODE(1, "JTAIL1")
d1459 1
d1835 7
a1841 2
                     if (_redcnt > 0) {
                     /* sorry */
d1843 1
a1843 1
                     SPEC_COUNTER_CODE(2, "APPLY")
d1855 7
a1861 2
                     if (_redcnt > 0) {
                     /* sorry */
d1863 1
a1863 1
                     SPEC_COUNTER_CODE(1, "SAPPLY")
d1866 1
a1866 1
                     COMM0("apply");
d1948 4
d1953 3
d1962 3
a1964 1
                     SPEC_COUNTER_CODE(2, "CASE")
d2312 16
d2334 2
d2344 2
d2351 1
a2351 1
		       
d2832 24
a2855 1
                   if (!T_SPEC_WINNER(curr_pid)) {
d2862 1
a2862 2

                     /* hey, it might be a (newly) GRANDDAD process ! */
d2864 1
a2864 1
/* fprintf(debugger, "SPECWIN: spec_multi_results = %d\n", spec_multi_results); fflush(debugger); */
d2866 1
a2866 2
                     /* if multiple results are permitted, transform top of Stack to a */
                     /* unary list */
d2868 1
a2868 1
                  /* THIS IS SKIPPED TOTALLY BECAUSE OF BULLSHIT FACTOR */
d2870 1
a2870 2
                  /*   if (spec_multi_results) {
                       DBUG_PRINT("INTER", ("spec_multi_results: %d", spec_multi_results));
d2872 1
a2872 14
fprintf(debugger, "SPECWIN: creating list...\n"); fflush(debugger); 

                       GET_DESC(_desc);
                       LI_DESC_MASK(_desc,1,C_LIST,TY_UNDEF);
                       GET_HEAP(1,A_LIST(*_desc,ptdv));
                       L_LIST(*_desc,dim) = 1;
                       RES_HEAP;
                       pth = R_LIST(*_desc,ptdv);
                       *pth = (T_HEAPELEM)POP_W();
                       DBUG_PRINT("INTER", ("RESULT is %x !", *pth));
                       REL_HEAP;
                       PUSH_W(_desc);
                       _desc = NULL;
                       }  */
a2885 1
                     _redcnt = curr_pid->start_red_count - (curr_pid->abs_red_count + ack_red_count - _redcnt);
d2898 2
a2899 2
                     } else {
                     DBUG_PRINT("INTER", ("already a winning thread, just return the result with SPECEND..."));
d2939 1
a2939 1
                   arg = curr_pid;
d2941 1
a2941 1
                   curr_pid = arg;
d2959 5
a2963 1
                    DBUG_PRINT("DIST",("dummy pushed, Top of W-Stack: %x",ps_w->TopofStack));
a2964 1
                    PC_SET_SPECWAIT(curr_pid);
d2970 3
d2975 1
a2975 2
                      DBUG_PRINT("INTER", ("no son's spawned..."));
                      /* so this NCASE has failed... if it's SPEC_DAD, it can quit now */
d2977 12
a2988 10
                      /************* speculative process is failing ******************/

                      if (T_SPEC_PROCESS(curr_pid)==1) { /* yes, it is... */
                        DBUG_PRINT("INTER", ("it's a SPEC process"));
                        PC_SET_SPEC_TERM(curr_pid);
                        spec_send_fail_control(curr_pid->control_node, curr_pid->control_pid, curr_pid);
                        if (curr_pid == 0)
                          DBUG_RETURN(IR_SCHED);
                        else
                          DBUG_RETURN (IR_WAIT);
d2990 1
a2990 2
                        DBUG_PRINT("INTER", ("it's a SPEC_GRAND process !"));
                        post_mortem ("no post-processing of failed SPEC processes implemented yet");
d2992 2
d2995 1
d3000 1
d3009 45
d3058 54
a3111 2
                   if (/* (curr_pid->control->result) ||*/ T_SPEC_WINNER(curr_pid)) {
                     DBUG_PRINT("INTER", ("there's a result..."));
d3113 29
a3141 1
                     ptdesc= (T_PTD)POP_W();
d3143 1
a3143 1
                     /* maybe there would have been a replace command... never mind... */
d3145 18
a3162 16
                     if (spec_multi_results) {
                       DBUG_PRINT("INTER", ("multi results: %d", curr_pid->specmask2));

/* fprintf(debugger, "MULTI-results ! specmask2 = %d\n", curr_pid->specmask2); fflush(debugger); */

                       if (curr_pid->specmask2>1) {
                         DBUG_PRINT("INTER", ("these lists have to be concatenated..."));
                         /* concatenating... */
                         /* tmp variables: arity, ptdesc, arg, nfv */
                         /* curr_pid->specmask2 is the number of lists */
                         /* calculating the total length of the resulting list */
                         arity = 0;
                         DBUG_PRINT("INTER", ("PC_GET_SPEC_SPAWNED(curr_pid) = %d", PC_GET_SPEC_SPAWNED(curr_pid)));
                         for (arg = 0; arg < curr_pid->specmask2; arg++) {
                           DBUG_PRINT("INTER", ("descriptor: %x", *(PTR_DESCRIPTOR)curr_pid->processes[PC_GET_SPEC_SPAWNED(curr_pid)*2+arg*2]));
                           _desc = (PTR_DESCRIPTOR)curr_pid->processes[PC_GET_SPEC_SPAWNED(curr_pid)*2+arg*2];
d3165 14
a3178 2
                           arity += R_LIST(*(PTR_DESCRIPTOR)curr_pid->processes[PC_GET_SPEC_SPAWNED(curr_pid)*2+arg*2],dim);
                           DBUG_PRINT("INTER", ("length of list %d: %d", arg, R_LIST(*(PTR_DESCRIPTOR)curr_pid->processes[PC_GET_SPEC_SPAWNED(curr_pid)*2+arg*2],dim)));
d3180 8
a3187 1
                         DBUG_PRINT("INTER", ("final length of the resulting list: %d", arity));
d3190 2
a3191 2
                         GET_HEAP(arity,A_LIST(*_desc,ptdv)); /* now arity can be reused */
                         L_LIST(*_desc,dim) = arity;
a3192 1
                         /* now copy all pointers in the new list */
d3194 12
a3205 11
                         DBUG_PRINT("INTER", ("ptdv of target list is: %x", R_LIST((*_desc),ptdv)));
                         for (arg = 0; arg < curr_pid->specmask2; arg++) {
                           DBUG_PRINT("INTER", ("concatenating list %d", arg));
                           for (arity = 0; arity<R_LIST(*(PTR_DESCRIPTOR)curr_pid->processes[PC_GET_SPEC_SPAWNED(curr_pid)*2+arg*2],dim); arity++) {
                             DBUG_PRINT("INTER", ("updating help: %x, arity(=for-counter)=%d", help, arity));
                             *((int *)help)++ = nfv = *(((int *) R_LIST(*(PTR_DESCRIPTOR)curr_pid->processes[PC_GET_SPEC_SPAWNED(curr_pid)*2+arg*2],ptdv))+arity);
                             if (T_POINTER(nfv)) {
                               DBUG_PRINT("INTER", ("increasing reference count for %x", nfv));
                               INC_REFCNT((PTR_DESCRIPTOR)nfv); 
                               } else {
                               DBUG_PRINT("INTER", ("non-pointer value: %x", nfv));
a3207 2
                           DBUG_PRINT("INTER", ("decreasing refcount of %x", curr_pid->processes[PC_GET_SPEC_SPAWNED(curr_pid)*2+arg*2]));
                           DEC_REFCNT((PTR_DESCRIPTOR)curr_pid->processes[PC_GET_SPEC_SPAWNED(curr_pid)*2+arg*2]);
d3209 1
d3211 3
a3213 1
                         PUSH_W(_desc);
d3215 75
a3289 4
                         DBUG_PRINT("INTER", ("only one result..."));
                         /* so the result should be at position processes[0]... */
                         DBUG_PRINT("INTER", ("PC_GET_SPEC_SPAWNED: %d", PC_GET_SPEC_SPAWNED(curr_pid)));
                         PUSH_W(curr_pid->processes[PC_GET_SPEC_SPAWNED(curr_pid)*2]);
d3291 3
d3295 122
a3416 2
                       DBUG_PRINT("INTER", ("there was only one result: %x", curr_pid->specmask2));
                       PUSH_W(curr_pid->specmask2);
d3418 3
a3420 10
                     } else if (spec_failcase && (T_SPEC_PROCESS(curr_pid)==1)) {
                       DBUG_PRINT("INTER", ("this process dies !"));
                       PC_SET_SPEC_TERM(curr_pid);
                       spec_send_fail_control(curr_pid->control_node, curr_pid->control_pid, curr_pid);
                       if (curr_pid == 0)
                         DBUG_RETURN(IR_SCHED);
                       else
                         DBUG_RETURN(IR_WAIT);
                       } else
                     post_mortem ("no post-processing of failed SPEC processes implemented yet");
d4880 1
a4880 1
                                      DBUG_PRINT("INTER", ("SIZEOFSTACK(S_tilde): %d, T_KLAA(TOP_T()): %d", SIZEOFSTACK(S_tilde), T_KLAA(TOP_T())));
d4917 12
a4928 1
/*uh, 16.10.90*/                  if (IS_TRUE(arg)) { code+=3; goto loop;}
d4931 5
d4938 45
d5356 4
d5361 3
d5371 3
a5373 1
                     SPEC_COUNTER_CODE(2, "GAMMABETA")
d5375 1
d5385 4
d5390 3
d5400 3
a5402 1
                     SPEC_COUNTER_CODE(2, "GAMMACASE")
d5404 1
@


1.69
log
@further (unspecified ;-) modifications on speculative evaluation AND
another bugfix regarding pattern matching (applications to closures
are treated as undecidable, which may be the right decision ;-)
@
text
@d2 5
d289 2
a293 1
extern INSTR_DESCR instr_tab[];
d618 1
d691 2
d695 5
d736 5
d742 3
a744 1
#endif
d1890 7
d1915 1
a1915 1
                       DBUG_PRINT("inter",("hier hinweg gekommen !"));
d1929 1
a1929 1
                       DBUG_PRINT("rinter", ("before if..."));
d1934 1
a1934 1
                         DBUG_PRINT ("rinter", ("match undecided"));
d1958 1
a1958 1
                         DBUG_PRINT("rinter", ("guard undecided"));
d1996 1
a1996 1
                         DBUG_PRINT("rinter", ("vor dem load_expr"));
d1998 1
a1998 1
                         DBUG_PRINT("rinter", ("nach dem load_expr"));
d2138 7
d4332 2
a4333 2
                         if (spec_failcase)
                           post_mortem("MKCASE occured in spec dad process...");
d4338 3
d4342 2
a4343 1
                                      if ((D_SIZEOFSTACK(ps_t)>0)&& (T_KLAA(TOP_T()))) {
d4345 2
a4346 1
                                      if ((SIZEOFSTACK(S_tilde)>0)&& (T_KLAA(TOP_T()))) {
d4348 1
d4351 1
d4355 1
d4357 1
d4845 1
a4845 1
    default:         sprintf(buf,"inter: invalid instruction (%d)",code[-1]);
@


1.68
log
@further work on speculative evaluation
@
text
@d2 3
d261 1
d578 4
d695 1
a695 1
DBUG_PRINT ("DUMP", ("A-Stack:"));
d706 1
a706 1
DBUG_PRINT ("DUMP", ("I_STACK:"));
d810 1
a810 1
                     SPEC_COUNTER_CODE(2)
d846 1
a846 1
                     SPEC_COUNTER_CODE(2)
d873 1
a873 1
                     SPEC_COUNTER_CODE(2)
d901 1
a901 1
                     SPEC_COUNTER_CODE(2)
d1123 1
a1123 1
                     SPEC_COUNTER_CODE(1)
d1201 1
a1201 1
                     SPEC_COUNTER_CODE(2)
d1230 1
a1230 1
                     SPEC_COUNTER_CODE(1)
d1246 1
a1246 1
                     SPEC_COUNTER_CODE(1)
d1264 1
a1264 1
                     SPEC_COUNTER_CODE(1)
d1277 1
a1277 1
                     SPEC_COUNTER_CODE(1)
d1291 1
a1291 1
                     SPEC_COUNTER_CODE(1)
d1661 1
d1663 10
d1679 9
d1767 1
d1778 1
a1778 1
                     SPEC_COUNTER_CODE(2)
d2311 5
d2606 5
d2613 3
d2617 1
d2619 1
d2621 26
d2648 1
a2648 1
                       /* this means it's the only one process around */
d2650 3
d2655 2
d2661 11
a2671 1
                     DBUG_RETURN (IR_WAIT); }
d2674 3
d2704 18
d2748 2
a2749 2
                      if (curr_pid->father_pid) { /* yes, it is... */
                        DBUG_PRINT("INTER", ("it's a SPEC_DAD process"));
d2777 2
a2778 3
                   if ((curr_pid->control->result) || T_SPEC_WINNER(curr_pid)) {
                     DBUG_PRINT("INTER", ("there's a result, don't do anything, fine."));
                     DBUG_PRINT("INTER", ("WRONG ! PUSH_W(specmask2) !!"));
d2780 1
a2780 1
                     /* First, insert the code for DROP which is left out all the time */
d2782 4
a2785 6
/*uh, 16.10.90*/     /* DROP */
/*uh, 16.10.90*/     /* entfernt das oberste Element P des Work-Stacks. Ist dieses Element e
in Zeiger */
/*uh, 16.10.90*/     /* auf einen Descriptor, so wird der Refcount behandelt. */
/*uh, 16.10.90*/                  ptdesc= (T_PTD)POP_W();
/*uh, 16.10.90*/                  if (ptdesc && T_POINTER(ptdesc)) DEC_REFCNT(ptdesc);
d2787 1
a2787 1
                     /* maybe there would have been a replace command... never mind... */
d2789 61
a2849 2
                     PUSH_W(curr_pid->specmask2);
                     } else {
a2850 1
                     }
d3586 3
d3616 3
d3620 1
d3629 3
d3633 1
d3679 2
a3680 2
#define IS_VAR_OR_CLOS_DESC(x)  ( (x)==C_EXPRESSION || (x)==C_CONSTANT) /* || \ */
/*uh, 16.10.90*/                                 /*   (x) == C_FUNC) */
d4059 3
d4070 3
d4074 1
d4084 5
d4099 2
a4100 1
/*uh, 16.10.90*/                  UPDATE_W(1,(STACKELEM)ptdesc); /* Refcount!!! */
d4106 1
a4106 1
/*uh, 16.10.90*/     /* diesen Wert auf dem Backtrack-Stack an die Stelle DEPTH. */
d4118 2
a4119 1
/*uh, 16.10.90*/                  UPDATE_W(arg,(STACKELEM)ptdesc); /* Refcount */
d4287 1
a4287 1
                         if (spec_failcase && (T_SPEC_LEAF(curr_pid)==1)) {
d4337 1
a4337 1
/*uh, 16.10.90*/                  arg = POP_W();
d4344 3
d4348 1
d4351 3
d4355 1
d4370 4
d4422 1
a4422 1
/*uh, 16.10.90*/                  UPDATE_A(arg,(STACKELEM)ptdesc);
d4447 3
d4451 3
d4530 3
d4713 1
d4724 1
a4724 1
                     SPEC_COUNTER_CODE(2)
d4732 1
d4743 1
a4743 1
                     SPEC_COUNTER_CODE(2)
d4846 2
a4847 1
  DBUG_PRINT ("INTER", ("descriptor: %d", (int) ptdesc));
d4874 5
d4968 5
d5000 5
d5468 5
@


1.67
log
@some additions supporting speculative evaluation
@
text
@d2 3
d255 5
d727 1
a727 1
    if (sig_msg_flag)
d729 6
d1118 2
a1119 1
                     arg = POP_W();                   /* arg:    praedikat   */
d2570 28
a2597 2
   case I_SPECRTF: /* returning from speculative process */
                   FUNC0("specrtf");
d2599 7
d2607 3
a2609 2
                   spec_send_winner(curr_pid->control_node, curr_pid->control_pid, curr_pid);
                   DBUG_RETURN (IR_WAIT);
d2611 6
d2622 1
d2626 29
a2655 1
                    PC_SET_SPECWAIT(curr_pid);
d2667 28
d4095 20
@


1.66
log
@warning removed
@
text
@d2 3
a234 3
#if TIME_SLICE
#include "spec_sched.h"
#endif
d244 4
d279 1
a279 1
#if ADV_SCHED
d282 2
d716 2
a717 1
#if ADV_SCHED
d721 1
d727 1
d730 1
d787 3
d823 3
d850 3
d878 3
a1085 1
                     arg = POP_W();                   /* arg:    praedikat   */
d1087 1
d1100 5
d1177 3
d1206 3
d1222 3
d1240 3
d1253 3
d1267 3
d1733 3
d2540 2
d2544 39
d4383 3
d4401 3
@


1.65
log
@#ifndef CAF_UPDATE: ignore I_UPDATE (instead of giving an error message)
@
text
@d2 3
d1243 2
a1244 2
                     ptdesc = *code;    /* ptc */
                     if (ptdesc)        /* update only once */
@


1.64
log
@#ifdef CAF_UPDATE : if the result of a beta call does not
depend on any environment (beta(0) and no tilde-frame), an
I_UPDATE-instruction is inserted after the I_BETA to update
the original function code with I_RTP result (I_RTC result).
@
text
@d2 6
a1235 1
#ifdef CAF_UPDATE
d1238 1
d1261 1
a1263 1
#endif /* CAF_UPDATE */
@


1.63
log
@using ++ in macro-arguments ? AAAAARGH ;-) fixed in I_BINDSUBL
@
text
@d2 3
d1230 28
@


1.62
log
@C_FUNC TY_CASE ptc's might be used to indicate the number of the when-clause
(bugfix for the distributed version)
@
text
@d2 4
d3938 4
a3941 2
/*uh, 16.10.90*/                  ptdesc     = (T_PTD)MID_R(*code++);
/*uh, 16.10.90*/                  (int)func  = (PTR_HEAPELEM)MID_R(*code++) - R_LIST(*ptdesc,ptdv); /* Start */
d3943 3
a3945 2
                                  help       = (int) MID_R(*code++);
                                  DBUG_PRINT ("INTER", ("(PTR_HEAPELEM)MID_R(*code++) = %x", help));
d3962 1
@


1.61
log
@ASM-instruction mkslot : 1 -> 0 parameters
@
text
@d2 3
d1743 1
a1743 1
                       L_NOMAT(*ptd,act_nomat) = (int)R_CASE(*ptdesc,ptc);
d1764 2
d1794 1
d1832 1
d1834 1
@


1.60
log
@some changes in I_WAIT
@
text
@d2 3
d1262 2
a1263 2
                     FUNC1("mkslot");
                     arity = *code++;
@


1.59
log
@some ADV_SCHED (advanced scheduling) changes for the distributed version
@
text
@d2 3
d692 1
a694 1
    sig_interrupt = 0;
@


1.58
log
@stack-access-macros moved to rstack.h (seq. and distributed version)
@
text
@d2 3
d250 6
d685 9
d696 1
d2293 5
d2370 8
@


1.57
log
@L_apply: case ptdesc == interaction inserted
@
text
@d2 3
d196 1
d346 1
a346 124
#ifdef  PUSH_A
#undef  PUSH_A
#endif

#if D_SLAVE             /* ach 04/01/92 */

#define POP_W()           D_POPSTACK(*ps_w)
#define PPOP_W()          D_PPOPSTACK(*ps_w)
#define TOP_W()           D_READSTACK(*ps_w)
#define PUSH_W(x)         D_PUSHSTACK(*ps_w,(x))
#define PPUSH_W(x)        D_PPUSHSTACK(*ps_w,(x))
#define WRITE_W(x)        D_WRITESTACK(*ps_w,(x))
#define MID_W(n)          D_MIDSTACK(*ps_w,n)
#define UPDATE_W(n,x)     D_UPDATESTACK(*ps_w,n,(x))

#define POP_A()           D_POPSTACK(*ps_a)
#define PPOP_A()          D_PPOPSTACK(*ps_a)
#define TOP_A()           D_READSTACK(*ps_a)
#define PUSH_A(x)         D_PUSHSTACK(*ps_a,(x))
#define PPUSH_A(x)        D_PPUSHSTACK(*ps_a,(x))
#define WRITE_A(x)        D_WRITESTACK(*ps_a,(x))
#define MID_A(x)          D_MIDSTACK(*ps_a,x)
#define UPDATE_A(n,x)     D_UPDATESTACK(*ps_a,n,(x))

#if WITHTILDE
#define POP_R()           D_POPSTACK(*ps_r)
#define PPOP_R()          D_PPOPSTACK(*ps_r)
#define TOP_R()           D_READSTACK(*ps_r)
#define PUSH_R(x)         D_PUSHSTACK(*ps_r,(x))
#define PPUSH_R(x)        D_PPUSHSTACK(*ps_r,(x))
#define WRITE_R(x)        D_WRITESTACK(*ps_r,(x))
#define MID_R(x)          D_MIDSTACK(*ps_r,(x))
#define UPDATE_R(n,x)     D_UPDATESTACK(*ps_r,n,(x))
#else
#define POP_R()           D_POPSTACK(D_S_R)
#define PPOP_R()          D_PPOPSTACK(D_S_R)
#define TOP_R()           D_READSTACK(D_S_R)
#define PUSH_R(x)         D_PUSHSTACK(D_S_R,(x))
#define PPUSH_R(x)        D_PPUSHSTACK(D_S_R,(x))
#define WRITE_R(x)        D_WRITESTACK(D_S_R,(x))
#define MID_R(x)          D_MIDSTACK(D_S_R,(x))
#define UPDATE_R(n,x)     D_UPDATESTACK(D_S_R,n,(x))
#endif /* WITHTILDE */

#define POP_E()           D_POPSTACK(D_S_H)
#define PPOP_E()          D_PPOPSTACK(D_S_H)
#define TOP_E()           D_READSTACK(D_S_H)
#define PUSH_E(x)         D_PUSHSTACK(D_S_H,(x))
#define PPUSH_E(x)        D_PPUSHSTACK(D_S_H,(x))
#define WRITE_E(x)        D_WRITESTACK(D_S_H,(x))
#define MID_E(x)          D_MIDSTACK(D_S_H,(x))
#define UPDATE_E(n,x)     D_UPDATESTACK(D_S_H,n,(x))

#if WITHTILDE
#define POP_T()           D_POPSTACK(*ps_t)
#define PPOP_T()          D_PPOPSTACK(*ps_t)
#define TOP_T()           D_READSTACK(*ps_t)
#define PUSH_T(x)         D_PUSHSTACK(*ps_t,(x))
#define PPUSH_T(x)        D_PPUSHSTACK(*ps_t,(x))
#define WRITE_T(x)        D_WRITESTACK(*ps_t,(x))
#define MID_T(x)          D_MIDSTACK(*ps_t,(x))
#define UPDATE_T(n,x)     D_UPDATESTACK(*ps_t,n,(x))
#endif /* WITHTILDE */

#else

#define POP_W()           POPSTACK(*ps_w)
#define PPOP_W()          PPOPSTACK(*ps_w)
#define TOP_W()           READSTACK(*ps_w)
#define PUSH_W(x)         PUSHSTACK(*ps_w,(x))
#define PPUSH_W(x)        PPUSHSTACK(*ps_w,(x))
#define WRITE_W(x)        WRITESTACK(*ps_w,(x))
#define MID_W(n)          MIDSTACK(*ps_w,n)
#define UPDATE_W(n,x)     UPDATESTACK(*ps_w,n,(x))

#define POP_A()           POPSTACK(*ps_a)
#define PPOP_A()          PPOPSTACK(*ps_a)
#define TOP_A()           READSTACK(*ps_a)
#define PUSH_A(x)         PUSHSTACK(*ps_a,(x))
#define PPUSH_A(x)        PPUSHSTACK(*ps_a,(x))
#define WRITE_A(x)        WRITESTACK(S_i,(x))
#define MID_A(x)          MIDSTACK(*ps_a,x)
#define UPDATE_A(n,x)     UPDATESTACK(*ps_a,n,(x))

#if WITHTILDE
#define POP_R()           POPSTACK(*ps_r)
#define PPOP_R()          PPOPSTACK(*ps_r)
#define TOP_R()           READSTACK(*ps_r)
#define PUSH_R(x)         PUSHSTACK(*ps_r,(x))
#define PPUSH_R(x)        PPUSHSTACK(*ps_r,(x))
#define WRITE_R(x)        WRITESTACK(*ps_r,(x))
#define MID_R(x)          MIDSTACK(*ps_r,(x))
#define UPDATE_R(n,x)     UPDATESTACK(*ps_r,n,(x))
#else
#define POP_R()           POPSTACK(S_m)
#define PPOP_R()          PPOPSTACK(S_m)
#define TOP_R()           READSTACK(S_m)
#define PUSH_R(x)         PUSHSTACK(S_m,(x))
#define PPUSH_R(x)        PPUSHSTACK(S_m,(x))
#define WRITE_R(x)        WRITESTACK(S_m,(x))
#define MID_R(x)          MIDSTACK(S_m,(x))
#define UPDATE_R(n,x)     UPDATESTACK(S_m,n,(x))
#endif /* WITHTILDE */

#define POP_E()           POPSTACK(S_e)
#define PPOP_E()          PPOPSTACK(S_e)
#define TOP_E()           READSTACK(S_e)
#define PUSH_E(x)         PUSHSTACK(S_e,(x))
#define PPUSH_E(x)        PPUSHSTACK(S_e,(x))
#define WRITE_E(x)        WRITESTACK(S_e,(x))
#define MID_E(x)          MIDSTACK(S_e,(x))
#define UPDATE_E(n,x)     UPDATESTACK(S_e,n,(x))

/* mah 261093 */
#if WITHTILDE
#define POP_T()           POPSTACK(*ps_t)
#define PPOP_T()          PPOPSTACK(*ps_t)
#define TOP_T()           READSTACK(*ps_t)
#define PUSH_T(x)         PUSHSTACK(*ps_t,(x))
#define PPUSH_T(x)        PPUSHSTACK(*ps_t,(x))
#define WRITE_T(x)        WRITESTACK(*ps_t,(x))
#define MID_T(x)          MIDSTACK(*ps_t,(x))
#define UPDATE_T(n,x)     UPDATESTACK(*ps_t,n,(x))
#endif /* WITHTILDE */
a347 1
#endif /* D_SLAVE */
@


1.56
log
@introduced ASM-instructions to build frames (I_MKFRAME) and slots (I_MKSLOT)
@
text
@d2 3
d5057 27
@


1.55
log
@S_tilde unknown in D_SLAVE-Version
@
text
@d2 3
d1346 32
@


1.54
log
@interactions supported
@
text
@d2 3
d3888 3
d3892 1
@


1.53
log
@some pvm changes...
@
text
@d2 3
d934 24
d1475 12
d4540 23
@


1.52
log
@bug from last revision fixed
@
text
@d2 3
d783 1
d786 2
a787 1
#endif
@


1.51
log
@useless label removed
@
text
@d2 3
d1974 1
a1974 1
/* label seems of no need any more: car 7/3/95
d1976 1
a1976 1
*/
@


1.50
log
@changed nCUBE to D_SLAVE
@
text
@d2 3
d1971 1
d1973 1
@


1.49
log
@UH-PM "in etc. bugfix
@
text
@d2 3
d163 1
a163 1
#if nCUBE
d178 1
a178 1
#if nCUBE
d191 1
a191 1
#if nCUBE
d199 1
a199 1
#if (!nCUBE)
d215 1
a215 1
#if nCUBE
d274 1
a274 1
#if nCUBE
d291 1
a291 1
#if nCUBE                  /* ach 04/01/93: Bei dynamischer Stackverwaltung werden andere Typen benutzt */
d325 1
a325 1
#if nCUBE               /* ach 04/01/92 */
d446 1
a446 1
#endif /* nCUBE */
d460 1
a460 1
#if nCUBE
d540 1
a540 1
#if nCUBE
d635 1
a635 1
#if nCUBE
d675 1
a675 1
#if (!nCUBE)
d685 1
a685 1
#endif /* !nCUBE */
d687 1
a687 1
#if (DEBUG && !nCUBE)
d722 1
a722 1
#if nCUBE
d730 1
a730 1
#  if nCUBE
d735 1
a735 1
#if nCUBE
d764 1
a764 1
#if nCUBE
d768 1
a768 1
#if (nCUBE && TIME_SLICE)    /* check for timeout */
d771 1
a771 1
#endif /* nCUBE && TIME_SLICE */
d773 1
a773 1
#if nCUBE
d2300 1
a2300 1
#if nCUBE
d2317 2
a2318 2
#if nCUBE
#if (nCUBE && D_MESS && D_MSCHED)  /*** HIER MUSS RS VIELLEICHT NOCH WAS AENDERN!!! ***/
d2333 1
a2333 1
#endif /* nCUBE */
d2338 1
a2338 1
#if nCUBE
d2349 1
a2349 1
#if (nCUBE && D_MESS && D_MCOMMU)
d2372 1
a2372 1
#if nCUBE
d2393 1
a2393 1
#if nCUBE
d2410 2
a2411 2
#if nCUBE
#if (nCUBE && D_MESS && D_MSCHED) /*** HIER MUSS RS VIELLEICHT NOCH WAS AENDERN!!! ***/
d2426 1
a2426 1
#endif  /* nCUBE */
d2443 1
a2443 1
#if nCUBE
d2456 1
a2456 1
#if nCUBE
d2467 1
a2467 1
#if nCUBE
d2478 1
a2478 1
#if nCUBE
d2489 1
a2489 1
#if nCUBE
d2500 1
a2500 1
#if nCUBE
d2515 1
a2515 1
#if nCUBE
d2526 1
a2526 1
#if nCUBE
d2538 1
a2538 1
#if nCUBE
d2548 1
a2548 1
#if nCUBE
d2561 1
a2561 1
#if nCUBE
d2576 1
a2576 1
#if nCUBE
d2587 1
a2587 1
#if nCUBE
d2598 1
a2598 1
#if nCUBE
d2609 1
a2609 1
#if nCUBE
d2624 1
a2624 1
#if nCUBE
d2636 1
a2636 1
#if nCUBE
d2648 1
a2648 1
#if nCUBE
d2660 1
a2660 1
#if nCUBE
d2676 1
a2676 1
#if nCUBE
d2687 1
a2687 1
#if nCUBE
d2698 1
a2698 1
#if nCUBE
d2709 1
a2709 1
#if nCUBE
d4302 1
a4302 1
#if !nCUBE
d4312 1
a4312 1
#endif /* !nCUBE */
d4316 2
a4317 2
#if nCUBE
#if (nCUBE && D_MESS && D_MCOMMU)
d4604 1
a4604 1
#if (nCUBE && D_MESS && D_MHEAP)
d4761 1
a4761 1
#if nCUBE
d4850 1
a4850 1
#if (nCUBE && D_MESS && D_MHEAP)
d4979 1
a4979 1
/*#if nCUBE
d5027 1
a5027 1
#if nCUBE
d5038 1
a5038 1
#if nCUBE
d5053 1
a5053 1
#if nCUBE
d5063 1
a5063 1
#if nCUBE
@


1.48
log
@thete's something wrong with BINDSUBLIST depending on the direction of the matching :-((
(errr, make that THERE's ! :-)
@
text
@d2 4
d3911 1
a3911 1
                                  help       = (PTR_HEAPELEM)MID_R(*code++);
d4016 2
@


1.47
log
@various bugfixes and new features concerning UH's patternmatching
@
text
@d2 3
d3906 5
a3910 1
/*uh, 16.10.90*/                  help       = (PTR_HEAPELEM)MID_R(*code++) - R_LIST(*ptdesc,ptdv) - 1; /* ende */
@


1.46
log
@DIGIT and SCALAR added (UH-PM)
@
text
@d2 3
d1958 1
a3291 3
/*uh, 16.10.90*/                  if (_redcnt < beta_count) goto matchint_undecided;
/*uh, 16.10.90*/                  _redcnt -= beta_count;
/*uh, 16.10.90*/
a3329 3
/*uh, 16.10.90*/                  if (_redcnt < beta_count) goto matchreal_undecided;
/*uh, 16.10.90*/                  _redcnt -= beta_count;
/*uh, 16.10.90*/
a3364 3
/*uh, 16.10.90*/                  if (_redcnt < beta_count) goto matchdigit_undecided;
/*uh, 16.10.90*/                  _redcnt -= beta_count;
/*uh, 16.10.90*/
d3830 1
a3830 2
                                      ptdesc = (T_PTD) code; 
                                      goto L_casefail;
d3834 11
a3844 1
/*uh, 16.10.90*/  case I_JBOOL:   /* FAIL UNDECIDED ( W: value -- ) */
d3850 1
a3850 2
/*uh, 16.10.90*/                  FUNC3("jbool");
                                  help = (int) *code++;
d3854 1
a3854 1
/*uh, 16.10.90*/                  if (IS_TRUE(arg)) goto loop;
d3856 1
d3859 7
a3865 2
                                     /* PUSH_W(HASH);  for MKCASE, but pm-variables on stack A would be freed... :-( */
                                     PUSH_R(SET_VALUE(DOLLAR,(int)help));
@


1.45
log
@removed some warnings...
@
text
@d2 3
d220 1
d1731 1
a1731 1
                       L_NOMAT(*ptd,act_nomat) = 1;
d3320 79
a3555 27
/*uh, 16.10.90*/  case I_MATCHNILS:  /* matching eines nilstrings, neu von rs 1995 */
/*uh, 16.10.90*/      /* MATCHNIL "MATCH-NILS" */
/*uh, 16.10.90*/                  FUNC2("matchnils");
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  ARG2=TOP_W();
/*uh, 16.10.90*/
/*uh, 16.10.90*/                  if (T_POINTER(ARG2)) {
/*uh, 16.10.90*/                    help = R_DESC(*(T_PTD)ARG2,class);
/*uh, 16.10.90*/                    if (IS_VAR_OR_CLOS_DESC(help)) goto matchnils_undecided;
/*uh, 16.10.90*/                    if ((T_PTD)ARG2==_nilstring) goto matchnils_succeed;
/*uh, 16.10.90*/                  }
/*uh, 16.10.90*/
/*uh, 16.10.90*/     /*        matchnils_fail: */
/*uh, 16.10.90*/                  code = (int *)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchnils_undecided:
                                  PUSH_T (KLAA);
/*uh, 16.10.90*/                  code+=1;
/*uh, 16.10.90*/                  code = (int*)*code;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/
/*uh, 16.10.90*/               matchnils_succeed:
/*uh, 16.10.90*/                  code+=2;
/*uh, 16.10.90*/                  goto loop;
/*uh, 16.10.90*/

d3849 1
a3849 1
/*uh, 16.10.90*/                  UNDECIDED = *code++;
d3855 5
a3859 5
                                     /* PUSH_W(HASH); */
                                     /* PUSH_R(SET_VALUE(DOLLAR,(int)help));
                                     goto L_undecided; BIG HACK :-) */
                                     PUSH_T(KLAA);
/*uh, 16.10.90*/                     code = (int*)UNDECIDED; }
@


1.44
log
@minor bugfix in uh's pm
@
text
@d2 3
d215 4
a489 7
#define FUNC3(x)          if (OutInstr && debdisplay) { \
/*uh, 31.10.90*/                              NEXTINSTR(); \
/*uh, 31.10.90*/                              printf("%s(%1d, %1d, %1d)             \n",\
/*uh, 31.10.90*/                                     x,*code,*(code+1),*(code+2)); \
/*uh, 31.10.90*/                            }\
/*uh, 31.10.90*/                            fprintf(TraceFp,"%s(%1d,%1d,%1d);\n",\
/*uh, 31.10.90*/                                    x,*code,*(code+1),*(code+2))
d2795 1
a2795 1
/*dguh, 27.07.90*/                POP_E();                  /* nil */
d2835 1
a2835 1
/*dguh, 27.07.90*/                POP_W();
d2843 1
a2843 1
/*dguh, 27.07.90*/                   POP_W();
d2854 1
a2854 1
/*dguh, 27.07.90*/                   POP_W();
d2885 1
a2885 1
/*dguh, 27.07.90*/                  POP_E();
d2897 1
a2897 1
/*dguh, 27.07.90*/                  POP_E();
d3017 1
a3017 1
/*dguh, 27.07.90*/                  POP_E();
d3029 1
a3029 1
/*dguh, 27.07.90*/                  POP_E();
d3170 1
a3170 1
/*uh, 16.10.90*/                     POP_W() ;   /* Refcount-Behandlung???? */
d3179 1
a3179 1
/*uh, 16.10.90*/                     POP_R() ;   /* Refcount-Behandlung???? */
d3213 1
a3213 1
                                  *pth = ptdesc; 
d3458 1
a3458 1
/*uh, 16.10.90*/               matchnil_fail:
d3485 1
a3485 1
/*uh, 16.10.90*/               matchnils_fail:
d3521 1
a3521 1
/*uh, 16.10.90*/               matchprim_fail:
d3779 1
a3779 1
                                      ptdesc = code; 
@


1.43
log
@SELECTION-descriptors used only in preprocessing
@
text
@d2 3
d3772 1
a3772 1
                                      if (T_KLAA(TOP_T())) {
d3779 1
@


1.42
log
@UH PM GAMMA and GAMMACASE 0 red step
@
text
@d2 3
d4581 3
a4583 3
#if UH_ZF_PM
          arity = R_CASE(*ptdesc,nargs) - R_SWITCH(*(T_PTD)R_CLAUSE(*(T_PTD)R_SELECTION(*R_CASE(*ptdesc,ptd),clauses),sons)[3],anz_args);
#else
d4585 1
a4585 1
#endif /* UH_ZF_PM */
@


1.41
log
@now MATCHLIST REALLY matches lists ! :-)
no more UNDECIDED matching if the argument is a
(unnamed) function (as in old PM)
@
text
@d2 5
d1624 1
a1624 1
                    post_mortem ("UH_PM: no _redcounting yet !");
a1628 1
#if !UH_ZF_PM
a1629 1
#endif /* UH_ZF_PM */
d4152 1
a4152 1
                    post_mortem ("UH_PM: no _redcounting yet !");
@


1.40
log
@minor changes
@
text
@d2 3
d3216 2
a3217 2
#define IS_VAR_OR_CLOS_DESC(x)  ( (x)==C_EXPRESSION || (x)==C_CONSTANT || \
/*uh, 16.10.90*/                                    (x) == C_FUNC)
d3658 3
a3660 2
/*uh, 16.10.90*/                    if (R_DESC(*(T_PTD)ARGUMENT,class)== C_LIST &&
/*uh, 16.10.90*/                        R_LIST(*(T_PTD)ARGUMENT,dim) >= LEN) goto loop;
d3713 1
d4148 3
@


1.39
log
@stackelem == stackelem (UH's sourcecode)
UARGH !
...corrected...
@
text
@d2 5
d1385 2
d1395 1
d1413 2
d1436 2
d1446 1
d1477 1
d1479 1
d1495 1
d1506 2
d1927 1
d1966 1
d3755 2
@


1.38
log
@UH PM bugfix -> BINDSUBL now generates an empty string
@
text
@d2 3
d3873 1
d3876 2
a3877 2
/*uh, 16.10.90*/                     if (ARGUMENT == *((PTR_HEAPELEM)ptdesc)++) goto loop;
/*uh, 16.10.90*/                  }
@


1.37
log
@bugfix in single when
@
text
@d2 3
d3802 6
a3807 2
/*uh, 16.10.90*/                     ptdesc = _nil;
/*uh, 16.10.90*/                     INC_REFCNT(_nil);
@


1.36
log
@UH String PM implemented
@
text
@d2 3
a3720 2
/*uh, 16.10.90*/         int i,free_args;  /* Anzahl der freien Variablen */
/*uh, 16.10.90*/         T_PTD casedesc, closedesc; 
a3721 1
/*uh, 16.10.90*/         /* post_mortem("CASE-closures z.Zt. nicht unterstuetzt."); */
a3725 6
/*uh, 16.10.90*/         /* Da das umfassende SUB im Preprozessor schon geschlossen  */
/*uh, 16.10.90*/         /* wurde, liegen die an die relativ freien Variablen gebundenen */
/*uh, 16.10.90*/         /* Werte im erweiterten Stack-Frame unmittelbar unterhalb der */
/*uh, 16.10.90*/         /* Pattern-Variablen selbst. (Stack I) */
/*uh, 16.10.90*/         /* Es gilt also deren Anzahl zu ermitteln, damit das Paket in */
/*uh, 16.10.90*/         /* der richtigen Groesse gepackt werden kann... */
a3727 1
/*uh, 16.10.90*/                   /* casedesc=(T_PTD)*code++;  */ /* CASE-Descriptor */
a3738 60
                         /*              goto L_casefail; */
/*uh, 16.10.90*/                      free_args=(int)R_CASE(*casedesc,nargs)-1;
/*uh, 16.10.90*/
                          post_mortem("inter: UH-MKCASE reached, great ! :-( ");
/*uh, 16.10.90*/          printf("Es sollten %d relativ freie Variablen vorhanden sein!\n",free_args);
/*uh, 16.10.90*/
/*uh, 16.10.90*/            /* Neuen SELECTION-Descriptor erzeugen, der wie der bisherige SELECTION */
/*uh, 16.10.90*/            /* aufgebaut ist, dessen OTHERWISE aber nun neu gemacht werden muss */
/*uh, 16.10.90*/            /* (Applikation mit aktuellem Argument) */
/*uh, 16.10.90*/                      help = (int)R_CASE(*casedesc,ptd);  /* SELECTION-Descriptor */
/*uh, 16.10.90*/
/*uh, 16.10.90*/                      MAKEDESC(ptdesc,1,C_MATCHING,TY_SELECTION);
/*uh, 16.10.90*/                   /* L_SELECTION(*ptdesc,nclauses)=R_SELECTION(*(T_PTD)help,nclauses); */
/*uh, 16.10.90*/                      L_SELECTION(*ptdesc,clauses)=(T_PTD)arg=
/*uh, 16.10.90*/                                                     R_SELECTION(*(T_PTD)help,clauses);
/*uh, 16.10.90*/                      if ((T_PTD)arg) INC_REFCNT((T_PTD)arg);
/*uh, 16.10.90*/
/*uh, 16.10.90*/
/*uh, 16.10.90*/                      help=(int)R_SELECTION(*(T_PTD)help,otherwise);
/*uh, 16.10.90*/                      if (help && R_DESC(*(T_PTD)help,type)==TY_CASE)
/*uh, 16.10.90*/                       /* Otherwise ist direct ein CASE-Ausdruck und kein EXPRESSION Desc */
/*uh, 16.10.90*/                       /* => AP einflicken */ {
/*uh, 16.10.90*/                        MAKEDESC((T_PTD)arg,1,C_EXPRESSION,TY_EXPR);
/*uh, 16.10.90*/                        GET_HEAP(4,A_EXPR(*(T_PTD)arg,pte)); /* Platz fuer @@ x y */
/*uh, 16.10.90*/                        pth=R_EXPR(*(T_PTD)arg,pte);
/*uh, 16.10.90*/                        RES_HEAP;  /* Fuelle Heapblock  */
/*uh, 16.10.90*/                        *pth++ = 3;                   /* Laenge */
/*uh, 16.10.90*/                        *pth++ = SET_ARITY(AP,2);
/*uh, 16.10.90*/                        *pth++ = TOP_A();            /* Argument */
/*uh, 16.10.90*/                        if (T_POINTER(TOP_A())) INC_REFCNT((T_PTD)TOP_A());
/*uh, 16.10.90*/                        *pth++ = help;                /* CASE-Descriptor */
/*uh, 16.10.90*/                        REL_HEAP;
/*uh, 16.10.90*/                        L_SELECTION(*ptdesc,otherwise)=(T_PTD)arg;
/*uh, 16.10.90*/                      } else { /* ansonsten einfach so eintragen */
/*uh, 16.10.90*/                        L_SELECTION(*ptdesc,otherwise)=(T_PTD)help;
/*uh, 16.10.90*/                        if (help && T_POINTER(help)) INC_REFCNT((T_PTD)help);
/*uh, 16.10.90*/                      }
/*uh, 16.10.90*/
/*uh, 16.10.90*/         /* Dann die relativ freien Variablen binden */
/*uh, 16.10.90*/
/*uh, 16.10.90*/                      /* Erzeuge einen Ausdruck der Form  @@ arg CASE */
/*uh, 16.10.90*/                      /* Zuerst also CASE-Descriptor erzeugen */
/*uh, 16.10.90*/                      MAKEDESC(closedesc,1,C_FUNC,TY_CLOS);
/*uh, 16.10.90*/                      L_CLOS(*closedesc,args)=R_CASE(*casedesc,nargs);
/*uh, 16.10.90*/                      L_CLOS(*closedesc,nargs)=R_CASE(*casedesc,nargs)-1;
/*uh, 16.10.90*/                      L_CLOS(*closedesc,ftype)=TY_SELECTION;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                      /* Argumentvektor fuellen: Struktur:  SELdesc|args|casearg */
/*uh, 16.10.90*/                      GET_HEAP(free_args+3,A_CLOS(*closedesc,pta));
/*uh, 16.10.90*/                      pth=R_CLOS(*closedesc,pta);
/*uh, 16.10.90*/                      RES_HEAP;
/*uh, 16.10.90*/                    *pth++= (int)ptdesc;  /* Der neue SELECTION-Desc */
/*uh, 16.10.90*/                      /* Hier unterscheiden, ob Argumente verbraucht werden duerfen */
/*uh, 16.10.90*/                      /* for (i=0; i<free_args; i++)  *pth++ = MID_I(i); */
/*uh, 16.10.90*/                      for (i=0; i<free_args; i++)  *pth++ = POP_W();
/*uh, 16.10.90*/                      *pth++= POP_A();      /* Das CASE-Argument */
/*uh, 16.10.90*/                      REL_HEAP;
/*uh, 16.10.90*/
/*uh, 16.10.90*/                      PUSH_A(closedesc);         /* Closure ist Ergebnis */
/*uh, 16.10.90*/                      goto loop;
@


1.35
log
@MKIFRAME -> MKAFRAME
@
text
@a0 1

d2 3
d3150 2
d3156 21
d3220 1
d3266 1
d3307 1
d3348 1
d3390 1
d3422 1
d3431 28
d3485 1
d3632 24
d3662 1
d3685 24
d3715 1
d3719 1
a3719 1
/*uh, 16.10.90*/         T_PTD casedesc, closedesc;
d3737 9
a3745 2
                                      PUSH_W (KLAA);
                                      goto L_undecided;
d3814 2
a3815 1
/*uh, 16.10.90*/                  FUNC2("jbool");
d3820 8
a3827 4
/*uh, 16.10.90*/                  if (IS_FALSE(arg))
/*uh, 16.10.90*/                     code = (int*)FAIL;
/*uh, 16.10.90*/                  else
/*uh, 16.10.90*/                     code = (int*)UNDECIDED;
d3875 1
d3925 1
@


1.34
log
@UH PM using 4 stacks
@
text
@d3 3
d3112 2
a3113 2
/*uh, 16.10.90*/  case I_MKIFRAME:  /* size ( I x -- x 1(1) 1(2) ... 1(size) ) */
/*uh, 16.10.90*/    /* MKIFRAME "MaKeInkanationFrame" */
@


1.33
log
@uh pm bugfixes
@
text
@d3 3
d3105 1
a3105 1
/*uh, 16.10.90*/                     PUSH_E(1); /* 1 wegen RefCount Behandlung (eg. kein Pointer) */
d3133 1
a3133 1
/*uh, 16.10.90*/                     POP_E() ;   /* Refcount-Behandlung???? */
d3485 1
a3485 1
/*uh, 16.10.90*/                  ptdesc = (T_PTD)MID_E(arg+BTPTR);
d3495 1
a3495 1
/*uh, 16.10.90*/                  UPDATE_E(arg+BTPTR,MID_W(1));
d3712 1
a3712 1
/*uh, 16.10.90*/                  UPDATE_E(arg,help);
d3715 1
a3715 1
/*uh, 16.10.90*/                  UPDATE_E(arg,help);
d3726 1
a3726 1
/*uh, 16.10.90*/                  UPDATE_E(arg,help);
d3735 3
a3737 3
/*uh, 16.10.90*/                  ptdesc     = (T_PTD)MID_E(*code++);
/*uh, 16.10.90*/                  (int)func  = (PTR_HEAPELEM)MID_E(*code++) - R_LIST(*ptdesc,ptdv); /* Start */
/*uh, 16.10.90*/                  help       = (PTR_HEAPELEM)MID_E(*code++) - R_LIST(*ptdesc,ptdv) - 1; /* ende */
d3766 1
a3766 1
/*uh, 16.10.90*/                  UPDATE_E(arg,ptdesc);   /* Start */
d3769 1
a3769 1
/*uh, 16.10.90*/                  UPDATE_E(arg,ptdesc);     /* Ptr */
d3773 1
a3773 1
/*uh, 16.10.90*/                  UPDATE_E(arg,(STACKELEM)ptdesc);   /* Descriptor */
d3778 1
a3778 1
/*uh, 16.10.90*/                  UPDATE_E(arg,help);     /* End */
d3817 1
a3817 1
/*uh, 16.10.90*/                  if (MID_E(arg)<MID_W(1)) { /* running pointer at start */
d3831 1
a3831 1
/*uh, 16.10.90*/                  if (MID_E(arg)>MID_W(1)) { /* running pointer at start */
d4569 3
@


1.32
log
@uh pm changes
@
text
@d3 3
d4471 3
d4475 1
@


1.31
log
@UH PM bugfixes
@
text
@d3 3
d1676 3
d1680 2
@


1.30
log
@more UH bugfixlike changes
@
text
@d3 3
d1574 4
a1578 3
#if UH_ZF_PM
                     POST_MORTEM("cannot close case yet!");
#endif
d1580 1
d1582 1
d1694 1
d3610 1
d3612 1
@


1.29
log
@UH patternmatch bugfixes
@
text
@d3 3
d1658 1
d1668 1
d1670 2
d3600 1
a3600 1
/*uh, 16.10.90*/                      casedesc=(T_PTD)*code++;   /* CASE-Descriptor */
d3602 2
@


1.28
log
@UH PM bugfixes
@
text
@d3 3
d1569 3
a4147 15
#if UH_ZF_PM
       PPOP_A();                 /* case weg von a */
        DEC_REFCNT(ptdesc);       /* wird nicht frei! */
        ptdesc = (T_PTD)R_CASE(*ptdesc,ptc); /* pc holen */
        COMM0("case");

        if (_redcnt >= delta_count) {
           _redcnt -= delta_count;
           PUSH_R(code);
           SET_TAIL_FLAG();
           code = (INSTR *)ptdesc;       /* subroutine call   */
           goto loop;
        }
        POST_MORTEM("cannot close case yet!");
#else
a4152 1
#endif /* UH_ZF_PM */
@


1.27
log
@more UH PM stuff
@
text
@d3 3
d3077 1
a3077 1
/*uh, 16.10.90*/    /* legt auf dem Inkarnations-Stack I ein Frame der Groesse SIZE an, in das die */
d3223 1
a3223 1
/*uh, 16.10.90*/                  ARG2=TOP_A();
d3263 1
a3263 1
/*uh, 16.10.90*/                  ARG2=TOP_A();
d3304 1
a3304 1
/*uh, 16.10.90*/                  ARG2=TOP_A();
d3374 1
a3374 1
/*uh, 16.10.90*/                  ARG2=TOP_A() & ~F_EDIT;
d3402 3
a3404 3
/*uh, 16.10.90*/                  arg = (int) (((PTR_HEAPELEM)MID_A(1)) - help);
/*uh, 16.10.90*/                  UPDATE_A(1,arg); /* uh 04 Okt 91 */
/*uh, 16.10.90*/                  /* MID_A(1)= (STACKELEM)arg; */
d3414 1
a3414 1
/*uh, 16.10.90*/                  /* MID_A(1)= (STACKELEM)arg; */
d3441 2
a3442 2
/*uh, 16.10.90*/                  arg = (int) (MID_A(arg));
/*uh, 16.10.90*/                  WRITE_A(arg);   /* Refcount */
d3452 1
a3452 1
/*uh, 16.10.90*/                  UPDATE_A(1,(STACKELEM)ptdesc); /* Refcount!!! */
d3461 1
a3461 1
/*uh, 16.10.90*/                  UPDATE_E(arg+BTPTR,MID_A(1));
d3486 1
a3486 1
/*uh, 16.10.90*/                  ptdesc = (T_PTD) (TOP_A());
d3493 1
a3493 1
/*uh, 16.10.90*/                  UPDATE_A(1,(STACKELEM)arg);
d3526 1
a3526 1
/*uh, 16.10.90*/                  ARGUMENT=TOP_A();
d3591 1
d3673 1
a3673 1
/*uh, 16.10.90*/                  help = TOP_A();
d3676 1
a3676 1
/*uh, 16.10.90*/                  help = MID_A(1);
d3687 1
a3687 1
/*uh, 16.10.90*/                  help = MID_A(1);      /* Zeiger auf noch gematchtes Element */
d3710 1
a3710 1
/*uh, 16.10.90*/                  UPDATE_W(arg,(STACKELEM)ptdesc);
d3726 1
a3726 1
/*uh, 16.10.90*/                  ptdesc = (T_PTD)MID_A(1);      /* Zeiger auf noch gematchtes Element */
d3733 1
a3733 1
/*uh, 16.10.90*/                  ptdesc = (T_PTD)TOP_A();
d3756 1
a3756 1
/*uh, 16.10.90*/                  ARGUMENT=TOP_A();
d3779 1
a3779 1
/*uh, 16.10.90*/                  if (MID_E(arg)<MID_A(1)) { /* running pointer at start */
d3793 1
a3793 1
/*uh, 16.10.90*/                  if (MID_E(arg)>MID_A(1)) { /* running pointer at start */
d3804 1
a3804 1
/*uh, 16.10.90*/                  arg = TOP_A();
d3807 1
a3807 1
/*uh, 16.10.90*/                  WRITE_A(help);
@


1.26
log
@more UH pm stuff
@
text
@d3 3
d3055 1
a3055 1
/*uh, 16.10.90*/                  arg = TOP_A();
d3057 1
a3057 1
/*uh, 16.10.90*/                     PUSH_A(0);
d3059 1
a3059 1
/*uh, 16.10.90*/                  PUSH_A(arg);   /* Refcount Behandlung???? */
d3078 1
a3078 1
/*uh, 16.10.90*/                     PUSH_A(1);  /* 1 wegen Refcount-Behandlung (kein Pointer) */
d3087 1
a3087 1
/*uh, 16.10.90*/                     POP_A() ;   /* Refcount-Behandlung???? */
d3339 1
a3339 1
/*uh, 16.10.90*/                  ARG2=TOP_A();
d3409 2
a3410 2
/*uh, 16.10.90*/                  arg = (int) (((PTR_HEAPELEM)MID_A(1)) + help);
/*uh, 16.10.90*/                  UPDATE_A(1,arg);  /* uh 04 Okt 91 */
d3419 2
a3420 2
/*uh, 16.10.90*/                  ptdesc = (T_PTD)(*((PTR_HEAPELEM)MID_A(1)));
/*uh, 16.10.90*/                  WRITE_A((STACKELEM)ptdesc);
d3462 1
a3462 1
/*uh, 16.10.90*/     /*    Sichert den aktuellen Macthzeiger im Stackframe an der Stelle DEPTH-1. */
d3466 2
a3467 2
/*uh, 16.10.90*/                  ptdesc = (T_PTD)MID_A(1);
/*uh, 16.10.90*/                  UPDATE_A(arg,(STACKELEM)ptdesc); /* Refcount */
d3475 2
a3476 2
/*uh, 16.10.90*/                  ptdesc = (T_PTD)MID_A(arg);
/*uh, 16.10.90*/                  UPDATE_A(1,(STACKELEM)ptdesc); /* Refcount!!! */
d3498 1
a3498 1
/*uh, 16.10.90*/                  ptdesc = (T_PTD) (TOP_A());
d3508 1
a3508 1
/*uh, 16.10.90*/                  UPDATE_A(1,(STACKELEM)arg);
d3551 1
a3551 1
/*uh, 16.10.90*/                  ARGUMENT=TOP_A();
d3648 1
a3648 1
/*uh, 16.10.90*/    /* Testet den obersetn Wert VALUE des Work-Stacks. Ist er TRUE, so wird  */
d3655 1
a3655 1
/*uh, 16.10.90*/                  arg = POP_A();
@


1.25
log
@DYADIC instruction mkdclos
@
text
@d3 3
d3075 1
a3075 1
/*uh, 16.10.90*/                     PUSH_I(1);  /* 1 wegen Refcount-Behandlung (kein Pointer) */
d3104 1
a3104 1
/*uh, 16.10.90*/                  ptdesc = (T_PTD)TOP_A();
d3107 1
a3107 1
/*uh, 16.10.90*/                  UPDATE_W(arg,(STACKELEM)ptdesc);
d3131 1
a3131 1
/*uh, 16.10.90*/                  ARG2=TOP_A();
d3140 1
a3140 1
/*uh, 16.10.90*/                     /* Behandlung von TOP_A == C_SCALAR-Descriptor */
d3172 1
a3172 1
/*uh, 16.10.90*/                  ARG2=TOP_A();
d3425 1
a3425 1
/*uh, 16.10.90*/                  ptdesc= (T_PTD)POP_A();
@


1.24
log
@UH_ZF_PM + Tilde
@
text
@d3 3
a1348 3
#if WITHTILDE
		     FUNC3("mkdclos");
#else
a1349 1
#endif /* WITHTILDE */
d1353 1
a1353 1
		     nfv   = *code++;
@


1.23
log
@*** empty log message ***
@
text
@d3 3
d1543 1
a1543 1
#if !UH_ZF_PM
d1939 1
a1939 1
#endif /* UH_ZF_PM */
@


1.22
log
@core UH_ZF_PM source integrated
@
text
@d3 3
d3102 1
a3102 1
/*uh, 16.10.90*/                  UPDATE_I(arg,(STACKELEM)ptdesc);
d3157 1
a3157 1
/*uh, 16.10.90*/      /* Vergleicht das oberste Element X des Work-Stacks mit der Integer
d3202 1
a3202 1
/*uh, 16.10.90*/      /* Vergleicht das oberste Element X des Work-Stacks mit der booleschen
d3242 1
a3242 1
/*uh, 16.10.90*/      /* Vergleicht das oberste Element X des Work-Stacks mit der booleschen
d3282 1
a3282 1
/*uh, 16.10.90*/      /* Vergleicht das oberste Element X des Work-Stacks mit der booleschen
d3437 1
a3437 1
/*uh, 16.10.90*/     /* ueber den aktuellen Zeiger (second W).
d3630 1
a3630 1
/*uh, 16.10.90*/                      for (i=0; i<free_args; i++)  *pth++ = POP_I(i);
d3698 1
a3698 1
/*uh, 16.10.90*/                  UPDATE_I(arg,(STACKELEM)ptdesc);
d4130 5
d4136 9
d4150 1
@


1.21
log
@first time-slicing changes
@
text
@d3 3
d412 13
d472 6
d1537 2
d1932 3
d3029 773
@


1.20
log
@minor bugfix
@
text
@d3 3
d88 3
d659 5
@


1.19
log
@free1sw_t added
@
text
@d3 3
d3132 1
a3132 1
		     FUNC1("free1sw_t");
@


1.18
log
@PUSHH/POPH changed to R-Stack for tilde version
@
text
@d3 3
d3125 7
@


1.17
log
@more bug fixes
@
text
@d3 3
d2145 3
d2150 1
d2205 3
d2210 1
d2217 4
d2223 1
a2223 1

d2238 3
d2242 1
@


1.16
log
@support for DIST, DISTB in tilde version added
@
text
@d3 3
d2179 3
d2183 1
d2185 1
@


1.15
log
@compile bugfix (D_MESS ## WITHTILDE)
@
text
@d3 3
d2144 1
a2144 1
#if DEBUG
d2152 6
a2157 2
#if (nCUBE && D_MESS && D_MSCHED)
    code = (*d_m_distribute)((INSTR *)*code,(INSTR *)*(code+1),*(code+2),*(code+3),DIST_N);
d2159 3
d2163 2
a2164 1
#endif
d2220 1
a2220 1
#if DEBUG
d2228 4
a2231 1
#if (nCUBE && D_MESS && D_MSCHED)
d2233 1
d2235 3
d2239 1
d2967 1
a2967 1
/* Analaog dazu wird der neue Tildeframe auf dem aktuellen R-stack        */
@


1.14
log
@first beta release of distributed tilde-version
@
text
@d3 3
d3491 5
d3497 1
@


1.13
log
@first beta of merged picard with tilde
@
text
@d3 3
d176 5
d225 10
d243 1
d254 11
d345 5
d416 3
@


1.12
log
@*** empty log message ***
@
text
@d3 3
d2285 12
@


1.11
log
@popfree_t generation added to apply instruction
@
text
@d3 3
d633 1
a633 1
    case I_MOVE_AW:  /* === MOVE : move one item from a to w === */
@


1.10
log
@bug fixes for tilde version
@
text
@d1 1
d3 3
d155 5
d446 1
d448 1
a448 2
static INSTR rout_sapply[] = { I_POPFREE_T, I_SAPPLY, I_POPFREE_T, I_RTS };
#else
a449 1
#endif /* WITHTILDE */
a454 48

#if WITHTILDE
/* -------------------------------------------------------------------- */
/* ---                       load_body_expr                         --- */
/* -------------------------------------------------------------------- */

/* copy heap expression to stack E.           */
/* replace pattern variables by bound values. */
/* load_body_expr is only used in case of a   */
/* pattern match with undecided guard expr    */

void load_body_expr(bodyptr, framesize)
STACKELEM **bodyptr;
int framesize;
{
  register int          size;
  register STACKELEM       x;
  register STACKELEM    *ptr;
  
  RES_HEAP;
  ptr = *bodyptr;
  size = ptr[0];

  IS_SPACE(S_e,size);
  
  while (size > 0)
  {                 
    x = ptr[size];   

    if (T_POINTER(x))
      INC_REFCNT((PTR_DESCRIPTOR)x);
    else  
    {
      if (T_NUM(x))    
      {
	x = MID_A(framesize-1-VALUE(x));
      }
      else if (T_TILDE(x))
	x = MID_T(VALUE(x));   
    }
    
    PPUSH_E(x);
    size--;
  }
  REL_HEAP;
}
#endif /* WITHTILDE */

d1314 1
d1335 1
d1554 1
a1554 1
                       arg  = R_SWITCH(*ptdesc,anz_args);  /* NCASE: stelligkeit des SWITCH */
d1580 5
d1590 36
a1625 1
			 load_body_expr(A_MATCH(*ptdesc,body),VALUE(TOP_R()));
d1643 1
a1643 9
#endif /* WITHTILDE */
#if WITHTILDE
			 {
			   int i;
			   if ((i = VALUE(POP_R())) > 0)
			     for (; i > 0 ; i--)
			       PPOP_A();
			 }
#else
d1653 37
d1692 2
d1697 4
a1700 4
                         L_NOMAT(*ptd,guard_body)[0] = 3;            /* length   */
                         L_NOMAT(*ptd,guard_body)[1] = POP_W();      /* guard    */
                         L_NOMAT(*ptd,guard_body)[2] = (int)ptdesc;  /* body     */
			 L_NOMAT(*ptd,guard_body)[3] = POP_W();      /* argument */
d1703 2
a3187 4
#if WITHTILDE
	PUSH_R(0); /* dummy fuer popfree_t: nur in einer closure koennten */
	           /* tildevariablen freigegeben werden.                  */
#endif /* WITHTILDE */
a3198 4
#if WITHTILDE
	PUSH_R(0); /* dummy fuer popfree_t: nur in einer closure koennten */
	           /* tildevariablen freigegeben werden.                  */
#endif /* WITHTILDE */
d3216 1
d3218 1
d3241 8
a3248 4
	  while (nfv-- > 0) { /* tilde frame */
	    ptdesc = (T_PTD)*pth--;
	    T_INC_REFCNT(ptdesc);
	    PUSH_T(ptdesc);
d3273 8
d3296 1
d3338 9
a3346 5
	    while (nfv > 0) { /* tilde frame */
	      ptdesc = (T_PTD)*pth--;
	      T_INC_REFCNT(ptdesc);
	      PUSH_T(ptdesc);
	      nfv--;
d3367 1
d3369 8
a3383 7
#if WITHTILDE
	    /* es sind keine argumente ausgelagert worden */
	    /* also duerfen auch keine freigegeben werden */

	    WRITE_R(0);
#endif /* WITHTILDE */

d3494 10
a3503 5
	  while (nfv > 0) { /* tilde frame */
	    ptdesc = (T_PTD)*pth--;
	    T_INC_REFCNT(ptdesc);
	    PUSH_T(ptdesc);
	    nfv--;
d3512 5
a3558 4
#if WITHTILDE
	PUSH_R(0); /* hier dummy fuer popfree_t */
#endif /* WITHTILDE */

a3599 4
#if WITHTILDE
      PUSH_R(0); /* hier dummy fuer popfree_t */
#endif /* WITHTILDE */

a3727 4
#if WITHTILDE
    PUSH_R(0); /* dummy fuer popfree_t */
#endif /* WITHTILDE */

d3762 1
d3768 6
a3783 3
#if WITHTILDE
  PUSH_R(0);
#endif /* WITHTILDE */
a3784 3
#if 0
  PUSH_R(0);
#endif /* WITHTILDE */
a3817 4

#if WITHTILDE
  PUSH_R(0); /* dummy fuer popfree_t */
#endif /* WITHTILDE */
@


1.9
log
@pattern match added to tilde version
@
text
@d2 3
d437 1
d447 51
a497 3
/* --------------------------------------------------------------------*/
/* ---                         Interpreter                         --- */
/* --------------------------------------------------------------------*/
d978 3
d982 1
a1330 5
#if 0
		     if (gamma_closure == 1)
		       *pth++ = (T_HEAPELEM)POP_R(); /* Funktionszeiger liegt auf R */
		     else
		       *pth++ = (T_HEAPELEM)POP_W(); /* Funktionszeiger liegt auf W */
d1332 1
a1332 23
		     while (arity-- > 0) {
		       *pth++ = (T_HEAPELEM)POP_W(); /* DeBruinvariablen */
		     }
		     {
		       int old_nfv = nfv;

		       while (nfv > 0) {
			 /* Tildevariablen duerfen nicht gepoppt werden, da */
			 /* sie von der Aufrufenden Funktion freigegeben    */
			 /* werden sollen.                                  */
			 if (gamma_closure == 0)
			   *pth++ = (T_HEAPELEM)MID_T(old_nfv-nfv);
			 else
			   /* gammaclosures poppen ihre argumente von r */
			   /* da free_r direkt folgt                    */
			   *pth++ = (T_HEAPELEM)POP_R();
			 nfv--;
		       }
		     }
		     gamma_closure = 0;

#endif
		     if (gamma_closure == 1) {
d1339 18
a1356 5
			 while (nfv > 0) {
			   /* gammaclosures poppen ihre argumente von r */
			   /* da free_r direkt folgt                    */
			   *pth++ = (T_HEAPELEM)POP_R();
			   nfv--;
d1492 16
d1512 1
d1580 1
a1580 1
#endif /* WITHTILDE */
d1586 3
d1611 1
d1622 3
a1626 1
#if !WITHTILDE
d1641 1
a1641 1
#endif /* !WITHTILDE */
d1710 9
a1727 1
		   L_nomatch:
d1731 2
d1739 1
a1739 1
                       L_NOMAT(*ptd,ptsdes) = ptdesc;   /* SWITCH descriptor */
d1749 8
a1758 2
		     /* wenn das case geschlossen ist, muss eine closure */
		     /* werden. mah 090294                               */
d3002 1
a3002 1
		     gamma_closure = 1;              /* function on R    */
d3022 15
a3036 11
			FUNCL("gammacase");
			ptdesc = (T_PTD)*code++;
			if (_redcnt >= delta_count) {
			  _redcnt -= delta_count;
			  SWITCHSTACKS_T();
			  PUSH_R(code);
			  SET_TAIL_FLAG();
			  code = (INSTR *)ptdesc;       /* subroutine call   */
			  goto loop;
			}
                     /* case schliessen */
d3041 1
d3140 1
a3140 1
    nfv = R_UNIV(*ptdesc,args);
d3715 6
d3722 2
@


1.8
log
@bux fix in primfunc handling of l_apply
@
text
@d2 3
d167 2
d171 1
d412 1
a412 1
/* hoffentlich nicht mehr noetig mah 120194                        */
d1519 1
d1521 1
d1540 11
a1550 1
                         L_NOMAT(*ptd,guard_body) = 0;        /* no GUARD/BODY */
d1552 1
d1561 1
d1576 9
d1592 1
d1597 9
d1610 1
d1615 2
d1643 3
d1653 26
a1681 3
#if WITHTILDE
                     if ((int)R_SWITCH(*R_CASE(*ptdesc,ptd),anz_args) > 1) {
#else
a1682 1
#endif /* WITHTILDE */
a1685 1

a1691 3
#if WITHTILDE
                     arg = R_SWITCH(*R_CASE(*ptdesc,ptd),anz_args);
#else
a1692 1
#endif /* WITHTILDE */
d1718 1
d2893 1
a2893 1
		     /* used only following a GAMMABETA instruction                   */
a2936 4
    case I_GAMMAJCOND:/* GAMMAJCOND f:
			 perform closed condtional reduction */
                     FUNCL("gammajcond");
		     /* closed conditional on top of goal expression */
a2937 6
                     /* offenes conditional, das praed. liegt oben auf a     */
                     /* falls pred = true/false wird zum then/else-code      */
                     /* gesprungen, ansonsten wird geschlossen.              */
                     arg = POP_W();                   /* arg:    praedikat   */
                     if (_redcnt >= delta_count) {
		       SWITCHSTACKS_T();
d2939 17
a2955 14
                       if (T_SA_TRUE(arg)) {
                         _redcnt -= delta_count;
                         /* then-code folgt */
                         code++;
                         goto loop;
                       }
                       if (T_SA_FALSE(arg))  {
                         _redcnt -= delta_count;
                         code = (INSTR *)*code;
                         goto loop;
                       }
                     }
                     /* conditional nicht reduzierbar, schliessen */
		     goto L_condfail;
d2964 8
d3082 4
d3335 3
a3337 2
          /* arity: anzahl der argumente auf'm stack */
          /* arg: anzahl der argumente der closure */
d3358 16
d3387 1
d3392 1
d3394 1
d3489 1
a3489 1
	    for (arg = arity ; --arg >= 0 ; pth--) {
d3637 3
d3641 1
a3641 1
#if WITHTILDE
d3643 1
a3643 1
#endif /* WITHTILDE */    
d3678 1
a3678 1
#if 0
d3700 1
d3753 1
@


1.7
log
@new style push and move instructions
@
text
@d2 3
d332 1
a332 1
                          fprintf(TraceFp,"%s(%1d, %1d);\n",x,*code,*(code+1),*(code+2))
d427 3
d431 1
a1303 2
			 int old_nfv = nfv;
			 
d1370 1
d1429 3
d1453 1
a1453 1
                     /* pm_am hinterlaesst auf stack a SA_TRUE (DOLLAR auf m) */
d1521 3
d1525 1
d1611 3
d1615 1
d1626 3
d1630 1
a2793 5
    case I_PUSHRET_T:/* === PUSHRET_T r : push return address === */
                     FUNCL("pushret_t");
                     PUSH_R(*code++);
/*                     SET_TAIL_FLAG_T();*/
                     goto loop;
a2816 1
                   L_rtt:
a2842 1
                   L_gamma:
d2874 10
a2883 6
    case I_GAMMAJTAIL:/* GAMMAJTAIL0 f:
			 perform n-ary function call with tail end beta-call */
		     FUNCL("gammajtail");
                     ptdesc = (T_PTD)*code++;
                     if (_redcnt >= beta_count) {
                       _redcnt -= beta_count;
d2885 12
a2896 5
                       SWITCHSTACKS();
		       PUSH_R(code);
                       SET_TAIL_FLAG();
                       code = (INSTR *)ptdesc;
                       goto loop;
d2898 2
a2899 1
                     goto L_betafail;		     
d2922 6
a2927 1

d3283 3
d3287 1
a3394 2
	    int offset;

d3510 1
a3510 1
    func = POP_W();               /* primfunc */ 
d3515 1
a3525 1
      PPUSH_W(func);
a3535 4
#if WITHTILDE
    PUSH_R(0); /* dummy fuer popfree_t */
#endif /* WITHTILDE */
    
a3540 2
  PUSH_R(0); /* dummy fuer popfree_t */

d3550 3
d3586 4
@


1.6
log
@*** empty log message ***
@
text
@d2 3
d323 9
d367 3
d399 1
d403 1
d409 1
a409 1

d447 1
d626 3
d659 3
d683 3
d708 3
d715 20
d736 17
d787 1
a787 1

d909 3
d916 3
d923 3
d927 1
d942 9
d1099 2
a1100 2
    case I_FREE:     /* === FREE n : free an n-size argument frame === */
                     FUNC1("free");
d1108 2
a1109 2
    case I_FREE1:    /* === FREE1 : free one argument === */
                     FUNC0("free1");
a1122 9
#if WITHTILDE
		     if (TEST_GAMMABETA()) {
		       DEL_GAMMABETA();
		       code = POP_RET();
		       SWITCHSTACKS_T();
		     }
		     else
#endif /* WITHTILDE */
/* gammabeta versuchsweise nur fuer rtf implementiert mah 301193 */
d1172 1
d1174 3
d1178 1
d1188 3
d1192 1
d1202 3
d1206 1
d1216 3
d1220 1
d1256 8
a1263 1
		     if (nfv)
d1267 1
d1271 53
a1323 2
		     while (nfv-- > 0) {
		       *pth++ = (T_HEAPELEM)POP_R(); /* Tildevariablen */
d1719 3
d1811 3
d1833 3
d2778 2
a2779 2
    case I_FREE_T:     /* === FREE_T n : free an n-size tilde frame === */
                     FUNC1("free_t");
d2781 1
a2781 1
                     /* arg: anzahl der von t freizugebenden argumente (>0!) */
d2783 1
a2783 1
                       ptdesc = (T_PTD)POP_T();
d2787 3
a2789 3
    case I_FREE1_T:  /* === FREE1_T : free one argument === */
                     FUNC0("free1_t");
                     ptdesc = (T_PTD)POP_T();
a2794 4
		     if (TEST_GAMMABETA()) {
		       DEL_GAMMABETA();
		       SWITCHSTACKS();
		     }
d2814 9
a2822 13
    case I_RTFT:     /* === RTFT : return function value from gammabeta function call */
		     /* Ruecksprung aus einer mit gammabeta aufgerufenen Funktion     */
		     /* Arbeitet wie rtf und vertauscht zusaetzlich t und r           */
		     /* nicht benutzt */
		     FUNC0("rtft");
                     if (TEST_TAIL_FLAG()) {
                       DEL_TAIL_FLAG();
                     }
		     else {
		       SWITCHSTACKS();
		       PUSH_W(POP_A());                /* move result */
		     }
                     code = POP_RET();             /* returnadresse */
a2829 2
                     if (_redcnt >= beta_count) {
                       _redcnt -= beta_count;        /* count reduction   */
a2833 1
                     }
d2844 2
a2845 1
			COMM0("mkbclos"); 
a2855 1
		       SET_GAMMABETA();              /* set gammabeta flag*/
a2869 1
		       SET_GAMMABETA();
d2874 22
d2945 1
a2945 1
  /* stack a: | .. arg_arity .. arg_1 func */
d2951 1
a2951 1
  /* ptdesc: (pointer auf) die funktion oben auf a */
d2953 1
a2953 1
    /* funktionsdescriptor (COMB,CASE,CLOS,CONDI) auf a */
d2955 1
a2955 1
    DBUG_PRINT ("INTER", (" funktionsdescriptor (COMB,CASE,CLOS,CONDI) auf a"));
d2958 5
a2962 1
    /* arg: anzahl der benoetigten argumente */
d2972 5
a2976 1
        PPOP_W();                 /* funktion weg von a */
d2987 1
a2987 1
        PPOP_W();                 /* case weg von a */
d2998 2
a2999 2
        PPOP_W();                 /* closure weg von a */
        /* ptdesc: zeiger auf die closure (weg von a) */
d3002 5
d3008 3
d3019 3
d3023 1
d3025 13
d3043 2
d3068 2
d3109 15
d3130 1
d3144 7
d3154 1
a3154 1
            /* help: praedikat (liegt nicht mehr auf a) */
d3164 3
d3168 1
d3178 1
a3178 1
              /* ptdesc: zeiger auf die closure (weg von a) */
d3184 13
a3196 2
              L_CLOS(*ptdesc,args) += 1;  /* zusaetzliches argument  */
              L_CLOS(*ptdesc,nargs) = 0;  /* braucht keine args mehr */
d3201 5
d3207 1
d3213 3
d3217 1
d3255 1
a3255 1
          /* substitute fuer freie variablen auf i */
d3261 1
a3261 1
          /* und nun argument(e) auf a */
d3287 1
a3287 1
        /* ptdesc: zeiger auf's conditional (auf a) */
d3291 5
d3298 1
a3298 1
          /* argumente auf i schaufeln */
d3303 1
a3303 1
          /* argumente von a poppen */
d3309 3
d3313 1
d3337 4
d3348 1
a3348 1
          /* stack a: | .. arg_arity .. arg_1 clos */
d3358 15
d3392 1
a3392 1
          /* stack a: | .. arg_arity .. arg_1 clos */
d3400 4
d3410 3
d3414 1
d3420 1
a3420 1
            do {
d3425 1
a3425 1
            do {
d3428 6
d3471 5
a3475 1
    /* primitive funktion oben auf a */
d3499 1
a3499 1
    /* sonstige pointer oder stackelemente oben auf a */
d3503 4
d3511 3
d3535 1
d3537 1
d3626 1
@


1.5
log
@ps_i, ps_a changed to ps_a, ps_w
@
text
@d2 3
d371 1
a371 1
/* um den neuen Tilde-frame aufzubauen, koennen tail-end-rekurisionen */
d376 1
a376 1
/*
d383 12
a394 2
#endif
*/
d428 3
d560 4
a563 2
    case I_PUSH:     /* === PUSH p : push a pointer onto the working stack === */
                     FUNCX("push");
d567 3
a569 2
    case I_PUSHC:    /* === PUSHC c : push a constant onto the working stack === */
                     FUNCN("pushc");
d572 3
a574 7
#if WITHTILDE
#if 0
    case I_PUSH_AW:
#endif
#endif /* WITHTILDE */
    case I_PUSHARG:  /* === PUSHARG n : push I-stackentry n onto the working stack === */
                     FUNC1("pusharg");
d580 3
a582 7
#if WITHTILDE
#if 0
    case I_PUSH_AW0:
#endif
#endif /* WITHTILDE */
    case I_PUSHARG0: /* === PUSHARG0 : push stackentry 0 onto the stack === */
                     FUNC0("pusharg0");
d587 3
a589 2
    case I_MOVE:     /* === MOVE : move one item from i to a === */
                     FUNC0("move");
d889 5
d895 1
d1037 9
d1048 1
a1048 1
    case I_RTM:      /* === RTM : move conditionally from a to i and return === */
d1099 3
d1109 3
d1119 3
d1129 4
a1132 1
                   L_mkdclos:
d1135 1
a1135 1
                     /* stack a: oben die funktion, darunter die argumente */
d1138 2
d1141 3
d1145 1
d1148 3
d1152 1
d1155 3
d1161 12
d1176 1
d1714 1
a1714 1
                     varg = *code++;
d1941 1
a1941 1
                         MPRINT_PROC_DISTEND(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, curr_pid->ppid, TOP_R());
a2533 2
#if 0
/* Die neuen PUSHs sind noch nicht vollstaendig implementiert */
d2535 9
d2552 1
a2552 1
    case I_PUSH_TW0: /* === PUSH_TA0 :
d2554 1
a2554 1
                     FUNC0("push_ta0");
d2584 1
a2584 1
                     FUNC0("push_tr0");
d2592 1
a2592 1
    case I_MOVE_TW:  /* === MOVE_TW : move one item from T to W === */
d2596 1
a2596 1
    case I_MOVE_TR:  /* === MOVE_TR : move one item from T to R === */
d2600 1
a2600 1
    case I_MOVE_AR:  /* === MOVE_AR : move one item from A to R === */
d2604 5
a2608 1
#endif /* 0 */
d2630 8
a2637 4
    case I_RTM_T:    /* === RTM : move conditionally from a to i and return ===  */
                     /* mah 171193 nicht mehr conditionally, da kein tail_t-flag */
                     FUNC0("rtm");
                     SWITCHSTACKS_T();
d2639 1
d2641 3
a2643 3
    case I_RTF_T:    /* === RTF_T : return function value === */
                     FUNC0("rtf_t");
                   L_rtf_t:
d2645 1
a2645 2
                     SWITCHSTACKS_T();
                     PUSH_W(POP_T());                /* move result */
d2647 1
d2656 15
d2687 1
a2687 1
                     PUSH_W(ptdesc);                 /* push function    */
d2689 3
a2691 1
                     if (arg == 0) goto loop;        /* keine closure    */
d2693 1
a2693 1
			COMM0("mkbclos");   /* mah 251093 vielleicht gammaclosure ? */
d2695 29
d2746 1
d2748 1
@


1.4
log
@removed warnings update
@
text
@a1 3
 * Revision 1.3  1993/09/01  12:37:17  base
 * ANSI-version mit mess und verteilungs-Routinen
 *
d16 1
d93 1
a93 1
extern char    *stelname();        /* rear.c */
d140 2
a141 2
DStackDesc     *ps_a;              
DStackDesc     *ps_i;
d145 6
a150 2
StackDesc      *ps_a;              /* zeiger auf aktuellen a-stack */
StackDesc      *ps_i;              /* zeiger auf aktuellen i-stack */
d160 2
a161 2
#ifdef  PUSH_I
#undef  PUSH_I
d166 9
d181 1
a181 1
#define MID_A(n)          D_MIDSTACK(*ps_a,n)
a183 9
#define POP_I()           D_POPSTACK(*ps_i)
#define PPOP_I()          D_PPOPSTACK(*ps_i)
#define TOP_I()           D_READSTACK(*ps_i)
#define PUSH_I(x)         D_PUSHSTACK(*ps_i,(x))
#define PPUSH_I(x)        D_PPUSHSTACK(*ps_i,(x))
#define WRITE_I(x)        D_WRITESTACK(*ps_i,(x))
#define MID_I(x)          D_MIDSTACK(*ps_i,x)
#define UPDATE_I(n,x)     D_UPDATESTACK(*ps_i,n,(x))

d204 9
d218 2
a219 2
#define WRITE_A(x)        WRITESTACK(*ps_a,(x))
#define MID_A(n)          MIDSTACK(*ps_a,n)
d222 10
a231 9
#define POP_I()           POPSTACK(*ps_i)
#define PPOP_I()          PPOPSTACK(*ps_i)
#define TOP_I()           READSTACK(*ps_i)
#define PUSH_I(x)         PUSHSTACK(*ps_i,(x))
#define PPUSH_I(x)        PPUSHSTACK(*ps_i,(x))
#define WRITE_I(x)        WRITESTACK(S_i,(x))
#define MID_I(x)          MIDSTACK(*ps_i,x)
#define UPDATE_I(n,x)     UPDATESTACK(*ps_i,n,(x))

d240 1
d251 12
d279 2
a280 2
#define SWITCHSTACKS()    {register DStackDesc *x = ps_a; ps_a = ps_i; ps_i = x;} \
                           switchstacks(ps_a,ps_i); \
d285 2
a286 2
#define SWITCHSTACKS()    {register StackDesc *x = ps_a; ps_a = ps_i; ps_i = x;} \
                           switchstacks(ps_a,ps_i); \
d289 6
d338 1
a338 1
#define SWITCHSTACKS()    {register DStackDesc *x = ps_a; ps_a = ps_i; ps_i = x;}
d340 6
a345 1
#define SWITCHSTACKS()    {register StackDesc *x = ps_a; ps_a = ps_i; ps_i = x;}
d360 24
a383 9
#define TAIL_FLAG         0
#define POP_RET()         (INSTR *)(POP_R() & ~TAIL_FLAG)
#define TEST_TAIL_FLAG()  (TOP_R() == TAIL_FLAG)
#define SET_TAIL_FLAG()   PUSH_R(TAIL_FLAG)
#define DEL_TAIL_FLAG()   PPOP_R()
#define INVERT_TAIL_FLAG() if (TOP_R() == TAIL_FLAG) \
                             PPOP_R(); \
                           else PUSH_R(TAIL_FLAG)
#define STACKSPACE(n)     IS_SPACE((*ps_a),(n))
d420 1
d442 2
a443 2
  ps_a = &S_a;          /* initial working  stack is mapped on S_a  */
  ps_i = &S_m1;         /* initial argument stack is mapped on S_m1 */
d445 3
d450 2
d455 7
a461 4
  strcpy(S_e.Name, "H"); stackname_dr(&S_e);
  strcpy(S_a.Name, "A"); stackname_dr(&S_a);
  strcpy(S_m1.Name,"I"); stackname_dr(&S_m1);
  strcpy(S_m.Name, "R"); stackname_dr(&S_m);
d474 2
d505 11
d518 1
a518 1
                     ((IS_POINTER(TOP_A()))?R_DESC(*(T_PTD)TOP_A(),class):-1), 
a524 11
DBUG_PRINT ("DUMP", ("I_STACK:"));
DBUG_PRINT ("DUMP", ("Topaddresse: %x; Schotter: %x (class %d, type %d)", 
                     ps_i->TopofStack,
                     TOP_I(),
                     ((IS_POINTER(TOP_I()))?R_DESC(*(T_PTD)TOP_I(),class):-1),
                     ((IS_POINTER(TOP_I()))?R_DESC(*(T_PTD)TOP_I(),type):-1)));
if (d_stacksize(ps_i) > 1)
DBUG_PRINT ("DUMP", ("Unner dem liegt ey: %x (class %d, type %d)", 
                     MID_I(1),
                     ((IS_POINTER(MID_I(1)))?R_DESC(*(T_PTD)MID_I(1),class):-1),
                     ((IS_POINTER(MID_I(1)))?R_DESC(*(T_PTD)MID_I(1),type):-1)));
d547 1
a547 1
                     PUSH_A(*code++);
d551 1
a551 1
                     PUSH_A(*code++);
d553 5
d560 1
a560 1
                     ptdesc = (T_PTD)MID_I(*code);
d563 1
a563 1
                     PUSH_A(ptdesc);
d565 5
d572 1
a572 1
                     ptdesc = (T_PTD)TOP_I();
d574 1
a574 1
                     PUSH_A(ptdesc);
d578 1
a578 1
                     PUSH_A(POP_I());
d586 1
a586 1
                       if ((*(red_func_tab[FUNC_INDEX(func)]))(TOP_A())) {
d588 1
a588 1
                         WRITE_A(_desc);
d594 1
a594 1
                     PUSH_A(func);
d602 8
a609 8
					  TOP_A(),
					  ((IS_POINTER(TOP_A()))?R_DESC(*(T_PTD)TOP_A(),class):-1),
					  ((IS_POINTER(TOP_A()))?R_DESC(*(T_PTD)TOP_A(),type):-1),
					  ((IS_POINTER(TOP_A()) && (R_DESC(*(T_PTD)TOP_A(),class) == C_DIGIT))?*R_DIGIT(*(T_PTD)TOP_A(),ptdv):TOP_A()),
					  MID_A(1),
					  ((IS_POINTER(MID_A(1)))?R_DESC(*(T_PTD)MID_A(1),class):-1),
					  ((IS_POINTER(MID_A(1)))?R_DESC(*(T_PTD)MID_A(1),type):-1),
					  ((IS_POINTER(MID_A(1)) && (R_DESC(*(T_PTD)MID_A(1),class) == C_DIGIT))?*R_DIGIT(*(T_PTD)MID_A(1),ptdv):MID_A(1))));
d615 1
a615 1
                       if ((*(red_func_tab[FUNC_INDEX(func)]))(TOP_A(),MID_A(1))) {
d617 2
a618 2
                         PPOP_A();
                         WRITE_A(_desc);
d624 1
a624 1
                     PUSH_A(func);
d635 1
a635 1
                       if ((*(red_func_tab[FUNC_INDEX(func)]))(TOP_A(),MID_A(1),MID_A(2))) {
d637 3
a639 3
                         PPOP_A();
                         PPOP_A();
                         WRITE_A(_desc);
d645 1
a645 1
                     PUSH_A(func);
d656 1
a656 1
                       if ((*(red_func_tab[FUNC_INDEX(func)]))(TOP_A(),MID_A(1),MID_A(2),MID_A(3))) {
d658 4
a661 4
                         PPOP_A();
                         PPOP_A();
                         PPOP_A();
                         WRITE_A(_desc);
d667 1
a667 1
                     PUSH_A(func);
d675 4
a678 4
                     arg = TOP_A(); \
                     if (pf_test(arg,MID_A(1))) { \
                       PPOP_A(); \
                       WRITE_A(pf_makro(arg,TOP_A())); \
d681 3
a683 3
                     if (pf_func(arg,MID_A(1))) { \
                       PPOP_A(); \
                       WRITE_A(_desc); \
d688 1
a688 1
                     PUSH_A(pf_stel); \
d694 2
a695 2
                     if (pf_test(TOP_A())) { \
                       WRITE_A(pf_makro(TOP_A())); \
d698 2
a699 2
                     if (pf_func(TOP_A())) { \
                       WRITE_A(_desc); \
d704 1
a704 1
                     PUSH_A(pf_stel); \
d774 1
a774 1
                     arg = POP_A();                   /* arg:    praedikat   */
d791 1
a791 1
                     arg = POP_A();                   /* arg:    praedikat   */
d808 1
a808 1
                     arg = POP_A();                   /* arg:    praedikat   */
d824 1
a824 1
                     PPUSH_A(arg);                        /* praedikat */
d828 1
a828 1
                     PPUSH_A(ptdesc);                     /* conditional */
d837 2
a838 2
                     *pth++ = (T_HEAPELEM)TOP_A();        /* conditional */
                     if (R_CONDI(*(T_PTD)TOP_A(),args)) {
d842 1
a842 1
                         ptd = (T_PTD)MID_I(help);
d850 1
a850 1
                         *pth++ = (T_HEAPELEM)POP_I();
d853 2
a854 2
                     PPOP_A();                            /* conditional */
                     *pth = (T_HEAPELEM)TOP_A();          /* praedikat   */
d856 1
a856 1
                     WRITE_A(_desc);
d875 1
a875 1
                     PUSH_A(ptdesc);                 /* push function    */
d898 1
a898 1
                       PUSH_I(POP_A());              /* move argument */
d936 1
a936 1
                       PUSH_I(POP_A());
d956 1
a956 1
                     PUSH_I(POP_A());
d973 1
a973 1
                     PUSH_I(POP_A());
d989 2
a990 2
                       pth[arity] = (T_HEAPELEM)POP_A();
                     pth[arity] = (T_HEAPELEM)TOP_A();
d992 1
a992 1
                     WRITE_A(_desc);
d1000 1
a1000 1
                       ptdesc = (T_PTD)POP_I();
d1006 1
a1006 1
                     ptdesc = (T_PTD)POP_I();
a1013 2
                       code = POP_RET();             /* returnadresse */
                       goto loop;
d1015 4
a1018 2
                     SWITCHSTACKS();
                     PUSH_A(POP_I());                /* move result */
d1025 1
a1025 1
                       PUSH_A(POP_I());                /* move */
d1042 1
a1042 1
                     PUSH_A(ptdesc);
d1054 1
a1054 1
                     PUSH_A(ptdesc);
d1110 1
a1110 1
                       *pth++ = (T_HEAPELEM)POP_A();
d1116 1
a1116 1
                     PPUSH_A(_desc);
d1141 1
a1141 1
                       ptdesc = (T_PTD)POP_I();
d1154 1
a1154 1
                     ptdesc = (T_PTD)POP_A();                 /* conditional */
d1162 1
a1162 1
                         ptd = (T_PTD)MID_A(arity);
d1164 1
a1164 1
                         PUSH_A(ptd);
d1168 1
a1168 1
                     PUSH_A(SA_TRUE);
d1177 1
a1177 1
                     PUSH_R(POP_A());                         /* then-expr   */
d1183 1
a1183 1
                         ptd = (T_PTD)MID_A(arity);
d1185 1
a1185 1
                         PUSH_A(ptd);
d1189 1
a1189 1
                     PUSH_A(SA_FALSE);
d1196 1
a1196 1
                     arg = POP_A();                  /* else-expr      */
d1200 3
a1202 3
                     PUSH_A(arity);                  /* then-expr      */
                     PUSH_A(arg);                    /* else-expr      */
                     PUSH_A(SET_ARITY(COND,2));      /* cond-constr    */
d1225 1
a1225 1
                     pm_am(R_MATCH(*ptdesc,code),TOP_A());
d1233 1
a1233 1
                     if (T_HASH(TOP_A())) {
d1237 1
a1237 1
                     if (T_SA_TRUE(TOP_A())) {
d1239 1
a1239 1
                       PPOP_A();                   /* SA_TRUE */
d1251 1
a1251 1
                     if (T_HASH(TOP_A())) {
d1253 1
a1253 1
                       PPOP_A();                   /* hash symbol */
d1256 1
a1256 1
                     if (T_SA_TRUE(TOP_A())) {
d1259 1
a1259 1
                       PPOP_A();                   /* SA_TRUE */
d1262 1
a1262 1
                       ptd = (T_PTD)POP_A();       /* das zu matchende argument */
d1268 1
a1268 1
                     if (T_SA_FALSE(TOP_A())) {
d1271 1
a1271 1
                       PPOP_A();                   /* SA_FALSE */
d1275 1
a1275 1
                         ptd = (T_PTD)POP_I();
d1298 1
a1298 1
                       if (T_KLAA(TOP_A())) {
d1302 1
a1302 1
                         PPOP_A();                            /* KLAA */
d1319 1
a1319 1
                               ptdesc = (T_PTD)MID_I(help-VALUE(MID_E(i))); /* adressierung "von unten" */
d1329 1
a1329 1
                             PUSH_E(POP_I());
d1338 1
a1338 1
                         L_NOMAT(*ptd,guard_body)[1] = POP_A();      /* guard */
d1346 1
a1346 1
                         load_pmlist(ps_a,POP_A());
d1357 1
a1357 1
                         *pth++ = (T_HEAPELEM)POP_A();             /* argument */
d1362 3
a1364 3
                           if (T_POINTER(MID_I(arity)))
                             INC_REFCNT((T_PTD)MID_I(arity));
                           *pth++ = (T_HEAPELEM)MID_I(arity);
d1369 1
a1369 1
                       PPUSH_A(ptdesc);                   /* EXPR descriptor */
d1382 1
a1382 1
                       load_pmilist(ps_a,POP_A());
d1404 1
a1404 1
                         help = MID_I(arg);
d1412 1
a1412 1
                       *pth++ = POP_A();          /* argument */
d1415 1
a1415 1
                     PPUSH_A(ptdesc);
d1420 1
a1420 1
                     ptdesc = (T_PTD)MID_I(arg);
d1422 1
a1422 1
                     PUSH_I(ptdesc);
d1429 2
a1430 2
                       arg = POP_A();         /* index */
                       arity = TOP_A();       /* list/string */
d1461 1
a1461 1
                               WRITE_A(ptdesc);
d1468 2
a1469 2
                                   PUSH_I(index);
                                   PUSH_I(ptd2);              /* liste */
d1487 1
a1487 1
                               WRITE_A(ptdesc);
d1497 1
a1497 1
                       PPUSH_A(arg);
d1499 1
a1499 1
                     PUSH_A(LSELECT);
d1512 1
a1512 1
                     ptdesc = (T_PTD)POP_A();
d1517 2
a1518 2
                       PUSH_I(arity);                /* anzahl argumente */
                       PUSH_I(0);                    /* bottomsymbol */
d1524 1
a1524 1
                         PUSH_I(*pth++);
d1542 2
a1543 2
                     while ((ptdesc = (T_PTD)POP_I()) != 0) {
                       PUSH_A(ptdesc);
d1555 1
a1555 1
                     arity = POP_I();                /* anzahl argumente */
d1562 3
a1564 3
                     L_CONS(*ptdesc,tl) = (T_PTD)POP_A();
                     L_CONS(*ptdesc,hd) = (T_PTD)TOP_A();
                     WRITE_A(ptdesc);
d1569 3
a1571 3
                     L_CONS(*ptdesc,hd) = (T_PTD)POP_A();
                     L_CONS(*ptdesc,tl) = (T_PTD)TOP_A();
                     WRITE_A(ptdesc);
d1575 1
a1575 1
                     ptdesc = (T_PTD)TOP_A();
d1579 1
a1579 1
                       WRITE_A(arg);
d1584 1
a1584 1
                       PUSH_A(TAG_INT(1));
d1588 1
a1588 1
                     PUSH_A(M_FIRST);
d1594 1
a1594 1
                     ptdesc = (T_PTD)TOP_A();
d1598 1
a1598 1
                       WRITE_A(arg);
d1603 1
a1603 1
                       PUSH_A(TAG_INT(1));
d1607 1
a1607 1
                     PUSH_A(M_FIRST);
d1613 3
a1615 3
                     ptdesc = (T_PTD)POP_I();        /* liste */
                     arg = POP_I();                  /* index */
                     arity = TOP_A();                /* element */
d1639 2
a1640 2
                       *pth++ = (T_HEAPELEM)POP_A();
                     *pth = (T_HEAPELEM)TOP_A();
d1642 1
a1642 1
                     WRITE_A(_desc);
d1649 1
a1649 1
                     arg = *code++;
d1876 1
a1876 1
                         MPRINT_PROC_DISTEND(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, (int) curr_pid->ppid, (int) TOP_R());
d2050 1
a2050 1
/*dguh, 27.07.90*/                WRITE_E(POP_A());
d2101 1
a2101 1
/*dguh, 27.07.90*/                    PUSH_A((T_PTD)arg);
d2120 1
a2120 1
/*dguh, 27.07.90*/                    PUSH_A((T_PTD)arg);
d2127 1
a2127 1
/*dguh, 27.07.90*/                PUSH_A(ptdesc);
d2132 1
a2132 1
/*dguh, 27.07.90*/                ptdesc = (T_PTD)POP_A();
d2143 2
a2144 2
/*dguh, 27.07.90*/                arity = TOP_A();
/*dguh, 27.07.90*/                ptdesc = (T_PTD)MID_A(1);
d2149 2
a2150 2
/*dguh, 27.07.90*/                PUSH_I(arg);
/*dguh, 27.07.90*/                WRITE_A(TAG_INT(VAL_INT(arity)-1));
d2155 2
a2156 2
/*dguh, 27.07.90*/                ptdesc = (T_PTD)TOP_A();
/*dguh, 27.07.90*/                PUSH_A( TAG_INT(R_LIST(*ptdesc,dim)) );
d2161 1
a2161 1
/*dguh, 27.07.90*/                if (VAL_INT(TOP_A())) {
d2165 1
a2165 1
/*dguh, 27.07.90*/                POP_A();
d2171 1
a2171 1
/*dguh, 27.07.90*/                arg = TOP_A();
d2173 1
a2173 1
/*dguh, 27.07.90*/                   POP_A();
d2182 1
a2182 1
/*dguh, 27.07.90*/                arg = TOP_A();
d2184 1
a2184 1
/*dguh, 27.07.90*/                   POP_A();
d2193 1
a2193 1
/*dguh, 27.07.90*/                ptdesc = (T_PTD)TOP_A();
d2276 1
a2276 1
/*dguh, 27.07.90*/                   *pth++ = POP_A();           /* Listen-Closure */
d2294 2
a2295 2
/*dguh, 27.07.90*/                      if (T_POINTER(MID_I(help))) INC_REFCNT((T_PTD)MID_I(help)); /* uh 04Okt 91 */
/*dguh, 27.07.90*/                      *pth++=MID_I(help);   /* ZF-Variablen */
d2301 2
a2302 2
/*dguh, 27.07.90*/                      if (T_POINTER(MID_I(arity))) INC_REFCNT((T_PTD)MID_I(arity)); /* uh 04Okt91 */
/*dguh, 27.07.90*/                      *pth++=MID_I(arity);  /* lambda Variablen */
d2401 1
a2401 1
/*dguh, 27.07.90*/                   *pth++ = POP_A();
d2416 2
a2417 2
/*dguh, 27.07.90*/                        if (T_POINTER(MID_I(help))) INC_REFCNT((T_PTD)MID_I(help)); /* uh 04Okt91 */
/*dguh, 27.07.90*/                        *pth++=MID_I(help);   /* ZF-Variablen */
d2423 2
a2424 2
/*dguh, 27.07.90*/                        if (T_POINTER(MID_I(arity))) INC_REFCNT((T_PTD)MID_I(arity)); /* uh 04Okt91 */
/*dguh, 27.07.90*/                        *pth++=MID_I(arity);  /* lambda Variablen */
d2454 151
d2615 5
a2619 4
  strcpy(S_e.Name, "e");  stackname_dr(&S_e);
  strcpy(S_a.Name, "a");  stackname_dr(&S_a);
  strcpy(S_m1.Name,"m1"); stackname_dr(&S_m1);
  strcpy(S_m.Name, "m");  stackname_dr(&S_m);
d2646 1
a2646 1
  ptdesc = (T_PTD)TOP_A();
d2667 1
a2667 1
        PPOP_A();                 /* funktion weg von a */
d2678 1
a2678 1
        PPOP_A();                 /* case weg von a */
d2689 1
a2689 1
        PPOP_A();                 /* closure weg von a */
d2707 1
a2707 1
            PUSH_A(ptdesc);
d2737 1
a2737 1
            PUSH_A(ptdesc);
d2762 1
a2762 1
          help = POP_A();                 /* praedikat */
d2775 1
a2775 1
              PUSH_I(ptdesc);
d2779 1
a2779 1
            PUSH_A(help);             /* praedikat */
d2805 1
a2805 1
              PPUSH_A(ptdesc);             /* closure */
d2838 1
a2838 1
                PPUSH_A(ptdesc);         /* closure   */
d2873 1
a2873 1
            PUSH_I(ptdesc);
d2879 1
a2879 1
            PUSH_A(ptdesc);
d2905 1
a2905 1
        help = MID_A(arg);           /* praedikat  */
d2909 2
a2910 2
            PUSH_I(MID_A(arg));
          PPOP_A();                  /* conditional */
d2914 1
a2914 1
            PPOP_A();
d2962 2
a2963 2
            PPOP_A();
            *++pth = TOP_A();
d2968 1
a2968 1
          WRITE_A(ptdesc);                /* die closure */
d3002 1
a3002 1
            PPOP_A();                    /* alte closure */
d3004 1
a3004 1
              *p2++ = (T_HEAPELEM)POP_A();
d3008 1
a3008 1
            PPUSH_A(ptdesc);             /* neue closure */
d3045 1
a3045 1
    func = POP_A();               /* primfunc */ 
d3060 1
a3060 1
      PPUSH_A(func);
d3103 4
a3106 4
    case 4: PPUSH_A(help);
    case 3: PPUSH_A(arity);
    case 2: PPUSH_A(arg);
    case 1: PUSH_A(func);
d3110 1
a3110 1
      PUSH_A(func);
d3125 1
a3125 1
    *pth-- = (T_HEAPELEM)POP_A();
d3128 1
a3128 1
  PPUSH_A(ptdesc);
@


1.3
log
@ANSI-version mit mess und verteilungs-Routinen
@
text
@d2 3
d1804 1
a1804 1
                         MPRINT_PROC_DISTEND(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, curr_pid->ppid, TOP_R());
@


1.2
log
@ANSI-Version
@
text
@d2 3
d15 1
d22 4
d27 1
d37 24
a62 1
extern int     _redcnt;            /* <w>, rstate.c - reduktionszaehler */
a65 1
extern BOOLEAN _interrupt;         /* <w>, fuer die ausnahmebehandlung  */
a66 1
extern jmp_buf _interruptbuf;      /* <w>, fuer die ausnahmebehandlung  */
d71 16
a111 1
extern STACKELEM *ppopstack();             /* rheap.c */
a113 1
extern STACKELEM midstack();               /* rstack.c */
a115 1
extern void updatestack();                 /* rstack.c */
d125 10
d137 7
d147 2
d159 40
d235 1
d248 9
d260 3
d302 4
d307 2
d350 3
d354 2
a355 1
register INSTR *code;
d359 4
a362 4
  register volatile int          arg=0;           /* anzahl argumente          */
  register volatile int          arity=0;         /* stelligkeit               */
  register volatile int          func=0;          /* funktion (pf)             */
  register volatile int          help=0;          /* hilfsvariable             */
d381 2
d385 2
d390 4
a393 1
#if DEBUG
d421 46
a466 1
  loop:
d468 7
d490 2
a491 1
                     ptdesc = (T_PTD)MID_I(*code++);
d525 10
d1038 3
d1236 1
a1236 1
                         if (T_SNAP(READSTACK(S_e))) {
d1242 1
a1242 1
                           for (i = ARITY(READSTACK(S_e)); i > 0 ; i-- ) {
d1578 391
d2386 3
d2393 2
d2398 10
a2407 1
  return;
d2409 4
d2420 3
d2426 3
d2432 3
d2437 3
d2448 3
d2459 3
d2470 3
d2484 3
d2488 3
d2499 3
d2526 3
d2539 3
d2560 3
d2568 3
d2582 3
d2595 3
d2599 1
d2628 3
d2670 3
d2712 3
d2717 3
d2727 3
d2745 3
d2762 3
d2766 1
d2790 3
d2798 3
d2813 3
d2841 3
d2853 3
d2865 3
d2875 1
a2875 1
  switch (FUNC_ARITY(func)) {
d2882 3
a2884 1
  } /* end switch */
d2910 3
d2914 2
d2921 4
d2927 2
d2936 3
d2940 2
d2946 4
d2952 1
@


1.1
log
@Initial revision
@
text
@d1 4
a4 1
/* $Log$ */
d26 1
d48 1
a48 1
#endif DEBUG
d55 27
d233 5
a237 4
  register int          arg;             /* anzahl argumente          */
  register int          arity;           /* stelligkeit               */
  register int          func;            /* funktion (pf)             */
  register int          help;            /* hilfsvariable             */
d254 1
a254 1
#endif UH_ZF_PM
d271 1
a271 1
#endif DEBUG
d281 1
a281 1
#endif SCAVENGE
d1107 1
a1107 1
                     if (R_SWITCH(*R_CASE(*ptdesc,ptd),case_type) > 1) {
d1180 2
a1181 1
                           if (0 < index && index <= R_LIST(*ptd2,dim)) {
d1379 1
a1379 1
#endif TESTSPACE
d1397 1
a1397 1
/*dguh, 27.07.90*/  case I_ENDZF:    /* ( E list e1 ... en n -- ) ( W -- list++[e1..en] )
d1537 1
a1537 1
/*dguh, 27.07.90*/  case I_MAKEZF:     /* ( W ??? -- closure )
d1669 1
a1669 1
/*dguh, 27.07.90*/  case I_MAKEBOOL:   /*  ( w ??? -- closure )
d1770 1
a1770 1
/*dguh, 27.07.90*/                   MAKE_DESC(arg,1,C_EXPRESSION,TY_EXPR); /* FOR PCS *?
d1789 1
a1789 1
#endif UH_ZF_PM
d1801 1
a1801 1
#endif DEBUG
d2216 2
a2217 1
  for (i = 0 ; i < R_LIST(*p,dim); i++ ) {
@
