head	1.22;
access;
symbols
	continuation_based_interactions:1.16
	pre_interactions:1.15;
locks; strict;
comment	@ * @;


1.22
date	96.02.29.15.44.19;	author stt;	state Exp;
branches;
next	1.21;

1.21
date	96.02.23.13.30.15;	author rs;	state Exp;
branches;
next	1.20;

1.20
date	96.02.22.17.18.58;	author stt;	state Exp;
branches;
next	1.19;

1.19
date	96.02.22.16.40.40;	author stt;	state Exp;
branches;
next	1.18;

1.18
date	96.02.20.16.23.08;	author stt;	state Exp;
branches;
next	1.17;

1.17
date	96.02.16.14.02.20;	author cr;	state Exp;
branches;
next	1.16;

1.16
date	95.10.25.15.32.23;	author sf;	state Exp;
branches;
next	1.15;

1.15
date	95.06.13.12.05.11;	author sf;	state Exp;
branches;
next	1.14;

1.14
date	95.06.01.15.29.13;	author sf;	state Exp;
branches;
next	1.13;

1.13
date	95.06.01.15.16.16;	author sf;	state Exp;
branches;
next	1.12;

1.12
date	95.05.19.11.44.12;	author sf;	state Exp;
branches;
next	1.11;

1.11
date	95.05.19.08.53.11;	author sf;	state Exp;
branches;
next	1.10;

1.10
date	95.05.19.08.14.13;	author sf;	state Exp;
branches;
next	1.9;

1.9
date	95.05.18.10.05.11;	author sf;	state Exp;
branches;
next	1.8;

1.8
date	95.05.03.13.10.32;	author sf;	state Exp;
branches;
next	1.7;

1.7
date	95.05.03.12.44.01;	author sf;	state Exp;
branches;
next	1.6;

1.6
date	95.03.31.12.04.42;	author sf;	state Exp;
branches;
next	1.5;

1.5
date	95.03.31.08.24.00;	author sf;	state Exp;
branches;
next	1.4;

1.4
date	95.03.27.14.28.37;	author sf;	state Exp;
branches;
next	1.3;

1.3
date	95.03.24.07.42.09;	author sf;	state Exp;
branches;
next	1.2;

1.2
date	95.03.08.12.30.38;	author sf;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	95.03.07.14.54.59;	author sf;	state Exp;
branches;
next	;

1.2.1.1
date	95.03.24.08.22.22;	author sf;	state Exp;
branches;
next	;


desc
@@


1.22
log
@bug in intact/primf closure fixed.
@
text
@#include <stdio.h>
#include <stdlib.h>
#include "dbug.h"
#include "rstdinc.h"
#include "rstelem.h"
#include "rheapty.h"
#include "rstackty.h"
#include <sys/time.h>

#define DESC(x)        (* (PTR_DESCRIPTOR) x)

/******************************************************************************/
/*                                                                            */
/* Encoding of the Output sending back to reduma                              */
/*                                                                            */
/* output : tag data                                                          */
/*                                                                            */
/* with                                                                       */
/*                                                                            */
/* data   : length output* (in case of ri_list,ri_frame,ri_intact)            */
/*        : tagged_integer | tagged_boolean  (in case of ri_int or ri_bool)   */
/*        : value_of_real (in case of ri_real)                                */
/*        : arity arg graph_adr  (in case of ri_case, ri_comb or ri_cond)     */
/*        : act_nomat reason ptsdes guard_body[0] guard_body[1] guard_body[2] */
/*          guard_body[3]                                                     */
/*        : arity arg (in case of ri_sub)                                     */
/*        : tag arity arg nfv (in case of closure) ...                        */
/*        : name value (in case of ri_slot)                                   */
/*                                                                            */
/* act_nomat : integer                                                        */
/* reason    : integer                                                        */
/* arity     : integer                                                        */
/* arg       : integer                                                        */
/* graph_adr : integer                                                        */
/* guard_body[0] : integer                                                    */
/* guard_body[1] : output                                                     */
/* guard_body[2] : output                                                     */
/* guard_body[3] : output                                                     */
/* name          : output                                                     */
/* value         : output                                                     */
/*                                                                            */
/* tag    : ri_int | ri_real | ri_list | ri_func                              */
/*        | ri_mat | ri_vect | ri_tvect | ri_cons | ri_prim | ri_intact       */
/*                                                                            */
/*                                                                            */
/******************************************************************************/

typedef enum {
                ri_bool = 0, ri_int = 1, ri_real = 2, ri_list = 3, ri_clos = 4, 
                ri_mat = 5, ri_vect = 6, ri_tvect = 7, ri_cons = 8, ri_prim = 9,
                ri_comb = 10, ri_cond = 11, ri_expr = 12, ri_case = 13,
                ri_CAVE = 14, ri_nomat = 15, ri_sub = 16, ri_dyncomb = 17,
                ri_char = 18, ri_string = 19, ri_var = 20, ri_const = 21,
                ri_name = 22, ri_constant = 23, ri_undef = 24, ri_frame = 25,
                ri_slot = 26, ri_intact = 27
              } RED_INPUT;
/******************************************************************************/

void load_expr(), trav_e_a(), trav_a_hilf(), DescDump(), res_heap(), rel_heap();
int newdesc(), post_mortem(), newheap(), mvheap();
extern char Tasm2KiR[80];
extern PTR_DESCRIPTOR _desc;
extern PTR_DESCRIPTOR  _nil;
extern PTR_DESCRIPTOR  _nilstruct;
extern PTR_DESCRIPTOR  _nilstring;

extern double tasm_time;

T_PTD ptdesc;

FILE *tasm2kir;

int go_get_it(void)
{
  PTR_DESCRIPTOR my_desc;
  int t_signal;
  int return_value, dim, i;
  PTR_HEAPELEM pth; /* pointer to heapelement */

  DBUG_ENTER("go_get_it");
  fscanf(tasm2kir, "%d", &t_signal);
  switch(t_signal)
  {
    case ri_bool:
    case ri_prim:
    case ri_char:
    case ri_constant:
    case ri_int:  fscanf(tasm2kir, "%d", &return_value); break;
    case ri_real: MAKEDESC(my_desc, 1, C_SCALAR, TY_REAL);
                  fscanf(tasm2kir, "%lf", A_SCALAR(*my_desc, valr));
                  return_value = (int)my_desc;
                  break;
    case ri_mat:  
    case ri_vect:
    case ri_tvect:{ int nrows, ncols, type, idata;
                    double rdata, *rv;

                    MAKEDESC(my_desc, 1, C_MATRIX, TY_INTEGER);
                    return_value = (int)my_desc;
                    L_MVT(*my_desc, ptdd, C_MATRIX) = NULL;
                    if (ri_mat == t_signal)
                      L_MVT(*my_desc, class, C_MATRIX) = C_MATRIX;
                    else if (ri_vect == t_signal)
                      L_MVT(*my_desc, class, C_MATRIX) = C_VECTOR;
                    else if (ri_tvect == t_signal)
                      L_MVT(*my_desc, class, C_MATRIX) = C_TVECTOR;
                    fscanf(tasm2kir, "%d %d %d", &type, &nrows, &ncols);
                    if (ri_int == type)
                      L_MVT(*my_desc, type, C_MATRIX) = TY_INTEGER;
                    else if (ri_bool == type)
                      L_MVT(*my_desc, type, C_MATRIX) = TY_BOOL;
                    else if (ri_real == type)
                      L_MVT(*my_desc, type, C_MATRIX) = TY_REAL;
                    else if (ri_undef == type)
                      L_MVT(*my_desc, type, C_MATRIX) = TY_UNDEF;
                    L_MVT(*my_desc, nrows, C_MATRIX) = nrows;
                    L_MVT(*my_desc, ncols, C_MATRIX) = ncols;
                    if ((ri_int == type) || (ri_bool == type))
                    {
                      GET_HEAP(nrows * ncols, A_MVT((*my_desc), ptdv, C_MATRIX));
                      for(i = 0; i < nrows * ncols; i++)
                      {
                        fscanf(tasm2kir, "%d", &idata);
                        L_MVT(*my_desc, ptdv, C_MATRIX)[i] = idata; 
                      }
                    }
                    else
                    {
                      GET_HEAP(nrows * ncols * sizeof(double) / sizeof(T_HEAPELEM), 
                          A_MVT(*my_desc, ptdv, C_MATRIX));
                      rv = (double *)R_MVT(*my_desc, ptdv, C_MATRIX);
                      for(i = 0; i < nrows * ncols; i++)
                      {
                        fscanf(tasm2kir, "%lf", &rdata);
                        rv[i] = rdata;
                      }
                      L_MVT(*my_desc, ptdv, C_MATRIX) = (PTR_HEAPELEM)rv;
                    } 
                    break;
                  }
    case ri_string: fscanf(tasm2kir, "%d", &dim);
                    MAKEDESC(my_desc, 1, C_LIST, TY_STRING);
                    L_LIST(*my_desc, ptdd) = NULL;
                    return_value = (int)my_desc;
                    L_LIST((*my_desc), dim) = dim;
                    if (dim > 0)
                    {
                      GET_HEAP(dim, A_LIST((*my_desc), ptdv));
                      pth = R_LIST(*my_desc,ptdv);
                      for (i = 0; i < dim; i++)
                        pth[i] = go_get_it();
                    }
                  break;
    case ri_cons: fscanf(tasm2kir, "%d", &dim);
                  if (0 == dim) return_value = (int)_nil;       
                  else 
                  {
                    MAKEDESC(my_desc, 1, C_LIST, TY_UNDEF);
                    L_LIST(*my_desc, ptdd) = NULL;
                    return_value = (int)my_desc;
                    L_LIST((*my_desc), dim) = dim;
                    L_LIST((*my_desc), special) = 0;
                    if (dim > 0)
                    {
                      GET_HEAP(dim, A_LIST((*my_desc), ptdv));
                      pth = R_LIST(*my_desc,ptdv);
                      for (i = 0; i < dim; i++)
                        pth[i] = go_get_it();
                    }
                    ptdesc = (T_PTD)R_LIST(*my_desc, ptdv)[0];
                    pth = R_LIST(*ptdesc, ptdv);
                    dim = R_LIST(*my_desc, dim);
                    pth[1] |= SET_EDIT(-99);
                    pth[dim -1] |= SET_EDIT(-99);
                    if (4 == dim)
                      pth[2] |= SET_EDIT(2);
                  }
                  break;
    case ri_list: fscanf(tasm2kir, "%d", &dim);
                  if (0 == dim) return_value = (int)_nil;       
                  else 
                  {
                    MAKEDESC(my_desc, 1, C_LIST, TY_UNDEF);
                    L_LIST(*my_desc, ptdd) = NULL;
                    return_value = (int)my_desc;
                    L_LIST((*my_desc), dim) = dim;
                    if (dim > 0)
                    {
                      GET_HEAP(dim, A_LIST((*my_desc), ptdv));
                      pth = R_LIST(*my_desc,ptdv);
                      for (i = 0; i < dim; i++)
                        pth[i] = go_get_it();
                    }
                  }
                  break;
    case ri_frame: fscanf(tasm2kir, "%d", &dim); /* cr 16.02.96 */
                  if (0 == dim) return_value = (int)_nilstruct;       
                  else 
                  {
                    MAKEDESC(my_desc, 1, C_FRAME, TY_FRAME);
                    return_value = (int)my_desc;
                    L_FRAME((*my_desc), dim) = dim;
                    if (dim > 0)
                    {
                      GET_HEAP(dim, A_FRAME((*my_desc), slots));
                      pth = R_FRAME(*my_desc,slots);
                      for (i = 0; i < dim; i++)
                        pth[i] = go_get_it();
                    }
                  }
                  break;
    case ri_slot: MAKEDESC(my_desc, 1, C_FRAME, TY_SLOT); /* cr 16.02.96 */
                  return_value = (int)my_desc;
                  L_SLOT((*my_desc), name) = (T_PTD)go_get_it();
                  L_SLOT((*my_desc), value) = go_get_it();
                  break;
    case ri_comb: {
                    int arity; /* used args */
                    int arg;   /* needed args */
                    int graph_adr; /* zeiger auf letrecdescr. */
                    int old_desc; /* zeiger auf COMB-Descriptor */

                    fscanf(tasm2kir, " %d %d %d %d", &arity, &arg, &graph_adr, &old_desc);
                    MAKEDESC(my_desc,1,C_FUNC,TY_COMB);
                    return_value = (int)my_desc;
                    L_COMB(*my_desc, nargs) = arity;
                    L_COMB(*my_desc, args) = arg;
                    L_COMB(*my_desc, ptd) = (T_PTD)graph_adr;
                    L_COMB(*my_desc, ptc) = R_COMB(*(PTR_DESCRIPTOR)old_desc, ptc);
                    break;
                  }
    case ri_dyncomb: {
                    int arity; /* used args */
                    int arg;   /* needed args */

                    fscanf(tasm2kir, " %d %d", &arity, &arg);
                    MAKEDESC(my_desc,1,C_FUNC,TY_COMB);
                    return_value = (int)my_desc;
                    L_COMB(*my_desc, nargs) = arity;
                    L_COMB(*my_desc, args) = arg;
                    L_COMB(*my_desc, ptd) = (T_PTD)go_get_it();
                    break;
                  }
#if WITHTILDE                  
    case ri_case: {
                    int arity; /* used args */
                    int arg;   /* needed args */
                    int graph_adr; /* zeiger auf letrecdescr. */
                    int old_desc; /* zeiger auf CASE-Deskriptor */

                    fscanf(tasm2kir, " %d %d %d %d", &arity, &arg, &graph_adr, &old_desc);
                    MAKEDESC(my_desc,1,C_FUNC,TY_CASE);
                    return_value = (int)my_desc;
                    L_CASE(*my_desc, nargs) = arity;
                    L_CASE(*my_desc, args) = arg;
                    L_CASE(*my_desc, ptd) = (T_PTD)graph_adr;
                    L_CASE(*my_desc, ptc) = R_CASE(*(PTR_DESCRIPTOR)old_desc, ptc);
                    break;
                  }
    case ri_nomat:{
                    int act_nomat, reason, ptsdes, len;

                    fscanf(tasm2kir, " %d %d %d %d", &act_nomat, &reason, &ptsdes, &len);
                    MAKEDESC(my_desc, 1, C_EXPRESSION, TY_NOMAT);
                    return_value = (int)my_desc;
                    L_NOMAT(*my_desc, act_nomat) = act_nomat;
                    GET_HEAP(4, A_NOMAT(*my_desc, guard_body));
                    L_NOMAT(*my_desc, reason) = reason;
                    L_NOMAT(*my_desc, ptsdes) = (T_PTD)ptsdes;
                    L_NOMAT(*my_desc, guard_body)[0] = len;
                    L_NOMAT(*my_desc, guard_body)[1] = go_get_it(); /* guard */ 
                    L_NOMAT(*my_desc, guard_body)[2] = go_get_it(); /* closure */
                    L_NOMAT(*my_desc, guard_body)[3] = go_get_it(); /* arg from match */
                    ptdesc = (T_PTD)R_SWITCH(*(T_PTD)ptsdes, ptse)[act_nomat];
                    load_expr(A_MATCH(*ptdesc, body));
                    trav_e_a();
                    trav_a_hilf();
                    if (NULL == mvheap(A_FUNC(*ptdesc, pte))) 
                      post_mortem("rtasm.c: go_get_it(): Heap out of space");
                    break;
                  }
#endif
    case ri_cond: {
                    int arity; /* used args */
                    int arg;   /* needed args */
                    int graph_adr; /* zeiger auf letrecdescr. */
                    int old_desc; /* zeiger auf CONDI_Deskriptor */

                    fscanf(tasm2kir, " %d %d %d %d", &arity, &arg, &graph_adr, &old_desc);
                    MAKEDESC(my_desc, 1, C_FUNC, TY_CONDI);
                    return_value = (int)my_desc;
                    L_CONDI(*my_desc, nargs) = arity;
                    L_CONDI(*my_desc, args) = arg;
                    L_CONDI(*my_desc, ptd) = (T_PTD)graph_adr;
                    L_CONDI(*my_desc, ptc) = R_CONDI(*(PTR_DESCRIPTOR)old_desc, ptc);
                    break;
                  }
    case ri_const: {
                    int a;
                    fscanf(tasm2kir, " %d", &a);               /* reading ri_var */ 
                    MAKEDESC(my_desc, 1, C_CONSTANT, TY_VAR);
                    return_value = (int)my_desc;
                    fscanf(tasm2kir, " %d", &a);
                    L_VAR(*my_desc, nlabar) = a;
                    L_VAR(*my_desc, ptnd) = (T_PTD)go_get_it();
                    break;
                  }
    case ri_expr: {
                    
                    int arity; /* used args + 1 */
                    int arg; 
                    int what_is_it; /* what kind of expression */
                    
                    fscanf(tasm2kir, " %d", &what_is_it);
                    switch(what_is_it)
                    {
#if WITHTILDE

                      case ri_name:
                      {
                        fscanf(tasm2kir, " %d", &arg); /* # of following elements */
                        MAKEDESC(my_desc, 1, C_EXPRESSION, TY_NAME);
                        return_value = (int)my_desc;
                        GET_HEAP(arg + 1, A_NAME(*my_desc, ptn));
                        pth = R_NAME(*my_desc, ptn);
                        *pth++ = arg;
                        RES_HEAP;
                        for (i = 0; i < arg; i++)
                        {
                          fscanf(tasm2kir, " %d", &arity);
                          pth[i] = arity;
                        }
                        REL_HEAP;
                        break;
                      }
                      
                      case ri_expr:
                      {
                        
                        MAKEDESC(my_desc, 1, C_EXPRESSION, TY_EXPR);
                        return_value = (int)my_desc;
                        fscanf(tasm2kir, " %d %d", &arity, &arg);
                        GET_HEAP(arity + 1, (int)A_EXPR(*my_desc, pte));
                        pth = (PTR_HEAPELEM)R_EXPR(*my_desc, pte);
                        *pth++ = arity;
                        *pth++ = arg;
                        for (i = 0; i < arity - 1; i++)
                          pth[i] = go_get_it();
                        break;
                      }
                      case ri_nomat:
                      {
                        int act_nomat, reason, ptsdes;
                        int guard_body_0, guard_body_1, guard_body_2;
                        fscanf(tasm2kir, " %d %d %d %d", &act_nomat, &reason,
                                                         &ptsdes, &guard_body_0);
                        fscanf(tasm2kir, " %d %d", &guard_body_1, &guard_body_2);
                        MAKEDESC(my_desc, 1, C_EXPRESSION, TY_NOMAT);
                        return_value = (int)my_desc;
                        L_NOMAT(*my_desc, act_nomat) = act_nomat;
                        L_NOMAT(*my_desc, reason) = reason;
                        L_NOMAT(*my_desc, ptsdes) = (T_PTD)ptsdes;
                        GET_HEAP(4,A_NOMAT(*my_desc, guard_body)); 
                        L_NOMAT(*my_desc, guard_body)[0] = guard_body_0;
                        L_NOMAT(*my_desc, guard_body)[1] = guard_body_1;
                        L_NOMAT(*my_desc, guard_body)[2] = guard_body_2;
                        L_NOMAT(*my_desc, guard_body)[3] = go_get_it();
                        break;
                      }
                      break;
#endif
                      case ri_sub:
                      {
                        fscanf(tasm2kir, " %d %d", &arity, &arg);
                        MAKEDESC(my_desc, 1, C_EXPRESSION, TY_SUB);
                        return_value = (int)my_desc;
                        GET_HEAP(arity + 1, (int)A_EXPR(*my_desc, pte));
                        pth = (PTR_HEAPELEM)R_EXPR(*my_desc,pte);
                        *pth++ = arity;
                        *pth++ = arg;
                        for (i = 0; i < arity - 1; i++)
                          pth[i] = go_get_it();
                        break;
                      }
                  }
                  break;
                }

    case ri_clos: {
                    int arity; /* used args */
                    int arg;   /* needed args */
                    int primf; /* the tagged function itself */
                    int what_is_it; /* what kind of closure */
                    int j;     /* only for to count */

                    fscanf(tasm2kir, " %d", &what_is_it);
                    switch(what_is_it)
                    {
#if WITHTILDE
                      case ri_nomat:
                      {
                        int nfv, ptsdes, failed_when, i;
                        T_PTD ptd_nomat, ptd_sub, ptd_comb, ptd;

                        fscanf(tasm2kir, " %d %d %d %d %d", 
                                           &arity, &arg, &nfv, &ptsdes, &failed_when);
                        MAKEDESC(my_desc,2,C_FUNC,TY_CLOS);
                        GET_HEAP(arity + nfv + 1, A_CLOS(*my_desc,pta));
                        L_CLOS(*my_desc,args) = arity;
                        L_CLOS(*my_desc,nargs) = arg;
                        L_CLOS(*my_desc,nfv) = nfv;
                        L_CLOS(*my_desc,ftype) = TY_NOMATBODY;
                        
                        MAKEDESC(ptd_nomat, 1, C_EXPRESSION, TY_NOMAT);
                        return_value = (int)ptd_nomat;
                        L_NOMAT(*ptd_nomat, act_nomat) = failed_when;
                        L_NOMAT(*ptd_nomat, ptsdes) = (T_PTD)ptsdes;
                        GET_HEAP(4, A_NOMAT(*ptd_nomat, guard_body));
                        L_NOMAT(*ptd_nomat, guard_body)[0] = 3;   /* 3 following elems */
                        L_NOMAT(*ptd_nomat, guard_body)[2] = (int)my_desc;/* ptr to clos */
                        L_NOMAT(*ptd_nomat, guard_body)[1] = go_get_it();  /* guard */
                        L_NOMAT(*ptd_nomat, guard_body)[3] = go_get_it();  /* match */
                        L_NOMAT(*ptd_nomat, reason) = 3; /* guard neither true nor false*/

                        MAKEDESC(ptd_comb, 2, C_FUNC, TY_COMB);
                        L_COMB(*ptd_comb, args) = 0;
                        L_COMB(*ptd_comb, nargs) = arity;
                        L_COMB(*ptd_comb, ptc) = (INSTR *)0;
                        L_CLOS(*my_desc, pta)[0] = (int)ptd_comb; /* put the COMB 
                                                                desc into the CLOS desc */

                        MAKEDESC(ptd_sub, 1, C_EXPRESSION, TY_SUB);
                        L_COMB(*ptd_comb, ptd) = ptd_sub; /* put the SUB desc into the 
                                                             COMB desc */
                        L_FUNC(*ptd_sub, nargs) = arity;
                        L_FUNC(*ptd_sub, special) = 0;
                        L_FUNC(*ptd_sub, namelist) = 0;
/* get the expression pointed to by ptd */
                        ptd = (T_PTD)R_SWITCH(*(T_PTD)ptsdes, ptse)[failed_when];
                        load_expr(A_MATCH(*ptd, body));
                        trav_e_a();
                        trav_a_hilf();
                        if (NULL == mvheap(A_FUNC(*ptd_sub, pte)))
                          post_mortem("rtasm.c (go_get_it()): Heap out of space");
/* now build the rest of the arg.vector in CLOSURE */
                        pth = (PTR_HEAPELEM)R_CLOS(*my_desc, pta);
                        pth++;
                        for (i = 0; i < arity + nfv; i++)
                          pth[i] = go_get_it();
                        break;
                      }
#endif                      
                      case ri_comb:
                      {
                        int nfv;

                        fscanf(tasm2kir, " %d %d %d", &arity, &arg, &nfv);
                        MAKEDESC(my_desc,1,C_FUNC,TY_CLOS);
                        return_value = (int)my_desc;
                        GET_HEAP(arity + nfv + 1, A_CLOS(*my_desc,pta));
                        L_CLOS(*my_desc,args) = arity;
                        L_CLOS(*my_desc,nargs) = arg;
#if WITHTILDE
                        L_CLOS(*my_desc,nfv) = nfv;
#endif
                        L_CLOS(*my_desc,ftype) = TY_COMB;
                        pth = (PTR_HEAPELEM)R_CLOS(*my_desc, pta);
                        j = arity + nfv + 1;
                        for (i = 0; i < j; i++)
                          pth[i] = go_get_it();
                        break;
                      }
                      case ri_case:
                      { 
                        int nfv;

                        fscanf(tasm2kir, " %d %d %d", &arity, &arg, &nfv);
                        MAKEDESC(my_desc,1,C_FUNC,TY_CLOS);
                        return_value = (int)my_desc;
                        GET_HEAP(arity + nfv + 1, A_CLOS(*my_desc,pta));
                        L_CLOS(*my_desc,args) = arity;
                        L_CLOS(*my_desc,nargs) = arg;
#ifdef WITHTILDE
                        L_CLOS(*my_desc,nfv) = nfv;
#endif
                        L_CLOS(*my_desc,ftype) = TY_CASE;
                        pth = (PTR_HEAPELEM)R_CLOS(*my_desc,pta);
                        j = arity + nfv + 1;
                        for (i = 0; i < j; i++)
                          pth[i] = go_get_it();
                        break;
                      }

                      case ri_cond:
                      {
                        int nfv;
     
                        fscanf(tasm2kir, " %d %d %d", &arity, &arg, &nfv);
                        MAKEDESC(my_desc,1,C_FUNC,TY_CLOS);
                        return_value = (int)my_desc;
                        GET_HEAP(arity + nfv + 1, A_CLOS(*my_desc,pta));
                        L_CLOS(*my_desc,args) = arity;
                        L_CLOS(*my_desc,nargs) = arg;
#ifdef WITHTILDE
                        L_CLOS(*my_desc,nfv) = nfv;
#endif
                        L_CLOS(*my_desc,ftype) = TY_CONDI;
                        pth = (PTR_HEAPELEM)R_CLOS(*my_desc,pta);
                        j = arity + nfv + 1;
                        for (i = 0; i < j; i++)
                          pth[i] = go_get_it();
                        break;
                      }
                      
                      case ri_prim:
                      case ri_intact:
                      {
                        fscanf(tasm2kir, " %d %d %d", &primf, &arity, &arg);
                        MAKEDESC(my_desc,1,C_FUNC,TY_CLOS);
                        return_value = (int)my_desc;
                        GET_HEAP(arity + 1, A_CLOS(*my_desc,pta));
                        L_CLOS(*my_desc,args) = arity;
                        L_CLOS(*my_desc,nargs) = arg;
                        if (what_is_it == ri_prim)
                          L_CLOS(*my_desc,ftype) = TY_PRIM;
                        else
                          L_CLOS(*my_desc,ftype) = TY_INTACT;
                        pth = (PTR_HEAPELEM)R_CLOS(*my_desc,pta);
                        *pth++ = primf;
                        for (i = 0; i < arity; i++)
                          pth[i] = go_get_it();
                        break;
                      }

                      default:  post_mortem("get_tasm_output: unknown tag");
                    }
                    break;
                  }
    case ri_intact: {
                    fscanf(tasm2kir, " %d ", &dim);
                    MAKEDESC(my_desc,1,C_INTACT,TY_INTACT);
                    return_value = (int)my_desc;
                    L_INTACT(*my_desc, dim) = dim;
                    GET_HEAP(dim + 1, A_INTACT(*my_desc,args));
                    RES_HEAP;
                    pth = R_INTACT(*my_desc,args);
                    for(i = 0; i < dim; i++)
                      pth[i] = go_get_it();
                    REL_HEAP;
                    break;
                  }

                    
    default:  post_mortem("get_tasm_output: unknown tag"); 
  }               
  DBUG_RETURN(return_value);
}

int get_tasm_output(void)
{
  DBUG_ENTER(get_tasm_output);
  if (NULL == (tasm2kir = fopen(Tasm2KiR, "rt")))
    post_mortem("get_tasm_output: unable to open inputfile");
  fscanf(tasm2kir, "%lf", &tasm_time);
  DBUG_PRINT("get_tasm_output", ("tasm_time: %lf", tasm_time));
  DBUG_RETURN(go_get_it());
}
@


1.21
log
@first line of tasm2kir: processing time (double)
@
text
@d12 35
a46 35
/*******************************************************************************/
/*                                                                             */
/* Encoding of the Output sending back to reduma                               */
/*                                                                             */
/* output : tag data                                                           */
/*                                                                             */
/* with                                                                        */
/*                                                                             */
/* data   : length output* (in case of ri_list,ri_frame,ri_intact)             */
/*        : tagged_integer | tagged_boolean  (in case of ri_int or ri_bool)    */
/*        : value_of_real (in case of ri_real)                                 */
/*        : arity arg graph_adr  (in case of ri_case, ri_comb or ri_cond)      */
/*        : act_nomat reason ptsdes guard_body[0] guard_body[1] guard_body[2]  */
/*          guard_body[3]                                                      */
/*        : arity arg (in case of ri_sub)                                      */
/*        : tag arity arg nfv (in case of closure) ...                         */
/*        : name value (in case of ri_slot)                                    */
/*                                                                             */
/* act_nomat : integer                                                         */
/* reason    : integer                                                         */
/* arity     : integer                                                         */
/* arg       : integer                                                         */
/* graph_adr : integer                                                         */
/* guard_body[0] : integer                                                     */
/* guard_body[1] : output                                                      */
/* guard_body[2] : output                                                      */
/* guard_body[3] : output                                                      */
/* name          : output                                                      */
/* value         : output                                                      */
/*                                                                             */
/* tag    : ri_int | ri_real | ri_list | ri_func                               */
/*        | ri_mat | ri_vect | ri_tvect | ri_cons | ri_prim                    */
/*                                                                             */
/*                                                                             */
/*******************************************************************************/
d57 1
a57 1
/*******************************************************************************/
d530 1
a530 1
                        for (i = 0; i < arity - arg; i++)
@


1.20
log
@ri_intact value fixed
@
text
@d8 1
d66 3
d564 2
@


1.19
log
@input of interaction closures
@
text
@d54 1
a54 1
                ri_slot = 26, ri_intact
@


1.18
log
@case ri_intact
@
text
@d512 1
d520 4
a523 1
                        L_CLOS(*my_desc,ftype) = TY_PRIM;
d530 1
@


1.17
log
@added ri_frame,ri_slot
@
text
@d19 1
a19 1
/* data   : length output* (in case of ri_list,ri_frame)                       */
d54 1
a54 1
                ri_slot = 26
d530 14
@


1.16
log
@reduce2nf preparation
@
text
@d19 1
a19 1
/* data   : length_of_list output* (in case of ri_list)                        */
d27 1
d38 2
d53 2
a54 1
                ri_name = 22, ri_constant = 23, ri_undef = 24
d63 1
d191 21
@


1.15
log
@undef added
@
text
@d191 1
d193 1
a193 1
                    fscanf(tasm2kir, " %d %d %d", &arity, &arg, &graph_adr);
d199 1
d219 1
d221 1
a221 1
                    fscanf(tasm2kir, " %d %d %d", &arity, &arg, &graph_adr);
d224 4
a227 3
                    L_COMB(*my_desc, nargs) = arity;
                    L_COMB(*my_desc, args) = arg;
                    L_COMB(*my_desc, ptd) = (T_PTD)graph_adr;
d257 1
d259 1
a259 1
                    fscanf(tasm2kir, " %d %d %d", &arity, &arg, &graph_adr);
d265 1
@


1.14
log
@teppfuhler
@
text
@d50 1
a50 1
                ri_name = 22, ri_constant = 23,
d105 2
@


1.13
log
@retranslating of mat, vect, tvect
@
text
@d109 1
a109 1
                      GET_HEAP(nrows * ncols, *A_MVT((*my_desc), ptdv, C_MATRIX));
d119 1
a119 1
                          *A_MVT(*my_desc, ptdv, C_MATRIX));
@


1.12
log
@rereading of userdefined constructors (not as list)
@
text
@d84 46
d132 1
d148 1
d173 1
@


1.11
log
@nilstring removed in reading of strings
@
text
@d103 1
a103 1
                    L_LIST((*my_desc), special) |= SET_EDIT(9);
d111 7
@


1.10
log
@bug fixed
@
text
@a84 3
                  if (0 == dim) return_value = (int)_nilstring;
                  else
                  {
a94 1
                  }
@


1.9
log
@minor change
@
text
@d436 1
a436 1
                        for (i = 0; i < arity; i++)
@


1.8
log
@warnings removed
@
text
@d107 1
a107 1
                    L_LIST((*my_desc), special) = SET_EDIT(9);
@


1.7
log
@*** empty log message ***
@
text
@d54 1
a54 1
void load_expr(), trav_e_a(), trav_a_hilf();
@


1.6
log
@bug fixed in PM
@
text
@d100 17
@


1.5
log
@retranslating of global free vars
@
text
@d237 1
a237 1
                        pth = (PTR_HEAPELEM)A_EXPR(*my_desc, pte);
@


1.4
log
@retranslation of strings
@
text
@d49 2
a50 1
                ri_char = 18, ri_string = 19
d78 1
d191 10
d211 19
d300 1
a300 1
                        MAKEDESC(my_desc,1,C_FUNC,TY_CLOS);
d318 1
a318 1
                        MAKEDESC(ptd_comb, 1, C_FUNC, TY_COMB);
@


1.3
log
@some PM retranslating
@
text
@d48 2
a49 1
                ri_CAVE = 14, ri_nomat = 15, ri_sub = 16, ri_dyncomb = 17
d58 1
d76 1
d81 16
@


1.2
log
@retranslating of unreducible expressions like 'ap 5 to [7]
@
text
@d15 1
a15 1
/* output : signal data                                                        */
d19 8
a26 3
/* data   : length_of_list output*                                             */
/*        : tagged_integer | tagged_boolean                                    */
/*        : value_of_real                                                      */
d28 11
a38 1
/* signal : ri_int | ri_real | ri_list | ri_func                               */
d47 2
a48 1
                ri_comb = 10, ri_cond = 11, ri_expr = 12
d51 3
a53 2
 
int newdesc(), post_mortem(), newheap();
d57 1
d63 1
d75 3
a77 3
    case ri_real: MAKEDESC(_desc, 1, C_SCALAR, TY_REAL);
                  fscanf(tasm2kir, "%lf", A_SCALAR(*_desc, valr));
                  return_value = (int)_desc;
d83 10
a92 7
                    MAKEDESC(_desc, 1, C_LIST, TY_UNDEF);
                    return_value = (int)_desc;
                    L_LIST((*_desc), dim) = dim;
                    GET_HEAP(dim, A_LIST((*_desc), ptdv));
                    pth = R_LIST(*_desc,ptdv);
                    for (i = 0; i < dim; i++)
                      pth[i] = go_get_it();
d101 53
a153 5
                    MAKEDESC(_desc,1,C_FUNC,TY_COMB);
                    return_value = (int)_desc;
                    L_COMB(*_desc, nargs) = arity;
                    L_COMB(*_desc, args) = arg;
                    L_COMB(*_desc, ptd) = (T_PTD)graph_adr;
d156 1
d163 5
a167 5
                    MAKEDESC(_desc, 1, C_FUNC, TY_CONDI);
                    return_value = (int)_desc;
                    L_CONDI(*_desc, nargs) = arity;
                    L_CONDI(*_desc, args) = arg;
                    L_CONDI(*_desc, ptd) = (T_PTD)graph_adr;
d171 1
d173 55
a227 12
                    int arg;   
 
                    fscanf(tasm2kir, " %d %d", &arity, &arg);
                    MAKEDESC(_desc, 1, C_EXPRESSION, TY_EXPR);
                    return_value = (int)_desc;
                    GET_HEAP(arity + 1, (int)A_EXPR(*_desc, pte));
                    pth = (PTR_HEAPELEM)R_EXPR(*_desc,pte);
                    *pth++ = arity;
                    *pth++ = arg;
                    for (i = 0; i < arity - 1; i++)
                      pth[i] = go_get_it();
                    break;
d229 2
d242 54
d301 25
a325 5
                        MAKEDESC(_desc,1,C_FUNC,TY_CLOS);
                        return_value = (int)_desc;
                        GET_HEAP(arity + nfv + 1, A_CLOS(*_desc,pta));
                        L_CLOS(*_desc,args) = arity;
                        L_CLOS(*_desc,nargs) = arg;
d327 1
a327 1
                        L_CLOS(*_desc,nfv) = nfv;
d329 2
a330 2
                        L_CLOS(*_desc,ftype) = TY_COMB;
                        pth = (PTR_HEAPELEM)R_CLOS(*_desc,pta);
d336 1
d342 5
a346 5
                        MAKEDESC(_desc,1,C_FUNC,TY_CLOS);
                        return_value = (int)_desc;
                        GET_HEAP(arity + nfv + 1, A_CLOS(*_desc,pta));
                        L_CLOS(*_desc,args) = arity;
                        L_CLOS(*_desc,nargs) = arg;
d348 1
a348 1
                        L_CLOS(*_desc,nfv) = nfv;
d350 2
a351 2
                        L_CLOS(*_desc,ftype) = TY_CONDI;
                        pth = (PTR_HEAPELEM)R_CLOS(*_desc,pta);
d361 7
a367 7
                        MAKEDESC(_desc,1,C_FUNC,TY_CLOS);
                        return_value = (int)_desc;
                        GET_HEAP(arity + 1, A_CLOS(*_desc,pta));
                        L_CLOS(*_desc,args) = arity;
                        L_CLOS(*_desc,nargs) = arg;
                        L_CLOS(*_desc,ftype) = TY_PRIM;
                        pth = (PTR_HEAPELEM)R_CLOS(*_desc,pta);
d373 1
a373 1
                      default: post_mortem("get_tasm_output: unknown tag");
d378 1
a378 1
    default: post_mortem("get_tasm_output: unknown tag"); 
@


1.2.1.1
log
@bug fix in file reading (in case of ri_expr)
@
text
@d15 1
a15 1
/* output : tag data                                                           */
d19 3
a21 8
/* data   : length_of_list output* (in case of ri_list)                        */
/*        : tagged_integer | tagged_boolean  (in case of ri_int or ri_bool)    */
/*        : value_of_real (in case of ri_real)                                 */
/*        : arity arg graph_adr  (in case of ri_case, ri_comb or ri_cond)      */
/*        : act_nomat reason ptsdes guard_body[0] guard_body[1] guard_body[2]  */
/*          guard_body[3]                                                      */
/*        : arity arg (in case of ri_sub)                                      */
/*        : tag arity arg nfv (in case of closure) ...                         */
d23 1
a23 11
/* act_nomat : integer                                                         */
/* reason    : integer                                                         */
/* arity     : integer                                                         */
/* arg       : integer                                                         */
/* graph_adr : integer                                                         */
/* guard_body[0] : integer                                                     */
/* guard_body[1] : output                                                      */
/* guard_body[2] : output                                                      */
/* guard_body[3] : output                                                      */
/*                                                                             */
/* tag    : ri_int | ri_real | ri_list | ri_func                               */
d32 1
a32 2
                ri_comb = 10, ri_cond = 11, ri_expr = 12, ri_case = 13,
                ri_CAVE = 14, ri_nomat = 15, ri_sub = 16, ri_dyncomb = 17
d35 2
a36 3

void load_expr(), trav_e_a(), trav_a_hilf();
int newdesc(), post_mortem(), newheap(), mvheap();
a39 1
T_PTD ptdesc;
a44 1
  PTR_DESCRIPTOR my_desc;
d56 3
a58 3
    case ri_real: MAKEDESC(my_desc, 1, C_SCALAR, TY_REAL);
                  fscanf(tasm2kir, "%lf", A_SCALAR(*my_desc, valr));
                  return_value = (int)my_desc;
d64 7
a70 10
                    MAKEDESC(my_desc, 1, C_LIST, TY_UNDEF);
                    return_value = (int)my_desc;
                    L_LIST((*my_desc), dim) = dim;
                    if (dim > 0)
                    {
                      GET_HEAP(dim, A_LIST((*my_desc), ptdv));
                      pth = R_LIST(*my_desc,ptdv);
                      for (i = 0; i < dim; i++)
                        pth[i] = go_get_it();
                    }
d79 5
a83 53
                    MAKEDESC(my_desc,1,C_FUNC,TY_COMB);
                    return_value = (int)my_desc;
                    L_COMB(*my_desc, nargs) = arity;
                    L_COMB(*my_desc, args) = arg;
                    L_COMB(*my_desc, ptd) = (T_PTD)graph_adr;
                    break;
                  }
    case ri_dyncomb: {
                    int arity; /* used args */
                    int arg;   /* needed args */

                    fscanf(tasm2kir, " %d %d", &arity, &arg);
                    MAKEDESC(my_desc,1,C_FUNC,TY_COMB);
                    return_value = (int)my_desc;
                    L_COMB(*my_desc, nargs) = arity;
                    L_COMB(*my_desc, args) = arg;
                    L_COMB(*my_desc, ptd) = (T_PTD)go_get_it();
                    break;
                  }
#if WITHTILDE                  
    case ri_case: {
                    int arity; /* used args */
                    int arg;   /* needed args */
                    int graph_adr; /* zeiger auf letrecdescr. */

                    fscanf(tasm2kir, " %d %d %d", &arity, &arg, &graph_adr);
                    MAKEDESC(my_desc,1,C_FUNC,TY_CASE);
                    return_value = (int)my_desc;
                    L_COMB(*my_desc, nargs) = arity;
                    L_COMB(*my_desc, args) = arg;
                    L_COMB(*my_desc, ptd) = (T_PTD)graph_adr;
                    break;
                  }
    case ri_nomat:{
                    int act_nomat, reason, ptsdes, len;

                    fscanf(tasm2kir, " %d %d %d %d", &act_nomat, &reason, &ptsdes, &len);
                    MAKEDESC(my_desc, 1, C_EXPRESSION, TY_NOMAT);
                    return_value = (int)my_desc;
                    L_NOMAT(*my_desc, act_nomat) = act_nomat;
                    GET_HEAP(4, A_NOMAT(*my_desc, guard_body));
                    L_NOMAT(*my_desc, reason) = reason;
                    L_NOMAT(*my_desc, ptsdes) = (T_PTD)ptsdes;
                    L_NOMAT(*my_desc, guard_body)[0] = len;
                    L_NOMAT(*my_desc, guard_body)[1] = go_get_it(); /* guard */ 
                    L_NOMAT(*my_desc, guard_body)[2] = go_get_it(); /* closure */
                    L_NOMAT(*my_desc, guard_body)[3] = go_get_it(); /* arg from match */
                    ptdesc = (T_PTD)R_SWITCH(*(T_PTD)ptsdes, ptse)[act_nomat];
                    load_expr(A_MATCH(*ptdesc, body));
                    trav_e_a();
                    trav_a_hilf();
                    if (NULL == mvheap(A_FUNC(*ptdesc, pte))) 
                      post_mortem("rtasm.c: go_get_it(): Heap out of space");
a85 1
#endif
d92 5
a96 5
                    MAKEDESC(my_desc, 1, C_FUNC, TY_CONDI);
                    return_value = (int)my_desc;
                    L_CONDI(*my_desc, nargs) = arity;
                    L_CONDI(*my_desc, args) = arg;
                    L_CONDI(*my_desc, ptd) = (T_PTD)graph_adr;
a99 1
                    
d101 12
a112 55
                    int arg; 
                    int what_is_it; /* what kind of expression */
                    
                    fscanf(tasm2kir, " %d", &what_is_it);
                    switch(what_is_it)
                    {
#if WITHTILDE
                      case ri_expr:
                      {
                        
                        MAKEDESC(my_desc, 1, C_EXPRESSION, TY_EXPR);
                        return_value = (int)my_desc;
                        fscanf(tasm2kir, " %d %d", &arity, &arg);
                        GET_HEAP(arity + 1, (int)A_EXPR(*my_desc, pte));
                        pth = (PTR_HEAPELEM)R_EXPR(*my_desc, pte);
                        *pth++ = arity;
                        *pth++ = arg;
                        for (i = 0; i < arity - 1; i++)
                          pth[i] = go_get_it();
                        break;
                      }
                      case ri_nomat:
                      {
                        int act_nomat, reason, ptsdes;
                        int guard_body_0, guard_body_1, guard_body_2;
                        fscanf(tasm2kir, " %d %d %d %d", &act_nomat, &reason,
                                                         &ptsdes, &guard_body_0);
                        fscanf(tasm2kir, " %d %d", &guard_body_1, &guard_body_2);
                        MAKEDESC(my_desc, 1, C_EXPRESSION, TY_NOMAT);
                        return_value = (int)my_desc;
                        L_NOMAT(*my_desc, act_nomat) = act_nomat;
                        L_NOMAT(*my_desc, reason) = reason;
                        L_NOMAT(*my_desc, ptsdes) = (T_PTD)ptsdes;
                        GET_HEAP(4,A_NOMAT(*my_desc, guard_body)); 
                        L_NOMAT(*my_desc, guard_body)[0] = guard_body_0;
                        L_NOMAT(*my_desc, guard_body)[1] = guard_body_1;
                        L_NOMAT(*my_desc, guard_body)[2] = guard_body_2;
                        L_NOMAT(*my_desc, guard_body)[3] = go_get_it();
                        break;
                      }
                      break;
#endif
                      case ri_sub:
                      {
                        fscanf(tasm2kir, " %d %d", &arity, &arg);
                        MAKEDESC(my_desc, 1, C_EXPRESSION, TY_SUB);
                        return_value = (int)my_desc;
                        GET_HEAP(arity + 1, (int)A_EXPR(*my_desc, pte));
                        pth = (PTR_HEAPELEM)R_EXPR(*my_desc,pte);
                        *pth++ = arity;
                        *pth++ = arg;
                        for (i = 0; i < arity - 1; i++)
                          pth[i] = go_get_it();
                        break;
                      }
a113 2
                  break;
                }
a124 54
#if WITHTILDE
                      case ri_nomat:
                      {
                        int nfv, ptsdes, failed_when, i;
                        T_PTD ptd_nomat, ptd_sub, ptd_comb, ptd;

                        fscanf(tasm2kir, " %d %d %d %d %d", 
                                           &arity, &arg, &nfv, &ptsdes, &failed_when);
                        MAKEDESC(my_desc,1,C_FUNC,TY_CLOS);
                        GET_HEAP(arity + nfv + 1, A_CLOS(*my_desc,pta));
                        L_CLOS(*my_desc,args) = arity;
                        L_CLOS(*my_desc,nargs) = arg;
                        L_CLOS(*my_desc,nfv) = nfv;
                        L_CLOS(*my_desc,ftype) = TY_NOMATBODY;
                        
                        MAKEDESC(ptd_nomat, 1, C_EXPRESSION, TY_NOMAT);
                        return_value = (int)ptd_nomat;
                        L_NOMAT(*ptd_nomat, act_nomat) = failed_when;
                        L_NOMAT(*ptd_nomat, ptsdes) = (T_PTD)ptsdes;
                        GET_HEAP(4, A_NOMAT(*ptd_nomat, guard_body));
                        L_NOMAT(*ptd_nomat, guard_body)[0] = 3;   /* 3 following elems */
                        L_NOMAT(*ptd_nomat, guard_body)[2] = (int)my_desc;/* ptr to clos */
                        L_NOMAT(*ptd_nomat, guard_body)[1] = go_get_it();  /* guard */
                        L_NOMAT(*ptd_nomat, guard_body)[3] = go_get_it();  /* match */
                        L_NOMAT(*ptd_nomat, reason) = 3; /* guard neither true nor false*/

                        MAKEDESC(ptd_comb, 1, C_FUNC, TY_COMB);
                        L_COMB(*ptd_comb, args) = 0;
                        L_COMB(*ptd_comb, nargs) = arity;
                        L_COMB(*ptd_comb, ptc) = (INSTR *)0;
                        L_CLOS(*my_desc, pta)[0] = (int)ptd_comb; /* put the COMB 
                                                                desc into the CLOS desc */

                        MAKEDESC(ptd_sub, 1, C_EXPRESSION, TY_SUB);
                        L_COMB(*ptd_comb, ptd) = ptd_sub; /* put the SUB desc into the 
                                                             COMB desc */
                        L_FUNC(*ptd_sub, nargs) = arity;
                        L_FUNC(*ptd_sub, special) = 0;
                        L_FUNC(*ptd_sub, namelist) = 0;
/* get the expression pointed to by ptd */
                        ptd = (T_PTD)R_SWITCH(*(T_PTD)ptsdes, ptse)[failed_when];
                        load_expr(A_MATCH(*ptd, body));
                        trav_e_a();
                        trav_a_hilf();
                        if (NULL == mvheap(A_FUNC(*ptd_sub, pte)))
                          post_mortem("rtasm.c (go_get_it()): Heap out of space");
/* now build the rest of the arg.vector in CLOSURE */
                        pth = (PTR_HEAPELEM)R_CLOS(*my_desc, pta);
                        pth++;
                        for (i = 0; i < arity + nfv; i++)
                          pth[i] = go_get_it();
                        break;
                      }
#endif                      
d130 5
a134 25
                        MAKEDESC(my_desc,1,C_FUNC,TY_CLOS);
                        return_value = (int)my_desc;
                        GET_HEAP(arity + nfv + 1, A_CLOS(*my_desc,pta));
                        L_CLOS(*my_desc,args) = arity;
                        L_CLOS(*my_desc,nargs) = arg;
#if WITHTILDE
                        L_CLOS(*my_desc,nfv) = nfv;
#endif
                        L_CLOS(*my_desc,ftype) = TY_COMB;
                        pth = (PTR_HEAPELEM)R_CLOS(*my_desc, pta);
                        j = arity + nfv + 1;
                        for (i = 0; i < j; i++)
                          pth[i] = go_get_it();
                        break;
                      }
                      case ri_case:
                      { 
                        int nfv;

                        fscanf(tasm2kir, " %d %d %d", &arity, &arg, &nfv);
                        MAKEDESC(my_desc,1,C_FUNC,TY_CLOS);
                        return_value = (int)my_desc;
                        GET_HEAP(arity + nfv + 1, A_CLOS(*my_desc,pta));
                        L_CLOS(*my_desc,args) = arity;
                        L_CLOS(*my_desc,nargs) = arg;
d136 1
a136 1
                        L_CLOS(*my_desc,nfv) = nfv;
d138 2
a139 2
                        L_CLOS(*my_desc,ftype) = TY_CASE;
                        pth = (PTR_HEAPELEM)R_CLOS(*my_desc,pta);
a144 1

d150 5
a154 5
                        MAKEDESC(my_desc,1,C_FUNC,TY_CLOS);
                        return_value = (int)my_desc;
                        GET_HEAP(arity + nfv + 1, A_CLOS(*my_desc,pta));
                        L_CLOS(*my_desc,args) = arity;
                        L_CLOS(*my_desc,nargs) = arg;
d156 1
a156 1
                        L_CLOS(*my_desc,nfv) = nfv;
d158 2
a159 2
                        L_CLOS(*my_desc,ftype) = TY_CONDI;
                        pth = (PTR_HEAPELEM)R_CLOS(*my_desc,pta);
d169 7
a175 7
                        MAKEDESC(my_desc,1,C_FUNC,TY_CLOS);
                        return_value = (int)my_desc;
                        GET_HEAP(arity + 1, A_CLOS(*my_desc,pta));
                        L_CLOS(*my_desc,args) = arity;
                        L_CLOS(*my_desc,nargs) = arg;
                        L_CLOS(*my_desc,ftype) = TY_PRIM;
                        pth = (PTR_HEAPELEM)R_CLOS(*my_desc,pta);
d181 1
a181 1
                      default:  post_mortem("get_tasm_output: unknown tag");
d186 1
a186 1
    default:  post_mortem("get_tasm_output: unknown tag"); 
@


1.1
log
@Initial revision
@
text
@d32 1
a32 1
                ri_comb = 10, ri_cond = 11
d92 1
a92 1
                    MAKEDESC(_desc,1,C_FUNC,TY_CONDI);
d97 15
@
