head	1.22;
access;
symbols
	continuation_based_interactions:1.4;
locks; strict;
comment	@ * @;


1.22
date	2001.07.02.14.53.33;	author base;	state Exp;
branches;
next	1.21;

1.21
date	98.07.03.11.28.11;	author rs;	state Exp;
branches;
next	1.20;

1.20
date	98.06.17.15.27.06;	author rs;	state Exp;
branches;
next	1.19;

1.19
date	97.02.17.16.22.02;	author stt;	state Exp;
branches;
next	1.18;

1.18
date	96.07.31.12.37.04;	author stt;	state Exp;
branches;
next	1.17;

1.17
date	96.03.05.13.26.43;	author stt;	state Exp;
branches;
next	1.16;

1.16
date	96.03.01.17.04.07;	author stt;	state Exp;
branches;
next	1.15;

1.15
date	96.02.26.14.42.17;	author stt;	state Exp;
branches;
next	1.14;

1.14
date	96.02.20.13.26.03;	author cr;	state Exp;
branches;
next	1.13;

1.13
date	96.02.16.16.16.04;	author rs;	state Exp;
branches;
next	1.12;

1.12
date	96.02.15.16.57.39;	author stt;	state Exp;
branches;
next	1.11;

1.11
date	96.02.13.13.25.46;	author stt;	state Exp;
branches;
next	1.10;

1.10
date	96.02.08.17.14.31;	author stt;	state Exp;
branches;
next	1.9;

1.9
date	96.01.18.16.45.53;	author stt;	state Exp;
branches;
next	1.8;

1.8
date	96.01.08.15.36.59;	author stt;	state Exp;
branches;
next	1.7;

1.7
date	95.11.27.09.28.48;	author stt;	state Exp;
branches;
next	1.6;

1.6
date	95.11.17.14.09.48;	author stt;	state Exp;
branches;
next	1.5;

1.5
date	95.11.15.16.43.56;	author stt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.09.15.46.29;	author stt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.08.15.17.29;	author stt;	state Exp;
branches;
next	1.2;

1.2
date	95.09.12.14.30.03;	author stt;	state Exp;
branches;
next	1.1;

1.1
date	95.09.08.10.17.36;	author stt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@compiler warnings eliminated
@
text
@/*
 * $Log: rintact.c,v $
 * Revision 1.21  1998/07/03 11:28:11  rs
 * minor changes
 *
 * Revision 1.20  1998/06/17 15:27:06  rs
 * support for train primitives as interactions
 *
 * Revision 1.19  1997/02/17  16:22:02  stt
 * new function redirect_io()
 * ia_fscanf replaced by ia_fredirect
 * new variables _ptr_instream, _ptr_outstream
 *
 * Revision 1.18  1996/07/31  12:37:04  stt
 * Return-state ERROR literally changed to NE.
 *
 * Revision 1.17  1996/03/05  13:26:43  stt
 * intact_tab[] updated
 *
 * Revision 1.16  1996/03/01  17:04:07  stt
 * test_format()
 *
 * Revision 1.15  1996/02/26  14:42:17  stt
 * output shape of print_environment changed.
 *
 * Revision 1.14  1996/02/20  13:26:03  cr
 * added interactions get and put
 *
 * Revision 1.13  1996/02/16  16:16:04  rs
 * some changes concerning the integration of measurements
 * in tasm
 *
 * Revision 1.12  1996/02/15  16:57:39  stt
 * Pointer to red_dummy replaced by NULL.
 * Using stack access macros from rstack.h.
 * binds_on_stack is now global.
 *
 * Revision 1.11  1996/02/13  13:25:46  stt
 * some standard header includes moved to rintact.h
 *
 * Revision 1.10  1996/02/08  17:14:31  stt
 * simple reduction counting
 * 0-ary interactions are no longer put into descriptors and
 * therefore there must be a special case in intact_inter().
 *
 * Revision 1.9  1996/01/18  16:45:53  stt
 * new function print_environment
 * tilde() from editor copied into this file
 *
 * Revision 1.8  1996/01/08  15:36:59  stt
 * major changes for monadic i/o, many comments
 *
 * Revision 1.7  1995/11/27  09:28:48  stt
 * declarations and use of "virtual working directory" in complete_name
 *
 * Revision 1.6  1995/11/17  14:09:48  stt
 * 'environment' initiated with stdin, stdout and stderr
 *
 * Revision 1.5  1995/11/15  16:43:56  stt
 * evaluation of interactions only if it is no subexpression
 *
 * Revision 1.4  1995/11/09  15:46:29  stt
 * interactions moved to riafunc.c
 * defines moved to rintact.h
 *
 * Revision 1.3  1995/11/08  15:17:29  stt
 * Interaction interpreter and functions implemented.
 *
 * Revision 1.2  1995/09/12  14:30:03  stt
 * interactions supported
 *
 * Revision 1.1  1995/09/08  10:17:36  stt
 * Initial revision
 */

/*
 * --- rintact.c ---------------------------------- stt --- 08.09.95 ----
 *
 * This file contains some global variables like intact_tab, environment
 * etc., some help functions for descriptor and kir file handle handling
 * and, most important, the interaction interpreter routine intact_inter().
 * The routines of the interactions are defined in the file riafunc.c.
 *
 * How does the interaction interpreter work:
 * It is called after the 'normal' interpreter (inter()) has finished. This
 * happens in the function reduce(). The result of inter() lies on the stack W.
 * The interaction interpreter examines the result whether it is some kind of
 * interaction. If not, the reduction continues with the post processing. If
 * yes, the interaction is performed and the new result is checked again, until
 * it is no longer an interaction. If the result is executable, i.e. it is some
 * kind of kir function, than inter() is called again, else the reduction
 * continues with the post processing.
 */


#if D_SLAVE
#include "rncstack.h"
#include "rncmessage.h"
#else
#include "rstackty.h"
#endif

#include "rstdinc.h"
#include "rheapty.h"
#include "rstack.h"
#include "rstelem.h"
#include "rextern.h"
#include "rinter.h"
#include "dbug.h"
#include "rintact.h"

#if TRAIN
#include "/home/railway/inc/RailControl.h"
#endif /* TRAIN */

/* --- global variables --------------------------------------------------- */

/*
 * The interaction table combines the name of an interaction with the function
 * which performed it. The position of an interaction in the table have to
 * match the index of the interaction, which is defined in rstelem.h.
 * Interactions with the function pointer NULL are not yet implemented or
 * are special, like exit, bind, unit.
 *
 * The type of the table (INTACT_TAB) is defined in rstdinc.h:
 *   typedef struct { 
 *     FCTPTR fkt;
 *     char   *name;
 *   } INTACT_TAB;
 */
INTACT_TAB intact_tab[] =         /* FUNC_INDEX */
{{red_fopen,    "ia_fopen"      } /*  0 */
,{red_fclose,   "ia_fclose"     } /*  1 */
,{red_fgetc,    "ia_fgetc"      } /*  2 */
,{red_fputc,    "ia_fputc"      } /*  3 */
,{red_ungetc,   "ia_ungetc"     } /*  4 */
,{red_fgets,    "ia_fgets"      } /*  5 */
,{red_read,     "ia_read"       } /*  6 */
,{red_fputs,    "ia_fputs"      } /*  7 */
,{NULL,         "ia_fprintf"    } /*  8 */
,{red_fredirect,"ia_fredirect"  } /*  9 */
,{red_fseek,    "ia_fseek"      } /*  a */
,{red_ftell,    "ia_ftell"      } /*  b */
,{NULL,         "ia_exit"       } /*  c */
,{red_eof,      "ia_eof"        } /*  d */
,{NULL,         "ia_bind"       } /*  e */
,{NULL,         "ia_unit"       } /*  f */
,{red_finfo,    "ia_finfo"      } /* 10 */
,{red_status,   "ia_status"     } /* 11 */
,{red_remove,   "ia_remove"     } /* 12 */
,{red_rename,   "ia_rename"     } /* 13 */
,{red_copy,     "ia_copy"       } /* 14 */
,{red_mkdir,    "ia_mkdir"      } /* 15 */
,{red_rmdir,    "ia_rmdir"      } /* 16 */
,{red_chdir,    "ia_chdir"      } /* 17 */
,{red_getwd,    "ia_getwd"      } /* 18 */
,{red_dir,      "ia_dir"        } /* 19 */
,{red_get,      "ia_get"        } /* 1a */
,{red_put,      "ia_put"        } /* 1b */

#if TRAIN

,{red_set_speed, "ia_set_speed" }
,{red_get_speed, "ia_get_speed" }
,{red_set_direction, "ia_set_direction" }
,{red_get_direction, "ia_get_direction" }
,{red_set_point, "ia_set_point" }
,{red_get_point, "ia_get_point" }
,{red_set_relay, "ia_set_relay" }
,{red_get_relay, "ia_get_relay" }
,{red_set_signal, "ia_set_signal" }
,{red_get_signal, "ia_get_signal" }
,{red_read_M1, "ia_read_M1" }
,{red_read_M2, "ia_read_M2" }

#endif

};

const int INTACT_TAB_SIZE = (sizeof(intact_tab)/sizeof(intact_tab[0]));


/*
 * Some variables which are set in reduce(). They contain values which were 
 * hand over from the editor to the reduction unit.
 */
int _issubexpr;   /* The expression, which should be reduced, is a subexpr. */
char *_ptr_start_dir;   /* The directory in which the reduma is started in. */
char *_ptr_instream;    /* stt 17.02.97         Source and target file for  */
char *_ptr_outstream;   /*     interactions stdIO                           */

/*
 * Number of binds on the bind stack. Will be initialised in reduct().
 */
int ia_binds_on_stack;

/*
 * Pointer to the string which contains the "virtual" working directory.
 * For some notes to the "virtual" working directory see description in
 * riafunc.c, red_getwd.
 * The string is initalised in intact_inter().
 */
char *virtual_wd = NULL;

/*
 * Predefined kir file handles for standard I/O.
 */
FILEHANDLE stderr_filehandle = { stderr, "stderr", 4, 0,
                                 "STDERR", NULL };
FILEHANDLE stdout_filehandle = { stdout, "stdout", 4, 0,
                                 "STDOUT", &stderr_filehandle };
FILEHANDLE stdin_filehandle = { stdin, "stdin", 1, 0,
                                "STDIN", &stdout_filehandle };

/*
 * Global variable, which is used as the entry point of the kir file handle
 * list. All (dynamical generated) file handles in a kir program are inserted
 * in this list. When they were closed, they were deleted out of this list.
 * Normally, there are only a few entries in the same time, so there is no need
 * for a hash table or something like that.
 * The list is initalised with the standard I/O file handles.
 */
FILEHANDLE *environment = &stdin_filehandle;



/* --- help function declarations ----------------------------------------- */


/* ------------------------------------------------------------------------
 * Print the environment list to the given output channel.
 */
void print_environment(FILE *out)
{
  FILEHANDLE *fh;
  char modus[3];
  char no_mode[] = "Filehandle has no valid mode.";

  fprintf(out, "\nList of open files:\n\n");
  fh = environment;
  while (fh != NULL)
  {
    if (T_MODE_R(R_FILEHANDLE(*fh, mode)))
      modus[0] = 'r';
    else
    if (T_MODE_W(R_FILEHANDLE(*fh, mode)))
      modus[0] = 'w';
    else
    if (T_MODE_A(R_FILEHANDLE(*fh, mode)))
      modus[0] = 'a';
    else
      modus[0] = 'X';

    if (T_MODE_PLUS(R_FILEHANDLE(*fh, mode)))
    {
      modus[1] = '+';
      modus[2] = '\0';
    }
    else
      modus[1] = '\0';

    fprintf(out, "Name  : %s\n", R_FILEHANDLE(*fh,filename));
    fprintf(out, "Mode  : %s\n", (modus[0] == 'X') ? no_mode : modus);
    fprintf(out, "Handle: '%s`\n\n", R_FILEHANDLE(*fh,handle));

    fh = R_FILEHANDLE(*fh,next);
  }
}


/* ------------------------------------------------------------------------
 * Checks if the argument is a valid format string for printf (print = 1)
 * or scanf (print = 0).
 *
 * Syntax for printf format strings: '[-+ ]DIGITS[.]DIGITS{diouxXfeEgG}`
 * 
 * Syntax for scanf format strings: 'DIGITS{diouxXfeEgG}`
 *
 * (DIGITS is a (maybe empty) string off digits. ('0'..'9'))
 *
 * Returns  0  if it is not
 *          1  if it is valid for integers (d,i,o,u,x,X)
 *          2  if it is valid for reals (f,g,G,e,E)
 *
 * used by: red_sprintf, red_sscanf (rvalfunc.c)
 *
 */
int test_format(const char *format, int print)
{
  int ret = 0, i = 0, state = 0;
  int len;

  DBUG_ENTER ("test_format");
  START_MODUL("test_format");

  len = strlen(format);

  while (i < len)
  {
    switch (state)
    {
      case 0: /* Start with '%'? */
              if (format[i++] == '%')
                state = (print == 1) ? 1 : 2;
              else
                i = len + 1;
              break;
      case 1: /* Test flags in print pattern. */
              if ((format[i] == '+') ||
                  (format[i] == '-') ||
                  (format[i] == ' ') )
                i++;
              else
                state++;
              break;
      case 2: /* fieldwidth */
              if (format[i] >= '0' &&
                  format[i] <= '9' )
                i++;
              else
                state = (print == 1) ? 3 : 5;
              break;
      case 3: /* precision point */
              if (format[i] == '.')
              {
                state = 4;
                i++;
              }
              else
                state = 5;
              break;
      case 4: /* precision digits */
              if (format[i] >= '0' &&
                  format[i] <= '9' )
                i++;
              else
                state++;
              break;
      case 5: /* type */
              switch (format[i++])
              {
                case 'd':
                case 'i':
                case 'o':
                case 'u':
                case 'x':
                case 'X':
                          ret = 1;
                          break;
                case 'f':
                case 'e':
                case 'E':
                case 'g':
                case 'G':
                          ret = 2;
              }
              state++;
              break;
      case 6: /* format string too long */
              ret = 0;
              i = len + 1;
    }
  }

  END_MODUL("test_format");
  DBUG_RETURN(ret);
}


#if UNIX
/* ------------------------------------------------------------------------
 * Do tilde expansion in file names.
 * This is a copy of the function in cfiles.c from the editor.
 */
static int tilde(char *file, char *exp)
{
#if !D_SLAVE
  *exp = '\0';
  if (file) {
    if (*file == '~') {
      char user[128];
      struct passwd *pw = NULL;
      int i = 0;

      user[0] = '\0';
      file++;
      while (*file != '/' && i < sizeof(user))
        user[i++] = *file++;
      user[i] = '\0';
      if (i == 0) {
        char *login = (char *) getlogin();

        if (login == NULL && (pw = getpwuid(getuid())) == NULL)
          return (0);
        if (login != NULL)
          strcpy(user, login);
      }
      if (pw == NULL && (pw = getpwnam(user)) == NULL)
        return (0);
      strcpy(exp, pw->pw_dir);
    }
    strcat(exp, file);
    return (1);
  }
#endif /* D_SLAVE */
  return (0);
}
#endif

/* ------------------------------------------------------------------------
 * Returns a LIST descriptor representation of the argument string.
 */
PTR_DESCRIPTOR makestrdesc (const char *str)
{
  PTR_DESCRIPTOR desc;
  PTR_HEAPELEM   ptdv;
  int dim,i;

  dim = strlen(str);
  MAKEDESC(desc, 1, C_LIST, TY_STRING);
  L_LIST(*desc,dim) = dim;
  L_LIST(*desc,ptdd) = NULL;
  GET_HEAP(dim,A_LIST(*desc,ptdv));
  ptdv = R_LIST(*desc,ptdv);
  RES_HEAP;
  for (i=0; i<dim; i++) ptdv[i] = TAG_STR_CHAR(str[i]);
  REL_HEAP;
  return(desc);
}


/* ------------------------------------------------------------------------
 * Returns a string representation of the argument, if this is a 
 * LIST-STRING descriptor.
 */
char *getstrfromdesc(PTR_DESCRIPTOR desc)
{
  short dim, i;
  char *str;
  PTR_HEAPELEM  ptdv;
  short error = 0;
  
  if (T_POINTER(desc) &&
      (R_DESC(*desc,class) == C_LIST) &&
      (R_DESC(*desc,type)  == TY_STRING))
  {
    dim  = R_LIST(*desc,dim);
    ptdv = R_LIST(*desc,ptdv);
    
    if ((str = (char *) malloc(dim+1)) == NULL)
      post_mortem("rintact: memory allocation for str not possible.");

    for (i=0; i<dim; i++)
    {
      if (T_STR_CHAR(ptdv[i]))
        str[i] = (char) VALUE(ptdv[i]);
      else
        error = 1;
    }
    
    str[dim] = NULL;
  }
  else
    return(NULL);

  if (error == 1)
  {
    free(str);
    return(NULL);
  }
  else
    return(str);

  /* If the return value is NULL, it was not decidable wheter an error
   * occurred or the argument has dimension 0.
   */
}


/* ------------------------------------------------------------------------
 * Returns a constructor descriptor OK{wert} or NE{wert}.
 */
PTR_DESCRIPTOR makereturnval (int status, PTR_DESCRIPTOR wert)
{
  PTR_DESCRIPTOR list;
  PTR_DESCRIPTOR desc;
  PTR_HEAPELEM   ptdv;

  if (status == OK)
    MAKESTRDESC(list, "_OK");
  else
    MAKESTRDESC(list, "_NE");
  
  MAKEDESC(desc, 1, C_LIST, TY_UNDEF);
  L_LIST(*desc,dim)     = 2;
  L_LIST(*desc,special) = 9;    /* display list in constructor form */
  L_LIST(*desc,ptdd)    = NULL;
  GET_HEAP(2,A_LIST(*desc,ptdv));
  ptdv = R_LIST(*desc,ptdv);
  RES_HEAP;
  ptdv[0] = (int) list;
  ptdv[1] = (int) wert;
  REL_HEAP;
  return(desc);
}


/* ------------------------------------------------------------------------
 * Returns the complete path and name of the argument. If name is not  an
 * absolute pathname, name will be appended to the virtual working directory
 * (virtual_wd). If name starts with a '~', the '~' will be extended to the
 * users home directory. After that, the full name will be simplified by
 * deleting such sequences as 'dir_name/../' or '/./'.
 */
char *completename(char *name, int dir_or_file)
{
  char *fullname, *tmp;
  int pos_t, pos_s;                     /* position target, source */
  
  if ((fullname = (char *) malloc(MAXNAMLEN + 1)) == NULL)
    post_mortem("rintact: memory allocation for fullname not possible.");

  if ((name[0] == '/') ||
      (name[0] == '~'))
  {
    if (strlen(name) > MAXNAMLEN)
      post_mortem("rintact: filename too long");
    strcpy(fullname, name);
  }
  else
  {
    if ((strlen(name) + strlen(virtual_wd)) > MAXNAMLEN)
      post_mortem("rintact: filename too long");
    strcpy(fullname,virtual_wd);
    strcat(fullname,name);       /* concat virtual_wd and name */
  }

  if (dir_or_file == ISDIR)
  {
    pos_t = strlen(fullname);
    if (fullname[pos_t-1] != '/')
    {
      fullname[pos_t] = '/';        /* append '/' at the end of the name */
      fullname[pos_t+1] = '\0';
    }
  }
  
#if UNIX
  if (fullname[0] == '~')
  {
    char ext[MAXNAMLEN+1];
    extern int tilde();

    if (tilde(fullname, ext) == 1)   /* substitute '~' with users home dir. */
      strcpy(fullname, ext);
  }
#endif

  /* simplification of fullname */
  
  while ((tmp = strstr(fullname, "//")) != NULL)
  {
    pos_t = tmp - fullname;
    while (fullname[pos_t] != '\0')
    {
      fullname[pos_t] = fullname[pos_t + 1];
      pos_t++;
    }
  }

  while ((tmp = strstr(fullname, "/./")) != NULL)
  {
    pos_t = tmp - fullname;
    while (fullname[pos_t] != '\0')
    {
      fullname[pos_t] = fullname[pos_t+2];
      pos_t++;
    }
  }

  while ((tmp = strstr(fullname, "/../")) != NULL)
  {
    pos_t = tmp - fullname;
    if (pos_t == 0)
      pos_s = 3;
    else
    {
      pos_s = pos_t + 4;
      while ((pos_t > 0) && (fullname[pos_t-1] != '/'))
        pos_t--;
    }

    while (fullname[pos_t] != '\0')
      fullname[pos_t++] = fullname[pos_s++];
  }

  free(name);
  return(fullname);
}


/* ------------------------------------------------------------------------
 * Free a FILEHANDLE structure.
 */
void freefilehandle(FILEHANDLE *fh)
{
  free(R_FILEHANDLE(*fh,fp));
  free(R_FILEHANDLE(*fh,filename));
  free(R_FILEHANDLE(*fh,handle));
  free(fh);
}


/* ------------------------------------------------------------------------
 * Returns 1, if the filename field and the mode field of the two argument
 * file handles are equal, else 0.
 */
int cmpfilehandle(FILEHANDLE *fh1, FILEHANDLE *fh2)
{
  if ((R_FILEHANDLE(*fh1,mode) == R_FILEHANDLE(*fh2,mode)) &&
      (strcmp(R_FILEHANDLE(*fh1,filename), R_FILEHANDLE(*fh2,filename)) == 0))
    return(0);
  else
    return(1);
}


/* ------------------------------------------------------------------------
 * Adds a new file handle to the file handle list and returns the kir file
 * handle string. 
 * mode had to be in {r w a r+ w+ a+}
 */
char *addfilehandle(FILE *fp, char *filename, char *mode)
{
  FILEHANDLE *fh, **fhptr;
  char       *fname, *handlestr, mode_code, indexstr[8];
  int        index, gap_found;

  if ((fh = (FILEHANDLE *) malloc(sizeof(FILEHANDLE))) == NULL)
    post_mortem("rintact: memory allocation for fh not possible.");
  if ((fname = (char *) malloc(strlen(filename)+1)) == NULL)
    post_mortem("rintact: memory allocation for fname not possible.");

  strcpy(fname, filename);
  
  L_FILEHANDLE(*fh,fp)       = fp;
  L_FILEHANDLE(*fh,filename) = fname;

  mode_code = 0;
  switch (mode[0])
  {
    case 'r': mode_code |= MODE_R;  break;
    case 'w': mode_code |= MODE_W;  break;
    case 'a': mode_code |= MODE_A;  break;
  }
  if (mode[1] == '+')
    mode_code |= MODE_PLUS;
    
  L_FILEHANDLE(*fh,mode)     = mode_code;
  
  /*
   * The file handle list will be scanned for entries with the same filename
   * and the same mode as the arguments. There may be several handles which
   * do fulfill this, separated by their index. The new file handle should
   * obtain the smallest free index (there may be gaps in the sequence of
   * indices after closing a file handle) and inserted in the list between
   * the two file handles (if existing) with the next smaller and the next
   * bigger index.  fhptr always points to the next entry which is to be
   * examined. The loop will be executed until fhptr points to the end of the
   * list or a file handle with the same filename and mode and an index
   * greater than the actual index-counter, in which case there is a index
   * gap.  The new file handle will be inserted right before the element
   * fhptr points to.
   */
  index = 1;
  gap_found = 0;
  fhptr = &environment;
  while (*fhptr != NULL && gap_found == 0)
  {
    if (CMPFILEHANDLE(fh, *fhptr) == 0) 
    {
      if (R_FILEHANDLE(**fhptr, index) > index)
        gap_found = 1;
      else
        index++;
    }
    
    if (gap_found == 0)
      fhptr = &(R_FILEHANDLE(**fhptr,next));
  }
  L_FILEHANDLE(*fh,next) = *fhptr;
  *fhptr = fh;

  L_FILEHANDLE(*fh,index)     = index;
  sprintf(indexstr, "%d", index);
  
  /* Length of handlestr = len(fname)+4(asterix)+6(Index)+2(Mode)+1(EOS) */
  if ((handlestr = (char *) malloc(strlen(fname)+13)) == NULL)
    post_mortem("rintact: memory allocation for handlestr not possible.");
  
  strcpy(handlestr,"*");
  strcat(handlestr,fname);
  strcat(handlestr,"*");
  strcat(handlestr,mode);
  strcat(handlestr,"*");
  strcat(handlestr,indexstr);
  strcat(handlestr,"*");

  L_FILEHANDLE(*fh,handle)   = handlestr;
  return(handlestr);
}


/* ------------------------------------------------------------------------ 
 * Removes a file handle out of the list.
 */
int rmfilehandle(FILEHANDLE *fh)
{
  FILEHANDLE *lastfh, *aktfh;

  if (environment == NULL)
    return(1);

  if (environment == fh)
  {
    environment = R_FILEHANDLE(*environment,next);
    FREEFILEHANDLE(fh);
    return(0);
  }

 
  lastfh = environment;
  aktfh  = R_FILEHANDLE(*environment,next);

  while (aktfh != NULL)
  {
    if (aktfh == fh)
    {
      L_FILEHANDLE(*lastfh,next) = R_FILEHANDLE(*aktfh,next);
      FREEFILEHANDLE(fh);
      return(0);
    }
    
    lastfh = aktfh;
    aktfh  = R_FILEHANDLE(*aktfh,next);
  }

  return(1); 
}


/* ------------------------------------------------------------------------ 
 * Returns a pointer to the file handle which is associated to the
 * file handle string argument.
 */
FILEHANDLE *getfilehandle(char *handle)
{
  FILEHANDLE *fh;
  
  fh = environment;
  while (fh != NULL)
  {
    if (strcmp(R_FILEHANDLE(*fh,handle),handle) == 0)
      break;
    fh  = R_FILEHANDLE(*fh,next);
  }
  /* If the file handle is not in the list NULL is returned. */
  
  return(fh);
}


/* ------------------------------------------------------------------------ 
 * Redirects the standard IO of interactions to a terminal. The terminal
 * is given to the editor at starttime with the option '-s <terminal>'.
 */
void redirect_io()
{
  FILEHANDLE *fh;
  FILE *fp;

  if (_ptr_instream != NULL)
  {
    if ((fp = fopen(_ptr_instream,"r")) == NULL)
      post_mortem("rintact.c: Cannot open input source.");
    else
    {
      if ((GETFILEHANDLE(fh,(char *)"STDIN")) == NULL)
        post_mortem("rintact.c: Cannot get filehandle 'STDIN'.");
      else L_FILEHANDLE(*fh,fp) = fp;
    }
  }
  
  if (_ptr_outstream != NULL)
  {
    if ((fp = fopen(_ptr_outstream,"a")) == NULL)
      post_mortem("rintact.c: Cannot open output target.");
    else
    {
      if ((GETFILEHANDLE(fh,(char *)"STDOUT")) == NULL)
        post_mortem("rintact.c: Cannot get filehandle 'STDOUT'.");
      else L_FILEHANDLE(*fh,fp) = fp;
    }
  }
}


/* ------------------------------------------------------------------------ 
 * Replace top of stack W with itself, embedded into the remaining
 * bind constructors on the bind stack.
 * Example:
 *  BIND_STACK: bind(x1,y1) bind(x2,y2)
 *  TOP_W() := bind(bind(TOP_W(),y2),y1)
 */
void recoverbinds(void)
{
  STACKELEM      *args;
  short          not_bind = 0;
  PTR_DESCRIPTOR ptdesc2, ptdesc1;

  START_MODUL("recoverbinds");
  
  ptdesc1 = (PTR_DESCRIPTOR) POP_W();
  while (ia_binds_on_stack > 0)
  {
    ptdesc2 = ptdesc1;
    ptdesc1 = (PTR_DESCRIPTOR) POP_R();
    ia_binds_on_stack--;
    
    if (T_POINTER(ptdesc1) &&
        (R_DESC(*ptdesc1,class) == C_INTACT) &&
        (R_DESC(*ptdesc1,type) == TY_INTACT) )
    {
      args   = (STACKELEM *) R_INTACT(*ptdesc1,args);
      if (T_IA_BIND((STACKELEM) args[0]))
      {
        if (R_DESC(*ptdesc1,ref_count) > 1)
        {
          /* Decrement ref_count, make new bind with ptdesc2 and arg[2] */
          DEC_REFCNT(ptdesc1);
          MAKEDESC(ptdesc1, 1, C_INTACT, TY_INTACT);
          L_INTACT(*ptdesc1,dim)  = 3;
          GET_HEAP(4, A_INTACT(*ptdesc1,args));
          RES_HEAP;
          R_INTACT(*ptdesc1,args)[0] = IA_BIND;
          R_INTACT(*ptdesc1,args)[1] = (STACKELEM) ptdesc2;
          /* insert the y of the original bind(x,y) */
          R_INTACT(*ptdesc1,args)[2] = args[2];
          REL_HEAP;
          if (T_POINTER(args[2]))
            INC_REFCNT(((PTR_DESCRIPTOR) args[2]));
        }
        else
        {
          /* replace 1. bind-arg with ptdesc2 */
          if (T_POINTER(args[1]))
           DEC_REFCNT(((PTR_DESCRIPTOR) args[1]));
          RES_HEAP;
          args[1] = (STACKELEM) ptdesc2;
          REL_HEAP;
        }
      }
      else
        not_bind = 1;
    }
    else
      not_bind = 1;

    if (not_bind)
      post_mortem("rintact.c: Item on bind stack is not a bind().");
  }
  
  END_MODUL("recoverbinds");
  
  WRITE_W(ptdesc1);
}


/***************************************************************************
 *  intact_inter -- The interaction interpreter.
 ***************************************************************************/

/* If there is an interaction lying on the a-stack (as the result of inter()),
 * the interaction interpreter will perform it until the result is no longer an
 * interaction. After that, inter() will be called again.
 * The continuation based version (14.09.95) now is completely replaced by the
 * monadic style version (20.12.95).
 *
 * At this time, there are three special interactions: bind, unit and exit.
 * bind combines two interactions (or expressions) and dictates a computation
 *  order on interaction. First the interactions in the first argument must be
 *  reduced, and if their result is an unit, the second argument will be
 *  applied to the unit argument.
 * unit enclose the result of a normal interaction (typical) or any other
 *  expression. The only way to accessing the argument of a unit is to use the
 *  unit as the first argument of a bind.
 * exit terminates the program execution (the whole reduma) immediately.
 * The other interactions (if implemented) are performed by calling their
 * function. Their result will be enclosed by a unit construct.
 *
 * How does the monadic style version work:
 * As mentioned above, to execute several interactions you have to combine
 * them with bind. The reduction of a bind goes like this:
 * If the 1.argument of the bind is an interaction (other than unit), push
 * the bind constructor on the bind stack and reduce the argument. When it is
 * reduced to a unit, then pop the bind from the stack and apply the 2.argument
 * to the unit. So, the stack is used to implement a recursive descent into the
 * left subtree of a bind.
 * If, in some state of reduction, the (sub)expression is not reducible,
 * neither by  inter() nor by intact_inter(), and there are bind's on the bind
 * stack left, you have to recover the hole expression, i.e. take the bind's
 * from the stack and re-combinate them.
 * For further details see the comments below and the master thesis of Stephan
 * Timm, 1996.
 */
int intact_inter(void)
{
  /* Static code segments, used for applying a continuation to a result.
   * Example:  bind(unit(x), cont) -> ap cont to x
   */
  static INSTR beta_code[] = { I_BETA, 0, I_EXT, I_END};
  static INSTR apply_code[] = { I_APPLY, 1, I_EXT, I_END};
  
  PTR_DESCRIPTOR desc, ptdesc;           /* pointers to descriptors          */
  STACKELEM      *args, intact;          /* pointers to heap elements        */
  FCTPTR         fctptr;                 /* pointer to interaction functions */
  int dim;                          /* dimension of descriptors              */
  int status = 0;                   /* return value of interaction functions */
  int ret = 0;                      /* address of asm code segment to be     */
                                    /* interpreted by inter().               */
                                     
  
  START_MODUL("intact_inter");

  if (virtual_wd == NULL)                 /* If not yet initiated do it now. */
  {
    dim = strlen(_ptr_start_dir) + 2;
    if ((virtual_wd = (char *) malloc(dim)) == NULL)
      post_mortem("rintact: Cannot allocate memory for _ptr_start_dir.");
    strcpy(virtual_wd, _ptr_start_dir);
    dim = strlen(virtual_wd);
    if (virtual_wd[dim-1] != '/')   /* virtual_wd always has to end with a / */
    {
      virtual_wd[dim] = '/';
      virtual_wd[dim+1] = '\0';
    }
    /* Redirect standard IO of interactions */
    redirect_io();
  }
  
  desc = (PTR_DESCRIPTOR) TOP_W();           /* Get result of inter() */
  
  /*
   * Repeat the loop as long as desc is an interaction (new values are assigned
   * to desc in the loop). 0-ary interactions are simple stack elements while
   * n-ary, n>0, interactions are stored as interaction descriptors.
   * After leaving the loop, there are two possibilities:
   * 1. ret == 0
   *   The result isn't reducible any more. Do not call inter() again.
   * 2. ret != 0
   *   The result is an application which is to be reduced by inter(). ret is
   *   the address of a asm code sequence to be executed. 
   */
  while ( ( ( T_POINTER(desc)   /* Is it an interaction? */
              &&
              (R_DESC(*desc,class) == C_INTACT)
              &&
              (R_DESC(*desc,type) == TY_INTACT)
            )
            ||
            T_IA_GETWD((STACKELEM) desc)
          )
          &&
          !_issubexpr     /* and not a subexpression selected in the editor? */
          &&
          (_redcnt > 0)                   /* Are there Reduction steps left? */
        )
  {                              /* (Reduce interactions on top level only.) */
    ret = 0;
    
    if T_IA_GETWD((STACKELEM) desc)
    {
      status = (int) red_getwd();
      if (status == SYNERR)
      {
        /*
         * The arguments are syntactical wrong. No reduction will be made,
         * interrupt loop.
         */
        WRITE_W(desc);
        desc = (PTR_DESCRIPTOR) NULL;
      }
      else
      {
        /*
         * Interaction was performed, display result.
         */
        MAKERETURNVAL(status, _desc);

        /* Make unit descriptor */
        MAKEDESC(ptdesc, 1, C_INTACT, TY_INTACT);
        L_INTACT(*ptdesc,dim)  = 2;
        GET_HEAP(3, A_INTACT(*ptdesc,args));
        RES_HEAP;
        R_INTACT(*ptdesc,args)[0] = IA_UNIT;
        R_INTACT(*ptdesc,args)[1] = (T_HEAPELEM) _desc;
        REL_HEAP;
        _desc = NULL;

        WRITE_W(ptdesc);
        _redcnt -= 1;
        desc = ptdesc;      /* desc is unit -> repeat loop */
      }
    }
    else
    {
      args   = (STACKELEM *) R_INTACT(*desc,args);
      intact = (STACKELEM) args[0];                   /* type of interaction */
  
      if (FUNC_INDEX(intact) >= INTACT_TAB_SIZE)
        post_mortem("rintact: interaction has wrong index");
        
      /*
       * The interactions bind, unit and exit are special and therefore be
       * treated in special cases.
       */
      if (T_IA_BIND(intact))
      {
        /*
         * The first argument of a bind will be remembered in ptdesc.
         * By decreasing the reference count of the bind (later) the refcnt of
         * of ptdesc get wrong. Therefore the bind being pushed on the stack
         * gets a NULL-Pointer as its 1.argument. (hack)
         */
        ptdesc = (PTR_DESCRIPTOR) args[1];      /* ptdesc = x from bind(x,y) */
        args[1] = (STACKELEM) NULL;
        PUSH_R(desc);
        ia_binds_on_stack++;
        desc = ptdesc;
        WRITE_W(desc);
      }
      else if (T_IA_UNIT(intact))
      {
        if (ia_binds_on_stack > 0)
        {
          /*
           * At this point, I have made the following assumption:
           * The first time intact_inter() is called the bind stack (S_m) is
           * empty.
           * If inter() is (re)called, the stack is returned in the same state
           * as it was before the call (even if there are bind's on it).
           * -> If inter() uses the stack, it recovers the original state before
           *    exiting.
           * If I leave intact_inter for the last time, the stack is empty
           * again.
           * So, if the stack is not empty, the item on the stack had to be a
           * bind constructor which I have put on the stack earlier.
           * In this case I have to pop and 'execute' it, i.e. the 2.argument
           * of the bind (the continuation) has to be applied to the argument
           * of the unit ( R_INTACT(*desc,args)[1] ). This corresponds to one
           * ascending step in the recursive reduction.
           */
           
          short not_bind = 0;        /* There had to be a bind on the stack. */
  
          ptdesc = (PTR_DESCRIPTOR) POP_R();
          ia_binds_on_stack--;
          if (T_POINTER(ptdesc) &&
              (R_DESC(*ptdesc,class) == C_INTACT) &&
              (R_DESC(*ptdesc,type) == TY_INTACT) )
          {
            args   = (STACKELEM *) R_INTACT(*ptdesc,args);
            if (T_IA_BIND((STACKELEM) args[0]))
            {
              PTR_DESCRIPTOR cont = (PTR_DESCRIPTOR) args[2];
              WRITE_W(R_INTACT(*desc,args)[1]);     /* save unit arg. */
              
              if (T_POINTER(cont) &&
                  (R_DESC(*cont,class) == C_FUNC) &&
                  (R_DESC(*cont,type ) == TY_COMB) &&
                  (R_COMB(*cont,nargs) == 1) )
              {
                beta_code[1] = (INSTR) R_COMB(*cont,ptc);
                ret = (int) beta_code;
              }
              else
              {
                PUSH_W(cont);
                ret = (int) apply_code;
              }
              /*
               * Doing some reference counting. (hard job)
               * The bind and the unit constructors are no longer needed, but
               * their arguments are. Therefor increment the refcnt of the
               * unit argument and the 2.argument of the bind (cont) and
               * decrement the refcnt of bind and unit.
               */
              if (T_POINTER(cont))
                INC_REFCNT(cont);
              DEC_REFCNT(ptdesc);                        /* bind constructor */
              if (T_POINTER((PTR_DESCRIPTOR) R_INTACT(*desc,args)[1]))
                INC_REFCNT((PTR_DESCRIPTOR) R_INTACT(*desc,args)[1]);
              DEC_REFCNT(desc);                          /* unit constructor */
              _redcnt -= 1;                    /* decrease reduction counter */
            }
            else
              not_bind = 1;
          }
          else
            not_bind = 1;
  
          if (not_bind)
            post_mortem("rintact.c: Item on bind stack is not a bind().");
        }
        else
        {
          WRITE_W(desc); /* unit(...) is the result of the reduction.*/
        }
        desc = (PTR_DESCRIPTOR) NULL;   /* Interrupt the loop in every case. */
      }
      else if (T_IA_EXIT(intact))
      {
        /*
         * The distributed version of kir may get into difficulties if this
         * exit was executed in a son process.
         */
        if (T_INT(args[1]))
          exit((long int) args[1] / 2);
        else
          exit(1);
      }
      else if ((fctptr = intact_tab[FUNC_INDEX(intact)].fkt) != NULL)
      {
        /*
         * desc is a primitive interaction. Call interaction function an
         * return unit( Status{Value} ).
         */
         
        /*
         * dim is equal to arity of interaction + 1 (the interaction)
         */
        dim    = R_INTACT(*desc,dim);
  
        switch (dim - 1)
        {
          case 1:  status = (int) ((*fctptr)(args[1]));  break;
          case 2:  status = (int) ((*fctptr)(args[1],args[2]));  break;
          case 3:  status = (int) ((*fctptr)(args[1],args[2],args[3]));  break;
          default: post_mortem("rintact.c: interaction has wrong dimension");
        }
        
        if (status == SYNERR)
        {
          /*
           * The arguments are syntactical wrong. No reduction will be made,
           * interrupt loop.
           */
          WRITE_W(desc);
          desc = (PTR_DESCRIPTOR) NULL;
        }
        else 
        {
          /*
           * Reduce interaction, display result.
           */
          DEC_REFCNT(desc);
          MAKERETURNVAL(status, _desc);
      
          /* Make unit descriptor */
          MAKEDESC(ptdesc, 1, C_INTACT, TY_INTACT);
          L_INTACT(*ptdesc,dim)  = 2;
          GET_HEAP(3, A_INTACT(*ptdesc,args));
          RES_HEAP;
          R_INTACT(*ptdesc,args)[0] = IA_UNIT;
          R_INTACT(*ptdesc,args)[1] = (T_HEAPELEM) _desc;
          REL_HEAP;
          _desc = NULL;
      
          WRITE_W(ptdesc);
          _redcnt -= 1;
          desc = ptdesc;                     /* desc is unit -> repeat loop */
        }
      }
      else
      {
        /*
         * desc is a primitive, but not yet implemented interaction. No further
         * reduction can be made, the loop will be interrupted.
         */
        WRITE_W(desc);
        desc = (PTR_DESCRIPTOR) NULL;
      }
    }
  } /* while (desc is interaction) */

  if ( ret == 0 && ia_binds_on_stack > 0 )
  {
    /*
     * The reduction is finished, any bind's left on the bind stack must be
     * recovered to get back the hole expression.
     */
    recoverbinds();
    _desc = NULL;
  }
  
  END_MODUL("intact_inter");
  return(ret);
}

@


1.21
log
@minor changes
@
text
@d1 5
a5 1
/* $Log: rintact.c,v $
d74 1
a74 2
 *
 * */
d552 1
a552 1
    extern tilde();
d783 1
d787 1
d791 2
d795 1
d799 1
d803 2
@


1.20
log
@support for train primitives as interactions
@
text
@d2 3
d157 3
d172 3
@


1.19
log
@new function redirect_io()
ia_fscanf replaced by ia_fredirect
new variables _ptr_instream, _ptr_outstream
@
text
@d2 5
d106 3
d154 12
@


1.18
log
@Return-state ERROR literally changed to NE.
@
text
@d2 3
d127 1
a127 1
,{NULL,         "ia_fscanf"     } /*  9 */
d157 2
d742 27
d907 2
@


1.17
log
@intact_tab[] updated
@
text
@d2 3
d444 1
a444 1
 * Returns a constructor descriptor OK{wert} or ERROR{wert}.
d455 1
a455 1
    MAKESTRDESC(list, "_ERROR");
@


1.16
log
@test_format()
@
text
@d2 3
d130 5
a134 5
,{NULL,         "ia_remove"     } /* 12 */
,{NULL,         "ia_rename"     } /* 13 */
,{NULL,         "ia_copy"       } /* 14 */
,{NULL,         "ia_mkdir"      } /* 15 */
,{NULL,         "ia_rmdir"      } /* 16 */
@


1.15
log
@output shape of print_environment changed.
@
text
@d2 3
d225 99
@


1.14
log
@added interactions get and put
@
text
@d2 3
d105 29
a133 29
INTACT_TAB intact_tab[] =
{{red_fopen,    "ia_fopen"      } /* 0 */
,{red_fclose,   "ia_fclose"     } /* 1 */
,{red_fgetc,    "ia_fgetc"      } /* 2 */
,{red_fputc,    "ia_fputc"      } /* 3 */
,{red_ungetc,   "ia_ungetc"     } /* 4 */
,{red_fgets,    "ia_fgets"      } /* 5 */
,{red_read,     "ia_read"       } /* 6 */
,{red_fputs,    "ia_fputs"      } /* 7 */
,{NULL,         "ia_fprintf"    } /* 8 */
,{NULL,         "ia_fscanf"     } /* 9 */
,{red_fseek,    "ia_fseek"      } /* 10 */
,{red_ftell,    "ia_ftell"      } /* 11 */
,{NULL,         "ia_exit"       } /* 12 */
,{red_eof,      "ia_eof"        } /* 13 */
,{NULL,         "ia_bind"       } /* 14 */
,{NULL,         "ia_unit"       } /* 15 */
,{red_finfo,    "ia_finfo"      } /* 16 */
,{red_status,   "ia_status"     } /* 17 */
,{NULL,         "ia_remove"     } /* 18 */
,{NULL,         "ia_rename"     } /* 19 */
,{NULL,         "ia_copy"       } /* 20 */
,{NULL,         "ia_mkdir"      } /* 21 */
,{NULL,         "ia_rmdir"      } /* 22 */
,{red_chdir,    "ia_chdir"      } /* 23 */
,{red_getwd,    "ia_getwd"      } /* 24 */
,{red_dir,      "ia_dir"        } /* 25 */
,{red_get,      "ia_get"        } /* 26 */
,{red_put,      "ia_put"        } /* 27 */
a189 1
  int index = 0;
d193 1
a193 1
  fprintf(out, "\nThe file handle list.\n\n");
a196 2
    fprintf(out, "Filehandle %d:\n", index);

d217 2
a218 2
    fprintf(out, "Modus : %s\n", (modus[0] == 'X') ? no_mode : modus);
    fprintf(out, "Handle: %s\n\n", R_FILEHANDLE(*fh,handle));
a219 1
    index++;
@


1.13
log
@some changes concerning the integration of measurements
in tasm
@
text
@d2 4
d129 2
@


1.12
log
@Pointer to red_dummy replaced by NULL.
Using stack access macros from rstack.h.
binds_on_stack is now global.
@
text
@d2 5
d227 1
d255 1
@


1.11
log
@some standard header includes moved to rintact.h
@
text
@d2 3
d51 1
a51 1
 * happens in the function reduce(). The result of inter() lie on the stack A.
d70 1
a80 9
 * do-nothing-function for not yet implemented interactions and such,
 * who have a special meaning like exit, bind, unit.
 */
static int red_dummy()
{
  return (0);
} 

/*
d84 2
d94 26
a119 26
{{red_fopen,   "ia_fopen"      } /* 0 */
,{red_fclose,  "ia_fclose"     } /* 1 */
,{red_fgetc,   "ia_fgetc"      } /* 2 */
,{red_fputc,   "ia_fputc"      } /* 3 */
,{red_ungetc,  "ia_ungetc"     } /* 4 */
,{red_fgets,   "ia_fgets"      } /* 5 */
,{red_read,    "ia_read"       } /* 6 */
,{red_fputs,   "ia_fputs"      } /* 7 */
,{red_dummy,   "ia_fprintf"    } /* 8 */
,{red_dummy,   "ia_fscanf"     } /* 9 */
,{red_fseek,   "ia_fseek"      } /* 10 */
,{red_ftell,   "ia_ftell"      } /* 11 */
,{red_dummy,   "ia_exit"       } /* 12 */
,{red_eof,     "ia_eof"        } /* 13 */
,{red_dummy,   "ia_bind"       } /* 14 */
,{red_dummy,   "ia_unit"       } /* 15 */
,{red_finfo,   "ia_finfo"      } /* 16 */
,{red_status,  "ia_status"     } /* 17 */
,{red_dummy,   "ia_remove"     } /* 18 */
,{red_dummy,   "ia_rename"     } /* 19 */
,{red_dummy,   "ia_copy"       } /* 20 */
,{red_mkdir,   "ia_mkdir"      } /* 21 */
,{red_dummy,   "ia_rmdir"      } /* 22 */
,{red_chdir,   "ia_chdir"      } /* 23 */
,{red_getwd,   "ia_getwd"      } /* 24 */
,{red_dir,     "ia_dir"        } /* 25 */
d133 5
d472 2
a473 2
 * Adds a new file handle to the file handle list and returns the kir file handle
 * string. 
d505 12
a516 12
   * The file handle list will be scanned for entries with the same filename and
   * the same mode as the arguments. There may be several handles which do
   * fulfill this, separated by their index. The new file handle should obtain
   * the smallest free index (there may be gaps in the sequence of indices
   * after closing a file handle) and inserted in the list between the two
   * file handles (if existing) with the next smaller and the next bigger index.
   * fhptr always points to the next entry which is to be examined. The loop
   * will be executed until fhptr points to the end of the list or a file handle
   * with the same filename and mode and an index greater than the actual
   * index-counter, in which case there is a index gap.
   * The new file handle will be inserted right before the element fhptr points
   * to.
d617 2
a618 2
 * Returns an expression which is build from the first argument and the
 * bind constructors which are left on the bind stack.
d621 1
a621 1
 *  recoverexpression(expr, 2) -> bind(bind(expr,y2),y1)
d623 1
a623 1
PTR_DESCRIPTOR recoverexpression(PTR_DESCRIPTOR expr, int binds_on_stack)
d627 1
a627 1
  PTR_DESCRIPTOR ptdesc2, ptdesc1 = expr;
d629 1
a629 1
  START_MODUL("recoverexpression");
d631 2
a632 1
  while (binds_on_stack > 0)
d635 2
a636 2
    ptdesc1 = (PTR_DESCRIPTOR) POPSTACK(BIND_STACK);
    binds_on_stack--;
d678 1
a678 1
      post_mortem("rintact.c: Item on " BIND_STACK_STRING " is not a bind().");
d681 1
a681 1
  END_MODUL("recoverexpression");
d683 1
a683 1
  return(ptdesc1);
d707 1
a707 1
 *  function. Their result will be enclosed by a unit construct.
a731 2
  static int binds_on_stack = 0;        /* Number of binds on the bind stack */
  
d757 1
a757 1
  desc = (PTR_DESCRIPTOR) READSTACK(S_a);           /* Get result of inter() */
d796 1
a796 1
        WRITESTACK(S_a, desc);
d816 1
a816 1
        WRITESTACK(S_a, ptdesc);
d843 2
a844 2
        PUSHSTACK(BIND_STACK, (STACKELEM) desc);
        binds_on_stack++;
d846 1
a846 1
        WRITESTACK(S_a, desc);
d850 1
a850 1
        if (binds_on_stack > 0)
d872 2
a873 2
          ptdesc = (PTR_DESCRIPTOR) POPSTACK(BIND_STACK);
          binds_on_stack--;
d882 1
a882 1
              WRITESTACK(S_a,R_INTACT(*desc,args)[1]);     /* save unit arg. */
d894 1
a894 1
                PUSHSTACK(S_a,cont);
d919 1
a919 2
            post_mortem("rintact.c: Item on Stack " BIND_STACK_STRING
                        " is not a bind().");
d923 1
a923 1
          WRITESTACK(S_a, desc); /* unit(...) is the result of the reduction.*/
d938 1
a938 1
      else if ((fctptr = intact_tab[FUNC_INDEX(intact)].fkt) != red_dummy)
d964 1
a964 1
          WRITESTACK(S_a, desc);
d985 1
a985 1
          WRITESTACK(S_a, ptdesc);
d996 1
a996 1
        WRITESTACK(S_a, desc);
d1002 1
a1002 1
  if ( ret == 0 && binds_on_stack > 0 )
d1008 1
a1008 3
    RECOVEREXPRESSION(_desc, (PTR_DESCRIPTOR) READSTACK(S_a), binds_on_stack);
    binds_on_stack = 0;
    WRITESTACK(S_a,_desc);
@


1.10
log
@simple reduction counting
0-ary interactions are no longer put into descriptors and
therefore there must be a special case in intact_inter().
@
text
@d2 5
a56 8

#include <stdlib.h>
#include <string.h>
#include <dirent.h>

#if UNIX
#include <pwd.h>
#endif
@


1.9
log
@new function print_environment
tilde() from editor copied into this file
@
text
@d2 4
d100 26
a125 26
{{red_fopen,   "fopen"      } /* 0 */
,{red_fclose,  "fclose"     } /* 1 */
,{red_fgetc,   "fgetc"      } /* 2 */
,{red_fputc,   "fputc"      } /* 3 */
,{red_ungetc,  "ungetc"     } /* 4 */
,{red_fgets,   "fgets"      } /* 5 */
,{red_read,    "read"       } /* 6 */
,{red_fputs,   "fputs"      } /* 7 */
,{red_dummy,   "fprintf"    } /* 8 */
,{red_dummy,   "fscanf"     } /* 9 */
,{red_fseek,   "fseek"      } /* 10 */
,{red_ftell,   "ftell"      } /* 11 */
,{red_dummy,   "exit"       } /* 12 */
,{red_eof,     "eof"        } /* 13 */
,{red_dummy,   "bind"       } /* 14 */
,{red_dummy,   "unit"       } /* 15 */
,{red_finfo,   "finfo"      } /* 16 */
,{red_status,  "status"     } /* 17 */
,{red_dummy,   "remove"     } /* 18 */
,{red_dummy,   "rename"     } /* 19 */
,{red_dummy,   "copy"       } /* 20 */
,{red_mkdir,   "mkdir"      } /* 21 */
,{red_dummy,   "rmdir"      } /* 22 */
,{red_chdir,   "chdir"      } /* 23 */
,{red_getwd,   "getwd"      } /* 24 */
,{red_dir,     "dir"        } /* 25 */
d763 3
a765 1
   * to desc in the loop). After leaving the loop, there are two possibilities:
d772 14
a785 4
  while (T_POINTER(desc) &&                         /* Is it an interaction? */
      (R_DESC(*desc,class) == C_INTACT) &&
      (R_DESC(*desc,type) == TY_INTACT) &&
      (!_issubexpr) )     /* and not a subexpression selected in the editor? */
d789 28
a816 2
    args   = (STACKELEM *) R_INTACT(*desc,args);
    intact = (STACKELEM) args[0];                     /* type of interaction */
d818 18
a835 13
    if (FUNC_INDEX(intact) >= INTACT_TAB_SIZE)
      post_mortem("rintact: interaction has wrong index");
      
    /*
     * The interactions bind, unit and exit are special and therefor be treated
     * in special cases.
     */
    if (T_IA_BIND(intact))
    {
      ptdesc = (PTR_DESCRIPTOR) args[1];        /* ptdesc = x from bind(x,y) */
      if (T_POINTER(ptdesc) &&
          (R_DESC(*ptdesc,class) == C_INTACT) &&
          (R_DESC(*ptdesc,type ) == TY_INTACT)  )/* ptdesc is an interaction */
d843 1
a847 3
      }
      else
      {
a848 1
        desc = (PTR_DESCRIPTOR) NULL;
d850 1
a850 4
    }
    else if (T_IA_UNIT(intact))
    {
      if (binds_on_stack > 0)
d852 1
a852 25
        /*
         * At this point, I have made the following assumption:
         * The first time intact_inter() is called the bind stack (S_m) is
         * empty.
         * If inter() is (re)called, the stack is returned in the same state
         * as it was before the call (even if there are bind's on it).
         * -> If inter() uses the stack, it recovers the original state before
         *    exiting.
         * If I leave intact_inter for the last time, the stack is empty again.
         *
         * So, if the stack is not empty, the item on the stack had to be a
         * bind constructor which I have put on the stack earlier.
         * In this case I have to pop and 'execute' it, i.e. the 2.argument
         * of the bind (the continuation) has to be applied to the argument
         * of the unit ( R_INTACT(*desc,args)[1] ). This corresponds to one
         * ascending step in the recursive reduction.
         */
         
        short not_bind = 0;          /* There had to be a bind on the stack. */

        ptdesc = (PTR_DESCRIPTOR) POPSTACK(BIND_STACK);
        binds_on_stack--;
        if (T_POINTER(ptdesc) &&
            (R_DESC(*ptdesc,class) == C_INTACT) &&
            (R_DESC(*ptdesc,type) == TY_INTACT) )
d854 25
a878 2
          args   = (STACKELEM *) R_INTACT(*ptdesc,args);
          if (T_IA_BIND((STACKELEM) args[0]))
d880 2
a881 7
            PTR_DESCRIPTOR cont = (PTR_DESCRIPTOR) args[2];
            WRITESTACK(S_a,R_INTACT(*desc,args)[1]);   /* save unit argument */
            
            if (T_POINTER(cont) &&
                (R_DESC(*cont,class) == C_FUNC) &&
                (R_DESC(*cont,type ) == TY_COMB) &&
                (R_COMB(*cont,nargs) == 1) )
d883 30
a912 2
              beta_code[1] = (INSTR) R_COMB(*cont,ptc);
              ret = (int) beta_code;
d915 1
a915 17
            {
              PUSHSTACK(S_a,cont);
              ret = (int) apply_code;
            }
            /*
             * Doing some reference counting. (hard job)
             * The bind and the unit constructors are no longer needed, but
             * their arguments are. Therefor increment the refcnt of the
             * unit argument and the 2.argument of the bind (cont) and
             * decrement the refcnt of bind and unit.
             */
            if (T_POINTER(cont))
              INC_REFCNT(cont);
            DEC_REFCNT(ptdesc);                          /* bind constructor */
            if (T_POINTER((PTR_DESCRIPTOR) R_INTACT(*desc,args)[1]))
              INC_REFCNT((PTR_DESCRIPTOR) R_INTACT(*desc,args)[1]);
            DEC_REFCNT(desc);                            /* unit constructor */
d919 4
d925 4
a928 5
          not_bind = 1;

        if (not_bind)
          post_mortem("rintact.c: Item on Stack " BIND_STACK_STRING
                      " is not a bind().");
d930 1
a930 1
      else
d932 8
a939 1
        WRITESTACK(S_a, desc);  /* unit(...) is the result of the reduction.*/
d941 1
a941 26
      desc = (PTR_DESCRIPTOR) NULL;    /* Interrupt the loop in every case. */
    }
    else if (T_IA_EXIT(intact))
    {
      /*
       * The distributed version of kir may get into difficulties if this exit
       * was executed in a son process.
       */
      if (T_INT(args[1]))
        exit((long int) args[1] / 2);
      else
        exit(1);
    }
    else if ((fctptr = intact_tab[FUNC_INDEX(intact)].fkt) != red_dummy)
    {
      /*
       * desc is a primitive interaction. Call interaction function an
       * return unit( Status{Value} ).
       */
       
      /*
       * dim is equal to arity of interaction + 1 (the interaction)
       */
      dim    = R_INTACT(*desc,dim);

      switch (dim - 1)
d943 49
a991 5
        case 0:  status = (int) ((*fctptr)());  break;
        case 1:  status = (int) ((*fctptr)(args[1]));  break;
        case 2:  status = (int) ((*fctptr)(args[1],args[2]));  break;
        case 3:  status = (int) ((*fctptr)(args[1],args[2],args[3]));  break;
        default: post_mortem("rintact.c: interaction has wrong dimension");
d993 1
a993 2
      
      if (status == SYNERR)
d996 2
a997 2
         * The arguments are syntactical wrong. No reduction will be made,
         * interrupt loop.
a1001 29
      else 
      {
        /*
         * Reduce interaction, display result.
         */
        DEC_REFCNT(desc);
        MAKERETURNVAL(status, _desc);
    
        /* Make unit descriptor */
        MAKEDESC(ptdesc, 1, C_INTACT, TY_INTACT);
        L_INTACT(*ptdesc,dim)  = 2;
        GET_HEAP(3, A_INTACT(*ptdesc,args));
        RES_HEAP;
        R_INTACT(*ptdesc,args)[0] = IA_UNIT;
        R_INTACT(*ptdesc,args)[1] = (T_HEAPELEM) _desc;
        REL_HEAP;
    
        _desc = NULL;
        desc = ptdesc;      /* desc is unit -> repeat loop */
      }
    }
    else
    {
      /*
       * desc is a primitive, but not yet implemented interaction. No further
       * reduction can be made, the loop will be interrupted.
       */
      WRITESTACK(S_a, desc);
      desc = (PTR_DESCRIPTOR) NULL;
@


1.8
log
@major changes for monadic i/o, many comments
@
text
@d2 3
d53 4
d166 83
@


1.7
log
@declarations and use of "virtual working directory" in complete_name
@
text
@d2 3
d6 1
a6 1
 * 'environment' initialized with stdin, stdout and stderr
d16 1
a16 1
 * Interaction interpreter and functions implementet.
d26 18
a43 3
/* --- rintact.c ---------------------------------- stt --- 08.09.95 ---- */
/* --- Interaction table, help functions and interaction interpreter. --- */
/* --- Interaction definitions are in riafunc,c. ------------------------ */
a49 1
#include "rstdinc.h"
d56 2
d66 1
a66 1
/* --- internal variables ------------------------------------------------- */
d68 4
a71 6
/* Folgende "globale" Variablen werden vom Editor an die Reduma uebergeben. */
/* Siehe dazu reduce() in rreduce.c                                         */
int _issubexpr;      /* Der zu reduzierende Ausdruck ist ein Unterausdruck. */
char *_ptr_start_dir; /* Der String enhaelt das Verzeichnis, in dem der     */
                      /* Editor gestartet wurde.                            */
                      
d74 1
a74 1
  return (1);
d77 11
a87 7
/* Der Typ INTACT_TAB ist in rstdinc.h so definiert:
   typedef struct { 
     FCTPTR fkt;
     char   *name;
   } INTACT_TAB;
*/

a88 2
  /* Die Position in der Tabelle muss mit dem Index der Interaktion,
     der in rstelem.h definiert ist, uebereinstimmen. */
d101 1
a101 1
,{red_exit,    "exit"       } /* 12 */
d103 3
a105 3
,{red_dummy,   "undef. IA"  } /* 14 */
,{red_dummy,   "undef. IA"  } /* 15 */
,{red_fstatus, "fstatus"    } /* 16 */
d110 1
a110 1
,{red_dummy,   "mkdir"      } /* 21 */
d120 13
a132 1
/* Pointer auf den String, der das "virtuelle" Arbeitsverzeichnis enthaelt. */
d135 3
a137 2
/* Globaler Einstiegspunkt in die Filehandle-Liste, wird mit stdin, */
/* stdout und stderr initialisiert. */
d145 8
d156 1
d160 4
a163 1
PTR_DESCRIPTOR make_string_desc (const char *str)
d182 5
a186 1
char *get_string_from_desc(PTR_DESCRIPTOR desc)
d223 4
d230 4
a233 1
PTR_DESCRIPTOR make_return_val (int status, PTR_DESCRIPTOR wert)
d239 2
a240 2
  if (status == 0)
    list = make_string_desc("_OK");
d242 1
a242 1
    list = make_string_desc("_ERROR");
d246 1
a246 1
  L_LIST(*desc,special) = 9;    /* Konstruktor-Darstellung */
d258 8
a265 1
char *complete_name(char *name)
d285 1
a285 1
    strcat(fullname,name);
d288 1
a288 2
  pos_t = strlen(fullname);
  if (fullname[pos_t-1] != '/')
d290 6
a295 2
    fullname[pos_t] = '/';
    fullname[pos_t+1] = '\0';
d304 1
a304 1
    if (tilde(fullname, ext) == 1)
d309 2
d352 4
a355 1
void free_filehandle(FILEHANDLE *fh)
d364 5
a368 3
/* cmp_filehandle vergleicht die filename- und mode-Felder zweier */
/* Filehandle und gibt 1 bei Gleichheit zurueck, 0 sonst.         */
int cmp_filehandle(FILEHANDLE *fh1, FILEHANDLE *fh2)
d378 6
a383 1
char *add_filehandle(FILE *fp, char *filename, char *mode)
a398 1
  /* In red_fopen wird sichergestellt, dass mode aus {r w a r+ w+ a+} ist. */
d411 14
a424 8
  /* Die environment-Liste nach Eintraegen mit gleichem Filenamen und */
  /* gleichem Modus durchsuchen und fh an die Liste einhaengen. */
  /* Dabei zeigt *fhptr immer auf den naechsten zu pruefenden Eintrag und */
  /* die Schleife wird durchlaufen, bis dieser Eintrag NULL ist oder dieser */
  /* Eintrag ein Handle fuer dasselbe File mit gleichem Mode und dessen */
  /* Index groesser als der index-Zaehler ist. In dem Fall gibt es dort eine */
  /* Nummerierungsluecke, verursacht durch das Schliessen eines Handles. */
  /* fh wird dann VOR den letzten untersuchten Eintrag eingehaengt. */
d430 1
a430 1
    if (cmp_filehandle(fh, *fhptr) == 0) 
d447 1
a447 1
  /* Laenge des handlestr = len(fname)+4(Sterne)+6(Index)+2(Modus)+1(EOS) */
d464 4
a467 1
int rm_filehandle(FILEHANDLE *fh)
d477 1
a477 1
    free_filehandle(fh);
d490 1
a490 1
      free_filehandle(fh);
d502 5
a506 1
FILEHANDLE *get_filehandle(char *handle)
d517 2
a518 1

d523 69
d594 1
a594 5
 *  intact_inter -- Der Interaktions-Interpreter
 *                  Wenn der auf dem a-Stack liegende Ausdruck eine
 *                  Interaktion ist, so wird diese ausgefuehrt und die
 *                  Continuation auf das Ergebnis angewandt.
 *                         stt  14.09.95
d596 34
a629 1
 
d632 3
a634 1
  register PTR_DESCRIPTOR desc;
d637 11
a647 1
  int ret = 0;
d651 1
a651 1
  if (virtual_wd == NULL)    /* Wurde virtual_wd schon initialisiert? */
d653 2
a654 2
    int size = strlen(_ptr_start_dir) + 2;
    if ((virtual_wd = (char *) malloc(size)) == NULL)
d657 2
a658 2
    size = strlen(virtual_wd);
    if (virtual_wd[size-1] != '/')
d660 2
a661 2
      virtual_wd[size] = '/';
      virtual_wd[size+1] = '\0';
d665 12
a676 2
  desc = (PTR_DESCRIPTOR) READSTACK(S_a);
  if (T_POINTER(desc) &&
d679 3
a681 6
      (!_issubexpr) )
  {
    short dim, status;
    STACKELEM        *args, intact;
    PTR_DESCRIPTOR   cont;
    FCTPTR fctptr;
d684 1
a684 3
    dim    = R_INTACT(*desc,dim);
    intact = (STACKELEM) args[0];
    cont   = (PTR_DESCRIPTOR) args[dim-1];
d689 108
a796 5
    fctptr = intact_tab[FUNC_INDEX(intact)].fkt;
    
    /* Sonderbehandlung von exit und nicht implementierten Interaktionen */

    if (fctptr == red_exit)
d798 4
a801 2
      /* Bei der verteilten Version kommt es evt. zu Schwierigkeiten, wenn */
      /* das exit() an dieser Stelle durchgefuehrt wird. */
d807 1
a807 2
    else
    if (fctptr != red_dummy)
d809 11
a819 3
      /* dim is equal to arity of interaction + 2 */
      /* (interaction and continuation).          */
      switch (dim)
d821 5
a825 6
        case 2: status = (int) ((*fctptr)());  break;
        case 3: status = (int) ((*fctptr)(args[1]));  break;
        case 4: status = (int) ((*fctptr)(args[1],args[2]));  break;
        case 5: status = (int) ((*fctptr)(args[1],args[2],args[3]));  break;
        default: status = 1;
                 post_mortem("interaction has wrong dimension");
d828 1
a828 12
      if (T_POINTER(cont))
        INC_REFCNT(cont);
      DEC_REFCNT(desc);
      
      MAKERETURNVAL(status, _desc);
      WRITESTACK(S_a,_desc);
      _desc = NULL;
      
      if (T_POINTER(cont) &&
          (R_DESC(*cont,class) == C_FUNC) &&
          (R_DESC(*cont,type ) == TY_COMB) &&
          (R_COMB(*cont,nargs) == 1) )
d830 6
a835 2
        beta_code[1] = (INSTR) R_COMB(*cont,ptc);
        ret = (int) beta_code;
d837 1
a837 1
      else
d839 17
a855 2
        PUSHSTACK(S_a,cont);
        ret = (int) apply_code;
d858 21
d880 1
a880 1

@


1.6
log
@'environment' initialized with stdin, stdout and stderr
@
text
@d2 3
d30 1
d49 2
d52 3
a54 1

d101 3
d205 1
a205 1
  char *fullname, *tmp, *pwd;
d208 3
d213 12
a224 1
    return(name);
d226 27
a252 3
  pwd = getcwd((char *) NULL,264);
  if ((fullname = (char *) malloc(strlen(pwd) + strlen(name) + 2)) == NULL)
    post_mortem("rintact: memory allocation for fullname not possible.");
d254 9
a262 3
  strcpy(fullname,pwd);
  strcat(fullname,"/");
  strcat(fullname,name);
d266 10
a275 7
    pos_s = tmp - fullname;
    pos_s += 3;
    pos_t = pos_s - 4;
    while ((pos_t >= 0) &&
           (fullname[pos_t] != '/'))
      pos_t--;
    
d451 14
@


1.5
log
@evaluation of interactions only if it is no subexpression
@
text
@d2 3
d93 10
a102 3
/* Globaler Einstiegspunkt in die Filehandle-Liste, kann evt. mit stdin, */
/* stdout und stderr initialisiert werden. */
FILEHANDLE *environment = NULL;
@


1.4
log
@interactions moved to riafunc.c
defines moved to rintact.h
@
text
@d2 4
d42 2
d386 2
a387 1
      (R_DESC(*desc,type) == TY_INTACT) )
@


1.3
log
@Interaction interpreter and functions implementet.
@
text
@d2 3
d14 2
a15 1
/* --- Tables, variables and functions for interactions ----------------- */
a17 5
#include <dirent.h>
#include <errno.h>
#include <grp.h>
#include <limits.h>
#include <pwd.h>
a19 2
#include <time.h>
#include <sys/stat.h>
d33 1
d36 1
a36 1
/* --- external variables/functions ------------------------------------- */
d38 4
a42 92
extern T_PTD  newdesc();            /* rheap.c */
extern int    newheap();            /* rheap.c */
extern void   rel_heap();           /* rheap.c */
extern void   res_heap();           /* rheap.c */
extern void   DescDump();           /* rdesc.c */
extern void   test_dec_refcnt();    /* rheap.c */
extern void   test_inc_refcnt();    /* rheap.c */
extern void   stack_error();        /* rstack.c */

extern PTR_DESCRIPTOR _desc;       /* rstate.c */

extern int errno;
extern char *sys_errlist[];

/* --- variable/macro declarations -------------------------------------- */

/* Flags fuer den Dateimodus */
#define MODE_R          1
#define MODE_W          2
#define MODE_A          4
#define MODE_PLUS       8
#define P_MODE_READ     (MODE_R | MODE_PLUS)
#define P_MODE_WRITE    (MODE_W | MODE_A | MODE_PLUS)
#define T_MODE_R(x)     (((x) & MODE_R) == MODE_R)
#define T_MODE_W(x)     (((x) & MODE_W) == MODE_W)
#define T_MODE_A(x)     (((x) & MODE_A) == MODE_A)
#define T_MODE_PLUS(x)  (((x) & MODE_PLUS) == MODE_PLUS)
#define T_MODE_READ(x)  (((x) & P_MODE_READ) != 0)
#define T_MODE_WRITE(x) (((x) & P_MODE_WRITE) != 0)

#define MAKESTRDESC(d,x)    d = make_string_desc(x)
#define GETSTRING(p,d)      p = get_string_from_desc(d)
#define MAKERETURNVAL(x,d)  d = make_return_val(x,d)

#define COMPLETE_NAME(c)    c = complete_name(c)

#define L_FILEHANDLE(p,x)   ((p).x)
#define R_FILEHANDLE(p,x)   ((p).x)

typedef struct filehandle {
  FILE               *fp;
  char               *filename;
  char               mode;
  int                index;
  char               *handle;
  struct filehandle  *next;
} FILEHANDLE;

/* --- prototypes -------------------------------------------------------- */

/* interactions */

int red_chdir(STACKELEM path);
int red_copy(STACKELEM sname, STACKELEM tname);
int red_dir(STACKELEM path);
int red_eof(STACKELEM handle);
int red_exit();
int red_fclose(STACKELEM handle);
int red_fgetc(STACKELEM handle);
int red_fgets(STACKELEM handle);
int red_fopen(STACKELEM name, STACKELEM mode);
int red_fprintf(STACKELEM fp, STACKELEM format, STACKELEM args);
int red_fputc(STACKELEM handle, STACKELEM c);
int red_fputs(STACKELEM handle, STACKELEM str);
int red_fscanf(STACKELEM fp, STACKELEM format);
int red_fseek(STACKELEM fp, STACKELEM offset, STACKELEM origin);
int red_fstatus(STACKELEM handle);
int red_ftell(STACKELEM handle);
int red_getwd();
int red_mkdir(STACKELEM path);
int red_read(STACKELEM fp, STACKELEM anz);
int red_remove(STACKELEM name);
int red_rmdir(STACKELEM path);
int red_rename(STACKELEM sname, STACKELEM tname);
int red_status(STACKELEM name);
int red_ungetc(STACKELEM fp, STACKELEM c);


/* help functions */
PTR_DESCRIPTOR  make_string_desc (const char *str);
char            *get_string_from_desc(PTR_DESCRIPTOR desc);
PTR_DESCRIPTOR  make_return_val (int status, PTR_DESCRIPTOR wert);
char            *mergenames(char *pwd, char *name);
void            free_filehandle(FILEHANDLE *fh);
int             cmp_filehandle(FILEHANDLE *fh1, FILEHANDLE *fh2);
char            *add_filehandle(FILE *fp, char *filename, char *mode);
int             rm_filehandle(FILEHANDLE *fh);
FILEHANDLE      *get_filehandle(char *handle);
static int      red_dummy();

/* --- internal variables -------------------------------------------------- */

d81 1
a81 1
int intact_tab_size = (sizeof(intact_tab)/sizeof(intact_tab[0]));
d86 1
a86 1
static FILEHANDLE *environment = NULL;
d89 1
a89 7
/* --- function declarations --------------------------------------------- */

static int red_dummy()
{
  MAKESTRDESC(_desc,"dummy");
  return (0);
} 
d158 1
a158 1
    MAKESTRDESC(list, "_OK");
d160 1
a160 1
    MAKESTRDESC(list, "_ERROR");
a359 1041
/***************************************************************************/
/*************** Interactions **********************************************/
/***************************************************************************/

/* ----------------------------------------------------------------------- */
/* red_chdir:  change working directory                                    */
/* ----------------------------------------------------------------------- */
int red_chdir(STACKELEM path)
{
  int erg;
  char *newpath = NULL;
  
  START_MODUL("red_chdir");
  
  GETSTRING(newpath,(PTR_DESCRIPTOR) path);

  if (newpath == NULL)
  {
    MAKESTRDESC(_desc,"chdir: Argument is not a string.");
    return(1);
  }

  erg = chdir(newpath);
  free(newpath);
  
  if (erg != 0)
  {
    MAKESTRDESC(_desc,"chdir: chdir was not successful.");
    return(1);
  }
 
  MAKESTRDESC(_desc,"chdir");
  END_MODUL("red_chdir");
  return(0);
 
}


/* ----------------------------------------------------------------------- */
/* red_copy:  Kurze Beschreibung */
/* ----------------------------------------------------------------------- */
int red_copy(STACKELEM sname, STACKELEM tname)
{
  START_MODUL("red_copy");
  
  MAKESTRDESC(_desc,"copy");
  END_MODUL("red_copy");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_dir:  returns a list of all entries in the given directory          */
/* ----------------------------------------------------------------------- */
int red_dir(STACKELEM path)
{
  DIR *dir;
  struct dirent *entry;
  char *pathname;
  PTR_DESCRIPTOR *names;
  PTR_HEAPELEM   ptdv;
  int num_names, max_names;
  const int STEPNAMES = 50;


  START_MODUL("red_dir");
  
  GETSTRING(pathname, (PTR_DESCRIPTOR) path);

  if (pathname == NULL)
  {
    MAKESTRDESC(_desc,"dir: Argument is not a string.");
    return(1);
  }

  if ((dir = opendir(pathname)) == NULL)
  {
    MAKESTRDESC(_desc,
                "dir: Argument is not a directory or cannot be accessed.");
    return(1);
  }

  max_names = STEPNAMES;
  num_names = 0;
  if ((names = (PTR_DESCRIPTOR *)
               malloc(max_names*sizeof(PTR_DESCRIPTOR))) == NULL)
    post_mortem("rintact: memory allocation for names not possible.");

  while ((entry = readdir(dir)) != NULL)
  {
    if (num_names >= max_names)
    {
      max_names += STEPNAMES;
      if ((names = (PTR_DESCRIPTOR *)
                   realloc(names, max_names*sizeof(PTR_DESCRIPTOR))) == NULL)
        post_mortem("rintact: memory reallocation for names not possible.");
    }

    MAKESTRDESC(names[num_names++], entry->d_name);
  }
  
  closedir(dir);

  MAKEDESC(_desc, 1, C_LIST, TY_UNDEF);
  L_LIST(*_desc,dim) = num_names;
  L_LIST(*_desc,ptdd) = NULL;
  GET_HEAP(num_names, A_LIST(*_desc,ptdv));
  ptdv = R_LIST(*_desc,ptdv);
  RES_HEAP;
  memcpy((void *) ptdv, (void *) names, num_names*sizeof(PTR_DESCRIPTOR));
  REL_HEAP;
  
  free(names);
  END_MODUL("red_dir");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_eof:  checks eof condition of filehandle                            */
/*           Therefor it does a getc and an ungetc on the file.            */
/* ----------------------------------------------------------------------- */
int red_eof(STACKELEM handle)
{
  char c, *handlestr;
  FILEHANDLE *fh;

  START_MODUL("red_eof");
  
  GETSTRING(handlestr, (PTR_DESCRIPTOR) handle);

  if (handlestr == NULL)
  {
    MAKESTRDESC(_desc,"eof: Argument is not a string.");
    return(1);
  }
  
  fh = get_filehandle(handlestr);

  if (fh == NULL)
  {
    MAKESTRDESC(_desc,"eof: Argument is not a valid filehandle.");
    return(1);
  }

  if ((c = fgetc(R_FILEHANDLE(*fh,fp)) != EOF))
  {
    ungetc(c, R_FILEHANDLE(*fh,fp));
    MAKESTRDESC(_desc,"eof: Not end of file.");
    return(1);
  }
  
  MAKESTRDESC(_desc,"eof");
  END_MODUL("red_eof");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_exit:  wird nicht verwendet, da exit im Interpreter abgefangen wird */
/* ----------------------------------------------------------------------- */
int red_exit()
{
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_fclose:  close a file                                               */
/* ----------------------------------------------------------------------- */
int red_fclose(STACKELEM handle)
{
  char *handlestr;
  FILEHANDLE *fh;
  
  START_MODUL("red_fclose");
  
  GETSTRING(handlestr, (PTR_DESCRIPTOR) handle);

  if (handlestr == NULL)
  {
    MAKESTRDESC(_desc,"fclose: Argument is not a string.");
    return(1);
  }
  
  fh = get_filehandle(handlestr);

  if (fh == NULL)
  {
    MAKESTRDESC(_desc,"fclose:Argument is not a valid filehandle.");
    return(1);
  }
 
  if (fclose(R_FILEHANDLE(*fh,fp)) == EOF) 
  {
    MAKESTRDESC(_desc,"fclose: fclose not successful.");
    return(1);
  }
  
  if (rm_filehandle(fh) != 0)
  {
    MAKESTRDESC(_desc,"fclose: Cannot remove filehandle.");
    return(1);
  }
 
  MAKESTRDESC(_desc,"fclose");
  END_MODUL("red_fclose");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_fgetc:  reads one charakter from file                               */
/*             A charakter is a string with length 1.                      */
/* ----------------------------------------------------------------------- */
int red_fgetc(STACKELEM handle)
{
  char cstr[2] , *handlestr;
  FILEHANDLE *fh;

  START_MODUL("red_fgetc");
  
  GETSTRING(handlestr, (PTR_DESCRIPTOR) handle);

  if (handlestr == NULL)
  {
    MAKESTRDESC(_desc,"fgetc: Argument is not a string.");
    return(1);
  }
  
  fh = get_filehandle(handlestr);

  if (fh == NULL)
  {
    MAKESTRDESC(_desc,"fgetc: Argument is not a valid filehandle.");
    return(1);
  }

  if ( ! T_MODE_READ(R_FILEHANDLE(*fh,mode)))
  {
    MAKESTRDESC(_desc, "fgetc: File is not readable.");
    return(1);
  }

  if ((cstr[0] = getc(R_FILEHANDLE(*fh,fp))) == EOF)
  {
    MAKESTRDESC(_desc,"fgetc: End of file.");
    return(1);
  }
  
  cstr[1] = '\0';
  
  MAKESTRDESC(_desc,cstr);  
  END_MODUL("red_fgetc");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_fgets:  reads one line from file                                    */
/*             Reads till next '\n', '\n' is not returned.                 */
/* ----------------------------------------------------------------------- */
int red_fgets(STACKELEM handle)
{
  const int LENGTH = 250;
  int number;
  char str[LENGTH], *bigstr, *newstr, *handlestr;
  FILEHANDLE *fh;
  
  START_MODUL("red_fgets");
  
  GETSTRING(handlestr, (PTR_DESCRIPTOR) handle);

  if (handlestr == NULL)
  {
    MAKESTRDESC(_desc,"fgets: Argument is not a string.");
    return(1);
  }
  
  fh = get_filehandle(handlestr);

  if (fh == NULL)
  {
    MAKESTRDESC(_desc,"fgets: Argument is not a valid filehandle.");
    return(1);
  }

  if ( ! T_MODE_READ(R_FILEHANDLE(*fh,mode)))
  {
    MAKESTRDESC(_desc, "fgets: File is not readable.");
    return(1);
  }

  if (fgets(str, LENGTH, R_FILEHANDLE(*fh,fp)) == NULL)
  {
    MAKESTRDESC(_desc,"fgets: End of file.");
    return(1);
  }

  if (strlen(str) >= LENGTH -1)
  {
    number = 1;
    if ((bigstr = (char *) malloc(number * LENGTH)) == NULL)
      post_mortem("rintact: memory allocation for bigstr not possible.");
    
    strcpy(bigstr,str);

    do
    {
      if (fgets(str, LENGTH, R_FILEHANDLE(*fh,fp)) == NULL)
      {
        MAKESTRDESC(_desc,"fgets: read error.");
        return(1);
      }
      number++;
      if ((newstr = (char *) realloc(bigstr, number * LENGTH)) == NULL)
        post_mortem("rintact: memory reallocation for bigstr not possible.");
      
      bigstr = newstr;
      strcat(bigstr,str);
      
    } while (strlen(str) >= LENGTH -1);
  }
  else
    bigstr = str;
    
  number = strlen(bigstr);
  if (bigstr[number - 1] == '\n')
    bigstr[number - 1] = '\0';
    
  MAKESTRDESC(_desc,bigstr);  
  END_MODUL("red_fgets");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_fopen:  opens an file                                               */
/*             If successful, a FILEHANDLE entry will be appended to the   */
/*             environment-List.                                           */
/* ----------------------------------------------------------------------- */
int red_fopen(STACKELEM name, STACKELEM mode)
{
  char *namestr, *modestr, *handle;
  FILE *fp;
  int len,wrong_mode;
  
  START_MODUL("red_fopen");
  
  GETSTRING(namestr,(PTR_DESCRIPTOR) name);
  GETSTRING(modestr,(PTR_DESCRIPTOR) mode);

  if (namestr == NULL)
  {
    MAKESTRDESC(_desc,"fopen: First argument is not a string.");
    return(1);
  }
  
  if (modestr == NULL)
  {
    MAKESTRDESC(_desc,"fopen: Second argument is not a string.");
    return(1);
  }
  
  wrong_mode = 0;
  len = strlen(modestr);
  if ((len == 1) ||
      ((len == 2) && (modestr[1] == '+')))
  {
    switch (modestr[0])
    {
      case 'r':
      case 'w':
      case 'a': break;
      default : wrong_mode = 1;
    }
  }
  else
    wrong_mode = 1;

  if (wrong_mode == 1)
  {
    MAKESTRDESC(_desc,"fopen: Not a valid mode.");
    return(1);
  }

  COMPLETE_NAME(namestr);

  if ((fp = fopen(namestr, modestr)) == NULL)
  {
    MAKESTRDESC(_desc,"fopen: Cannot open file.");
    return(1);
  }
  
  handle = add_filehandle(fp, namestr, modestr);
  
  if (handle == NULL)
  {
    MAKESTRDESC(_desc,"fopen: Cannot create handle.");
    return(1);
  }

  MAKESTRDESC(_desc,handle);
  END_MODUL("red_fopen");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_fprintf:  Kurze Beschreibung */
/* ----------------------------------------------------------------------- */
int red_fprintf(STACKELEM fp, STACKELEM format, STACKELEM args)
{
  START_MODUL("red_fprintf");
  
  MAKESTRDESC(_desc,"fprintf");
  END_MODUL("red_fprintf");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_fputc:  puts character into output file                             */
/* ----------------------------------------------------------------------- */
int red_fputc(STACKELEM handle, STACKELEM c)
{
  char *handlestr, *outchar;
  FILEHANDLE *fh;
  
  START_MODUL("red_fputc");
  
  GETSTRING(handlestr, (PTR_DESCRIPTOR) handle);
  GETSTRING(outchar, (PTR_DESCRIPTOR) c);
  
  if (handlestr == NULL)
  {
    MAKESTRDESC(_desc, "fputc: 1. argument is not a string.");
    return(1);
  }

  if (outchar == NULL)
  {
    MAKESTRDESC(_desc, "fputc: 2. argument is not a string.");
    return(1);
  }

  if (strlen(outchar) != 1)
  {
    MAKESTRDESC(_desc, "fputc: 2. argument is not a single char.");
    return(1);
  }

  fh = get_filehandle(handlestr);
  
  if (fh == NULL)
  {
    MAKESTRDESC(_desc, "fputc: 1. argument is not a valid filehandle.");
    return(1);
  }

  if ( ! T_MODE_WRITE(R_FILEHANDLE(*fh,mode)))
  {
    MAKESTRDESC(_desc, "fputc: File is not writeable.");
    return(1);
  }

  if (fputc(outchar[0], R_FILEHANDLE(*fh,fp)) == EOF)
  {
    MAKESTRDESC(_desc,"fputc: fputc not successful.");
    return(1);
  }
  
  MAKESTRDESC(_desc, "fputc");
  END_MODUL("red_fputc");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_fputs:  puts string into output file                                */
/* ----------------------------------------------------------------------- */
int red_fputs(STACKELEM handle, STACKELEM str)
{
  char *handlestr, *outstring;
  FILEHANDLE *fh;
  
  START_MODUL("red_fputs");
  
  GETSTRING(handlestr, (PTR_DESCRIPTOR) handle);
  GETSTRING(outstring, (PTR_DESCRIPTOR) str);
  
  if (handlestr == NULL)
  {
    MAKESTRDESC(_desc, "fputs: 1. argument is not a string.");
    return(1);
  }

  if (outstring == NULL)
  {
    MAKESTRDESC(_desc, "fputs: 2. argument is not a string.");
    return(1);
  }

  fh = get_filehandle(handlestr);
  
  if (fh == NULL)
  {
    MAKESTRDESC(_desc, "fputs: 1. argument is not a valid filehandle.");
    return(1);
  }

  if ( ! T_MODE_WRITE(R_FILEHANDLE(*fh,mode)))
  {
    MAKESTRDESC(_desc, "fputs: File is not writeable.");
    return(1);
  }

  if (fputs(outstring, R_FILEHANDLE(*fh,fp)) == EOF)
  {
    MAKESTRDESC(_desc,"fputs: fputs not successful."); 
    return(1);
  }
  fputc('\n', R_FILEHANDLE(*fh,fp));

  MAKESTRDESC(_desc, "fputs");
  END_MODUL("red_fputs");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_fscanf:  Kurze Beschreibung */
/* ----------------------------------------------------------------------- */
int red_fscanf(STACKELEM fp, STACKELEM format)
{
  START_MODUL("red_fscanf");
  
  MAKESTRDESC(_desc,"fscanf");
  END_MODUL("red_fscanf");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_fseek:  reposit the read/write pointer                              */
/* ----------------------------------------------------------------------- */
int red_fseek(STACKELEM handle, STACKELEM offset, STACKELEM origin)
{
  char *handlestr, *origstr;
  FILEHANDLE *fh;
  int orig = 0;
  long int offs = 0;
  
  START_MODUL("red_fseek");
  
  GETSTRING(handlestr, (PTR_DESCRIPTOR) handle);
  if (handlestr == NULL)
  {
    MAKESTRDESC(_desc, "fseek: 1. argument is not a string.");
    return(1);
  }


  if (T_INT(offset))
  {
    offs = (long int) offset / 2;
  }
  else
  {
    MAKESTRDESC(_desc, "fseek: 2. argument is not an integer.");
    return(1);
  }

  GETSTRING(origstr, (PTR_DESCRIPTOR) origin);
  if (origstr == NULL)
  {
    MAKESTRDESC(_desc, "fseek: 3. argument is not a string.");
    return(1);
  }

  fh = get_filehandle(handlestr);
  
  if (fh == NULL)
  {
    MAKESTRDESC(_desc, "fseek: 1. argument is not a valid filehandle.");
    return(1);
  }

  if (strcmp(origstr, "SEEK_SET") == 0)
    orig = SEEK_SET;
  else
  if (strcmp(origstr, "SEEK_CUR") == 0)
    orig = SEEK_CUR;
  else
  if (strcmp(origstr, "SEEK_END") == 0)
    orig = SEEK_END;
  else
  {
    MAKESTRDESC(_desc, "fseek: 3. argument is not a valid origin.");
    return(1);
  }

  if (fseek(R_FILEHANDLE(*fh,fp), offs, orig) != 0)
  {
    MAKESTRDESC(_desc, "fseek: fseek not successful.");
    return(1);
  }

  MAKESTRDESC(_desc,"fseek");
  END_MODUL("red_fseek");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_fstatus:  Kurze Beschreibung */
/* ----------------------------------------------------------------------- */
int red_fstatus(STACKELEM handle)
{
  char modus[3];
  char *handlestr;
  FILEHANDLE *fh;
    
  START_MODUL("red_fstatus");
  
  GETSTRING(handlestr, (PTR_DESCRIPTOR) handle);
  
  if (handlestr == NULL)
  {
    MAKESTRDESC(_desc, "fstatus: Argument is not a string.");
    return(1);
  }

  fh = get_filehandle(handlestr);
  
  if (fh == NULL)
  {
    MAKESTRDESC(_desc, "fstatus: Argument is not a valid filehandle.");
    return(1);
  }

  if (T_MODE_R(R_FILEHANDLE(*fh, mode)))
    modus[0] = 'r';
  else
  if (T_MODE_W(R_FILEHANDLE(*fh, mode)))
    modus[0] = 'w';
  else
  if (T_MODE_A(R_FILEHANDLE(*fh, mode)))
    modus[0] = 'a';
  else
  {
    MAKESTRDESC(_desc, "fstatus: Filehandle has not a valid mode.");
    return(1);
  }

  if (T_MODE_PLUS(R_FILEHANDLE(*fh, mode)))
  {
    modus[1] = '+';
    modus[2] = '\0';
  }
  else
    modus[1] = '\0';
    
  MAKESTRDESC(_desc,modus);
  END_MODUL("red_fstatus");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_ftell:  returns the position of the filepointer in the named file   */
/* ----------------------------------------------------------------------- */
int red_ftell(STACKELEM handle)
{
  int pos;
  char *handlestr;
  FILEHANDLE *fh;
  
  START_MODUL("red_ftell");
  
  GETSTRING(handlestr, (PTR_DESCRIPTOR) handle);
  
  if (handlestr == NULL)
  {
    MAKESTRDESC(_desc, "ftell: Argument is not a string.");
    return(1);
  }

  fh = get_filehandle(handlestr);
  
  if (fh == NULL)
  {
    MAKESTRDESC(_desc, "ftell: Argument is not a valid filehandle.");
    return(1);
  }

  pos = ftell(R_FILEHANDLE(*fh,fp));
  if (pos < 0)
  {
    MAKESTRDESC(_desc,"ftell: read error.");
    return(1);
  }

  _desc = (PTR_DESCRIPTOR) TAG_INT(pos);
  END_MODUL("red_ftell");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_getwd:  returns the working directory                               */
/* ----------------------------------------------------------------------- */
int red_getwd()
{
  char *str;
  
  START_MODUL("red_getwd");
  
  str = getcwd((char *) NULL,264);

  if (str == NULL)
  {
    MAKESTRDESC(_desc,"getwd: getwd was not successful.");
    return(1);
  }

  MAKESTRDESC(_desc,str);
  free(str);
  END_MODUL("red_getwd");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_mkdir:  Kurze Beschreibung */
/* iiiiiiiiii Vorlaeufig Missbraucht */
/* ----------------------------------------------------------------------- */
int red_mkdir(STACKELEM path)
{
  FILE *fptr;
  FILEHANDLE *fh;
  int index = 0;

  START_MODUL("red_mkdir");
  
  if ((fptr = fopen("environment","w")) == NULL)
  {
    MAKESTRDESC(_desc,"fstatus: Cannont open file.");
    return(1);
  }

  fh = environment;
  while (fh != NULL)
  {
    fprintf(fptr, "\nFilehandle %d:\n", index);
    fprintf(fptr, "Filepointer %d, Modus %d\n",
             (int) R_FILEHANDLE(*fh,fp), (int) R_FILEHANDLE(*fh,mode));
    fprintf(fptr, "Name: %s\n", R_FILEHANDLE(*fh,filename));
    fprintf(fptr, "Handle: %s\n", R_FILEHANDLE(*fh,handle));
    
    index++;
    fh = R_FILEHANDLE(*fh,next);
  }
  fclose(fptr);
  
  MAKESTRDESC(_desc,"mkdir");
  END_MODUL("red_mkdir");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_read:  read anz bytes from file                                     */
/* ----------------------------------------------------------------------- */
int red_read(STACKELEM handle, STACKELEM anz)
{
  char *handlestr, *readed;
  FILEHANDLE *fh;
  int anzahl;
  
  START_MODUL("red_read");
  
  GETSTRING(handlestr, (PTR_DESCRIPTOR) handle);

  if (handlestr == NULL)
  {
    MAKESTRDESC(_desc,"read: 1. argument is not a string.");
    return(1);
  }
  
  fh = get_filehandle(handlestr);

  if (fh == NULL)
  {
    MAKESTRDESC(_desc,"read: 1. argument is not a valid filehandle.");
    return(1);
  }
  
  if (T_INT(anz))
  {
    anzahl = (long int) anz / 2;
  }
  else
  {
    MAKESTRDESC(_desc, "read: 2. argument is not an integer.");
    return(1);
  }

  if ( ! T_MODE_READ(R_FILEHANDLE(*fh,mode)))
  {
    MAKESTRDESC(_desc, "read: File is not readable.");
    return(1);
  }

  if ((readed = (char *) malloc(anzahl + 1)) == NULL)
    post_mortem("rintact: memory allocation for readed not possible.");
  
  clearerr(R_FILEHANDLE(*fh,fp));
  if (fread(readed, 1, anzahl, R_FILEHANDLE(*fh,fp)) == 0)
  {
    if (feof(R_FILEHANDLE(*fh,fp)))
    {
      MAKESTRDESC(_desc,"read: End of file.");
      return(1);
    }
    else
    {
      MAKESTRDESC(_desc,"read: Read error.");
      return(1);
    }
  }
  
  MAKESTRDESC(_desc,readed);
  END_MODUL("red_read");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_remove:  Kurze Beschreibung */
/* ----------------------------------------------------------------------- */
int red_remove(STACKELEM name)
{
  START_MODUL("red_remove");
  
  MAKESTRDESC(_desc,"remove");
  END_MODUL("red_remove");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_rename:  Kurze Beschreibung */
/* ----------------------------------------------------------------------- */
int red_rename(STACKELEM sname, STACKELEM tname)
{
  START_MODUL("red_rename");
  
  MAKESTRDESC(_desc,"rename");
  END_MODUL("red_rename");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_rmdir:  Kurze Beschreibung */
/* ----------------------------------------------------------------------- */
int red_rmdir(STACKELEM path)
{
  START_MODUL("red_rmdir");
  
  MAKESTRDESC(_desc,"rmdir");
  END_MODUL("red_rmdir");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_status:  Kurze Beschreibung */
/* ----------------------------------------------------------------------- */
int red_status(STACKELEM name)
{
  struct stat buf;
  char *filename, helpstr[40];
  struct group *group;
  struct passwd *user;
  PTR_HEAPELEM ptdv;
  PTR_DESCRIPTOR per_desc, uid_desc, gid_desc, siz_desc, dat_desc;
  char permission[] = "----------";
  
  START_MODUL("red_status");
  
  GETSTRING(filename, (PTR_DESCRIPTOR) name);

  if (filename == NULL)
  {
    MAKESTRDESC(_desc,"status: Argument is not a string.");
    return(1);
  }

  COMPLETE_NAME(filename);
  
  if (stat(filename, &buf) != 0)
  {
    switch (errno)
    {
      case EACCES:  MAKESTRDESC(_desc,"status: Search permission denied.");
                    break;
      case ENOENT:  MAKESTRDESC(_desc,"status: File does not exist.");
                    break;
      case ENOTDIR: MAKESTRDESC(_desc,
                  "status: A component of the path prefix is not a directory.");
                    break;
      default:      MAKESTRDESC(_desc,"status: Unspecified error occurred.");
    }
    return(1);
  }
  
  switch (buf.st_mode & S_IFMT)
  {
    case S_IFREG:  permission[0] = '-'; break;
    case S_IFCHR:  permission[0] = 'c'; break;
    case S_IFBLK:  permission[0] = 'b'; break;
    case S_IFDIR:  permission[0] = 'd'; break;
    case S_IFLNK:  permission[0] = 'l'; break;
    case S_IFSOCK: permission[0] = 's'; break;
    case S_IFIFO:  permission[0] = 'p'; break;
    default:       permission[0] = '?';
  }

  if (buf.st_mode & S_IRUSR) permission[1] = 'r';
  if (buf.st_mode & S_IWUSR) permission[2] = 'w';
  if (buf.st_mode & S_IXUSR) permission[3] = 'x';
  if (buf.st_mode & S_IRGRP) permission[4] = 'r';
  if (buf.st_mode & S_IWGRP) permission[5] = 'w';
  if (buf.st_mode & S_IXGRP) permission[6] = 'x';
  if (buf.st_mode & S_IROTH) permission[7] = 'r';
  if (buf.st_mode & S_IWOTH) permission[8] = 'w';
  if (buf.st_mode & S_IXOTH) permission[9] = 'x';

  if (buf.st_mode & S_ISUID)
    if (permission[3] == '-') permission[3] = 'S';
    else                      permission[3] = 's';
  
  if (buf.st_mode & S_ISGID)
    if (permission[6] == '-') permission[6] = 'S';
    else                      permission[6] = 's';
  
  if (buf.st_mode & S_ISVTX)
    if (permission[9] == '-') permission[9] = 'T';
    else                      permission[9] = 't';
  
  MAKESTRDESC(per_desc, permission);
  
  if ((user = getpwuid(buf.st_uid)) == NULL)
    post_mortem("rintact: Cannot get user.");
  MAKESTRDESC(uid_desc, user->pw_name);
  
  if ((group = getgrgid(buf.st_gid)) == NULL)
    post_mortem("rintact: Cannot get goup.");
  MAKESTRDESC(gid_desc, group->gr_name);
  
  sprintf(helpstr,"%d", (int) buf.st_size);
  MAKESTRDESC(siz_desc, helpstr);

  strftime(helpstr, 40, "%H:%M:%S %d.%m.%Y", localtime(&buf.st_mtime));
  MAKESTRDESC(dat_desc, helpstr);

  MAKEDESC(_desc, 1, C_LIST, TY_UNDEF);
  L_LIST(*_desc,dim) = 5;
  L_LIST(*_desc,ptdd) = NULL;
  GET_HEAP(5, A_LIST(*_desc,ptdv));
  ptdv = R_LIST(*_desc,ptdv);
  RES_HEAP;
  ptdv[0] = (int) per_desc;
  ptdv[1] = (int) uid_desc;
  ptdv[2] = (int) gid_desc;
  ptdv[3] = (int) siz_desc;
  ptdv[4] = (int) dat_desc;
  REL_HEAP;
  
  END_MODUL("red_status");
  return(0);
}


/* ----------------------------------------------------------------------- */
/* red_ungetc:  puts the character c back into the named input stream.     */
/*              If successful, the next read on this stream will return c. */
/* ----------------------------------------------------------------------- */
int red_ungetc(STACKELEM handle, STACKELEM c)
{
  char *cstr, *handlestr;
  FILEHANDLE *fh;

  START_MODUL("red_ungetc");
  
  GETSTRING(handlestr, (PTR_DESCRIPTOR) handle);
  GETSTRING(cstr, (PTR_DESCRIPTOR) c);

  if (handlestr == NULL)
  {
    MAKESTRDESC(_desc,"ungetc: 1. argument is not a string.");
    return(1);
  }
  
  if (cstr == NULL)
  {
    MAKESTRDESC(_desc,"ungetc: 2.argument is not a string.");
    return(1);
  }
  
  if (strlen(cstr) > 1)
  {
    MAKESTRDESC(_desc,"ungetc: 2.argument is not a single character.");
    return(1);
  }

  fh = get_filehandle(handlestr);

  if (fh == NULL)
  {
    MAKESTRDESC(_desc,"ungetc: Argument is not a valid filehandle.");
    return(1);
  }

  if (ungetc(cstr[0], R_FILEHANDLE(*fh,fp)) == EOF) 
  {
    MAKESTRDESC(_desc,"ungetc: ungetc not successful.");
    return(1);
  }
  
  MAKESTRDESC(_desc,"ungetc");  
  END_MODUL("red_ungetc");
  return(0);
}


/********  End of Interactions  ********************************************/


d361 2
a362 1
 *  intact_inter -- Wenn der auf dem a-Stack liegende Ausdruck eine
d392 1
a392 1
    if (FUNC_INDEX(intact) >= intact_tab_size)
@


1.2
log
@interactions supported
@
text
@a0 3
/* --- rintact.c ---------------------------------- stt --- 08.09.95 ---- */
/* --- Tables, variables and functions for interactions ----------------- */

d2 3
d10 13
d34 2
d37 1
d39 35
a73 1
/* --- internal variables/functions ------------------------------------- */
d75 64
a138 6
static int red_dummy()
{
  START_MODUL("red_dummy");
  END_MODUL("red_dummy");
  return (0);
} 
a139 1
   
d143 8
a150 8
{{red_dummy,   "fopen"      } /* 0 */
,{red_dummy,   "fclose"     } /* 1 */
,{red_dummy,   "fgetc"      } /* 2 */
,{red_dummy,   "fputc"      } /* 3 */
,{red_dummy,   "ungetc"     } /* 4 */
,{red_dummy,   "fgets"      } /* 5 */
,{red_dummy,   "read"       } /* 6 */
,{red_dummy,   "fputs"      } /* 7 */
d153 4
a156 4
,{red_dummy,   "fseek"      } /* 10 */
,{red_dummy,   "ftell"      } /* 11 */
,{red_dummy,   "exit"       } /* 12 */
,{red_dummy,   "eof"        } /* 13 */
d159 2
a160 2
,{red_dummy,   "fstatus"    } /* 16 */
,{red_dummy,   "status"     } /* 17 */
d166 3
a168 3
,{red_dummy,   "chdir"      } /* 23 */
,{red_dummy,   "getwd"      } /* 24 */
,{red_dummy,   "dir"        } /* 25 */
d172 1414
@


1.1
log
@Initial revision
@
text
@d4 4
a7 1
/* $Log$
d20 1
a31 5
typedef struct {
  FCTPTR fkt;  
  char   *nam; 
} INTACT_TAB;

d48 2
a49 2
,{red_dummy,   "eof"        } /* 12 */
,{red_dummy,   "exit"       } /* 13 */
@
