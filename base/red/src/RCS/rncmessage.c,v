head	1.62;
access;
symbols
	continuation_based_interactions:1.34
	pre_interactions:1.27
	nCUBE~:1.18;
locks; strict;
comment	@ * @;


1.62
date	98.09.30.08.30.41;	author rs;	state Exp;
branches;
next	1.61;

1.61
date	98.09.24.13.12.10;	author rs;	state Exp;
branches;
next	1.60;

1.60
date	98.09.13.15.30.30;	author rs;	state Exp;
branches;
next	1.59;

1.59
date	98.06.03.16.20.07;	author rs;	state Exp;
branches;
next	1.58;

1.58
date	98.03.31.09.54.42;	author rs;	state Exp;
branches;
next	1.57;

1.57
date	98.02.27.15.00.48;	author rs;	state Exp;
branches;
next	1.56;

1.56
date	98.02.18.13.34.36;	author rs;	state Exp;
branches;
next	1.55;

1.55
date	97.11.24.08.19.48;	author rs;	state Exp;
branches;
next	1.54;

1.54
date	97.06.06.09.13.11;	author rs;	state Exp;
branches;
next	1.53;

1.53
date	97.04.14.09.52.06;	author rs;	state Exp;
branches;
next	1.52;

1.52
date	97.02.17.13.18.12;	author rs;	state Exp;
branches;
next	1.51;

1.51
date	96.06.11.15.27.46;	author rs;	state Exp;
branches;
next	1.50;

1.50
date	96.03.22.10.33.20;	author rs;	state Exp;
branches;
next	1.49;

1.49
date	96.03.19.10.57.38;	author rs;	state Exp;
branches;
next	1.48;

1.48
date	96.03.18.16.58.03;	author cr;	state Exp;
branches;
next	1.47;

1.47
date	96.03.07.18.16.17;	author rs;	state Exp;
branches;
next	1.46;

1.46
date	96.03.07.15.38.22;	author rs;	state Exp;
branches;
next	1.45;

1.45
date	96.03.06.16.45.16;	author rs;	state Exp;
branches;
next	1.44;

1.44
date	96.03.01.16.21.47;	author rs;	state Exp;
branches;
next	1.43;

1.43
date	96.02.29.16.56.01;	author rs;	state Exp;
branches;
next	1.42;

1.42
date	96.02.28.15.49.44;	author rs;	state Exp;
branches;
next	1.41;

1.41
date	96.02.28.15.17.02;	author rs;	state Exp;
branches;
next	1.40;

1.40
date	96.02.28.13.49.25;	author cr;	state Exp;
branches;
next	1.39;

1.39
date	96.02.12.13.04.08;	author rs;	state Exp;
branches;
next	1.38;

1.38
date	96.01.25.16.18.22;	author rs;	state Exp;
branches;
next	1.37;

1.37
date	96.01.12.15.02.58;	author rs;	state Exp;
branches;
next	1.36;

1.36
date	95.12.07.16.48.50;	author rs;	state Exp;
branches;
next	1.35;

1.35
date	95.12.06.10.26.17;	author rs;	state Exp;
branches;
next	1.34;

1.34
date	95.10.20.13.22.31;	author rs;	state Exp;
branches;
next	1.33;

1.33
date	95.10.17.15.33.43;	author rs;	state Exp;
branches;
next	1.32;

1.32
date	95.09.22.12.46.47;	author rs;	state Exp;
branches;
next	1.31;

1.31
date	95.09.19.14.43.30;	author rs;	state Exp;
branches;
next	1.30;

1.30
date	95.09.18.13.39.40;	author rs;	state Exp;
branches;
next	1.29;

1.29
date	95.09.12.12.26.16;	author rs;	state Exp;
branches;
next	1.28;

1.28
date	95.09.11.14.21.22;	author rs;	state Exp;
branches;
next	1.27;

1.27
date	95.09.01.14.31.33;	author rs;	state Exp;
branches;
next	1.26;

1.26
date	95.08.08.14.37.47;	author rs;	state Exp;
branches;
next	1.25;

1.25
date	95.07.13.13.13.55;	author rs;	state Exp;
branches;
next	1.24;

1.24
date	95.07.12.15.22.57;	author rs;	state Exp;
branches;
next	1.23;

1.23
date	95.07.10.14.10.11;	author rs;	state Exp;
branches;
next	1.22;

1.22
date	95.07.07.15.15.25;	author rs;	state Exp;
branches;
next	1.21;

1.21
date	95.07.05.14.21.09;	author rs;	state Exp;
branches;
next	1.20;

1.20
date	95.06.30.12.33.16;	author rs;	state Exp;
branches;
next	1.19;

1.19
date	95.05.22.09.55.52;	author rs;	state Exp;
branches;
next	1.18;

1.18
date	95.05.17.12.58.10;	author rs;	state Exp;
branches;
next	1.17;

1.17
date	95.05.17.12.55.26;	author rs;	state Exp;
branches;
next	1.16;

1.16
date	94.10.27.15.22.52;	author dmk;	state Exp;
branches;
next	1.15;

1.15
date	94.09.06.14.17.59;	author dmk;	state Exp;
branches;
next	1.14;

1.14
date	94.06.11.12.59.17;	author ach;	state Exp;
branches;
next	1.13;

1.13
date	94.05.24.13.20.48;	author ach;	state Exp;
branches;
next	1.12;

1.12
date	94.05.19.12.01.42;	author ach;	state Exp;
branches;
next	1.11;

1.11
date	94.05.17.14.00.14;	author ach;	state Exp;
branches;
next	1.10;

1.10
date	94.05.16.11.42.06;	author ach;	state Exp;
branches;
next	1.9;

1.9
date	94.05.09.11.12.28;	author ach;	state Exp;
branches;
next	1.8;

1.8
date	94.05.06.12.24.06;	author ach;	state Exp;
branches;
next	1.7;

1.7
date	94.05.06.09.37.51;	author ach;	state Exp;
branches;
next	1.6;

1.6
date	94.05.04.07.03.27;	author ach;	state Exp;
branches;
next	1.5;

1.5
date	93.11.25.14.10.40;	author mah;	state Exp;
branches;
next	1.4;

1.4
date	93.10.28.14.07.50;	author rs;	state Exp;
branches;
next	1.3;

1.3
date	93.10.27.12.50.59;	author ach;	state Exp;
branches;
next	1.2;

1.2
date	93.10.25.15.50.51;	author rs;	state Exp;
branches;
next	1.1;

1.1
date	93.09.01.12.37.17;	author base;	state Exp;
branches;
next	;


desc
@ANSI-version mit mess und verteilungs-Routinen
@


1.62
log
@minor bugfixes in the speculative tickets version
@
text
@/* $Log: rncmessage.c,v $
 * Revision 1.61  1998/09/24 13:12:10  rs
 * bugfixed version for SPEC_TICKETS + some more features
 *
 * Revision 1.60  1998/09/13 15:30:30  rs
 * first version supporting speculative evaluations with TICKETS
 *
 * Revision 1.59  1998/06/03 16:20:07  rs
 * speculative evaluations version 2 completed
 *
 * Revision 1.58  1998/03/31 09:54:42  rs
 * dbug-messages removed, ready for re-compilation
 *
 * Revision 1.57  1998/02/27 15:00:48  rs
 * further bugfixes on speculative evaluation (preliminary, beware of debug messages !)
 *
 * Revision 1.56  1998/02/18  13:34:36  rs
 * modifications for speculative evaluations regarding
 * meaning preserving transformations
 *
 * Revision 1.55  1997/11/24  08:19:48  rs
 * old version check-in
 *
 * Revision 1.54  1997/06/06  09:13:11  rs
 * some more (complete) modifications concerning speculative evaluation
 * (don't say you have missed my talk ? ;-)
 *
 * Revision 1.53  1997/04/14  09:52:06  rs
 * further work on speculative evaluation
 *
 * Revision 1.52  1997/02/17  13:18:12  rs
 * some additions supporting speculative evaluation
 *
 * Revision 1.51  1996/06/11  15:27:46  rs
 * some scheduling improvements
 *
 * Revision 1.50  1996/03/22  10:33:20  rs
 * some problems concerning PM-instructions fixed
 *
 * Revision 1.49  1996/03/19  10:57:38  rs
 * support for C_PATTERN descriptors added
 *
 * Revision 1.48  1996/03/18  16:58:03  cr
 * support for C_INTACT
 *
 * Revision 1.47  1996/03/07  18:16:17  rs
 * C_FUNC TY_CASE ptc's might be used to indicate the number of the when-clause
 * (bugfix for the distributed version)
 *
 * Revision 1.46  1996/03/07  15:38:22  rs
 * another bugfix concerning the SUB-pattern-descriptor...
 *
 * Revision 1.45  1996/03/06  16:45:16  rs
 * sending/receiving CLAUSE and SELECTION descriptors
 * seems to work now
 *
 * Revision 1.44  1996/03/01  16:21:47  rs
 * still some work left ;-)
 *
 * Revision 1.43  1996/02/29  16:56:01  rs
 * still some work on sending MATCHING-descriptors left
 *
 * Revision 1.42  1996/02/28  15:49:44  rs
 * problems with TGUARD fixed...
 *
 * Revision 1.41  1996/02/28  15:17:02  rs
 * fixed label problems of the pattern matching instructions
 *
 * Revision 1.40  1996/02/28  13:49:25  cr
 * added support for C_FRAME (TY_FRAME/TY_SLOT)
 *
 * Revision 1.39  1996/02/12  13:04:08  rs
 * more DBUG output
 *
 * Revision 1.38  1996/01/25  16:18:22  rs
 * some changes for ADV_SCHED (-uling)
 *
 * Revision 1.37  1996/01/12  15:02:58  rs
 * set ADV_SCHED for the "advanced ticket scheduling", still under construction !
 *
 * Revision 1.36  1995/12/07  16:48:50  rs
 * some pvm + ncube + measurement changes
 *
 * Revision 1.35  1995/12/06  10:26:17  rs
 * some (final :-) changes for the nCUBE pvm version...
 *
 * Revision 1.34  1995/10/20  13:22:31  rs
 * some ncube+pvm changes
 *
 * Revision 1.33  1995/10/17  15:33:43  rs
 * minor changes (pvm)
 *
 * Revision 1.32  1995/09/22  12:46:47  rs
 * additional pvm + measure changes
 *
 * Revision 1.31  1995/09/19  14:43:30  rs
 * changes for the pvm + measuer version
 *
 * Revision 1.30  1995/09/18  13:39:40  rs
 * more DBUG output
 *
 * Revision 1.29  1995/09/12  12:26:16  rs
 * pvm + measure fixes
 *
 * Revision 1.28  1995/09/11  14:21:22  rs
 * some changes for the pvm measure version
 *
 * Revision 1.27  1995/09/01  14:31:33  rs
 * bugfix for the tilde-versions: send args+nfv in closures...
 *
 * Revision 1.26  1995/08/08  14:37:47  rs
 * bug fix in sending doubles
 * (thanks to mr. held there was no doku on this...)
 *
 * Revision 1.25  1995/07/13  13:13:55  rs
 * pvm bug fixes
 *
 * Revision 1.24  1995/07/12  15:22:57  rs
 * pvm changes
 *
 * Revision 1.23  1995/07/10  14:10:11  rs
 * some minor pvm changes...
 *
 * Revision 1.22  1995/07/07  15:15:25  rs
 * additional pvm changes
 *
 * Revision 1.21  1995/07/05  14:21:09  rs
 * additional pvm changes
 *
 * Revision 1.20  1995/06/30  12:33:16  rs
 * pvm changes (to be continued)
 *
 * Revision 1.19  1995/05/22  09:55:52  rs
 * changed nCUBE to D_SLAVE
 *
 * Revision 1.18  1995/05/17  12:58:10  rs
 * another test check-in (IGNORE)
 *
 * */

/***************************************************************/
/*                                                             */
/* rncmessage.c --- message routines for the nCube             */
/*                                                             */
/* ach 26/01/93                                                */
/*                                                             */
/***************************************************************/

#ifndef D_MESS_ONLY  
#define RNCMESSAGE Message-System!
#endif
#ifdef D_NN_SCHED
extern void nn_msg_send();
extern void nn_msg_receive();
extern int proc_org;


#include "rheapty.h"


#endif

#include "rheapty.h"
#include "rncheap.h"
#include "rncstack.h"
#include "rstdinc.h"
#include "rncmessage.h"
#include "rncsched.h"
#include "rstelem.h"
#include "rextern.h"
#include "rinter.h"
#include <stdio.h>
#if nCUBE
#include <nself.h>
#include <n_errno.h>
#endif /* nCUBE */
#include "dbug.h"
#include <malloc.h>
#include <string.h>
#include <setjmp.h>

#if D_MESS
#include <sys/stat.h>
#include <sys/signal.h>
#include "d_mess_io.h"
extern PROCESS_CONTEXT* curr_pid;
extern int newheap();
extern void freeheap();
extern T_DESCRIPTOR *newdesc();
extern void freedesc();
extern int compheap();
extern void allocate_d_stack_segment();
extern void free_d_stack_segment();
extern INSTR *distribute();
extern PROCESS_CONTEXT *process_create();
extern void process_terminate();
extern void process_sleep();
extern void process_wakeup();
extern void process_run();

extern int proc_tab_size;
#endif

#if D_PVM
#include "pvm3.h"
extern int pvmspawn_flag;
extern char *pvmspawn_where;
int pvmspawn_ntask;
int pvm_tids[128];
int pvmcoding; /* should be initialized in first communication... */
#endif /* D_PVM */

extern int d_sort_in;

/* extern void initialize_fred_fish();*/

#if D_SPEC
/* int m_curr_pid = 0; */  /******* DELETE ! for debugging purposes only *********/
extern int real_start_redcount;
extern int spec_father_slot;
#include "spec_sched.h"
extern int spec_sched_status;
extern FILE *debugger;
extern void abdul();
extern int rout_specmap2[];
#ifndef D_MESS_ONLY
int spec_message_size = MESSAGE_SIZE_OLD;
#endif
#endif

#if D_SPEC
#define MESSAGE_SIZE spec_message_size
#else  
#define MESSAGE_SIZE 1024
#endif 

#if D_MESS
#define D_MESS_DISABLED(text) { sprintf(m_super_name, "sorry, %s measurements are disabled", text); \
                              post_mortem(m_super_name); }
#endif

#if nCUBE
#ifndef D_MESS_ONLY      /* CHANGES IN DO_SEND, PLEASE ALSO IN D_MESS_ONLY CASE !!!!!! */

#if MSG_CHKSUM
#define DO_SEND(data)  ((buffer_p == buffer_end)? \
			(result = nwritep((char *)buffer,MESSAGE_SIZE*sizeof(int),dest,type,&flags), \
			 ((result < 0)?post_mortem("Error on nwrite"):0), \
			 buffer=buffer_p=(int *)ngetp(MESSAGE_SIZE*sizeof(int)), \
			 buffer_end=buffer + MESSAGE_SIZE):0, \
			 _tmp = (int)(data), \
			 chksum += _tmp, \
			 *buffer_p++ = _tmp) 
#else
#define DO_SEND(data)  ((buffer_p == buffer_end)? \
			(result = nwritep((char *)buffer,MESSAGE_SIZE*sizeof(int),dest,type,&flags), \
			 ((result < 0)?post_mortem("Error on nwrite"):0), \
			 buffer=buffer_p=(int *)ngetp(MESSAGE_SIZE*sizeof(int)), \
			 buffer_end=buffer + MESSAGE_SIZE):0, \
			 *buffer_p++ = (int)(data)) 
#endif
#else    /* DON'T FORGET CHANGES HERE !!!! */

#define DO_SEND(data)  ((buffer_p == buffer_end)? \
                        (result = nwritep((char *)buffer,MESSAGE_SIZE*sizeof(int),dest,type,&flags), \
			 ((result < 0)?post_mortem("Error on nwrite"):0), \
                         m_size += MESSAGE_SIZE*sizeof(int), \
                         buffer=buffer_p=(int *)ngetp(MESSAGE_SIZE*sizeof(int)), \
                         buffer_end=buffer + MESSAGE_SIZE):0, \
			*buffer_p++ = (int)(data))

#endif /* D_MESS_ONLY */
#endif /* nCUBE */

#if D_PVM
#define DO_SEND(data)  (_tmp=data, (pvm_counter > MESSAGE_SIZE)? \
                        (pvm_send(pvm_dest, type), \
                         pvm_counter = 0, \
                         pvm_initsend(pvmcoding)):0,\
                         pvm_pkint(&_tmp,1,1),\
                         pvm_counter++)
#endif /* D_PVM */

#if nCUBE
#ifndef D_MESS_ONLY  /* CHANGES IN DO_RECEIVE, PLEASE ALSO IN D_MESS_ONLY CASE !!!!!! */

#if MSG_CHKSUM
#define DO_RECEIVE()     ((buffer_p == buffer_end)? \
			  (nrelp((char *)buffer), \
			   result = nreadp(&buffer,MESSAGE_SIZE*sizeof(int),&src,&type,&flags), \
			   ((result < 0)?post_mortem("Error on nread"):0), \
			   buffer_p = buffer, \
			   buffer_end = buffer_p + result/sizeof(int)):0, \
			   chksum += *buffer_p, \
			  *buffer_p++) 
#else
#define DO_RECEIVE()     ((buffer_p == buffer_end)? \
			  (nrelp((char *)buffer), \
			   result = nreadp(&buffer,MESSAGE_SIZE*sizeof(int),&src,&type,&flags), \
			   ((result < 0)?post_mortem("Error on nread"):0), \
			   buffer_p = buffer, \
			   buffer_end = buffer_p + result/sizeof(int)):0, \
			  *buffer_p++) 
#endif
#else     /* DON'T FORGET CHANGES HERE !!!! */

#define DO_RECEIVE()     ((buffer_p == buffer_end)? \
                          (nrelp((char *)buffer), \
                           m_size += (result = nreadp(&buffer,MESSAGE_SIZE*sizeof(int),&src,&type,&flags)), \
                           ((result < 0)?post_mortem("Error on nread"):0), \
			   buffer_p = buffer, \
                           buffer_end = buffer_p + result/sizeof(int)):0, *buffer_p++)

#endif /* D_MESS_ONLY */
#endif /* nCUBE */

#if D_PVM
#define DO_RECEIVE()     ((pvm_counter > MESSAGE_SIZE)? \
                           (pvm_recv(pvm_src,type), \
                           pvm_counter = 0):0, \
                           pvm_upkint (&_tmp, 1, 1), \
                           pvm_counter++,_tmp)
#endif /* D_PVM */

#define SEND_2_SHORTS(data1,data2)  DO_SEND(((int)(data1) << 16) | (int)(data2))

#define RECEIVE_2_SHORTS(data1,data2) do {int tmp_data; \
					  tmp_data = DO_RECEIVE(); \
					  data1 = tmp_data >> 16; \
					  data2 = tmp_data & 0xffff;} while(0)

typedef struct sent_list_node {PTR_DESCRIPTOR ptr;
			       int original_entry;
			       DESC_CLASS original_class;
			       struct sent_list_node * next;} SENT_LIST_NODE;

extern unsigned int dist_stack_elems;        /* rncsched.c */
extern int dist_stack_free;          /* rncsched.c */
#if WITHTILDE
extern unsigned int dist_tilde_elems;        /* rncsched.c */
extern int dist_tilde_free;          /* rncsched.c */
#endif /* WITHTILDE */
extern DIST_TYPE dist_type;          /* rncsched.c */
extern INSTR * dist_instr;           /* rncsched.c */
extern DStackDesc D_S_H;             /* rncstack.c */
extern DStackDesc D_S_A;             /* rncstack.c */
extern DStackDesc D_S_R;             /* rncstack.c */
extern DStackDesc D_S_I;             /* rncstack.c */
extern DStackDesc D_S_hilf;          /* rncstack.c */
extern DStackDesc *ps_a;             /* rncinter.c */
extern DStackDesc *ps_w;             /* rncinter.c */
#if WITHTILDE
extern DStackDesc *ps_t;
extern DStackDesc *ps_r;
#endif /* WITHTILDE */
extern int proc_id;                  /* rncmain.c */
extern PROCESS_CONTEXT * curr_pid;   /* rncsched.c */
extern int ticket_pool[];
extern INSTR_DESCR instr_tab[];      /* rncinter.h */
extern int _redcnt;
extern INSTR* heap_code_start;       /* rncheap.c */
extern int _prec_mult;
extern int _prec;
extern int _prec10;
extern BOOLEAN _formated;
extern BOOLEAN LazyLists;
extern BOOLEAN _digit_recycling;
extern BOOLEAN _beta_count_only;
extern BOOLEAN _trunc;
extern BOOLEAN _count_reductions;
extern BOOLEAN _heap_reserved;
extern int _maxnum;
extern int _base;
extern int hd;
extern int hs;
extern int ss;
extern int stack_seg_size;
extern int sig_msg_flag;
extern int static_heap_upper_border;
extern int static_heap_lower_border;
extern int highdesc;
extern int stdesc_border;
extern int lookup_next;
extern int ticket_pool_counter;
extern int cube_dim;
extern char post_mortem_msg[256];
extern jmp_buf post_mortem_buffer;
extern int first_lookup;
#if ADV_SCHED
extern int tickets_cond, have_received_results, init_tickets_cond;
extern PROCESS_CONTEXT * ready_queue_first, *ready_queue_last;
#if D_MESS
extern int no_suspended;
#endif /* D_MESS */
#endif

extern PROCESS_CONTEXT *process_create();
extern void process_wakeup();

void flush_queue();

#if (ADV_SCHED || D_SPEC)
extern int sig_suspend;
#if D_MESS_ONLY
extern int sig_interrupt;
#else
int sig_interrupt=0;        /* checks whether the interpreter must be interrupted */
#endif /* D_MESS_ONLY */
#endif /* ADV_SCHED */

#if D_MESS
extern int host;
extern void handle_signal();
void msg_send();
void msg_receive();
#endif

#ifndef D_MESS_ONLY

int _tmp;

#else

extern int _tmp;

#endif

/***************************************************************/
/*                                                             */
/* msg_send()     sends a message                              */
/*                                                             */
/* arguments: dest   the number of the destination processor   */
/*                                                             */
/*            type   the type of the message                   */
/*                                                             */
/***************************************************************/

#ifdef D_MESS_ONLY

void m_msg_send(int dest, MESSAGE_TYPE type)

#else

void msg_send(int dest, MESSAGE_TYPE type)

#endif

{int stack_index=0;               /* number of sent stackelements  */
 int stack_elems;                 /* number of elements to be sent */
 int flags;                       /* for nwritep                   */
 int sent_index=0;                /* counter for sent descriptors  */
 int heap_elems,heap_counter;
 int code_sent=0;
 int param_counter;
 int result;
#if MSG_CHKSUM
 int chksum = 0;
#endif
 INSTR_DESCR send_instr;
 DESC_CLASS d_class;              /* class of descriptor           */
 DESC_TYPE d_type;                /* type of descriptor            */
 STACKELEM send_data,result_stelem;
 PTR_HEAPELEM heap_ptr,code_address;
 int *buffer,*buffer_p,*buffer_end;
#if D_PVM
 int pvm_counter=0;
 int pvm_dest = dest;
#endif /* D_PVM */

#if D_SPEC
 int send_spec;
#endif

 SENT_LIST_NODE *sent_list = NULL,*new_node;

 int dummy,*dummy2,*dummy3; /* Debugging */

#ifdef D_MESS_ONLY
 int m_backup_pid;
 int m_size = 0;
#endif
 int m_pid = -1;
 char *m_type;
/* #endif*/

#ifdef D_MESS_ONLY
 DBUG_ENTER("m_msg_send");
#else
 DBUG_ENTER("msg_send");
#endif

/* fprintf(debugger, "* ** entering msg_send, curr_pid: %x, sending type %d to node %d !\n", curr_pid, type, dest); fflush(debugger); */

#ifndef DBUG_OFF
  if (proc_id == dest)
    post_mortem("sending message to the same proc, shitty !");
#endif /* DBUG_OFF */

/*   if ((proc_id != 0) && (dest == host)) {
    post_mortem("Some node tried to send a message to the host...");
    } */
  

#if D_PVM
 if (pvm_dest != host) {
   DBUG_PRINT ("PVM", ("Sending to Node %d...", dest));
   pvm_dest = pvm_tids[dest];
   DBUG_PRINT ("PVM", ("this means tid t%x", pvm_dest));
   }
 else
   DBUG_PRINT ("PVM", ("Sending to the Host t%x", pvm_dest));
#endif /* D_PVM */

#ifdef D_MESS_ONLY
  m_backup_pid = m_curr_pid;
#endif

 if ((type == MT_NCUBE_READY) || (type == MT_ABORT))
   {

/*   fprintf(debugger, "0x%x: sending MT_NCUBE_READY, MT_ABORT to 0x%x\n", curr_pid, dest); fflush(debugger);     */

DBUG_PRINT ("PVM", ("MT_NCUBE_READY || MT_ABORT processing..."));

#ifdef D_MESS_ONLY

#if (D_SLAVE && D_MESS && D_MCOMMU)
    if (m_msg_send_begin)
      if (type == MT_NCUBE_READY)
        MPRINT_SEND_BEGIN(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, "MT_NCUBE_READY", dest, -1);
      else
        MPRINT_SEND_BEGIN(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, "MT_ABORT", dest, -1);
#endif
#endif /* D_MESS_ONLY */

#if D_PVM
    pvm_initsend(pvmcoding);
    pvm_send(pvm_dest,type);
#endif /* D_PVM */

#if nCUBE
    nwrite(NULL,0,dest,type,&flags);
#endif /* nCUBE */

#ifdef D_MESS_ONLY
#if (D_SLAVE && D_MESS && D_MCOMMU)
    if (m_msg_send_end)
      if (type == MT_NCUBE_READY)
        MPRINT_SEND_END(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, 0);
      else
        MPRINT_SEND_END(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, 0);
#endif
#endif

    DBUG_VOID_RETURN;}

 if (type == MT_POST_MORTEM)
   {

/* fprintf(debugger, "0x%x: sending MT_POST_MORTEM to 0x%x\n", curr_pid, dest); fflush(debugger);     */

DBUG_PRINT ("PVM", ("MT_POST_MORTEM processing..."));

#if nCUBE
    nwrite(post_mortem_msg,strlen(post_mortem_msg)+1,dest,type,&flags);
#endif /* NCUBE */
#if D_PVM
    pvm_initsend(pvmcoding);
    pvm_pkstr(post_mortem_msg);
    pvm_send(dest,type);
#endif /* D_PVM */
    DBUG_VOID_RETURN;}

 if (type == MT_NCUBE_FAILED)
   {

/*  fprintf(debugger, "0x%x: sending MT_NCUBE_FAILED to 0x%x\n", curr_pid, dest); fflush(debugger);      */

DBUG_PRINT ("PVM", ("MT_NCUBE_FAILED processing..."));

#if nCUBE
     nwrite(post_mortem_msg,strlen(post_mortem_msg)+1,dest,type,&flags);
#endif /* nCUBE */
#if D_PVM
    pvm_initsend(pvmcoding);
    pvm_pkstr(post_mortem_msg);
    pvm_send(dest,type);
#endif /* D_PVM */
    DBUG_VOID_RETURN;}


 /* prepare the message buffer */
#if nCUBE
 buffer=buffer_p=(int *)ngetp(MESSAGE_SIZE*sizeof(int));

/* fprintf(debugger, "********** buffer is now: %x, message size is %d\n", buffer, MESSAGE_SIZE); fflush(debugger);  */

#endif /* nCUBE */

#if D_PVM
   pvm_counter = 0;
   pvm_initsend(pvmcoding);
#endif /* D_PVM */

 buffer_end=buffer + MESSAGE_SIZE;
 switch (type)
   {
     case MT_CONTROL:

/*  fprintf(debugger, "sending MT_CONTROL\n"); fflush(debugger);   */

#if D_SPEC
       /* send CONTROL package */

       DBUG_PRINT ("MSG", ("send CONTROL message"));

#ifdef D_MESS_ONLY    /* *************************** correct later on !*/
      m_type = "MT_CONTROL"; /* this has to be interpreted, sorry */
      if (T_SPECMSG_GOON)
        m_type = "MT_CONTROL_GOON";
      else if (T_SPECMSG_BARR)
        m_type = "MT_CONTROL_BARR";
      else if (T_SPECMSG_FAIL)
        m_type = "MT_CONTROL_FAIL"; 
      else if (T_SPECMSG_HEREAMI)
        m_type = "MT_CONTROL_HERE";
      else if (T_SPECMSG_ACK)
        m_type = "MT_CONTROL_ACK";
      else if (T_SPECMSG_START)
        m_type = "MT_CONTROL_START";
      else if (T_SPECMSG_TERM)
        m_type = "MT_CONTROL_TERM";
      else if (T_SPECMSG_WIN)
        m_type = "MT_CONTROL_WIN";
      else if (T_SPECMSG_VITAL)
        m_type = "MT_CONTROL_VITAL";
      else post_mortem ("unknown CONTROL message type...");

      m_pid = spec_control[1];
      if (T_SPECMSG_START)
        m_curr_pid = spec_control[4];
      else
        m_curr_pid = spec_control[2];

/* fprintf(debugger, "0x%x: sending %s message to (0x%x,0x%x) from 0x%x\n",curr_pid, m_type, spec_control[1], dest, m_curr_pid); fflush(debugger);    */

/* #ifdef D_MESS_ONLY */  /*************** DELETE */

#if (D_SLAVE && D_MESS && D_MCOMMU)
      if (m_msg_send_begin)
        MPRINT_SEND_BEGIN(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, m_type, dest, m_pid);
#endif

/* fprintf(debugger, "sending %s to %d,%x\n", m_type, dest, m_pid); fflush(debugger);    */

#endif

       DO_SEND(spec_control[0]);
       DO_SEND(spec_control[1]);
       DO_SEND(spec_control[2]);
       DO_SEND(spec_control[3]);
       DO_SEND(spec_control[4]);
       DO_SEND(spec_control[5]);
       DO_SEND(spec_control[6]);
       DO_SEND(spec_control[7]);
       DO_SEND(spec_control[8]);
       DO_SEND(spec_control[9]);

       if (T_SPECMSG_ACK) {
       /* send the data about the speculative sons to the control process */
       DBUG_PRINT("MSG", ("SPECMSG_ACK processing"));

#if D_SPEC_TICKETS
       if (spec_control[6] == 1) {
         DBUG_PRINT("MSG", ("post_proc processing..."));
         DO_SEND(SPEC_SF_NUMB_T(*(PTR_DESCRIPTOR)spec_control[7]));
         DO_SEND(SPEC_SF_NUMB_A(*(PTR_DESCRIPTOR)spec_control[7]));
         } else
#endif
       for (spec_control[4]=0; spec_control[4]<spec_control[3]; spec_control[4]++) {
         /* first the PID */
         DO_SEND(((PROCESS_CONTEXT *)spec_control[2])->processes[(spec_control[4]*2)]);
         DO_SEND(((PROCESS_CONTEXT *)spec_control[2])->processes[(spec_control[4]*2)+1]);
         DBUG_PRINT("MSG", ("it's pid %x on node %d !", ((PROCESS_CONTEXT *)spec_control[2])->processes[(spec_control[4]*2)], ((PROCESS_CONTEXT *)spec_control[2])->processes[(spec_control[4]*2)+1]));
         }
     }

#else
       post_mortem ("no CONTROL messages in non SPEC version!!!");
#endif /* D_SPEC */

       break;

     case MT_NEW_PROCESS:

/*   fprintf(debugger, "0x%x: sending MT_NEW_PROCESS to 0x%x\n", curr_pid, dest); fflush(debugger);       */

DBUG_PRINT ("PVM", ("MT_NEW_PROCESS processing..."));
      
#ifdef D_MESS_ONLY

/*      fprintf(debugger, "m_curr_pid: %x, curr_pid: %x\n", m_curr_pid, curr_pid); fflush(debugger); */

      m_type = "MT_NEW_PROCESS";

#if D_SPEC_TICKETS
#if (D_SLAVE && D_MESS && D_MCOMMU)
      if (m_msg_send_begin && (spec_post_proc != 0))
        PROCESS_PID = SPEC_SF_PROCESS(*(PTR_DESCRIPTOR)spec_frame);
#endif
#endif

#if (D_SLAVE && D_MESS && D_MCOMMU)
      if (m_msg_send_begin)
	MPRINT_SEND_BEGIN(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, m_type, dest, m_pid);
#endif
#endif

      /* send the header */
#if D_SPEC_TICKETS
      if (spec_post_proc != 0) {
        DO_SEND(SPEC_SF_PROCESS(*(PTR_DESCRIPTOR)spec_frame)); /* sending pid of the father */
        } else
#endif
      DO_SEND((int)curr_pid);                                 /* the pid of the sending process */

#if (!D_SPEC)
      DO_SEND((int)(dist_instr-GET_CODE_START()));            /* the pc of the subprocess */
#else
      if (dist_instr == 0) {
        DBUG_PRINT("MSG", ("dist_instr was 0, process spawned by specmap !"));

/* fprintf(debugger, "%x: sending CODE %x\n", curr_pid, -1); fflush(debugger); */

        DO_SEND((int)(-1));
        } else {
        DBUG_PRINT("MSG", ("dist_instr was != 0, okay !"));
        DBUG_PRINT("MSG", ("dist_instr: %x, GET_CODE_START: %x", dist_instr, GET_CODE_START()));
        DO_SEND((int)(dist_instr-GET_CODE_START())); 

/* fprintf(debugger, "%x: sending CODE %x\n", curr_pid, dist_instr-GET_CODE_START()); fflush(debugger); */

        }
#endif
#if D_SPEC
#if D_SPEC_TICKETS
      if ((spec_post_proc != 0) || ((int)curr_pid->specmask1 > 0))  {
#else
      if ((int)curr_pid->specmask1 > 0) {
#endif

#if D_SPEC_TICKETS
        DO_SEND(spec_frame);
        DO_SEND(spec_post_proc);
        DBUG_PRINT("MSG", ("sending spec_frame %x, and a flag as a_stack_addr %d", spec_frame, spec_post_proc));
#else
        DO_SEND(spec_father_slot);
        DO_SEND((int)&(curr_pid->son_results[spec_father_slot]));
        DBUG_PRINT("MSG", ("store result in slot %d (%x)", spec_father_slot, &(curr_pid->son_results[spec_father_slot])));
#endif /* D_SPEC_TICKETS */
        }
      else {
      DO_SEND(0);
#endif /* D_SPEC */
      DO_SEND((int)D_TOP_ADDRESS(*ps_w));                     /* where to put the result */
#if D_SPEC
      }
#endif

#if WITHTILDE
      DBUG_PRINT("MSG", ("h/r-stack address %x", ((int)D_TOP_ADDRESS(*ps_r))));

#if D_SPEC_TICKETS
      if (spec_post_proc != 0) {
        DBUG_PRINT("MSG", ("post_proc, send real counter addr"));
        DO_SEND(SPEC_SF_ADDRCOUNT(*(PTR_DESCRIPTOR)spec_frame));
        } else
#endif
      DO_SEND((int)D_TOP_ADDRESS(*ps_r));                     /* where to find the counter */
#else

#if D_SPEC_TICKETS
      post_mortem("unsupported");
#endif

      DO_SEND((int)D_TOP_ADDRESS(D_S_H));                     /* where to find the counter */
#endif
#if D_SPEC_TICKETS
      if (spec_post_proc != 0) {
        DO_SEND(SPEC_SF_REDSTEPS(*(PTR_DESCRIPTOR)spec_frame));
        DBUG_PRINT("MSG", ("sending post_proc redsteps: %d", SPEC_SF_REDSTEPS(*(PTR_DESCRIPTOR)spec_frame)));
        } else
#endif
      DO_SEND((_redcnt)?_redcnt-1:0);                         /* how many reductions the process may use */

#if D_SPEC /* sende Maske fuer spekulativen Prozess und andere data... */
#if D_SPEC_TICKETS
      if (spec_post_proc != 0) {
      DBUG_PRINT("MSG", ("sending 1 as flag !"));
      DO_SEND(1); /* sending 1 as a flag for a speculative process */
      } else {
#endif
      DO_SEND((int)curr_pid->specmask1);
      DBUG_PRINT("MSG", ("sending specmask (%x)", curr_pid->specmask1));
#if D_SPEC_TICKETS
      }
#endif

#if D_SPEC_TICKETS
      if (spec_post_proc != 0) {
        DO_SEND((int)((PROCESS_CONTEXT *)SPEC_SF_PROCESS(*(PTR_DESCRIPTOR)spec_frame))->control_pid); 
        DO_SEND((int)((PROCESS_CONTEXT *)SPEC_SF_PROCESS(*(PTR_DESCRIPTOR)spec_frame))->control_node);
        DO_SEND((int)SPEC_SF_NESTING(*(PTR_DESCRIPTOR)spec_frame));
        } else
#endif
      if ((int)curr_pid->specmask1 > 0) {
        DO_SEND((int)curr_pid->control_pid);
        DO_SEND((int)curr_pid->control_node); 
#if D_SPEC_TICKETS
        DO_SEND((int)curr_pid->nesting);
#endif
        }
#endif /* D_SPEC */

#if ADV_SCHED
      DO_SEND(curr_pid->letpar_level); /* sending letpar_level */
      DBUG_PRINT ("ADV_SCHED", ("sending letpar_level: %i", curr_pid->letpar_level));
#endif /* ADV_SCHED */

      stack_elems = dist_stack_elems;
      D_PUSHSTACK(D_S_hilf,ST_END_MARKER);     /* push marker on Hilfstack */     
      if (dist_type == DIST_N)              /* send full stack frame? */
#if (D_SPEC && D_SPEC_TICKETS)
        if ((spec_post_proc != 0) || ((int)curr_pid->specmask1 > 0)) { /* it's a speculative process creation */
          stack_index=0;
          DBUG_PRINT("MSG", ("special frame communication for speculative processes (A-stack)"));

          for (;stack_index<stack_elems;stack_index++)
            D_PUSHSTACK(D_S_hilf,(*spec_frame).u.li.ptdv[SPEC_SF_DATA+stack_index+SPEC_SF_NUMB_T(*spec_frame)]);
          } else
        for (;stack_index<stack_elems;stack_index++)                      /* COPIED from down below ;-) */
          D_PUSHSTACK(D_S_hilf,D_MIDSTACK(*ps_a,stack_index));
#else
	for (;stack_index<stack_elems;stack_index++)
	  D_PUSHSTACK(D_S_hilf,D_MIDSTACK(*ps_a,stack_index));
#endif
      else                                  /* send only needed args */
	{while (stack_elems>0)
	   {if (stack_elems & 1)
	      D_PUSHSTACK(D_S_hilf,D_MIDSTACK(*ps_a,stack_index));
	   else
	     D_PUSHSTACK(D_S_hilf,ST_DUMMY);
	    stack_elems >>= 1;
	    stack_index++;}
	 for (;stack_index<dist_stack_free;stack_index++)
	   D_PUSHSTACK(D_S_hilf,ST_DUMMY);}
      
      DO_SEND(stack_index);

      DBUG_PRINT("MSG", ("%d A-stack elements sent...", stack_index));

#if WITHTILDE
      stack_index = 0;
      stack_elems = dist_tilde_elems;
#if (D_SPEC && D_SPEC_TICKETS)
      if ((spec_post_proc != 0) || ((int)curr_pid->specmask1 > 0)) { /* it's a speculative process creation */
        DBUG_PRINT("MSG", ("special frame communication for speculative processes (T-stack)"));

        for (;stack_index<stack_elems;stack_index++)
          D_PUSHSTACK(D_S_hilf,(*spec_frame).u.li.ptdv[SPEC_SF_DATA+stack_index]);
        } else
      for (;stack_index<stack_elems;stack_index++)               /* just COPIED from down below ! */
        D_PUSHSTACK(D_S_hilf,D_MIDSTACK(*ps_t,stack_index));
#else
      for (;stack_index<stack_elems;stack_index++)
	D_PUSHSTACK(D_S_hilf,D_MIDSTACK(*ps_t,stack_index));
#endif
      
      DO_SEND(stack_index);

      DBUG_PRINT("MSG", ("%d T-stack elements sent...", stack_index));

#endif /* WITHTILDE */
      
send_loop:

      while((send_data = D_POPSTACK(D_S_hilf)) != ST_END_MARKER)
	{if ((!T_POINTER(send_data) || !isdesc(send_data)) && send_data) {
           DBUG_PRINT ("MSG", ("no pointer, VAL_INT= %d, value=%x", VAL_INT(send_data), send_data));

/* fprintf(debugger, "sending NO pointer...\n"); fflush(debugger); */

	   DO_SEND(send_data); }
	else
	  {if (!send_data)                                  /* NULL pointer? */
	     {DBUG_PRINT ("MSG", ("null pointer"));
              DO_SEND(0);
	      DO_SEND(1);}
	  else
	    {if (IS_STATIC(send_data))                       /* pointer into static heap? */
	       {DBUG_PRINT("STATHEAP",("sending %08x as static heap",send_data));
		DO_SEND(0);
		DO_SEND(((int)STATIC_OFFSET(send_data) << 4) | 0x0a);}     /* ...1010 as tag for offset in static heap */
	    else
	      {DBUG_PRINT("DYNHEAP",("sending %08x (refcount %d) as dynamic heap",send_data, ((T_PTD)send_data)->u.sc.ref_count));
               if (R_DESC(*(T_PTD)send_data,class) == C_SENT)   /* descriptor already sent? */
		 {DBUG_PRINT("DYNHEAP",("already sent..."));
                  DO_SEND(0);
		  DO_SEND(((*((int *)send_data + 1)) << 4) | 0x0e);}
	      else
		{DO_SEND(0);
		 DO_SEND(0);                            /* tag for 'pointer to following descriptor' */

                 DBUG_PRINT ("MSG", ("send pointer to following descriptor"));
		 
		 /* send class and type of descriptor packed into one int */
		 
		 SEND_2_SHORTS((short)(d_class = R_DESC(*(T_PTD)send_data,class)),(short)(d_type = R_DESC(*(T_PTD)send_data,type)));
		 
		 /* refcount doesn`t need to be sent, will be set to 1 on dest processor */
		 /* and now: the main part of sending: the descriptor bodies */
		 switch(d_class)
		   {case C_SCALAR:
                      DBUG_PRINT("MSG", ("C_SCALAR"));
		      DO_SEND(R_SCALAR(*(T_PTD)send_data,vali));
#if (nCUBE || D_PVM_NCUBE)
		      if (type == MT_END_RESULT)
			{DO_SEND(*((int *)A_SCALAR(*(T_PTD)send_data,valr) + 1));
			 DO_SEND(*(int *)A_SCALAR(*(T_PTD)send_data,valr));}
		      else
#endif /* nCUBE */
			{DO_SEND(*(int *)A_SCALAR(*(T_PTD)send_data,valr));
			 DO_SEND(*((int *)A_SCALAR(*(T_PTD)send_data,valr) + 1));}
		      break;
		    case C_DIGIT:
                      DBUG_PRINT("MSG", ("C_DIGIT"));
		      SEND_2_SHORTS(R_DIGIT(*(T_PTD)send_data,sign),R_DIGIT(*(T_PTD)send_data,ndigit));
		      heap_elems = (int)R_DIGIT(*(T_PTD)send_data,ndigit);
		      DO_SEND(R_DIGIT(*(T_PTD)send_data,Exp));
		      heap_ptr = R_DIGIT(*(T_PTD)send_data,ptdv);
		      for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			DO_SEND(*heap_ptr);
		      break;
		    case C_LIST:
                       DBUG_PRINT("MSG", ("C_LIST, dim is %d", R_LIST(*(T_PTD)send_data,dim)));

/* fprintf(debugger, "sending C_LIST..., dim is %d\n", R_LIST(*(T_PTD)send_data,dim)); fflush(debugger);*/

		       SEND_2_SHORTS(R_LIST(*(T_PTD)send_data,special),R_LIST(*(T_PTD)send_data,dim));
		       heap_elems = (int)R_LIST(*(T_PTD)send_data,dim);
		       heap_ptr = R_LIST(*(T_PTD)send_data,ptdv);
		       for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			 D_PUSHSTACK(D_S_hilf,*heap_ptr);
		       break;
                     case C_INTACT:
                       DBUG_PRINT("MSG", ("C_INTACT"));
                       heap_elems = (int)R_INTACT(*(T_PTD)send_data,dim);
                       DO_SEND(heap_elems);
                       heap_ptr = R_INTACT(*(T_PTD)send_data,args);
                       for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
                         D_PUSHSTACK(D_S_hilf,*heap_ptr);
                       break;
                     case C_FRAME:
                        switch(d_type)
                        { case TY_FRAME:
                             DBUG_PRINT("MSG", ("C_FRAME/TY_FRAME"));
                             DO_SEND(R_FRAME(*(T_PTD)send_data,dim));
                             heap_elems = (int)R_FRAME(*(T_PTD)send_data,dim);
                             heap_ptr = R_FRAME(*(T_PTD)send_data,slots);
                             for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
                                 D_PUSHSTACK(D_S_hilf,*heap_ptr);
                             break;
                          case TY_SLOT:
                             DBUG_PRINT("MSG", ("C_FRAME/TY_SLOT"));
                             D_PUSHSTACK(D_S_hilf,R_SLOT(*(T_PTD)send_data,name));
                             D_PUSHSTACK(D_S_hilf,R_SLOT(*(T_PTD)send_data,value));
                             break;
                        }
                        break;
		     case C_MATRIX:
                       DBUG_PRINT("MSG", ("C_MATRIX"));
		     case C_VECTOR:
                       DBUG_PRINT("MSG", ("C_VECTOR"));
		     case C_TVECTOR:
                       DBUG_PRINT("MSG", ("C_TVECTOR ***"));
		       SEND_2_SHORTS(R_MVT(*(T_PTD)send_data,nrows,class),R_MVT(*(T_PTD)send_data,ncols,class));
		       heap_elems = (int)R_MVT(*(T_PTD)send_data,nrows,class) * (int)R_MVT(*(T_PTD)send_data,ncols,class);
		       if ((_formated == 1) && (d_type == TY_REAL))
			 heap_elems *= 2;
		       heap_ptr = R_MVT(*(T_PTD)send_data,ptdv,class);
		       if ((_formated == 1) && (d_type != TY_STRING))
			 for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			   DO_SEND(*heap_ptr);
		       else
			 for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			   D_PUSHSTACK(D_S_hilf,*heap_ptr);
		       break;
		     case C_EXPRESSION:
                       DBUG_PRINT("MSG", ("C_EXPRESSION"));
		     case C_CONSTANT:
                       DBUG_PRINT("MSG", ("C_CONSTANT ***"));
		       switch(d_type)
			 {case TY_REC:
                            DBUG_PRINT ("MSG", ("TY_REC"));
			  case TY_ZF:
                            DBUG_PRINT ("MSG", ("TY_ZF"));
			  case TY_SUB:
                            DBUG_PRINT ("MSG", ("TY_SUB ***"));
			    SEND_2_SHORTS(R_FUNC(*(T_PTD)send_data,special),R_FUNC(*(T_PTD)send_data,nargs));
			    if (R_FUNC(*(T_PTD)send_data,namelist))
			      {heap_elems = *(int *)R_FUNC(*(T_PTD)send_data,namelist);
			       heap_ptr = R_FUNC(*(T_PTD)send_data,namelist) + 1;
			       DO_SEND(heap_elems);
#if WITHTILDE
			       param_counter = *(heap_ptr++);
			       DO_SEND(param_counter);
			       heap_elems--;
#endif
			       for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
#if WITHTILDE
				 if ((param_counter > 0) && (heap_counter >= param_counter-2))
				   DO_SEND(*heap_ptr);
				 else
#endif
				   D_PUSHSTACK(D_S_hilf,*heap_ptr);}
			    else
			      DO_SEND(-1);
#if WITHTILDE
			    if (R_FUNC(*(T_PTD)send_data,pte))
			      {
#endif
				heap_elems = *(int *)R_FUNC(*(T_PTD)send_data,pte);
				heap_ptr = R_FUNC(*(T_PTD)send_data,pte) + 1;
				DO_SEND(heap_elems);
				for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
				  D_PUSHSTACK(D_S_hilf,*heap_ptr);
#if WITHTILDE
			      }
			    else
			      DO_SEND(-1);
#endif
			    break;
#if WITHTILDE
			  case TY_SNSUB:
                            DBUG_PRINT("MSG", ("TY_SNSUB"));
			    SEND_2_SHORTS(R_FUNC(*(T_PTD)send_data,special),R_FUNC(*(T_PTD)send_data,nargs));
			    heap_elems = *(int *)R_FUNC(*(T_PTD)send_data,pte);
			    heap_ptr = R_FUNC(*(T_PTD)send_data,pte) + 1;
			    DO_SEND(heap_elems);
			    for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			      D_PUSHSTACK(D_S_hilf,*heap_ptr);
			    break;
#endif
			  case TY_ZFCODE:
                            DBUG_PRINT("MSG", ("TY_ZFCODE"));
			    SEND_2_SHORTS(R_ZFCODE(*(T_PTD)send_data,zfbound),R_ZFCODE(*(T_PTD)send_data,nargs));
			    D_PUSHSTACK(D_S_hilf,R_ZFCODE(*(T_PTD)send_data,ptd));
			    heap_elems = *(int *)R_ZFCODE(*(T_PTD)send_data,varnames);
			    heap_ptr = R_ZFCODE(*(T_PTD)send_data,varnames) + 1;
			    DO_SEND(heap_elems);
			    for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			      D_PUSHSTACK(D_S_hilf,*heap_ptr);
			    break;
			  case TY_COND:
                            DBUG_PRINT("MSG", ("TY_COND"));
			    DO_SEND((int)R_COND(*(T_PTD)send_data,special));
			    heap_elems = *(int *)R_COND(*(T_PTD)send_data,ptte);
			    heap_ptr = R_COND(*(T_PTD)send_data,ptte) + 1;
			    DO_SEND(heap_elems);
			    for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			      D_PUSHSTACK(D_S_hilf,*heap_ptr);
			    heap_elems = *(int *)R_COND(*(T_PTD)send_data,ptee);
			    heap_ptr = R_COND(*(T_PTD)send_data,ptee) + 1;
			    DO_SEND(heap_elems);
			    for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			      D_PUSHSTACK(D_S_hilf,*heap_ptr);
			    break;
			  case TY_VAR:
                            DBUG_PRINT("MSG", ("TY_VAR"));
			    DO_SEND(R_VAR(*(T_PTD)send_data,nlabar));
			    D_PUSHSTACK(D_S_hilf,R_VAR(*(T_PTD)send_data,ptnd));
			    break;
			  case TY_EXPR:
                            DBUG_PRINT("MSG", ("TY_EXPR"));
			    heap_elems = *(int *)R_EXPR(*(T_PTD)send_data,pte);
			    heap_ptr = R_EXPR(*(T_PTD)send_data,pte) + 1;
			    DO_SEND(heap_elems);
			    for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			      D_PUSHSTACK(D_S_hilf,*heap_ptr);
			    break;
			  case TY_NAME:
                            DBUG_PRINT("MSG", ("TY_NAME"));
                            if (T_INT((int)R_NAME(*(T_PTD)send_data,ptn))) {
                              /* sorry ;-), but this is the special case for NAME- */
                              /* descriptors in a (UH-) pattern graph, because */
                              /* the (real) name is irrelevant and so the index */
                              /* is stored in the ptn field */
                              DBUG_PRINT("MSG", ("It's an index: %d", VAL_INT((int)R_NAME(*(T_PTD)send_data,ptn))));
                              DO_SEND(R_NAME(*(T_PTD)send_data,ptn));
                            } else {
                            DO_SEND(0); /* T_INT will fail on that (hopefully) */
			    heap_elems = (*(int *)R_NAME(*(T_PTD)send_data,ptn));
                            DBUG_PRINT("MSG", ("heap_elems: %d", heap_elems));
			    heap_ptr = R_NAME(*(T_PTD)send_data,ptn) + 1;
			    DO_SEND(heap_elems);
			    for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
				D_PUSHSTACK(D_S_hilf,*heap_ptr);
                            }
			    break;
			  case TY_SWITCH:
                            DBUG_PRINT("MSG", ("TY_SWITCH"));
#if WITHTILDE
			    SEND_2_SHORTS(R_SWITCH(*(T_PTD)send_data,nwhen),R_SWITCH(*(T_PTD)send_data,anz_args));
			    DO_SEND(R_SWITCH(*(T_PTD)send_data,casetype));
#else
			    SEND_2_SHORTS(R_SWITCH(*(T_PTD)send_data,special),R_SWITCH(*(T_PTD)send_data,case_type));
			    DO_SEND(R_SWITCH(*(T_PTD)send_data,nwhen));
#endif
			    heap_elems = *(int *)R_SWITCH(*(T_PTD)send_data,ptse);
			    heap_ptr = R_SWITCH(*(T_PTD)send_data,ptse) + 1;
			    DO_SEND(heap_elems);
#if WITHTILDE
			    DO_SEND(*(heap_ptr+heap_elems-1));
			    heap_elems--;
#endif
			    for (heap_counter = 0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			      D_PUSHSTACK(D_S_hilf,*heap_ptr);
			    break;
			  case TY_NOMAT:
                            DBUG_PRINT("MSG", ("TY_NOMAT"));
#if WITHTILDE
			    SEND_2_SHORTS(R_NOMAT(*(T_PTD)send_data,act_nomat),R_NOMAT(*(T_PTD)send_data,reason));
#else
			    DO_SEND(R_NOMAT(*(T_PTD)send_data,act_nomat));
#endif
			    if (R_NOMAT(*(T_PTD)send_data,guard_body))
			      {DBUG_PRINT("MSG", ("R_NOMAT(*(T_PTD)send_data,guard_body: %d", R_NOMAT(*(T_PTD)send_data,guard_body)));
                               heap_elems = *(int *)R_NOMAT(*(T_PTD)send_data,guard_body);
			       heap_ptr = R_NOMAT(*(T_PTD)send_data,guard_body) + 1;
			       DO_SEND(heap_elems);
                               DBUG_PRINT("MSG", ("heap_elems: %d", heap_elems));
			       for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
				 D_PUSHSTACK(D_S_hilf,*heap_ptr);}
			    else
			      DO_SEND(-1);
			    D_PUSHSTACK(D_S_hilf,R_NOMAT(*(T_PTD)send_data,ptsdes));
			    break;
			  case TY_MATCH:
                            DBUG_PRINT("MSG", ("TY_MATCH"));
			    if (R_MATCH(*(T_PTD)send_data,guard))
			      {heap_elems = *(int *)R_MATCH(*(T_PTD)send_data,guard);
			       heap_ptr = R_MATCH(*(T_PTD)send_data,guard) + 1;
			       DO_SEND(heap_elems);
			       for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
				 D_PUSHSTACK(D_S_hilf,*heap_ptr);}
			    else
			      DO_SEND(-1);
			    if (R_MATCH(*(T_PTD)send_data,body))
			      {heap_elems = *(int *)R_MATCH(*(T_PTD)send_data,body);
			       heap_ptr = R_MATCH(*(T_PTD)send_data,body) + 1;
			       DO_SEND(heap_elems);
			       for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
				 D_PUSHSTACK(D_S_hilf,*heap_ptr);}
			    else
			      DO_SEND(-1);
			    if (R_MATCH(*(T_PTD)send_data,code))
			      {heap_elems = *(int *)R_MATCH(*(T_PTD)send_data,code);
			       heap_ptr = R_MATCH(*(T_PTD)send_data,code) + 1;
			       DO_SEND(heap_elems);
			       for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
				 {if (T_POINTER(*heap_ptr) && isdesc(*heap_ptr))
				    {DO_SEND(PM_DESC_MARKER);
				     D_PUSHSTACK(D_S_hilf,*heap_ptr);}
				  else
				    DO_SEND(*heap_ptr);}}
			    else
			      DO_SEND(-1);
			    break;
			  case TY_LREC:
                            DBUG_PRINT("MSG", ("TY_LREC"));
			    DO_SEND(R_LREC(*(T_PTD)send_data,nfuncs));
			    heap_elems = *(int *)R_LREC(*(T_PTD)send_data,namelist);
			    heap_ptr = R_LREC(*(T_PTD)send_data,namelist) + 1;
			    DO_SEND(heap_elems);
			    for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			      D_PUSHSTACK(D_S_hilf,*heap_ptr);
			    heap_elems = R_LREC(*(T_PTD)send_data,nfuncs);
#if WITHTILDE
			    heap_ptr = R_LREC(*(T_PTD)send_data,ptdv)+1;
#else
			    heap_ptr = R_LREC(*(T_PTD)send_data,ptdv);
#endif
			    for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			      D_PUSHSTACK(D_S_hilf,*heap_ptr);
			    break;
			  case TY_LREC_IND:
                            DBUG_PRINT("MSG", ("TY_LREC_IND"));
			    DO_SEND(R_LREC_IND(*(T_PTD)send_data,index));
			    D_PUSHSTACK(D_S_hilf,R_LREC_IND(*(T_PTD)send_data,ptdd));
			    D_PUSHSTACK(D_S_hilf,R_LREC_IND(*(T_PTD)send_data,ptf));
			    break;
			  case TY_LREC_ARGS:
                            DBUG_PRINT("MSG", ("TY_LREC_ARGS"));
			    DO_SEND(heap_elems = R_LREC_ARGS(*(T_PTD)send_data,nargs));
			    D_PUSHSTACK(D_S_hilf,R_LREC_ARGS(*(T_PTD)send_data,ptdd));
			    heap_ptr = R_LREC_ARGS(*(T_PTD)send_data,ptdv);
			    for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			      D_PUSHSTACK(D_S_hilf,*heap_ptr);
			    break;
                          default:
                            DBUG_PRINT("MSG", ("Unknown C_EXPRESSION C_CONSTANT desc !"));
                            post_mortem ("Unknown C_EXPRESSION C_CONSTANT desc !");
                            break;
                            }
		       break;
		     case C_FUNC:
                       DBUG_PRINT("MSG", ("C_FUNC"));
		     case C_CONS:
                       DBUG_PRINT("MSG", ("C_CONS ***"));
		       switch(d_type)
			 {case TY_CLOS:
                            DBUG_PRINT("MSG", ("TY_CLOS"));
			    SEND_2_SHORTS(R_CLOS(*(T_PTD)send_data,args),R_CLOS(*(T_PTD)send_data,nargs));
#if WITHTILDE
			    SEND_2_SHORTS(R_CLOS(*(T_PTD)send_data,ftype),R_CLOS(*(T_PTD)send_data,nfv));
#else
			    DO_SEND(R_CLOS(*(T_PTD)send_data,ftype));
#endif
#if WITHTILDE
                            heap_elems = R_CLOS(*(T_PTD)send_data,args)+R_CLOS(*(T_PTD)send_data,nfv)+1;
#else
			    heap_elems = R_CLOS(*(T_PTD)send_data,args)+1;
#endif
			    heap_ptr = R_CLOS(*(T_PTD)send_data,pta);
			    for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			      D_PUSHSTACK(D_S_hilf,*heap_ptr);
			    break;
			  case TY_COMB:
                            DBUG_PRINT("MSG", ("TY_COMB"));
			    SEND_2_SHORTS(R_COMB(*(T_PTD)send_data,args),R_COMB(*(T_PTD)send_data,nargs));
			    D_PUSHSTACK(D_S_hilf,R_COMB(*(T_PTD)send_data,ptd));
			    heap_ptr = R_COMB(*(T_PTD)send_data,ptc);
			    goto send_code;
			  case TY_CONDI:
                            DBUG_PRINT("MSG", ("TY_CONDI"));
			    SEND_2_SHORTS(R_CONDI(*(T_PTD)send_data,args),R_CONDI(*(T_PTD)send_data,nargs));
			    D_PUSHSTACK(D_S_hilf,R_CONDI(*(T_PTD)send_data,ptd));
			    heap_ptr = R_CONDI(*(T_PTD)send_data,ptc);
			    goto send_code;
			  case TY_CONS:
                            DBUG_PRINT("MSG", ("TY_CONS"));
			    D_PUSHSTACK(D_S_hilf,R_CONS(*(T_PTD)send_data,hd));
			    D_PUSHSTACK(D_S_hilf,R_CONS(*(T_PTD)send_data,tl));
			    break;
			  case TY_CASE:
                            DBUG_PRINT("MSG", ("TY_CASE"));
			  case TY_WHEN:
                            DBUG_PRINT("MSG", ("TY_WHEN"));
			  case TY_GUARD:
                            DBUG_PRINT("MSG", ("TY_GUARD"));
			  case TY_BODY:
                            DBUG_PRINT("MSG", ("TY_BODY ***"));
			    SEND_2_SHORTS(R_CASE(*(T_PTD)send_data,args),R_CASE(*(T_PTD)send_data,nargs));
			    D_PUSHSTACK(D_S_hilf,R_CASE(*(T_PTD)send_data,ptd));
			    heap_ptr = R_CASE(*(T_PTD)send_data,ptc);
                            DO_SEND(heap_ptr);
                            if (T_INT((int)heap_ptr)) { /* it's NO code-Pointer ! */
                              DBUG_PRINT("MSG", ("no code pointer"));
                              break;
                              }
send_code:
                            DBUG_PRINT("MSG", ("code index..."));
			    DO_SEND(heap_ptr - GET_CODE_START());
			    break;
                          default:
                            DBUG_PRINT("MSG", ("unknown C_FUNC C_CONS desc !"));
                            post_mortem("unknown C_FUNC C_CONS desc !");
                            break;
			  }                 /* switch(d_type) */
		       break;
                     case C_MATCHING:
                       DBUG_PRINT("MSG", ("C_MATCHING"));
                       switch(d_type) {
                         case TY_SELECTION:
                           DBUG_PRINT("MSG", ("TY_SELECTION"));
                           DO_SEND((int)R_SELECTION(*(T_PTD)send_data, nclauses));
                           D_PUSHSTACK(D_S_hilf,R_SELECTION(*(T_PTD)send_data, clauses));
                           D_PUSHSTACK(D_S_hilf,R_SELECTION(*(T_PTD)send_data, otherwise));
                           break;
                         case TY_CLAUSE:
                           DBUG_PRINT("MSG", ("TY_CLAUSE"));
                           D_PUSHSTACK(D_S_hilf,(int)R_CLAUSE(*(T_PTD)send_data, next));
                           heap_ptr = R_CLAUSE(*(T_PTD)send_data, sons);
                           for (heap_counter=0;heap_counter < 4;heap_counter++,heap_ptr++) {
                             D_PUSHSTACK(D_S_hilf,*heap_ptr);
                             DBUG_PRINT("MSG", ("*heap_ptr = %x", *heap_ptr)); }
                           break;
                        default:
                          DBUG_PRINT("MSG", ("unknown d_type")); break;
                         }
                       break;
                     case C_PATTERN:
                       DBUG_PRINT("MSG", ("C_PATTERN"));
                       DO_SEND((int)R_PATTERN(*(T_PTD)send_data, following));
                       D_PUSHSTACK(D_S_hilf,R_PATTERN(*(T_PTD)send_data, pattern));
                       D_PUSHSTACK(D_S_hilf,R_PATTERN(*(T_PTD)send_data, variable)); 
                       break;
		     default:
                       DBUG_PRINT("MSG", ("unknown d_class desc !"));
                       post_mortem("unknown d_class desc !");
                       break;
                    }                      /* switch(d_class) */
		  new_node = (SENT_LIST_NODE *)malloc(sizeof(SENT_LIST_NODE));
		  if (!new_node)
		    post_mortem("insufficient memory for sent_list");
		  new_node->ptr = (T_PTD)send_data;
		  new_node->original_entry = *((int *)send_data + 1);
		  new_node->original_class = d_class;
		  new_node->next = sent_list;
		  sent_list = new_node;
		  L_DESC(*(T_PTD)send_data,class) = C_SENT;
		  *((int *)send_data + 1) = sent_index++;
	       }                           /* else {descriptor not sent yet}*/
	     }                                 /* else {not in static heap} */
	   }                                  /* else {null pointer}        */
	 }                                       /* else {pointer on stack} */
       }                                                           /* while */
#if MSG_CHKSUM
      DO_SEND(chksum);
#endif
      DO_SEND(END_MARKER);
      while (sent_list)
	{SENT_LIST_NODE *tmp;
	 
	 L_DESC(*(sent_list->ptr),class) = sent_list->original_class;
	 *((int *)sent_list->ptr + 1) = sent_list->original_entry;
	 tmp = sent_list;
	 sent_list = sent_list->next;
	 free(tmp);}

/*      if (type == MT_END_RESULT)
	post_mortem("Das war's!"); */
	
      break;
    case MT_RESULT:

  /* initialize_fred_fish();  */

/*  fprintf(debugger, "0x%x: sending MT_RESULT to pid 0x%x on node %d\n", curr_pid, (int) PC_GET_PPID(curr_pid), dest); fflush(debugger);      */

    DBUG_PRINT ("PVM", ("MT_RESULT processing..."));
      
#if D_SPEC
      if (PC_GET_PPID(curr_pid) == 0) {
        DBUG_PRINT("MSG", ("reinstall father_pid !"));
        post_mortem("PPID was 0 !");
       curr_pid->ppid = curr_pid->father_pid;
      }
#endif /* D_SPEC */

#ifdef D_MESS_ONLY
      m_type = "MT_RESULT";
      m_pid = (int) PC_GET_PPID(curr_pid);
#if (D_SLAVE && D_MESS && D_MCOMMU)
      if (m_msg_send_begin)
	MPRINT_SEND_BEGIN(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, m_type, dest, m_pid);
#endif
#endif
      
     DBUG_PRINT("MSG",("Result -> Node %d: class %d,type %d, desc %x",dest,
			R_DESC(*((T_PTD)*(ps_w->TopofStack)),class),
			R_DESC(*((T_PTD)*(ps_w->TopofStack)),type),*(ps_w->TopofStack)));

      /* header */
      DO_SEND(PC_GET_PPID(curr_pid));

      DBUG_PRINT("MSG", ("sending to pid %x, curr_pid is %x", PC_GET_PPID(curr_pid), curr_pid));

#if WITHTILDE
      DO_SEND(D_POPSTACK(D_S_R));
      DO_SEND(D_POPSTACK(D_S_R));
#else
      DO_SEND(D_POPSTACK(D_S_H));
      DO_SEND(D_POPSTACK(D_S_H));
#endif

/* red counter handling */

      DO_SEND(PC_GET_SREDCNT(curr_pid)-_redcnt);

      DBUG_PRINT("MSG", ("the process used up %d steps...", PC_GET_SREDCNT(curr_pid)-_redcnt));

#if (D_SPEC && D_SLAVE)
      DBUG_PRINT("MSG", ("specmask1 is: %x", curr_pid->specmask1));
      DO_SEND(curr_pid->specmask1);
      DO_SEND(curr_pid->father_slot);
      DO_SEND(curr_pid);

      if (T_SPEC_WINNER(curr_pid)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_WINNER"));
        } 
      if (T_SPEC_NO_STEPS(curr_pid)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_NO_STEPS"));
        } 
      if (T_SPEC_FAIL(curr_pid)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_FAIL"));
        } 
      if (T_SPEC_NO_BSTEPS(curr_pid)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_NO_BSTEPS"));
        } 
      if (T_SPEC_GUARD(curr_pid)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_GUARD"));
        }
      if (T_SPEC_GUARD_SON(curr_pid)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_GUARD_SON"));
        }
      if (T_SPEC_UNRED_GUARD(curr_pid)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_UNRED_GUARD"));
        } 
      if (T_SPEC_INSYNC(curr_pid)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_INSYNC"));
        }
#endif /* D_SPEC */

      D_PUSHSTACK(D_S_hilf,ST_END_MARKER);
      result_stelem = D_POPSTACK(*ps_w);
      D_PUSHSTACK(D_S_hilf,result_stelem);
      goto send_loop;
    case MT_END_RESULT:


/*   initialize_fred_fish(); */

/*    fprintf(debugger, "0x%x: sending MT_END_RESULT to 0x%x\n", curr_pid, dest); fflush(debugger);    */

    DBUG_PRINT ("PVM", ("MT_END_RESULT processing..."));

#ifdef D_MESS_ONLY
  m_type = "MT_END_RESULT";
#if (D_SLAVE && D_MESS && D_MCOMMU)
  if (m_msg_send_begin)
    MPRINT_SEND_BEGIN(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, m_type, dest, m_pid);
#endif
#endif

/*      DBUG_PRINT("MSG",("End result: class %d,type %d",
			     R_DESC(*((T_PTD)*(ps_w->TopofStack)),class),
			     R_DESC(*((T_PTD)*(ps_w->TopofStack)),type))); */

#if D_SPEC
      /* there was a problem returning all steps back to the host */

      if (real_start_redcount != curr_pid->start_red_count) {
        DBUG_PRINT("MSG", ("start_red_count was modified, recalculate !"));
        DBUG_PRINT("MSG", ("real_start_redcount: %d, start_red_count: %d, _redcnt: %d",  
                    real_start_redcount, curr_pid->start_red_count, _redcnt));
        _redcnt = real_start_redcount - curr_pid->start_red_count;
        } 
#endif

      DO_SEND(_redcnt);
#if (ADV_SCHED && D_MESS)
      DO_SEND(no_suspended); /* sending the no. of suspended processes */
#endif /* ADV_SCHED && D_MESS */
      D_PUSHSTACK(D_S_hilf,ST_END_MARKER);
      result_stelem = D_POPSTACK(*ps_w);
      D_PUSHSTACK(D_S_hilf,result_stelem);
      SET_STATIC_BORDER(stdesc_border);
      DBUG_PRINT("STATHEAP",("new end of static heap: %08x",stdesc_border));
      goto send_loop;
    }                                       /* switch(type) */

#if nCUBE
 result = nwritep((char *)buffer,(buffer_p - buffer) * sizeof(int),dest,type,&flags);
 if (result < 0)
   post_mortem("error on nwrite");
#endif /* nCUBE */

#if D_PVM
 pvm_send(pvm_dest, type);
#endif /* D_PVM */

#ifdef D_MESS_ONLY
 m_size += (buffer_p - buffer) * sizeof(int);
#endif

 if ((type == MT_RESULT) || (type == MT_END_RESULT))
    T_DEC_REFCNT((T_PTD)result_stelem);

#ifdef D_MESS_ONLY
#if (D_SLAVE && D_MESS && D_MCOMMU)
 if (m_msg_send_end)
   MPRINT_SEND_END(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, m_size);
#endif
 m_curr_pid = m_backup_pid;
#endif

/*  fprintf(debugger, "* ** leaving msg_send\n"); fflush(debugger); */

 DBUG_VOID_RETURN;
}


/***************************************************************/
/*                                                             */
/* msg_receive()  receives a message and calls msg_handle      */
/*                                                             */
/***************************************************************/

#ifdef D_MESS_ONLY

void m_msg_receive()

#else

void msg_receive()

#endif

{int *buffer,*buffer_p,*buffer_end;
 int src=-1,type = -1,flags;
 STACKELEM *h_stack_addr, *a_stack_addr;
 int new_redcnt, new_letpar_level;
 int stelem_counter,stelem_number,heap_elems,heap_counter,param_counter;
 int received_index= 0;
 int *rec_addr, rec_data;
 int counter;
#if MSG_CHKSUM
 int chksum = 0;
#endif
 INSTR *new_pc = 0;
 INSTR_DESCR rec_instr;
 PROCESS_CONTEXT *new_pid,*ppid,*rec_pid;
 DESC_CLASS new_class;
 DESC_TYPE new_type;
 PTR_HEAPELEM new_heap,code_address;
 T_PTD *received_list;
 T_PTD new_desc;
 int rec_list_size = 256;
 int code_received = 0;
 int result;
#if D_SPEC
 PROCESS_CONTEXT *spec_tmp1;
 int spec_tmp2, spec_tmp3, spec_tmp4;
#if D_SPEC_TICKETS
 int spec_tmp6, spec_tmp7;
#endif
 int spec_flag; /* message for a speculative process */
#if D_SPEC_TICKETS
 int spec_help;
#endif
#endif
#if D_PVM
 int pvm_counter=0;
 int pvm_bufid;
 int pvm_length;
 int pvm_src;
 char m_remote_host[80];
 char m_remote_dir[80];
 char m_line[120];
#endif /* D_PVM */

#if ADV_SCHED
 int ic,jc;
#endif /* ADV_SCHED */
#if ADV_SCHED2
 PROCESS_CONTEXT *tmp1,*tmp2,*tmp3;
 int dummy;
#endif /* ADV_SCHED2 */
 
#if D_MESS
static struct sigaction act = {handle_signal,0,0};
#ifdef M_OLD_MERGING
 char mess_line[120];
#endif
 static char m_super_buffer[4096];
 int m_super_counter;
 struct stat stbuf;
 char name_line[120];
 int i,k;
 FILE *m_super_file1;
 FILE *m_super_file2;
 char m_super_name[120];
 int m_super_nr;
 int m_super_c;
#endif

#ifdef D_MESS_ONLY 
 int m_size = 0;
 char *m_type;
 int m_pid = -1;
 int f_pid = -1;
#endif 

#ifdef D_MESS_ONLY
 DBUG_ENTER ("m_msg_receive");
#else
 DBUG_ENTER("msg_receive");
#endif

/*   fprintf(debugger, "**** entering msg_receive\n"); fflush(debugger); */

#ifdef D_MESS_ONLY
#if (D_SLAVE && D_MESS && D_MCOMMU)
  if (m_msg_receive_begin)
    MPRINT_RECEIVE_BEGIN(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID);
#endif
#endif

 /* prepare the received list */
 received_list = (T_PTD *)malloc(sizeof(T_PTD)*rec_list_size);
 if (!received_list)
   post_mortem("insufficient memory for received_list (initializing)");

 /* receive first block off message */
#ifdef D_MESS_ONLY
#if nCUBE
 m_size += ( result = nreadp(&buffer,MESSAGE_SIZE * sizeof(int),&src,&type,&flags) );
 if (result < 0)
   post_mortem("error on nread");
#endif
#if D_PVM
 pvm_bufid = pvm_recv(-1,-1);
 pvm_bufinfo (pvm_bufid, &pvm_length, &type, &pvm_src);
 m_size += pvm_length;
#endif /* D_PVM */
#else
#if nCUBE
 result = nreadp(&buffer,MESSAGE_SIZE * sizeof(int),&src,&type,&flags);
 if (result < 0)
   post_mortem("error on nread");
#endif /* nCUBE */
#if D_PVM
 pvm_bufid = pvm_recv(-1,-1);
 pvm_bufinfo (pvm_bufid, &pvm_length, &type, &pvm_src); 
#endif /* D_PVM */
#endif
#if D_PVM
 pvm_counter = 0;
/* converting src back to logical node nr */
 if (pvm_src != host) {
   for (_tmp =0; _tmp<pvmspawn_ntask; _tmp++) /* identify the logical node number */
     if (pvm_src==pvm_tids[_tmp]){src=_tmp; break;}
   DBUG_PRINT("PVM", ("Receiving message from node %d, tid t%x", src, pvm_src)); }
 else
   DBUG_PRINT("PVM", ("Receiving message from Host tid t%x", pvm_src));
#endif /* D_PVM */

 buffer_p = buffer;
 buffer_end = buffer + result/sizeof(int);

/* if (type != MT_PARAM)
   hpchain2(); */

 res_heap();
 _heap_reserved = TRUE;

 DBUG_PRINT ("PVM", ("Before Switch..."));

 switch(type)
   {case MT_ABORT:

/*     fprintf(debugger, "receiving MT_ABORT\n"); fflush(debugger);   */

    DBUG_PRINT ("PVM", ("MT_ABORT processing..."));

#ifdef D_MESS_ONLY 
      m_type = "MT_ABORT";
#endif  /* D_MESS_ONLY */

      process_terminate_all();

      flush_queue();
      longjmp(post_mortem_buffer,1);
      break;

    case MT_CONTROL:

/*   fprintf(debugger, "receiving MT_CONTROL\n"); fflush(debugger);     */

#if D_SPEC
      DBUG_PRINT ("MSG", ("receiving MT_CONTROL message from node %d", src));

      /* receive the fixed package */
      spec_control[0] = DO_RECEIVE();
      spec_control[1] = DO_RECEIVE();
      spec_control[2] = DO_RECEIVE();
      spec_control[3] = DO_RECEIVE();
      spec_control[4] = DO_RECEIVE(); 
      spec_control[5] = DO_RECEIVE();
      spec_control[6] = DO_RECEIVE();
      spec_control[7] = DO_RECEIVE();
      spec_control[8] = DO_RECEIVE();
      spec_control[9] = DO_RECEIVE();

      /* now this stuff has to be interpreted */

      /* ok ok, I'll reformat the stuff vor 88 rows or so... ;-) */

      if (T_SPECMSG_HEREAMI) {   /********** T_SPECMSG_HEREAMI **********/

        DBUG_PRINT("MSG", ("HEREAMI-message received, processing"));
        DBUG_PRINT("MSG", ("the message is for pid : %x", spec_control[1]));

/*   fprintf(debugger, "0x%x: receiving HEREAMI from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);    */

#ifdef D_MESS_ONLY 
      m_type = "MT_CONTROL_HERE";
      m_pid = spec_control[2]; /* from which pid ?! */
      f_pid = spec_control[1]; /* for which pid ?! */
#endif

        spec_sched_status = 1;
        } else

      if (T_SPECMSG_ACK) {   /********** T_SPECMSG_ACK **********/
        DBUG_PRINT("MSG", ("ACK-message received, processing"));
        DBUG_PRINT("MSG", ("the message is for pid : %x", spec_control[1]));

#ifdef D_MESS_ONLY 
        m_type = "MT_CONTROL_ACK";
        m_pid = spec_control[2]; /* from which pid ?! */
        f_pid = spec_control[1]; /* for which pid ?! */
#endif 

/*   fprintf(debugger, "0x%x: receiving SPECMSG_ACK from (0x%x, 0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);   */

        if (!T_SPEC_GRANDDAD((PROCESS_CONTEXT *)spec_control[1])) {
          DBUG_PRINT("MSG", ("target proc is no GRANDDAD any more"));
          post_mortem("SPEC_ACK message received, but it wasn't a granddad process...");
          } else {

          DBUG_PRINT("MSG", ("Okey, let's register the processes"));

          /* remove the father process */
  
         spec_tmp1 = spec_control[1];
         spec_tmp2 = spec_control[3];
         spec_tmp4 = spec_control[2];
#if D_SPEC_TICKETS
         spec_tmp6 = spec_control[6];
         spec_tmp7 = spec_control[7];
         if (spec_tmp6 == 1) {
           DBUG_PRINT("MSG", ("post_proc, don't remove the father !"));
           spec_control[4]=1;
           spec_tmp2 = 1;
           }
#endif

/*   fprintf(debugger, "** it's this ACK !\n"); fflush(debugger);  */

          if (spec_control[4]==1) { /* it was a granddad speculative process */
            DBUG_PRINT("MSG", ("DON'T remove the father's PID from the PIPE..."));
            } else {
            DBUG_PRINT("MSG", ("remove the father's PID from the PIPE..."));
            spec_remove_control_pid(spec_control[1], spec_control[2], src, 0);

 /* dump_processes(spec_control[1]);  */
            }

          /* oh, this is some kind of loop, so we can't use the globals any more... */

          if ((spec_tmp1->control->leaves+spec_tmp2)>max_spec_procs)
             post_mortem("Too many speculative processes in syncronisation !");
 
          DBUG_PRINT("MSG", ("already stored: %d", spec_tmp1->control->leaves));

/*fprintf(debugger, "0x%x: %d are stored, %d have acknowledged... control 0x%x\n", curr_pid, spec_tmp1->control->leaves, spec_tmp1->control->have_ack, spec_tmp1); fflush(debugger);*/

          for (spec_tmp3=0; spec_tmp3<spec_tmp2; spec_tmp3++) {
            spec_tmp1->control->data[(spec_tmp1->control->leaves*2)+2*spec_tmp3] =
                  heap_counter=DO_RECEIVE();
            spec_tmp1->control->data[(spec_tmp1->control->leaves*2)+2*spec_tmp3+1] =
                  param_counter=DO_RECEIVE();
            DBUG_PRINT("MSG", ("registering pid %x of node %d as number %d", 
                       heap_counter, param_counter, spec_tmp1->control->leaves+spec_tmp3));

/* fprintf(debugger, "0x%x: nl ACK; registering pid 0x%x of node %d as number %d\n", curr_pid, heap_counter, param_counter, spec_tmp1->control->leaves+spec_tmp3); fflush(debugger);*/

            }  
          spec_control[1] = src;
          spec_control[2] = spec_tmp4;
          spec_control[4] = spec_tmp1;
#if D_SPEC_TICKETS
          spec_control[8] = spec_tmp6;
          spec_control[9] = spec_tmp7;
#endif

/*fprintf(debugger, "0x%x: ACK processed, %d leaves registered, %d have acknowledged\n", curr_pid, spec_tmp1->control->leaves, spec_tmp1->control->have_ack); fflush(debugger);*/

          spec_sched_status = 2;
          spec_tmp1->control->leaves += spec_tmp2;

/* fprintf(debugger, "A %d %d\n", spec_tmp1->control->leaves, spec_tmp1->control->have_ack); fflush(debugger); */

/* fprintf(debugger, "* TOTAL %d PROCESSES !\n", spec_tmp1->control->leaves); fflush(debugger); */

          DBUG_PRINT("MSG", ("total processes: %d", spec_tmp1->control->leaves));

          /* dump_processes(spec_tmp1);  */

          }  
        } else

      if (T_SPECMSG_BARR) {    /********** T_SPECMSG_BARR **********/
        /* this has to be ignored when a result has been found already */
        DBUG_PRINT("MSG", ("BARR-message received, processing"));
        DBUG_PRINT("MSG", ("the message is for pid : %x", spec_control[1]));

/*  fprintf(debugger, "0x%x: receiving BARR from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);  */


#ifdef D_MESS_ONLY 
        m_type = "MT_CONTROL_BARR";
        m_pid = spec_control[2]; /* from which pid ?! */
        f_pid = spec_control[1]; /* for which pid ?! */
#endif 

        spec_sched_status = 3;
        } else

      if (T_SPECMSG_GOON) {    /********** T_SPECMSG_GOON **********/
        DBUG_PRINT("MSG", ("GOON-message received, processing"));
        DBUG_PRINT("MSG", ("the message is for pid : %x, specmask %x", 
                  spec_control[1], ((PROCESS_CONTEXT *)spec_control[1])->specmask1));
        /* give the process more redsteps, err, more or less */
        /* first check whether it's not a waiting father or not */

#ifdef D_MESS_ONLY 
        m_type = "MT_CONTROL_GOON";
        m_pid = spec_control[2]; /* from which pid ?! */
        f_pid = spec_control[1]; /* for which pid ?! */
#endif 

/* fprintf(debugger, "0x%x: receiving GOON from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);  */

        spec_sched_status = 4;
        } else

      if (T_SPECMSG_WIN) {    /********** T_SPECMSG_WIN **********/
        /* there's a result somewhere !!! */
        /* now someone has to mask that there's already a result */
        DBUG_PRINT("MSG", ("WIN-message received, processing !"));

#ifdef D_MESS_ONLY 
        m_type = "MT_CONTROL_WIN";
        m_pid = spec_control[2]; /* from which pid ?! */
        f_pid = spec_control[1]; /* for which pid ?! */
#endif 

/* fprintf(debugger, "0x%x: receiving WIN from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);  */

        spec_sched_status = 5;

        } else 

      if (T_SPECMSG_START) {   /********** T_SPECMSG_START **********/
        /* finally, a speculative process may start working */
        DBUG_PRINT("MSG", ("SPECMSG_START received..."));
        DBUG_PRINT("MSG", ("initialize with %d red steps", spec_control[2]));

#ifdef D_MESS_ONLY 
        m_type = "MT_CONTROL_START";
        m_pid = spec_control[4]; /* from which pid ?! */
        f_pid = spec_control[1]; /* for which pid ?! */
#endif 

/* fprintf(debugger, "0x%x: receiving START from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[4], src, spec_control[1]); fflush(debugger); */

        spec_sched_status = 6;

        } else 

      if (T_SPECMSG_TERM) {    /********** T_SPECMSG_TERM **********/
        /* oh, terminate a process, how comes ? ;) */
        DBUG_PRINT("MSG", ("SPECMSG_TERM received..."));

#ifdef D_MESS_ONLY 
        m_type = "MT_CONTROL_TERM";
        m_pid = spec_control[2]; /* from which pid ?! */
        f_pid = spec_control[1]; /* for which pid ?! */
#endif 

/* fprintf(debugger, "0x%x: receiving TERM from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);  */

        DBUG_PRINT("MSG", ("Flag (0=father, 1=control) is %d !", spec_control[3]));

        spec_sched_status = 7;

        } else

      if (T_SPECMSG_FAIL) {   /********** T_SPECMSG_FAIL **********/
        /* oh, whowsers (Inspector Gadget) ! A failed spec process ! */
        DBUG_PRINT("MSG", ("SPECMSG_FAIL received !"));

        spec_control[0] = src;

/* fprintf(debugger, "0x%x: receiving FAIL from (0x%x,0x%d) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);  */
        
#ifdef D_MESS_ONLY 
        m_type = "MT_CONTROL_FAIL";
        m_pid = spec_control[2]; /* from which pid ?! */
        f_pid = spec_control[1]; /* for which pid ?! */
#endif

        spec_sched_status = 8;
        } else

      if (T_SPECMSG_VITAL) {   /********** T_SPECMSG_VITAL **********/
        /* vitalize a process... */
        DBUG_PRINT("MSG", ("vitalizing a process..."));

/* fprintf(debugger, "0x%x: receiving VITAL from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);  */
 
#ifdef D_MESS_ONLY 
        m_type = "MT_CONTROL_VITAL";
        m_pid = spec_control[2]; /* from which pid ?! */
        f_pid = spec_control[1]; /* for which pid ?! */
#endif 

        spec_sched_status = 10;
        }

         else {
          DBUG_PRINT("MSG", ("spec_control[0]: %x", spec_control[0]));
          post_mortem ("unknown control message ?!");
          }

/* fprintf(debugger, "Gebe buffer frei: %x (CONTROL)!\n", buffer); fflush(debugger); */

      nrelp((char *)buffer);
      free(received_list);

#else
      post_mortem ("no control messages allowed in non-SPEC version !");
#endif /* D_SPEC */

      break;

    case MT_TERMINATE:

/*  fprintf(debugger, "0x%x: receiving MT_TERMINATE from 0x%x\n", curr_pid, src); fflush(debugger);   */

    DBUG_PRINT ("PVM", ("MT_TERMINATE processing..."));

/* fprintf(debugger, "Exiting...!\n"); fflush(debugger); */

      exit(0);

    case MT_NEW_PROCESS:

/*  fprintf(debugger, "0x%x: receiving MT_NEW_PROCESS from 0x%x\n", curr_pid, src); fflush(debugger);   */

    DBUG_PRINT ("PVM", ("MT_NEW_PROCESS processing..."));

      /* receive the header */

      ppid         = (PROCESS_CONTEXT *)DO_RECEIVE();

#ifdef D_MESS_ONLY 
  m_type = "MT_NEW_PROCESS";
  m_pid = (int) ppid;
#endif 

#if D_SPEC
      new_pc       = /* (INSTR *) */ DO_RECEIVE();

      if (new_pc == -1) {

        DBUG_PRINT("MSG", ("this speculative process was spawned by specmap !"));
        new_pc = rout_specmap2; /* initiate microprogram */
        
/* fprintf(debugger, "%x: received CODE %x (specmap)\n", curr_pid, new_pc); fflush(debugger); */

        /* don't forget to move the stack items... or switch the stacks */

        } else {
        DBUG_PRINT("MSG", ("normal speculative process: new_pc = %x", new_pc));
        new_pc = (INSTR *)((int)new_pc*sizeof(int) + (int)GET_CODE_START());
        DBUG_PRINT("MSG", ("new_pc = %x, code_start is %x", new_pc, GET_CODE_START()));

/* fprintf(debugger, "%x: received CODE %x\n", curr_pid, new_pc); fflush(debugger); */

        }
#else
      new_pc       = (INSTR *)(DO_RECEIVE() + GET_CODE_START());
#endif
#if D_SPEC
      spec_father_slot = DO_RECEIVE();
      DBUG_PRINT("MSG", ("slot number is %d (0x%x)", spec_father_slot, spec_father_slot));
#endif
      a_stack_addr = (STACKELEM *)DO_RECEIVE();
      h_stack_addr = (STACKELEM *)DO_RECEIVE();
      new_redcnt      = DO_RECEIVE();

      DBUG_PRINT("MSG", ("received a_stack_addr (0x%x), h_stack_addr (0x%x), new_redcnt (%d)", a_stack_addr, h_stack_addr, new_redcnt));

#if D_SPEC
      spec_global = DO_RECEIVE(); 
      DBUG_PRINT("RECEIVE", ("spec_global: %x", spec_global));
#endif /* D_SPEC */

#if ADV_SCHED
      new_letpar_level = DO_RECEIVE();
#endif /* ADV_SCHED */

      /* create new process with data from header */

#if (D_SLAVE && D_MESS && D_MSCHED)
      new_pid = (*d_m_process_create)(new_pc,ppid,new_redcnt);
#else
      new_pid = process_create(new_pc,ppid,new_redcnt);
#endif

/* fprintf(debugger, "I was created by pid %x on node %d !\n", ppid, src), fflush(debugger); */

#if D_SPEC
      new_pid->father_slot = spec_father_slot;
   /*   if (new_pc == rout_specmap2) {
        DBUG_PRINT("MSG", ("OK, just  switch the stacks !"));
        new_pid->switched = W_A_SWITCHED; 
        } this crap does not work */
#endif

#if D_SPEC
      if (spec_global>0) {

        new_pid->father_pid = ppid;
        new_pid->father_node = src;
        new_pid->control_pid = DO_RECEIVE();
        new_pid->control_node = DO_RECEIVE();
#if D_SPEC_TICKETS
        new_pid->nesting = DO_RECEIVE();
#endif
        DBUG_PRINT("MSG", ("spec process created by node %d pid %x", src, ppid));
        DBUG_PRINT("MSG", ("control is at node %d pid %x", new_pid->control_node, new_pid->control_pid));
        PC_SET_SPEC_READY(new_pid);
        spec_control[0] = src;
        spec_control[1] = ppid;
        spec_control[2] = new_pid;
#if D_SPEC_TICKETS
        spec_control[3] = a_stack_addr;
        DBUG_PRINT("MSG", ("flag for non-Code-spawned-Process is %d, desc is %x", a_stack_addr, spec_father_slot));
        spec_control[4] = spec_father_slot;
#endif

        spec_sched_status = 9;
        }
#endif
  
#ifdef D_MESS_ONLY
      f_pid = (int) new_pid;
#endif

#if ADV_SCHED
      new_pid->start_letpar_level = new_pid->letpar_level = new_letpar_level;
      DBUG_PRINT ("ADV_SCHED", ("new letpar_levels received: %i", new_letpar_level));

#if ADV_SCHED2
      /* sort top-element of ready_queue deeper ;-) into the queue */

/*      fprintf(stderr,"*** %d sorting down...\n", proc_id); fflush(stderr); */

      tmp1 = NULL;
      tmp2 = ready_queue_first;
      tmp3 = ready_queue_first->next;
      dummy = 0; /***killme***/
      while ((tmp3!=NULL) && (tmp2->letpar_level>=tmp3->letpar_level)) {
        /* exchange */
        dummy++; /***killme***/
        if (tmp1 == NULL)
          ready_queue_first = tmp3;
        else
          tmp1->next = tmp3;
        tmp2->next = tmp3->next; /* tmp2 holds position */
        tmp3->next = tmp2; /* swap */
        tmp1 = tmp3;
        tmp3 = tmp2->next;
/*        fprintf (stderr, "exchanged %d and %d...", tmp2->letpar_level, tmp1->letpar_level); */
        }
      if (tmp3==NULL)
        ready_queue_last = tmp2;

/*      if (dummy>0) {
         fprintf(stderr, "swap'ed %d down...\n", dummy); fflush(stderr); } 
      fprintf(stderr,"\n"); fflush(stderr);  */
 
/*      fprintf(stderr,"*** %d sorted...\n", proc_id); fflush(stderr); */

#endif /* ADV_SCHED2 */

#endif /* ADV_SCHED */
      
      /* get addresses of new stacks */

#if WITHTILDE
      D_PUSHSTACK(PC_GET_R_STACK(new_pid),h_stack_addr);
      D_PUSHSTACK(PC_GET_R_STACK(new_pid),a_stack_addr);
      D_PUSHSTACK(PC_GET_R_STACK(new_pid),(src << 1));

/* fprintf (debugger, "0x%x: pushing %d as return-node for pid 0x%x on Stack R !\n", curr_pid, src, new_pid); fflush(debugger); */

#else
      D_PUSHSTACK(PC_GET_H_STACK(new_pid),h_stack_addr);
      D_PUSHSTACK(PC_GET_H_STACK(new_pid),a_stack_addr);
      D_PUSHSTACK(PC_GET_R_STACK(new_pid),src);
#endif
      
      D_PUSHSTACK(D_S_hilf,ST_END_MARKER);

      stelem_number = DO_RECEIVE();
      for (stelem_counter = 0; stelem_counter < stelem_number; stelem_counter++)
	{D_PUSHSTACK(PC_GET_REAL_I_STACK(new_pid),ST_DUMMY);
	 D_PUSHSTACK(PC_GET_H_STACK(new_pid),(int)D_TOP_ADDRESS(PC_GET_I_STACK(new_pid)) << 1);}

      for (stelem_counter = 0; stelem_counter < stelem_number; stelem_counter++)
	D_PUSHSTACK(D_S_hilf,D_POPSTACK(PC_GET_H_STACK(new_pid)));

#if WITHTILDE
      stelem_number = DO_RECEIVE();
      for (stelem_counter = 0; stelem_counter < stelem_number; stelem_counter++)
	{D_PUSHSTACK(PC_GET_H_STACK(new_pid),ST_DUMMY);
	 D_PUSHSTACK(PC_GET_R_STACK(new_pid),(int)D_TOP_ADDRESS(PC_GET_H_STACK(new_pid)) << 1);}

      for (stelem_counter = 0; stelem_counter < stelem_number; stelem_counter++)
	D_PUSHSTACK(D_S_hilf,D_POPSTACK(PC_GET_R_STACK(new_pid)));
#endif /* WITHTILDE */

receive_loop:
      while((int)(rec_addr = (int *)D_POPSTACK(D_S_hilf)) != ST_END_MARKER)
	{ if ((int)rec_addr & 1)
	   {counter = D_POPSTACK(D_S_hilf);
            DBUG_PRINT("MSG", ("counter at start: %d", counter));
	    DBUG_ASSERT(counter > 0);
	    if (counter > 1)
	      {D_PUSHSTACK(D_S_hilf,counter - 1);
	       D_PUSHSTACK(D_S_hilf,rec_addr - 2);}}  /* minus 2, it's still shifted! */
	 rec_addr = (int *)((int)rec_addr >> 1);
/*	 if (isheap(rec_addr))
	   post_mortem("Trying to overwrite header of heapblock!"); */
	 rec_data = DO_RECEIVE();
	 if (rec_data != 0)
	   {DBUG_PRINT("MSG",("receiving non-pointer value VAL_INT %d (%x)",VAL_INT(rec_data),rec_data));

/* fprintf(debugger, "receiving NO pointer...\n"); fflush(debugger); */

	    *rec_addr = rec_data;}
	 else
	   {rec_data = DO_RECEIVE();
	    if (T_STAT_POINTER(rec_data))
	      {*rec_addr = (int)REAL_STATIC_ADDRESS((int)rec_data >> 4);
	       DBUG_PRINT("MSG",("receiving static descriptor pointer %x",*rec_addr));
	       DBUG_ASSERT(isdesc(*rec_addr));
	       INC_REFCNT((T_PTD)*rec_addr);
	       DBUG_PRINT("MSG",("refcount is now %d",((T_PTD)*rec_addr)->u.sc.ref_count));}
	    else
	      {DBUG_PRINT("MSG",("receiving dynamic descriptor pointer..."));
               if (T_DESC_INDEX(rec_data))
		 {*(T_PTD *)rec_addr = received_list[rec_data >> 4];
		  DBUG_PRINT("MSG",("receiving index for descriptor at %x",*rec_addr));
		  DBUG_ASSERT(isdesc(*rec_addr));
		  INC_REFCNT((T_PTD)*rec_addr);
		  DBUG_PRINT("MSG",("refcount is now %d",((T_PTD)*rec_addr)->u.sc.ref_count));}
	       else
		 {if (T_NULL_POINTER(rec_data))
		    {*rec_addr = NULL;}
		 else                    /* a new descriptor will follow */
		   {RECEIVE_2_SHORTS(new_class,new_type);
		    MAKEDESC(new_desc,1,new_class,new_type);
		    *rec_addr = (int)new_desc;
		    DBUG_PRINT("MSG",("receiving desc for address %x: class %d, type %d",rec_addr,new_class,new_type));
		    switch(new_class)
		      {case C_SCALAR:
                         DBUG_PRINT("MSG", ("C_SCALAR"));
			 L_SCALAR(*new_desc,vali) = DO_RECEIVE();
			 *((int *)A_SCALAR(*new_desc,valr)) = DO_RECEIVE();
			 *((int *)A_SCALAR(*new_desc,valr) + 1) = DO_RECEIVE();
			 break;
		       case C_DIGIT:
                         DBUG_PRINT("MSG", ("C_DIGIT"));
			 RECEIVE_2_SHORTS(L_DIGIT(*new_desc,sign),L_DIGIT(*new_desc,ndigit));
			 L_DIGIT(*new_desc,Exp) = DO_RECEIVE();
			 heap_elems = R_DIGIT(*new_desc,ndigit);
			 GET_HEAP(heap_elems,A_DIGIT(*new_desc,ptdv));
			 new_heap = R_DIGIT(*new_desc,ptdv);
			 for (heap_counter = 0;heap_counter < heap_elems;heap_counter++,new_heap++)
			   *new_heap = DO_RECEIVE();
			 break;
		       case C_LIST:
                         DBUG_PRINT("MSG", ("C_LIST"));
			 RECEIVE_2_SHORTS(L_LIST(*new_desc,special),L_LIST(*new_desc,dim));

/* fprintf(debugger, "receiving C_LIST..., dim is %d\n", R_LIST(*new_desc,dim)); fflush(debugger); */

                         DBUG_PRINT("MSG", ("dim is %d", R_LIST(*new_desc,dim)));

			 L_LIST(*new_desc,ptdd) = NULL;
			 D_PUSHSTACK(D_S_hilf,heap_elems = R_LIST(*new_desc,dim));
			 GET_HEAP(heap_elems,A_LIST(*new_desc,ptdv));
			 new_heap = R_LIST(*new_desc,ptdv);
			 D_PUSHSTACK(D_S_hilf,((int)(new_heap + (heap_elems - 1)) << 1) | 1);
			 break;
                       case C_MATCHING:
                         DBUG_PRINT("MSG", ("C_MATCHING"));
                         switch(new_type) {
                           case TY_SELECTION:
                             DBUG_PRINT("MSG", ("TY_SELECTION"));
                             L_SELECTION(*new_desc,nclauses) = (unsigned short) DO_RECEIVE();
                             D_PUSHSTACK(D_S_hilf,(int)A_SELECTION(*new_desc,clauses) << 1);
                             D_PUSHSTACK(D_S_hilf,(int)A_SELECTION(*new_desc,otherwise) << 1);
                             break;
                           case TY_CLAUSE:
                             DBUG_PRINT("MSG", ("TY_CLAUSE"));
                             D_PUSHSTACK(D_S_hilf,(int)A_CLAUSE(*new_desc,next) << 1);
                             heap_elems = 4;
                             D_PUSHSTACK(D_S_hilf,heap_elems);
                             GET_HEAP(heap_elems,A_CLAUSE(*new_desc,sons));
                             new_heap = R_CLAUSE(*new_desc,sons);
                             D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems-1) << 1) | 1);
                             break;
                           default:
                            DBUG_PRINT("MSG", ("unknown d_type")); break;
                           }
                         break;
                       case C_PATTERN:
                         DBUG_PRINT("MSG", ("C_PATTERN"));
                         L_PATTERN(*new_desc,following) = DO_RECEIVE();
                         D_PUSHSTACK(D_S_hilf,(int)A_PATTERN(*new_desc,pattern) << 1);
                         D_PUSHSTACK(D_S_hilf,(int)A_PATTERN(*new_desc,variable) << 1);
                         break;
		       case C_INTACT:
                         DBUG_PRINT("MSG", ("C_INTACT"));
                         L_INTACT(*new_desc,dim) = DO_RECEIVE();
			 D_PUSHSTACK(D_S_hilf,heap_elems = R_INTACT(*new_desc,dim));
			 GET_HEAP(heap_elems,A_INTACT(*new_desc,args));
			 new_heap = R_INTACT(*new_desc,args);
			 D_PUSHSTACK(D_S_hilf,((int)(new_heap + (heap_elems - 1)) << 1) | 1);
			 break;
                       case C_FRAME:
                          switch(new_type)
                          { case TY_FRAME:
                               DBUG_PRINT("MSG", ("C_FRAME/TY_FRAME"));
                               L_FRAME(*new_desc,dim) = DO_RECEIVE();
                               D_PUSHSTACK(D_S_hilf,heap_elems = R_FRAME(*new_desc,dim));
                               GET_HEAP(heap_elems,A_FRAME(*new_desc,slots));
                               new_heap = R_FRAME(*new_desc,slots);
                               D_PUSHSTACK(D_S_hilf,((int)(new_heap + (heap_elems - 1)) << 1) | 1);
                               break;
                            case TY_SLOT:
                               DBUG_PRINT("MSG", ("C_FRAME/TY_SLOT"));
                               D_PUSHSTACK(D_S_hilf,(int)A_SLOT(*new_desc,name) << 1);
                               D_PUSHSTACK(D_S_hilf,(int)A_SLOT(*new_desc,value) << 1);
                               break;
                          }
                          break;
		       case C_MATRIX:
                         DBUG_PRINT("MSG", ("C_MATRIX"));
		       case C_VECTOR:
                         DBUG_PRINT("MSG", ("C_VECTOR"));
		       case C_TVECTOR:
                         DBUG_PRINT("MSG", ("C_TVECTOR ***"));
			 RECEIVE_2_SHORTS(L_MVT(*new_desc,nrows,new_class),L_MVT(*new_desc,ncols,new_class));
			 L_MVT(*new_desc,ptdd,new_class) = NULL;
			 if ((_formated == 1) && (new_type != TY_STRING))
			   {heap_elems = (R_MVT(*new_desc,nrows,new_class)*R_MVT(*new_desc,ncols,new_class));
			    if (new_type == TY_REAL)
			      heap_elems *= 2;}
			 else
			   D_PUSHSTACK(D_S_hilf,heap_elems = (R_MVT(*new_desc,nrows,new_class)*R_MVT(*new_desc,ncols,new_class)));
			 GET_HEAP(heap_elems,A_MVT(*new_desc,ptdv,new_class));
			 new_heap = R_MVT(*new_desc,ptdv,new_class);
			 if ((_formated == 1) && (new_type != TY_STRING))
			   for(;heap_elems >0;heap_elems--,new_heap++)
			     *new_heap = DO_RECEIVE();
			 else
			   D_PUSHSTACK(D_S_hilf,((int)(new_heap + (heap_elems -1)) << 1) | 1);
			 break;
		       case C_EXPRESSION:
                         DBUG_PRINT("MSG", ("C_EXPRESSION"));
		       case C_CONSTANT:
                         DBUG_PRINT("MSG", ("C_CONSTANT ***"));
			 switch(new_type)
			   {case TY_REC:
                              DBUG_PRINT("MSG", ("TY_REC"));
			    case TY_ZF:
                              DBUG_PRINT("MSG", ("TY_ZF"));
			    case TY_SUB:
                              DBUG_PRINT("MSG", ("TY_SUB ***"));
			      RECEIVE_2_SHORTS(L_FUNC(*new_desc,special),L_FUNC(*new_desc,nargs));
			      if ((heap_elems = DO_RECEIVE()) >= 0)
				{
#if WITHTILDE
				  counter = DO_RECEIVE();
                                  DBUG_PRINT("MSG", ("heap_elems: %d, counter: %d", heap_elems, counter));
				  if (counter > 0)
				    D_PUSHSTACK(D_S_hilf,counter-2);
				  else
				    D_PUSHSTACK(D_S_hilf,heap_elems-1);
#else
				  if (heap_elems >0)
				    D_PUSHSTACK(D_S_hilf,heap_elems);
#endif
				  GET_HEAP(heap_elems+1,A_FUNC(*new_desc,namelist));
				  new_heap = R_FUNC(*new_desc,namelist);
				  *new_heap = heap_elems;
#if WITHTILDE
				  *(++new_heap)=counter;
				  if (counter > 0)
				    {D_PUSHSTACK(D_S_hilf,((int)(new_heap + counter - 2) << 1) | 1);
				     for (;heap_elems>counter-1;heap_elems--)
				       *(new_heap + heap_elems - 1)=DO_RECEIVE();}
				  else
				    D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems - 1) << 1) | 1);
#else
				  if (heap_elems >0)
				    D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
#endif
				}
			      else
				L_FUNC(*new_desc,namelist) = NULL;
			      heap_elems = DO_RECEIVE();
#if WITHTILDE
			      if (heap_elems >= 0)
				{
#endif
				  D_PUSHSTACK(D_S_hilf,heap_elems);
				  GET_HEAP(heap_elems+1,A_FUNC(*new_desc,pte));
				  new_heap = R_FUNC(*new_desc,pte);
				  *new_heap = heap_elems;
				  D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
#if WITHTILDE
				}
			      else
				L_FUNC(*new_desc,pte) = NULL;
#endif
			      break;
#if WITHTILDE
			    case TY_SNSUB:
                              DBUG_PRINT("MSG", ("TY_SNSUB"));
			      RECEIVE_2_SHORTS(L_FUNC(*new_desc,special),L_FUNC(*new_desc,nargs));
			      L_FUNC(*new_desc,namelist) = NULL;
			      heap_elems = DO_RECEIVE();
			      D_PUSHSTACK(D_S_hilf,heap_elems);
			      GET_HEAP(heap_elems+1,A_FUNC(*new_desc,pte));
			      new_heap = R_FUNC(*new_desc,pte);
			      *new_heap = heap_elems;
			      D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			      break;
#endif
			    case TY_ZFCODE:
                              DBUG_PRINT("MSG", ("TY_ZFCODE"));
			      RECEIVE_2_SHORTS(L_ZFCODE(*new_desc,zfbound),L_ZFCODE(*new_desc,nargs));
			      D_PUSHSTACK(D_S_hilf,(int)A_ZFCODE(*new_desc,ptd) << 1);
			      heap_elems = DO_RECEIVE();
			      D_PUSHSTACK(D_S_hilf,heap_elems);
			      GET_HEAP(heap_elems+1,A_ZFCODE(*new_desc,varnames));
			      new_heap = R_ZFCODE(*new_desc,varnames);
			      *new_heap = heap_elems;
			      D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			      break;
			    case TY_COND:
                              DBUG_PRINT("MSG", ("TY_COND"));
			      L_COND(*new_desc,special) = DO_RECEIVE();
			      heap_elems = DO_RECEIVE();
			      D_PUSHSTACK(D_S_hilf,heap_elems);
			      GET_HEAP(heap_elems+1,A_COND(*new_desc,ptte));
			      new_heap = R_COND(*new_desc,ptte);
			      *new_heap = heap_elems;
			      D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			      heap_elems = DO_RECEIVE();
			      D_PUSHSTACK(D_S_hilf,heap_elems);
			      GET_HEAP(heap_elems+1,A_COND(*new_desc,ptee));
			      new_heap = R_COND(*new_desc,ptee);
			      *new_heap = heap_elems;
			      D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			      break;
			    case TY_VAR:
                              DBUG_PRINT("MSG", ("TY_VAR"));
			      L_VAR(*new_desc,nlabar) = DO_RECEIVE();
			      D_PUSHSTACK(D_S_hilf,(int)A_VAR(*new_desc,ptnd) << 1);
			      break;
			    case TY_EXPR:
                              DBUG_PRINT("MSG", ("TY_EXPR"));
			      heap_elems = DO_RECEIVE();
			      D_PUSHSTACK(D_S_hilf,heap_elems);
			      GET_HEAP(heap_elems+1,A_EXPR(*new_desc,pte));
			      new_heap = R_EXPR(*new_desc,pte);
			      *new_heap = heap_elems;
			      D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			      break;
			    case TY_NAME:
                              DBUG_PRINT("MSG", ("TY_NAME"));
			      heap_elems = DO_RECEIVE();
                              if (T_INT(heap_elems)) {
                                /* for description: see the sending of TY_NAME */ 
                                L_NAME(*new_desc,ptn) = (int) heap_elems;
                                DBUG_PRINT("MSG", ("It's an index: %d", VAL_INT(heap_elems)));
                              } else { 
                              heap_elems = DO_RECEIVE();
			      D_PUSHSTACK(D_S_hilf,heap_elems);
			      GET_HEAP(heap_elems+1,A_NAME(*new_desc,ptn));
			      new_heap = R_NAME(*new_desc,ptn);
			      *new_heap = heap_elems;
			      D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
                              } 
			      break;
			    case TY_SWITCH:
                              DBUG_PRINT("MSG", ("TY_SWITCH"));
#if WITHTILDE
			      RECEIVE_2_SHORTS(L_SWITCH(*new_desc,nwhen),L_SWITCH(*new_desc,anz_args));
			      L_SWITCH(*new_desc,casetype) = DO_RECEIVE();
#else
			      RECEIVE_2_SHORTS(L_SWITCH(*new_desc,special),L_SWITCH(*new_desc,case_type));
			      L_SWITCH(*new_desc,nwhen) = DO_RECEIVE();
#endif
			      heap_elems = DO_RECEIVE();
			      GET_HEAP(heap_elems+1,A_SWITCH(*new_desc,ptse));
			      new_heap = R_SWITCH(*new_desc,ptse);
			      *new_heap = heap_elems;
#if WITHTILDE
			      *(new_heap+(heap_elems--)) = DO_RECEIVE();
#endif
			      D_PUSHSTACK(D_S_hilf,heap_elems);
			      D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			      break;
			    case TY_NOMAT:
                              DBUG_PRINT("MSG", ("TY_NOMAT"));
#if WITHTILDE
			      RECEIVE_2_SHORTS(L_NOMAT(*new_desc,act_nomat),L_NOMAT(*new_desc,reason));
#else
			      L_NOMAT(*new_desc,act_nomat) = DO_RECEIVE();
#endif
			      if ((heap_elems = DO_RECEIVE()) >= 0)
				{D_PUSHSTACK(D_S_hilf,heap_elems);
				 GET_HEAP(heap_elems+1,A_NOMAT(*new_desc,guard_body));
				 new_heap = R_NOMAT(*new_desc,guard_body);
				 *new_heap = heap_elems;
				 D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);}
			      else
				L_NOMAT(*new_desc,guard_body) = NULL;
			      D_PUSHSTACK(D_S_hilf,(int)A_NOMAT(*new_desc,ptsdes) << 1);
			      break;
			    case TY_MATCH:
                              DBUG_PRINT("MSG", ("TY_MATCH"));
			      heap_elems = DO_RECEIVE();
			      if (heap_elems >= 0)
				{if (heap_elems > 0)
				   D_PUSHSTACK(D_S_hilf,heap_elems);
				 GET_HEAP(heap_elems+1,A_MATCH(*new_desc,guard));
				 new_heap = R_MATCH(*new_desc,guard);
				 *new_heap = heap_elems;
				 if (heap_elems > 0)
				   D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);}
			      else
				L_MATCH(*new_desc,guard) = NULL;
			      heap_elems = DO_RECEIVE();
			      if (heap_elems >= 0)
				{if (heap_elems > 0)
				   D_PUSHSTACK(D_S_hilf,heap_elems);
				 GET_HEAP(heap_elems+1,A_MATCH(*new_desc,body));
				 new_heap = R_MATCH(*new_desc,body);
				 *new_heap = heap_elems;
				 if (heap_elems > 0)
				   D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);}
			      else
				L_MATCH(*new_desc,body) = NULL;
			      if ((heap_elems = DO_RECEIVE()) >= 0)
				{GET_HEAP(heap_elems+1,A_MATCH(*new_desc,code));
				 new_heap = R_MATCH(*new_desc,code);
				 *new_heap++ = heap_elems;
				 for (heap_counter = 0;heap_counter < heap_elems; heap_counter++)
				   {rec_data = DO_RECEIVE();
				    if (rec_data == PM_DESC_MARKER)
				      D_PUSHSTACK(D_S_hilf,((int)new_heap++) << 1);
				    else
				      *new_heap++ = rec_data;}}
			      else
				L_MATCH(*new_desc,code) = NULL;
			      break;
			    case TY_LREC:
                              DBUG_PRINT("MSG", ("TY_LREC"));
			      L_LREC(*new_desc,nfuncs) = DO_RECEIVE();
			      heap_elems = DO_RECEIVE();
			      D_PUSHSTACK(D_S_hilf,heap_elems);
			      GET_HEAP(heap_elems+1,A_LREC(*new_desc,namelist));
			      new_heap = R_LREC(*new_desc,namelist);
			      *new_heap = heap_elems;
			      D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			      D_PUSHSTACK(D_S_hilf,heap_elems = R_LREC(*new_desc,nfuncs));
#if WITHTILDE
			      GET_HEAP(heap_elems+1,A_LREC(*new_desc,ptdv));
#else
			      GET_HEAP(heap_elems,A_LREC(*new_desc,ptdv));
#endif
			      new_heap = R_LREC(*new_desc,ptdv);
#if WITHTILDE
			      *new_heap++ = R_LREC(*new_desc,nfuncs);
#endif
			      D_PUSHSTACK(D_S_hilf,((int)(new_heap + (heap_elems - 1)) << 1) | 1);
			      break;
			    case TY_LREC_IND:
                              DBUG_PRINT("MSG", ("TY_LREC_IND"));
			      L_LREC_IND(*new_desc,index) = DO_RECEIVE();
			      D_PUSHSTACK(D_S_hilf,(int)A_LREC_IND(*new_desc,ptdd) << 1);
			      D_PUSHSTACK(D_S_hilf,(int)A_LREC_IND(*new_desc,ptf) << 1);
			      break;
			    case TY_LREC_ARGS:
                              DBUG_PRINT("MSG", ("TY_LREC_ARGS"));
			      L_LREC_ARGS(*new_desc,nargs) = DO_RECEIVE();
			      D_PUSHSTACK(D_S_hilf,(int)A_LREC_ARGS(*new_desc,ptdd) << 1);
			      D_PUSHSTACK(D_S_hilf,heap_elems = R_LREC_ARGS(*new_desc,nargs));
			      GET_HEAP(heap_elems,A_LREC_ARGS(*new_desc,ptdv));
			      new_heap = R_LREC_ARGS(*new_desc,ptdv);
			      D_PUSHSTACK(D_S_hilf,((int)(new_heap + (heap_elems - 1)) << 1) | 1);
			      break;}
			 break;
		       case C_FUNC:
                         DBUG_PRINT("MSG", ("C_FUNC"));
		       case C_CONS:
                         DBUG_PRINT("MSG", ("C_CONS ***"));
			 switch(new_type)
			   {case TY_CLOS:
                              DBUG_PRINT("MSG", ("TY_CLOS"));
			      RECEIVE_2_SHORTS(L_CLOS(*new_desc,args),L_CLOS(*new_desc,nargs));
#if WITHTILDE
			      RECEIVE_2_SHORTS(L_CLOS(*new_desc,ftype),L_CLOS(*new_desc,nfv));
#else
			      L_CLOS(*new_desc,ftype) = DO_RECEIVE();
#endif
#if WITHTILDE
                              D_PUSHSTACK(D_S_hilf,heap_elems = R_CLOS(*new_desc,args) + R_CLOS(*new_desc,nfv) + 1);
#else
			      D_PUSHSTACK(D_S_hilf,heap_elems = R_CLOS(*new_desc,args) + 1);
#endif
			      GET_HEAP(heap_elems,A_CLOS(*new_desc,pta));
			      new_heap = R_CLOS(*new_desc,pta);
			      D_PUSHSTACK(D_S_hilf,((int)(new_heap + (heap_elems - 1)) << 1) | 1);
			      break;
			    case TY_COMB:
                              DBUG_PRINT("MSG", ("TY_COMB"));
			      RECEIVE_2_SHORTS(L_COMB(*new_desc,args),L_COMB(*new_desc,nargs));
			      D_PUSHSTACK(D_S_hilf,(int)A_COMB(*new_desc,ptd) << 1);
			      if ((type != MT_NEW_GRAPH) || code_received)
				L_COMB(*new_desc,ptc) = (PTR_HEAPELEM)(GET_CODE_START() + DO_RECEIVE());
			      else
				{heap_elems = DO_RECEIVE();
				 GET_HEAP(heap_elems+1,A_COMB(*new_desc,ptc));
				 new_heap = R_COMB(*new_desc,ptc);
				 goto receive_code;}
			      break;
			    case TY_CONDI:
                              DBUG_PRINT("MSG", ("TY_CONDI"));
			      RECEIVE_2_SHORTS(L_CONDI(*new_desc,args),L_CONDI(*new_desc,nargs));
			      D_PUSHSTACK(D_S_hilf,(int)A_CONDI(*new_desc,ptd) << 1);
			      if ((type != MT_NEW_GRAPH) || code_received)
				L_CONDI(*new_desc,ptc) = (PTR_HEAPELEM)GET_CODE_START() + DO_RECEIVE();
			      else
				{heap_elems = DO_RECEIVE();
				 GET_HEAP(heap_elems+1,A_CONDI(*new_desc,ptc));
				 new_heap = R_CONDI(*new_desc,ptc);
				 goto receive_code;}
			      break;
			    case TY_CONS:
                              DBUG_PRINT("MSG", ("TY_CONS"));
			      D_PUSHSTACK(D_S_hilf,(int)A_CONS(*new_desc,hd) << 1);
			      D_PUSHSTACK(D_S_hilf,(int)A_CONS(*new_desc,tl) << 1);
			      break;
			    case TY_CASE:
                              DBUG_PRINT("MSG", ("TY_CASE"));
			    case TY_WHEN:
                              DBUG_PRINT("MSG", ("TY_WHEN"));
			    case TY_GUARD:
                              DBUG_PRINT("MSG", ("TY_GUARD"));
			    case TY_BODY:
                              DBUG_PRINT("MSG", ("TY_BODY ***"));
			      RECEIVE_2_SHORTS(L_CASE(*new_desc,args),L_CASE(*new_desc,nargs));
			      D_PUSHSTACK(D_S_hilf,(int)A_CASE(*new_desc,ptd) << 1);
                              heap_elems = DO_RECEIVE();
                              if (T_INT(heap_elems)) { /* it's NO code-pointer !! */
                                DBUG_PRINT("MSG", ("no Code pointer ! Instead: %d", VAL_INT((int) heap_elems)));
                                L_CASE(*new_desc,ptc) = heap_elems;
                                break;
                                }
			      if ((type != MT_NEW_GRAPH) || code_received) {
                                DBUG_PRINT("MSG", ("receiving code-index..."));
				L_CASE(*new_desc,ptc) = GET_CODE_START() + DO_RECEIVE(); }
			      else
				{heap_elems = DO_RECEIVE();
				 GET_HEAP(heap_elems+1,A_CASE(*new_desc,ptc));
				 new_heap = R_CASE(*new_desc,ptc);
			       receive_code:
				 code_address = new_heap;
                                 DBUG_PRINT("MSG", ("receiving Code..."));
				 for (heap_counter = 1;heap_counter < heap_elems; heap_counter ++)
				   {*new_heap = DO_RECEIVE();
				    rec_instr = instr_tab[*new_heap++];
				    switch(rec_instr.paramtype)
				      {case NUM_PAR:
					 /* Here is our special case again, see msg_send */
					 if ((rec_instr.instruction == I_DIST) || (rec_instr.instruction == I_DISTB))
					   {*(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
					    *(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
					    *(new_heap++) = DO_RECEIVE();
					    *(new_heap++) = DO_RECEIVE();
#if WITHTILDE
					    *(new_heap++) = DO_RECEIVE();
					    *(new_heap++) = DO_RECEIVE();
					    heap_counter += 6;
#else
					    heap_counter += 4;
#endif
					    break;}

#if D_SPEC
                                         if (rec_instr.instruction == I_SPECDIST)
                                           {*(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
                                            *(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
                                            *(new_heap++) = DO_RECEIVE();
                                            *(new_heap++) = DO_RECEIVE();
                                            heap_counter += 4;
                                            break;}
#endif

                                  /* special treatment for some pattern matching */
                                  /* instructions */

                                  if ((rec_instr.instruction >= I_APPEND) && (rec_instr.instruction <= I_MATCHDIGIT)) {
                                    switch(rec_instr.instruction) {
                                      case I_ATEND:
                                      case I_ATSTART:
                                        DBUG_PRINT("MSG", ("converting PM instruction %i", rec_instr.instruction));
                                        *(new_heap++) = DO_RECEIVE();
                                        *(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
                                        heap_counter += 2;
                                        break;
                                      case I_MATCHARB:
                                      case I_MATCHARBS:
                                      case I_MATCHBOOL:
                                      case I_MATCHC:
                                      case I_MATCHIN:
                                      case I_MATCHINT:
                                      case I_MATCHLIST:
                                      case I_MATCHPRIM:
                                      case I_MATCHSTR:
                                        DBUG_PRINT("MSG", ("converting PM instruction %i", rec_instr.instruction));
                                        *(new_heap++) = DO_RECEIVE();
                                        *(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
                                        *(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
                                        heap_counter += 3;
                                        break;
                                      case I_MATCHREAL:
                                      case I_MATCHDIGIT:
                                        DBUG_PRINT("MSG", ("converting PM instruction %i", rec_instr.instruction)); 
                                        D_PUSHSTACK(D_S_hilf,(int)(new_heap++) << 1);
                                        *(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
                                        *(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
                                        heap_counter += 3;
                                        break;
                                      case I_TGUARD:
                                        DBUG_PRINT("MSG", ("converting TGUARD PM instruction..."));
                                        *(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
                                        D_PUSHSTACK(D_S_hilf,(int)(new_heap++) << 1);
                                        *(new_heap++) = DO_RECEIVE();
                                        *(new_heap++) = DO_RECEIVE();
                                        *(new_heap++) = DO_RECEIVE();
                                        *(new_heap++) = DO_RECEIVE();
                                        heap_counter += 6;
                                        break;
                                      case I_MATCHTRUE:
                                      case I_MATCHFALSE:
                                        DBUG_PRINT("MSG", ("converting PM instruction %i", rec_instr.instruction));
                                        *(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
                                        *(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
                                        heap_counter += 2;
                                        break;
                                      default:
                                        for (param_counter = 0;param_counter < rec_instr.nparams; param_counter++)
                                          {*(new_heap++) = DO_RECEIVE();
                                            heap_counter ++;}
                                        break;
                                      }
                                    break;
                                    }

				       case ATOM_PAR:
				       case FUNC_PAR:
					 for (param_counter = 0;param_counter < rec_instr.nparams;param_counter++)
					   {*(new_heap++) = DO_RECEIVE();
					    heap_counter ++;}
					 break;
				       case DESC_PAR:
					 D_PUSHSTACK(D_S_hilf,(int)(new_heap++) << 1);
					 heap_counter++;
					 break;
				       case ADDR_PAR:
					 *(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
					 heap_counter++;
					 break;
				       }                                  /* switch */
				  }                                       /* for */
				 *new_heap = I_SYMTAB;
				 code_received = 1;
				 SET_CODE_START(code_address);
			       }                                          /* else {code not received} */
			      break;
			    }                                             /* switch (new_type) */
			 break;
		       }                                                  /* switch (new_class) */
		    received_list[received_index++] = new_desc;
		    if (received_index == rec_list_size)
		      {rec_list_size += 256;
		       received_list = (T_PTD *)realloc(received_list,rec_list_size * sizeof(T_PTD));
/* fprintf(debugger, "rec_list_size: %d\n", rec_list_size); fflush(debugger); */
		       if (!received_list)
			 post_mortem("insufficient memory for received_list");}
		  }                                                       /* else {descriptor not received yet} */
		}                                                       /* else {null pointer} */
	     }                                                          /* else {not in static heap} */
	  }                                                             /* else {extended pointer on stack} */
       }                                                                /* while */
#if MSG_CHKSUM
      rec_data = DO_RECEIVE();
      if (rec_data*2 != chksum) {
	post_mortem("Checksum error");
      }
#endif


      rec_data = DO_RECEIVE();
      if (rec_data != END_MARKER)
	post_mortem("END_MARKER expected but not found");
      DBUG_PRINT("MSG", ("END_MARKER found..."));
#if nCUBE

/* fprintf(debugger, "Gebe buffer frei: %x (GRAPH)!\n", buffer); fflush(debugger); */

      nrelp((char *)buffer);
#endif /* nCUBE */
      free(received_list);


  rel_heap();
  _heap_reserved = FALSE;

/* some additional speculative stuff */

#if D_SPEC

  if (new_pc == rout_specmap2) {
    DBUG_PRINT("MSG", ("OK, NOW switch the stacks !"));
    new_pid->switched = new_pid->switched | W_A_SWITCHED;
    } 

#if D_SPEC_TICKETS
  if ((spec_flag >0) && (type == MT_RESULT)) {
    DBUG_PRINT("MSG", ("copy speculative result to the appropriate destination..., spec_father_slot: %x", spec_father_slot));
    SPEC_SF_FIRSTF(*(PTR_DESCRIPTOR)spec_father_slot) = ((PROCESS_CONTEXT *)SPEC_SF_PROCESS(*(PTR_DESCRIPTOR)spec_father_slot))->nesting;
    ((PROCESS_CONTEXT *)SPEC_SF_PROCESS(*(PTR_DESCRIPTOR)spec_father_slot))->nesting = spec_help;

    DBUG_PRINT("MSG", ("entries for 0x%x: result 0x%x steps %d status 0x%x", spec_father_slot, SPEC_SF_FIRSTF(*(PTR_DESCRIPTOR)spec_father_slot), SPEC_SF_REDSTEPS(*(PTR_DESCRIPTOR)spec_father_slot), SPEC_SF_PSTATUS(*(PTR_DESCRIPTOR)spec_father_slot)));
    }
#endif

#endif /* D_SPEC */

      if (type == MT_NEW_GRAPH)
	{SET_STATIC_BORDER(highdesc);
	 DBUG_PRINT("STATHEAP",("new end of static heap: %08x",highdesc));
	 if (proc_id == 0)
	   PC_SET_PC(new_pid,R_COMB(*(T_PTD)D_READSTACK(PC_GET_H_STACK(new_pid)),ptc));
	 else
	   D_PPOPSTACK(D_S_hilf);}
      break;

 case MT_RESULT:

/*    fprintf(debugger, "0x%x: receiving MT_RESULT from 0x%x\n", curr_pid, src); fflush(debugger);      */

      /* initialize_fred_fish();   */

     DBUG_PRINT ("PVM", ("MT_RESULT processing..."));

#ifdef D_MESS_ONLY 
  m_type = "MT_RESULT";
#endif 

      rec_pid = (PROCESS_CONTEXT *)DO_RECEIVE();

      DBUG_PRINT("MSG", ("rec_pid = %x", rec_pid));

#ifdef D_MESS_ONLY
  f_pid = (int) rec_pid;
#endif

      DBUG_PRINT("MSG",("receiving result for process %x from %d",rec_pid,src));
      a_stack_addr = (STACKELEM *)DO_RECEIVE();
      DBUG_PRINT("MSG",("w_stack_addr: %x",a_stack_addr));
      h_stack_addr = (STACKELEM *)DO_RECEIVE();

#if (!D_SPEC)
      if (rec_pid == curr_pid)
	_redcnt -= DO_RECEIVE();
      else
	PC_SET_REDCNT(rec_pid,PC_GET_REDCNT(rec_pid) - DO_RECEIVE());

#else /* D_SPEC */
      spec_tmp3 = DO_RECEIVE(); /* this is the number of used red-steps */

      spec_flag = DO_RECEIVE(); /* this is 1 if it was a speculative result */
      spec_father_slot = DO_RECEIVE(); /* this is the slotnumber in the father's process context */

      DBUG_PRINT("MSG", ("spec_father_slot is 0x%x", spec_father_slot));

#if D_SPEC_TICKETS
      spec_help = ((PROCESS_CONTEXT *)SPEC_SF_PROCESS(*(PTR_DESCRIPTOR)spec_father_slot))->nesting;
      a_stack_addr = &((PROCESS_CONTEXT *)SPEC_SF_PROCESS(*(PTR_DESCRIPTOR)spec_father_slot))->nesting;
#endif

      spec_tmp2 = DO_RECEIVE(); /* this is the source pid, if it's spec */
      if (spec_flag>0)  { /* it's a result of a speculative process */

      DBUG_PRINT("MSG", ("analysing status information of son process: %x", spec_flag));
      if (T_S_WINNER(spec_flag)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_WINNER"));
        }
      if (T_S_NO_STEPS(spec_flag)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_NO_STEPS"));
        }
      if (T_S_FAIL(spec_flag)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_FAIL"));
        }
      if (T_S_NO_BSTEPS(spec_flag)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_NO_BSTEPS"));
        }
      if (T_S_GUARD(spec_flag)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_GUARD"));
        }
      if (T_S_GUARD_SON(spec_flag)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_GUARD_SON"));
        }
      if (T_S_INSYNC(spec_flag)==1) {
        DBUG_PRINT("MSG", ("flags... INSYNC"));
        }
      if (T_S_UNRED_GUARD(spec_flag)==1) {
        DBUG_PRINT("MSG", ("flags... SPEC_UNRED_GUARD"));
        }

/* fprintf(debugger, "receive: speculative process, T_WINNER %d, T_GRANDDAD %d\n", T_SPEC_WINNER(rec_pid), T_SPEC_GRANDDAD(rec_pid)); fflush(debugger);  */

#if D_SPEC_TICKETS
        DBUG_PRINT("MSG", ("receiving result for descriptor %x !", spec_father_slot));
#else
        DBUG_PRINT("MSG", ("receiving result for slot %d !", spec_father_slot));
#endif

#if D_SPEC_TICKETS
        DBUG_PRINT("MSG", ("counter for ALL results was %d", *(int*)SPEC_SF_ADDRCOUNT(*(PTR_DESCRIPTOR)spec_father_slot)));
        (*(int*)SPEC_SF_ADDRCOUNT(*(PTR_DESCRIPTOR)spec_father_slot))--;

/* fprintf(debugger, "0x%x: MESSAGE, COUNTER %x is now down to %d !\n", curr_pid, SPEC_SF_ADDRCOUNT(*(PTR_DESCRIPTOR)spec_father_slot), *(int*)SPEC_SF_ADDRCOUNT(*(PTR_DESCRIPTOR)spec_father_slot)); fflush(debugger); */

        DBUG_PRINT("MSG", ("counter for ALL results IS %d", *(int*)SPEC_SF_ADDRCOUNT(*(PTR_DESCRIPTOR)spec_father_slot)));
#else
        PC_SET_SPEC_SUM(rec_pid, PC_GET_SPEC_SUM(rec_pid)+1);

        DBUG_PRINT("MSG", ("results received: %d", PC_GET_SPEC_SUM(rec_pid)));
#endif

         /*  PC_SET_SPEC_FOLD(rec_pid); */ /* later ! If the process starts again ! */

/*          DBUG_PRINT("MSG", ("rec_pid: %x, rec_pid->son_status: %x", rec_pid, rec_pid->son_status)); */

#if D_SPEC_TICKETS
         SPEC_SF_PSTATUS(*(PTR_DESCRIPTOR)spec_father_slot) = spec_flag;
#else
         rec_pid->son_status[spec_father_slot] = spec_flag;
#endif

         DBUG_PRINT("MSG", ("status was stored... spec_flag is %x", spec_flag));

         if (T_S_GUARD_SON(spec_flag)==1) {

/* fprintf(debugger, "T_S_GUARD_SON set..., spec_tmp3=%d\n", spec_tmp3); fflush(debugger); */

           DBUG_PRINT("MSG", ("don't store reduction steps, GUARD_SON was set..., steps used: %d", spec_tmp3));
           if (spec_tmp3 != 0) {
             post_mortem("guard-terminated speculative process: redsteps ne 0 !"); }

           } else {
           DBUG_PRINT("MSG", ("store reduction steps..."));
#if D_SPEC_TICKETS
           SPEC_SF_REDSTEPS(*(PTR_DESCRIPTOR)spec_father_slot) = spec_tmp3;
#else
           rec_pid->son_redcnts[spec_father_slot] = spec_tmp3;
#endif
           }

         DBUG_PRINT("MSG", ("speculative \"result\": steps used=%d, status=%x, steps of the father=%d", spec_tmp3, spec_flag, rec_pid->red_count));

/*  fprintf (debugger, "receive: pid %x has %d steps left, %d were used by the son.\n", rec_pid, spec_tmp1, spec_tmp3); fflush(debugger);  */

        }
      else { /* THIS CODE IS COPIED FROM ABOVE */

/*  fprintf (debugger, "receive: pid %x is vital\n", rec_pid);  */

        if (rec_pid == curr_pid)
          _redcnt -= spec_tmp3;
        else
          PC_SET_REDCNT(rec_pid,PC_GET_REDCNT(rec_pid) - spec_tmp3);
        }
#endif /* D_SPEC */

#if ADV_SCHED
      if (!have_received_results) {
        have_received_results = init_tickets_cond = tickets_cond = 1;
        }
#endif /* ADV_SCHED */

      DBUG_PRINT("MSG", ("h_stack_addr %x, value %d", h_stack_addr, (*(int *)h_stack_addr)));

#if D_SPEC
      if (!spec_flag) {
        DBUG_PRINT("MSG", ("no speculative result..."));
#endif /* D_SPEC */

#if(!D_NN_SCHED)
      ticket_pool[src]++;
      ticket_pool_counter++;
#endif

/* fprintf(debugger, "no speculative result... wakeup...\n"); fflush(debugger); */

        DBUG_PRINT("MSG", ("rec_pid = %x, PC_STATUS(rec_pid) = %d, (PC_STATUS(rec_pid) == PS_WAITING) = %d", rec_pid, PC_STATUS(rec_pid), (PC_STATUS(rec_pid) == PS_WAITING)));
        
        if ((--(*(int *)h_stack_addr) == 0) && (PC_STATUS(rec_pid) == PS_WAITING))
#if (D_SLAVE && D_MESS && D_MSCHED)
          (*d_m_process_wakeup)(rec_pid);
#else
          process_wakeup(rec_pid);
#endif
#if D_SPEC
        } else {

#if D_SPEC_TICKETS
      spec_ticket_pool[src]++;
      spec_ticket_pool_counter++; 

/* fprintf(debugger, "0x%x: *RECEIVE* src: %d, spec_ticket_pool[src]: %d, spec_ticket_pool_counter: %d\n", curr_pid, src, spec_ticket_pool[src], spec_ticket_pool_counter);  */
/* fprintf(debugger, "0x%x: *RECEIVE* spec_ticket_pool[0] = %d, spec_ticket_pool[1] = %d, spec_ticket_pool[2] = %d, spec_ticket_pool[3] = %d\n", curr_pid, spec_ticket_pool[0], spec_ticket_pool[1], spec_ticket_pool[2], spec_ticket_pool[3]); fflush(debugger); */

      spec_control[0] = query_postpone();
      if (spec_control[0] != NULL) {
        DBUG_PRINT("MSG", ("ticket returned, some postponed expressions found..."));
        spec_sched_status = 11; /* post-process */
        }

      if (*(int*)SPEC_SF_ADDRCOUNT(*(PTR_DESCRIPTOR)spec_father_slot) == 0) {
        DBUG_PRINT("MSG", ("all speculative results have been gathered !"));

/* fprintf(debugger, "0x%x: MESSAGE, waking up suspended process, counter is down to 0.\n", curr_pid); fflush(debugger); */
         
        /* wake up the corresponding process */

#if (D_SLAVE && D_MESS && D_MSCHED)
          (*d_m_process_wakeup)(rec_pid);
#else
          process_wakeup(rec_pid);
#endif

        PC_CLEAR_SPEC_WAIT_WIN(rec_pid); /* clear GOON block */

        /* copy address of where to continue into the process context */

        rec_pid->pc = SPEC_SF_ASMMKNC(*(PTR_DESCRIPTOR)spec_father_slot);
        }

#else

        /* check here whether all results has been collected ! */
 
        DBUG_PRINT("MSG", ("SUM is %d, SPAWNED is %d", PC_GET_SPEC_SUM(rec_pid), PC_GET_SPEC_SPAWNED(rec_pid)));

        if (PC_GET_SPEC_SUM(rec_pid) == PC_GET_SPEC_SPAWNED(rec_pid)) {
          DBUG_PRINT("MSG", ("ALL results have been gathered ! Restart process !"));

#if (D_SLAVE && D_MESS && D_MSCHED)
          (*d_m_process_wakeup)(rec_pid);
#else
          process_wakeup(rec_pid);
#endif

          }
#endif /* D_SPEC_TICKETS */

        }
#endif /* D_SPEC */
 
      D_PUSHSTACK(D_S_hilf,ST_END_MARKER);
      D_PUSHSTACK(D_S_hilf,(int)a_stack_addr << 1);

#if ADV_SCHED

      /* check for suspend conditions */
      if (tickets_cond && curr_pid && ready_queue_first && (ticket_pool_counter >= 2)) {   
                                        /* restricted ticket handling is enabled */
                                        /* and there's a process running */
        jc=0;
        for (ic=0;ic<1<<cube_dim;ic++) {
          if (ticket_pool[ic]>0)
            jc++;
          if (jc >= 2)
            continue;
          } 
        /* setting sig_interrupt might be useless, but to be sure, let's set ;-) */
        sig_interrupt = sig_suspend = (jc >= 2) ? 1 : 0;

/*     fprintf (stderr, "insgesamt: %d, sig_suspend: %d\n", jc, sig_suspend); fflush(stderr); */

#if D_MESS
    /* counting the activation of white processes 'cause of another suspended process */
    if (sig_suspend) no_suspended++;
#endif /* D_MESS */
        }
#endif /* ADV_SCHED */
      goto receive_loop;

    case MT_NEW_GRAPH:

/*  fprintf(debugger, "0x%x: receiving MT_NEW_GRAPH from 0x%x\n", curr_pid, src); fflush(debugger);     */

     DBUG_PRINT ("PVM", ("MT_NEW_GRAPH processing..."));

#ifdef D_MESS_ONLY 
  m_type = "MT_NEW_GRAPH";
#endif 

      new_redcnt = DO_RECEIVE();

#if D_SPEC
      real_start_redcount = new_redcnt;
#endif

      if (proc_id==0)
	{
#if D_SPEC /* set global spec_variable to zero */
         spec_global = 0;
#endif

#if (D_SLAVE && D_MESS && D_MSCHED)
         new_pid = (*d_m_process_create)(0,-1,new_redcnt);
#else
         new_pid = process_create(0,-1,new_redcnt);
#endif

#if ADV_SCHED
         new_pid->start_letpar_level = 0;
         new_pid->letpar_level = 0;
         DBUG_PRINT ("ADV_SCHED", ("Initializing letpar_levels (0,0)..."));
#endif /* ADV_SCHED */

#if D_MESS_ONLY
         f_pid = (int) new_pid;
#endif

	 D_PUSHSTACK(PC_GET_H_STACK(new_pid),ST_DUMMY);
	 h_stack_addr = (STACKELEM *)D_TOP_ADDRESS(PC_GET_H_STACK(new_pid));}
      else
	{D_PUSHSTACK(D_S_hilf,ST_DUMMY);
	 h_stack_addr = (STACKELEM *)D_TOP_ADDRESS(D_S_hilf);}
      D_PUSHSTACK(D_S_hilf,ST_END_MARKER);
      D_PUSHSTACK(D_S_hilf,(int)h_stack_addr << 1);
      goto receive_loop;

 case MT_PARAM:

/*   fprintf(debugger, "0x%x: receiving MT_PARAM from 0x%x\n", curr_pid, src); fflush(debugger);   */

DBUG_PRINT ("PVM", ("MT_PARAM processing..."));

#if D_MESS
#if nCUBE
     sigaction (SIGMSGS,&act,NULL);   /* reinstall signal handler ... */
#endif
     sig_msg_flag = 0;
#if (ADV_SCHED || D_SPEC)
     sig_interrupt = 0;
#endif
#if ADV_SCHED
     have_received_results = 0;
     init_tickets_cond = 0;
     tickets_cond = 0;
#endif /* ADV_SCHED */
     m_curr_pid = -1;
#endif

#ifdef D_MESS_ONLY 
  m_type = "MT_PARAM";
#endif 

  _prec_mult        = DO_RECEIVE();
  _prec             = DO_RECEIVE();
  _prec10           = DO_RECEIVE();
  _formated         = DO_RECEIVE();
  LazyLists         = DO_RECEIVE();
  _digit_recycling  = DO_RECEIVE();
  _beta_count_only  = DO_RECEIVE();
  _trunc            = DO_RECEIVE();
  _count_reductions = DO_RECEIVE();
  _maxnum           = DO_RECEIVE();
  _base             = DO_RECEIVE();
  hs                = DO_RECEIVE();
  hd                = DO_RECEIVE();
  ss                = DO_RECEIVE();
  stack_seg_size    = DO_RECEIVE();
  d_sort_in         = DO_RECEIVE();

#if D_SPEC
  ack_red_count = DO_RECEIVE();
  max_spec_sons = DO_RECEIVE();
  max_spec_procs = DO_RECEIVE();
  spec_failcase = DO_RECEIVE();
  spec_multi_results = DO_RECEIVE();
  spec_mspecial = DO_RECEIVE();
  spec_kill_no_steps = DO_RECEIVE();
  spec_nondet = DO_RECEIVE();
  nospecnr = DO_RECEIVE();
  spec_retrans = DO_RECEIVE();
#endif /* D_SPEC */
   
#if D_MESS
      m_ackno           = DO_RECEIVE();
      m_merge_strat     = DO_RECEIVE();
      d_bib_mask        = DO_RECEIVE();
      DBUG_PRINT ("MSG", ("received real bitmask: %x", d_bib_mask));
#if nCUBE
      strcpy((char *)m_mesfilehea, (char *)buffer_p);
      strcpy(m_mesfilepath, ((char *)buffer_p)+strlen(m_mesfilehea)+1);
      buffer_p += ((int)(strlen(m_mesfilehea)+strlen(m_mesfilepath)+2)/(int)4)+1;
#endif
#if D_PVM
      pvm_upkstr(m_mesfilehea); 
      pvm_upkstr(m_mesfilepath); 
#endif
      DBUG_PRINT("MSG", ("m_mesfilehea: %s, strlen: %d, m_mesfilepath: %s, strlen: %d, int's: %d", m_mesfilehea, strlen(m_mesfilehea), \
m_mesfilepath, strlen(m_mesfilepath), ((int)(strlen(m_mesfilehea)+strlen(m_mesfilepath)+2)/(int)4)+1)); 

      d_init_mess(proc_id);
#endif

#if D_PVM
      DBUG_PRINT ("PVM", ("PARAMs received..."));
#endif  /* D_PVM */

      InitHeapManagement(hs,hd);
      alloc_stack_memory(ss);
      init_d_stack(&D_S_hilf);
      strcpy(D_S_hilf.name,"hilf");
      lookup_next = first_lookup;

#if D_SPEC_TICKETS
      spec_lookup_next = spec_first_lookup;
      DBUG_PRINT("MSG", ("spec_lookup_next set to %d", spec_lookup_next));
#endif

#if D_MESS

#if D_SPEC
#if (D_PVM && !D_PVM_NCUBE)
#if D_SPEC_TICKETS
      MPRINT_SPECIAL(D_MESS_FILE, M_TIMER, PROCESS_NR, -1, (spec_mspecial == 0) ? proc_tab_size+spec_proc_tab_size : proc_tab_size+spec_mspecial, m_base);
#else
      MPRINT_SPECIAL(D_MESS_FILE, M_TIMER, PROCESS_NR, -1, (spec_mspecial == 0) ? proc_tab_size : spec_mspecial, m_base);
#endif
#else
#if D_SPEC_TICKETS
      MPRINT_SPECIAL(D_MESS_FILE, 0.0, PROCESS_NR, -1, (spec_mspecial == 0) ? proc_tab_size+spec_proc_tab_size : proc_tab_size+spec_mspecial, m_base);
#else
      MPRINT_SPECIAL(D_MESS_FILE, 0.0, PROCESS_NR, -1, (spec_mspecial == 0) ? proc_tab_size : spec_mspecial, m_base);
#endif
#endif /* D_PVM */

#else /* D_SPEC */

#if (D_PVM && !D_PVM_NCUBE)
      MPRINT_SPECIAL(D_MESS_FILE, M_TIMER, PROCESS_NR, -1, proc_tab_size, m_base);
#else
      MPRINT_SPECIAL(D_MESS_FILE, 0.0, PROCESS_NR, -1, proc_tab_size, m_base);
#endif /* D_PVM */

#endif /* D_SPEC */

/* #if D_MHEAP  leave this out for measurements check */

      if (d_bib_mask & (1 << MINDEX_HEAP_ALLOC)) {
        DBUG_PRINT ("MSG", ("HEAP_ALLOC measure initiated"));
#if (!D_MHEAP) 
        D_MESS_DISABLED("heap");
#endif
        d_m_newheap = m_newheap; }
      else 
        d_m_newheap = newheap;

      if (d_bib_mask & (1 << MINDEX_HEAP_FREE)) {
        DBUG_PRINT ("MSG", ("HEAP_FREE measure initiated"));
#if (!D_MHEAP) 
        D_MESS_DISABLED("heap");
#endif
        d_m_freeheap = m_freeheap; }
      else
        d_m_freeheap = freeheap;

      if (d_bib_mask & (1 << MINDEX_HEAP_COMPACT)) {
        DBUG_PRINT ("MSG", ("HEAP_COMPACT measure initiated"));
#if (!D_MHEAP) 
        D_MESS_DISABLED("heap");
#endif
        d_m_compheap = m_compheap; }
      else
        d_m_compheap = compheap;

      if (d_bib_mask & (1 << MINDEX_DESC_ALLOC)) {
        DBUG_PRINT ("MSG", ("DESC_ALLOC measure initiated"));
#if (!D_MHEAP) 
        D_MESS_DISABLED("heap");
#endif
        d_m_newdesc = m_newdesc; }
      else
        d_m_newdesc = newdesc;

      if (d_bib_mask & (1 << MINDEX_DESC_FREE)) {
        DBUG_PRINT ("MSG", ("DESC_FREE measure initiated"));
#if (!D_MHEAP) 
        D_MESS_DISABLED("heap");
#endif
        d_m_freedesc = m_freedesc; }
      else
        d_m_freedesc = freedesc;

/* #endif  D_MHEAP */ 

/* #if D_MSTACK */

      if (d_bib_mask & (1 << MINDEX_STACK_SEG_ALLOC)) {
        DBUG_PRINT ("MSG", ("STACK SEG ALLOC measure initiated"));
#if (!D_MSTACK)
        D_MESS_DISABLED("stack");
#endif
        d_m_allocate_d_stack_segment = m_allocate_d_stack_segment; }
      else
        d_m_allocate_d_stack_segment = allocate_d_stack_segment;

      if (d_bib_mask & (1 << MINDEX_STACK_SEG_FREE)) {
        DBUG_PRINT ("MSG", ("STACK SEG FREE measure initiated"));
#if (!D_MSTACK)
        D_MESS_DISABLED("stack");
#endif
        d_m_free_d_stack_segment = m_free_d_stack_segment; }
      else
        d_m_free_d_stack_segment = free_d_stack_segment;

      if (d_bib_mask & (1 << MINDEX_STACK_PUSH)) {
        DBUG_PRINT ("MSG", ("STACK PUSH measure initiated"));
#if (!D_MSTACK)
        D_MESS_DISABLED("stack");
#endif
        d_m_stack_push = m_stack_push; }
      else
        d_m_stack_push = 0;
 
      if (d_bib_mask & (1 << MINDEX_STACK_POP)) {
        DBUG_PRINT ("MSG", ("STACK POP measure initiated"));
#if (!D_MSTACK)
        D_MESS_DISABLED("stack");
#endif
        d_m_stack_pop = m_stack_pop; }
      else
        d_m_stack_pop = 0;

/* #endif D_MSTACK */

/* #if D_MSCHED */

      if (d_bib_mask & (1 << MINDEX_PROC_DIST)) {
        DBUG_PRINT ("MSG", ("PROC DIST measure enabled !"));
#if (!D_MSCHED)
        D_MESS_DISABLED("scheduler");
#endif
        d_m_distribute = m_distribute; }
      else
        d_m_distribute = distribute;

      if (d_bib_mask & (1 << MINDEX_PROC_CREATE)) {
        DBUG_PRINT ("MSG", ("PROC CREATE measure enabled !"));
#if (!D_MSCHED)
        D_MESS_DISABLED("scheduler");
#endif
        d_m_process_create = m_process_create; }
      else
        d_m_process_create = process_create;

      if (d_bib_mask & (1 << MINDEX_PROC_TERMINATE)) {
        DBUG_PRINT ("MSG", ("PROC TERMINATE measure enabled !"));
#if (!D_MSCHED)
        D_MESS_DISABLED("scheduler");
#endif
        d_m_process_terminate = m_process_terminate; }
      else
        d_m_process_terminate = process_terminate;

      if (d_bib_mask & (1 << MINDEX_PROC_SLEEP)) {
        DBUG_PRINT ("MSG", ("PROC SLEEP measure enabled !"));
#if (!D_MSCHED)
        D_MESS_DISABLED("scheduler");
#endif
        d_m_process_sleep = m_process_sleep; }
      else
        d_m_process_sleep = process_sleep;

      if (d_bib_mask & (1 << MINDEX_PROC_RUN)) {
        DBUG_PRINT ("MSG", ("PROC RUN measure enabled !"));
#if (!D_MSCHED)
        D_MESS_DISABLED("scheduler");
#endif
        d_m_process_run = m_process_run; }
      else
        d_m_process_run = process_run; 

      if (d_bib_mask & (1 << MINDEX_PROC_WAKEUP)) {
        DBUG_PRINT ("MSG", ("PROC WAKEUP measure enabled !"));
#if (!D_MSCHED)
        D_MESS_DISABLED("scheduler");
#endif
        d_m_process_wakeup = m_process_wakeup; }
      else
        d_m_process_wakeup = process_wakeup; 

/* #endif  D_MSCHED */

/* #if D_MCOMMU */
 
      d_m_msg_send = msg_send;
      d_m_msg_receive = msg_receive;

      if (d_bib_mask & (1 << MINDEX_SEND_BEGIN)) {
        DBUG_PRINT ("MSG", ("SEND BEGIN measure enabled !"));
#if (!D_MCOMMU)
        D_MESS_DISABLED("communication");
#endif
        d_m_msg_send = m_msg_send; 
        m_msg_send_begin = 1; }
      else
        m_msg_send_begin = 0;

      if (d_bib_mask & (1 << MINDEX_SEND_END)) {
        DBUG_PRINT ("MSG", ("SEND END measure enabled !"));
#if (!D_MCOMMU)
        D_MESS_DISABLED("communication");
#endif
        d_m_msg_send = m_msg_send; 
        m_msg_send_end = 1; }
      else
        m_msg_send_end = 0;

      if (d_bib_mask & (1 << MINDEX_RECEIVE_BEGIN)) {
        DBUG_PRINT ("MSG", ("RECEIVE BEGIN measure enabled !"));
#if (!D_MCOMMU)
        D_MESS_DISABLED("communication");
#endif
        d_m_msg_receive = m_msg_receive; 
        m_msg_receive_begin = 1; }
      else
        m_msg_receive_begin = 0;

      if (d_bib_mask & (1 << MINDEX_RECEIVE_END)) {
        DBUG_PRINT ("MSG", ("RECEIVE END measure enabled !"));
#if (!D_MCOMMU)
        D_MESS_DISABLED("communication");
#endif
        d_m_msg_receive = m_msg_receive; 
        m_msg_receive_end = 1; }
      else
        m_msg_receive_end = 0;

/* #endif  D_MCOMMU */ 

#endif

      if (DO_RECEIVE() != END_MARKER) {
        DBUG_PRINT ("MSG", ("END_MARKER expected but not found..."));
        post_mortem("* END_MARKER expected but not found...");
	/* error !!! */;}


      break;

#if D_MESS
    case MT_CLOSE_MEASURE:

/*******************************/

initialize_fred_fish();


/*  fprintf(debugger, "receiving MT_CLOSE_MEASURE\n"); fflush(debugger);  */

      DBUG_PRINT ("MSG", ("Receiving MT_CLOSE_MEASURE !"));

      /* switch off signal handler */

#if (nCUBE || D_PVM_NCUBE)
      if (!m_merge_strat)
        sigaction (SIGMSGS,NULL,NULL);
#endif

      /* close measure file */

      if (fclose (d_mess_dat) == EOF)
        fprintf(stderr, "node %d: warning, cannot close measure file\n\n", proc_id);
 
      /* turn off all measure operations */

      d_m_newheap = newheap;
      d_m_freeheap = freeheap;
      d_m_compheap = compheap;
      d_m_newdesc = newdesc;
      d_m_freedesc = freedesc;
      d_m_allocate_d_stack_segment = allocate_d_stack_segment;
      d_m_free_d_stack_segment = free_d_stack_segment;
      d_m_stack_push = 0;
      d_m_stack_pop = 0;
      d_m_distribute = distribute;
      d_m_process_create = process_create;
      d_m_process_terminate = process_terminate;
      d_m_process_sleep = process_sleep;
      d_m_process_run = process_run;
      d_m_process_wakeup = process_wakeup;
      d_m_msg_send = msg_send;
      d_m_msg_receive = msg_receive;
      m_msg_send_begin = 0;
      m_msg_send_end = 0;
      m_msg_receive_begin = 0;
      m_msg_receive_end = 0;

      sleep(1);    /* wait for one second */

      if (proc_id == 0) {       /* i am no 0 ! */
        k = 0;
        for (i = 0; i < (1 << cube_dim); i++) {
          sprintf (name_line, "%s%s_uid%ld_%i", m_mesfilepath, m_mesfilehea, getuid(), i);         
          if (stat(name_line, &stbuf) == -1)
            fprintf(stderr, "node %d: warning, cannot access measurement file %d !\n", proc_id, i);
          DBUG_PRINT ("MERGE", ("length of file %d: %ld", i, stbuf.st_size));
          if ((int) stbuf.st_size == 0)
            fprintf (stderr, "node %d: warning, file %d empty !\n\n", proc_id, i);
          k = k + (int) stbuf.st_size; }
        DBUG_PRINT ("MERGE", ("total length: %d", k));
#if nCUBE
        nwrite(&k, 4, host, MT_CLOSE_MEASURE, &flags); 
#endif
#if D_PVM
        pvm_initsend(pvmcoding);
        pvm_pkint(&k, 1, 1);
        pvm_send(host, MT_CLOSE_MEASURE);
#endif
        }

      DBUG_PRINT ("MSG", ("measure file closed and measure actions terminated."));

      break;

    case MT_REMOTE_MEASURE:
      DBUG_PRINT ("MSG", ("Receiving MT_REMOTE_MEASURE !"));

      /* copy measure file nr to host */

#if nCUBE
      m_super_nr = *((int *)buffer);
#endif
#if D_PVM
      pvm_upkint(&m_super_nr, 1, 1);
      pvm_upkstr(m_remote_host);
      pvm_upkstr(m_remote_dir);

      DBUG_PRINT("S_MERGE", ("copying measurement file to host %s", m_remote_host));
#else
 
      DBUG_PRINT ("S_MERGE", ("copying measurement file no %d", m_super_nr));
#endif

      sprintf (d_mess_name, "%s%s_uid%ld_%i", m_mesfilepath, m_mesfilehea, getuid(), m_super_nr);
      sprintf (m_super_name, "/tmp/%s_uid%ld_%i", m_mesfilehea, getuid(), m_super_nr);

      DBUG_PRINT("S_MERGE", ("filenames:  %s to %s", d_mess_name, m_super_name));

#if (D_PVM && !D_PVM_NCUBE)
      sprintf (m_line,"rcp %s %s:%s", d_mess_name, m_remote_host, m_remote_dir );
      DBUG_PRINT ("S_MERGE", ("executing the command: %s", m_line));

      if (system(m_line) != 0)
        DBUG_PRINT("S_MERGE", ("couldn't execute the command ! :-("));
      
#else
      if ((m_super_file1 = fopen(d_mess_name, "r")) == NULL)
        fprintf (stderr, "node %d: warning, cannot open measurement file for reading\n\n", proc_id);
      if ((m_super_file2 = fopen(m_super_name, "w")) == NULL)
        fprintf (stderr, "node %d: warning, cannot open host measurement node file for writing\n\n", proc_id);

      while (!feof(m_super_file1)) {
        m_super_counter = fread (&m_super_buffer, 1, 4096, m_super_file1);
        fwrite (&m_super_buffer, 1, m_super_counter, m_super_file2);
        }

/* HAHAHAHAH great Code
      while ((m_super_c = fgetc(m_super_file1)) != EOF)
        fputc(m_super_c, m_super_file2); */
  
      if (fclose(m_super_file1) == EOF)
        fprintf (stderr, "node %d: warning, cannot close measurement file\n\n", proc_id);
      if (fclose(m_super_file2) == EOF)
        fprintf (stderr, "node %d: warning, cannot close measurement node file\n\n", proc_id);
#endif /* D_PVM */

#if nCUBE
      nwrite (&m_super_nr, 0, host, MT_CLOSE_MEASURE, &flags);
#endif
#if D_PVM
      pvm_initsend(pvmcoding);
      pvm_send(host, MT_CLOSE_MEASURE);
#endif

      break;

    case MT_OPEN_MEASURE:
      DBUG_PRINT ("MSG", ("Receiving MT_OPEN_MEASURE !"));

#ifndef M_OLD_MERGING
#if !D_PVM
      m_start_merge (buffer_p);
#endif

      break; 

/****** old merging *****/

#else

      if (fclose (d_mess_dat) == EOF)
        fprintf (stderr, "node %d: warning, cannot close measure file\n\n", proc_id);

      if ((d_mess_dat = fopen (d_mess_name, "r")) == NULL)
        fprintf (stderr, "node %d: warning, cannot open measure file\n\n", proc_id);

      i = 0;
      if (fgets(mess_line, 120, d_mess_dat) == NULL) {
        DBUG_PRINT ("MSG", ("Messdatei schon hier leer !"));

/* fprintf (stderr, "Prozessor %d meldet: Messdatei leer !\n", proc_id);
fflush (stderr); */

        if (fclose (d_mess_dat) == EOF)
           fprintf (stderr, "node %d: warning, cannot close measure file\n\n", proc_id);

        /* now open File again for more reductions !!!!! */
        if ((d_mess_dat = fopen (d_mess_name, "w")) == NULL)
          fprintf (stderr, "node %d: warning, cannot open measure file\n\n", proc_id);

        d_mess_buff[0] = '\n';
        d_mess_buff[1] = '\0';
        i = 2;
        }
      else {              /* now read measure-file until the buffer is full */
        DBUG_PRINT ("MSG", ("Hiho, hir bin ich..."));

        while ((i + (k = strlen(mess_line))) < (D_MESS_MAXBUF - 4)) {  /* space left for delimiters */ 
          DBUG_PRINT ("MSG", ("Reading: %s; i = %d; k = %d", mess_line, i, k));
          memcpy(d_mess_buff+i, mess_line, k);
          i += k;
          d_mess_buff[i] = '\0';

          if (fgets(mess_line, 120, d_mess_dat) == NULL) {
            DBUG_PRINT ("MSG", ("Messdatei leer !"));

/* fprintf (stderr, "Prozessor %d meldet: Messdatei leer !\n", proc_id);
fflush (stderr); */

            if (fclose (d_mess_dat) == EOF)
               fprintf (stderr, "node %d: warning, cannot close measure file\n\n", proc_id);

            /* now open File again for more reductions !!!!! */
            if ((d_mess_dat = fopen (d_mess_name, "w")) == NULL)
              fprintf (stderr, "node %d: warning, cannot open measure file\n\n", proc_id);

            d_mess_buff[i++] = '\n';
            d_mess_buff[i++] = '\0';
            break;
            }
          }
        }
      
      d_mess_buff[i++] = '\0';

      DBUG_PRINT ("MSG", ("Sending %d Bytes !, strlen: %d ", i, strlen(d_mess_buff)));

      nwrite (d_mess_buff, i, host, MT_SEND_MEASURE, &flags);  

      DBUG_PRINT ("MSG", ("Hab MT_SEND_MEASURE weggesendet !"));

/*
      fprintf (stderr, "Prozessor %d sendet auf ein MT_OPEN_MEASURE hin %d Bytes !\n", proc_id, strlen(d_mess_buff));
      fflush (stderr); */

#endif /* M_OLD_MERGING */

      break;

/**************** end of old merging ************/

    case MT_SEND_MEASURE:
      DBUG_PRINT ("MSG", ("Receiving MT_SEND_MEASURE !"));
      
#ifdef M_OLD_MERGING

/************** OLD MERGING **************/    /* for ASCII only ! */

      i = 0;
      k = strlen (mess_line);
      memcpy(d_mess_buff, mess_line, k);
      i += k;

      if (fgets(mess_line, 120, d_mess_dat) == NULL) {
        DBUG_PRINT ("MSG", ("Messdatei leer !"));

/* fprintf (stderr, "Prozessor %d meldet: Messdatei leer !\n", proc_id);
fflush (stderr); */

        if (fclose (d_mess_dat) == EOF)
           fprintf(stderr, "node %d: warning, cannot close measure file\n\n", proc_id);

        /* now open File again for more reductions !!!!! */
        if ((d_mess_dat = fopen (d_mess_name, "w")) == NULL)
          fprintf (stderr, "node %d: warning, cannot open measure file\n\n", proc_id);

        d_mess_buff[0] = '\n';
        d_mess_buff[1] = '\0';
        i = 2;
        }
      else {              /* now read measure-file until the buffer is full */
        i = 0;
        while ((i + (k = strlen(mess_line))) < (D_MESS_MAXBUF - 4)) {  /* space left for del
imiters */ 
          memcpy(d_mess_buff+i, mess_line, k); 
          i += k;
          if (fgets(mess_line, 120, d_mess_dat) == NULL) {
            DBUG_PRINT ("MSG", ("Messdatei leer !"));

/* fprintf (stderr, "Prozessor %d meldet: Messdatei leer !\n", proc_id);
fflush (stderr); */

            if (fclose (d_mess_dat) == EOF)
              fprintf(stderr, "node %d: warning, cannot close measure file\n\n", proc_id);

            /* now open File again for more reductions !!!!! */
            if ((d_mess_dat = fopen (d_mess_name, "w")) == NULL)
              fprintf (stderr, "node %d: warning, cannot open measure file\n\n", proc_id);

            d_mess_buff[i] = '\n';
            d_mess_buff[i+1] = '\0';
            i += 2;
            break;
            }
          }
        }
       
      d_mess_buff[i++] = '\0';

      DBUG_PRINT ("MSG", ("Sending %d Bytes !, strlen: %d ", i, strlen(d_mess_buff)));

      nwrite (d_mess_buff, i, host, MT_SEND_MEASURE, &flags);

      DBUG_PRINT ("MSG", ("Hab MT_SEND_MEASURE weggesendet !"));

/*     fprintf (stderr, "Prozessor %d sendet auf ein MT_SEND_MEASURE hin %d Bytes !\n", proc_id, strlen(d_mess_buff));
     fflush (stderr); */

#endif /* M_OLD_MERGING */

/****************** end of old merging ******************/

      break;
#endif
    }                                                                   /* switch (type) */

/*  fprintf(debugger, "**** leaving msg_receive, having received %s from %d,%x for %x\n", m_type, src, m_pid, f_pid); fflush(debugger); */

#ifdef D_MESS_ONLY
#if (D_SLAVE && D_MESS && D_MCOMMU)
  if (m_msg_receive_end)
    MPRINT_RECEIVE_END(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID, m_type, src, m_pid, m_size, f_pid);
#endif
#endif

 DBUG_VOID_RETURN;
}

#ifndef D_MESS_ONLY

/***************************************************************/
/*                                                             */
/* msg_check()    checks for incoming messages and calls       */
/*                msg_receive if a message has arrived         */
/*                                                             */
/* called by:  scheduler or signal handler                     */
/*                                                             */
/***************************************************************/

void msg_check()
{
int source=-1;
int type=-1;
/*dmk*/ int erg=0;

 DBUG_ENTER ("msg_check");

#if nCUBE
 /*DBUG_PRINT("MSG_CHECK", ("ntest result: %d", ntest(&source,&type)));*/
 source=type=-1;
 while ((erg = ntest(&source,&type))>=0)
#endif /* nCUBE */

#if D_PVM
 while ((erg = pvm_probe (-1, -1))>0)
#endif /* D_PVM */
   {
#ifdef D_NN_SCHED
     DBUG_PRINT("NN",("msg_check - erg : %d / type : %d " , erg, type));
     if (type == MT_STAT_REQ) {
       proc_org=-1;
       nn_msg_receive(MT_STAT_REQ);
       nn_msg_send(proc_org, MT_STAT_SEND);
     } else if (type == MT_STAT_SEND) {
       nn_msg_receive(MT_STAT_SEND);
     } else {
#endif
#if (D_SLAVE && D_MESS && D_MCOMMU)
        (*d_m_msg_receive)();
#else
        msg_receive();
#endif
#if D_SPEC
  if (spec_sched_status > 0) {
   speculative_scheduler();
   }
#endif /* D_SPEC */
#ifdef D_NN_SCHED
    }
#endif
    source=type=-1;
   } /* of while */
 sig_msg_flag = 0;
 DBUG_VOID_RETURN;
}

/***************************************************************/
/*                                                             */
/* flush_queue()    waits until a message of type MT_PARAM is  */
/*                  received; dismisses any other incoming     */
/*                  message                                    */
/*                                                             */
/*   callled in case of post_mortem                            */
/*                                                             */
/***************************************************************/

void flush_queue()
{char *buffer;
#if D_PVM
 int pvm_bufid;
 int pvm_length;
#endif /* D_PVM */
 int src,type,flags;

 DBUG_ENTER("flush_queue");

 for(;;)
   {do
      src = type = -1;
#if nCUBE
    while (ntest(&src,&type) < 0);
#endif /* nCUBE */

#if D_PVM
    while ((pvm_bufid = pvm_probe (-1, -1)) > 0);
    pvm_bufinfo (pvm_bufid, &pvm_length, &type, &src);
#endif /* D_PVM */
    
    if ((type == MT_PARAM) || (type == MT_TERMINATE))
      {sig_msg_flag = 1;
       DBUG_VOID_RETURN;}
    
#if nCUBE
    nreadp(&buffer,MESSAGE_SIZE * sizeof(int),&src,&type,&flags);

/* fprintf(debugger, "Gebe buffer frei: %x (flush_queue) !\n", buffer); fflush(debugger); */

    nrelp(buffer);
#endif /* nCUBE */
 }
}

#endif /* D_MESS_ONLY */
@


1.61
log
@bugfixed version for SPEC_TICKETS + some more features
@
text
@d2 3
d521 1
a521 1
/*  fprintf(debugger, "0x%x: sending MT_NCUBE_READY, MT_ABORT to 0x%x\n", curr_pid, dest); fflush(debugger);    */
d560 1
a560 1
/* fprintf(debugger, "0x%x: sending MT_POST_MORTEM to 0x%x\n", curr_pid, dest); fflush(debugger);    */
d577 1
a577 1
/* fprintf(debugger, "0x%x: sending MT_NCUBE_FAILED to 0x%x\n", curr_pid, dest); fflush(debugger);     */
d645 1
a645 1
/* fprintf(debugger, "0x%x: sending %s message to (0x%x,0x%x) from 0x%x\n",curr_pid, m_type, spec_control[1], dest, m_curr_pid); fflush(debugger);   */
d647 1
a647 1
/* #ifdef D_MESS_ONLY */ /*************** DELETE */
d696 1
a696 1
/*  fprintf(debugger, "0x%x: sending MT_NEW_PROCESS to 0x%x\n", curr_pid, dest); fflush(debugger);      */
d1349 1
a1349 1
/* fprintf(debugger, "0x%x: sending MT_RESULT to pid 0x%x on node %d\n", curr_pid, (int) PC_GET_PPID(curr_pid), dest); fflush(debugger);     */
d1434 1
a1434 1
/*   fprintf(debugger, "0x%x: sending MT_END_RESULT to 0x%x\n", curr_pid, dest); fflush(debugger);   */
d1705 1
a1705 1
/*  fprintf(debugger, "0x%x: receiving HEREAMI from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);    */
d1726 1
a1726 1
/*  fprintf(debugger, "0x%x: receiving SPECMSG_ACK from (0x%x, 0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);   */
d1810 1
a1810 1
/* fprintf(debugger, "0x%x: receiving BARR from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);  */
d1868 1
a1868 1
/* fprintf(debugger, "0x%x: receiving START from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[4], src, spec_control[1]); fflush(debugger);  */
d1913 1
a1913 1
/*fprintf(debugger, "0x%x: receiving VITAL from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);  */
d1942 1
a1942 1
/* fprintf(debugger, "0x%x: receiving MT_TERMINATE from 0x%x\n", curr_pid, src); fflush(debugger);   */
d1952 1
a1952 1
/* fprintf(debugger, "0x%x: receiving MT_NEW_PROCESS from 0x%x\n", curr_pid, src); fflush(debugger);    */
d2777 1
a2777 1
/*   fprintf(debugger, "0x%x: receiving MT_RESULT from 0x%x\n", curr_pid, src); fflush(debugger);      */
d3030 1
a3030 1
/* fprintf(debugger, "0x%x: receiving MT_NEW_GRAPH from 0x%x\n", curr_pid, src); fflush(debugger);     */
d3077 1
a3077 1
/*  fprintf(debugger, "0x%x: receiving MT_PARAM from 0x%x\n", curr_pid, src); fflush(debugger);   */
@


1.60
log
@first version supporting speculative evaluations with TICKETS
@
text
@d2 3
d210 2
d557 1
a557 1
/* fprintf(debugger, "0x%x: sending MT_POST_MORTEM to 0x%x\n", curr_pid, dest); fflush(debugger);     */
d693 1
a693 1
/* fprintf(debugger, "0x%x: sending MT_NEW_PROCESS to 0x%x\n", curr_pid, dest); fflush(debugger);     */
d1346 1
a1346 1
/* fprintf(debugger, "0x%x: sending MT_RESULT to pid 0x%x on node 0x%x\n", curr_pid, (int) PC_GET_PPID(curr_pid), dest); fflush(debugger);    */
d1431 1
a1431 1
/*  fprintf(debugger, "0x%x: sending MT_END_RESULT to 0x%x\n", curr_pid, dest); fflush(debugger);   */
d1660 1
a1660 1
/*    fprintf(debugger, "receiving MT_ABORT\n"); fflush(debugger);   */
d1702 1
a1702 1
/* fprintf(debugger, "0x%x: receiving HEREAMI from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);    */
d1723 1
a1723 1
/* fprintf(debugger, "0x%x: receiving SPECMSG_ACK from (0x%x, 0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);   */
d1775 1
a1775 1
/*fprintf(debugger, "0x%x: ACK; registering pid 0x%x of node %d as number %d\n", curr_pid, heap_counter, param_counter, spec_tmp1->control->leaves+spec_tmp3); fflush(debugger);*/
d1791 2
d1807 1
a1807 1
/*fprintf(debugger, "0x%x: receiving BARR from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);  */
d1881 1
a1881 1
/*fprintf(debugger, "0x%x: receiving TERM from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);  */
d1895 1
a1895 1
/*fprintf(debugger, "0x%x: receiving FAIL from (0x%x,0x%d) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);  */
d1949 1
a1949 1
/* fprintf(debugger, "0x%x: receiving MT_NEW_PROCESS from 0x%x\n", curr_pid, src); fflush(debugger);   */
d2097 3
d2774 1
a2774 1
/*  fprintf(debugger, "0x%x: receiving MT_RESULT from 0x%x\n", curr_pid, src); fflush(debugger);      */
d3113 1
d3125 1
@


1.59
log
@speculative evaluations version 2 completed
@
text
@d2 3
d210 1
a210 1
/* int m_curr_pid = 0; */ /******* DELETE ! for debugging purposes only *********/
d513 1
a513 1
/*  fprintf(debugger, "0x%x: sending MT_NCUBE_READY, MT_ABORT to 0x%x\n", curr_pid, dest); fflush(debugger);   */
d552 1
a552 1
/*  fprintf(debugger, "0x%x: sending MT_POST_MORTEM to 0x%x\n", curr_pid, dest); fflush(debugger);   */
d569 1
a569 1
/*  fprintf(debugger, "0x%x: sending MT_NCUBE_FAILED to 0x%x\n", curr_pid, dest); fflush(debugger);   */
d609 1
a609 1
#ifdef D_MESS_ONLY   
d637 3
a639 1
/* fprintf(debugger, "0x%x: sending %s message to (0x%x,0x%x) from 0x%x\n",curr_pid, m_type, spec_control[1], dest, m_curr_pid); fflush(debugger); */
d658 2
d665 7
d688 1
a688 1
/*   fprintf(debugger, "0x%x: sending MT_NEW_PROCESS to 0x%x\n", curr_pid, dest); fflush(debugger);    */
d697 8
d712 5
d718 1
d738 3
d742 1
d744 5
d752 1
d765 6
d773 5
d780 6
d789 6
d796 12
d811 3
d825 11
d838 1
d852 2
d857 3
d861 6
d869 1
d872 3
d897 1
a897 1
	      {DBUG_PRINT("DYNHEAP",("sending %08x (refcount %d) as dynamic heap",send_data, ((T_PTD)send_data)->ref_count));
d1341 1
a1341 1
/*  fprintf(debugger, "0x%x: sending MT_RESULT to pid 0x%x on node 0x%x\n", curr_pid, (int) PC_GET_PPID(curr_pid), dest); fflush(debugger);   */
d1423 4
a1426 1
/* fprintf(debugger, "0x%x: sending MT_END_RESULT to 0x%x\n", curr_pid, dest); fflush(debugger);  */
d1537 3
d1541 3
d1655 1
a1655 1
/*   fprintf(debugger, "receiving MT_ABORT\n"); fflush(debugger);   */
d1671 1
a1671 1
/*   fprintf(debugger, "receiving MT_CONTROL\n"); fflush(debugger);    */
d1685 2
d1697 1
a1697 1
/*   fprintf(debugger, "0x%x: receiving HEREAMI from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);   */
d1718 1
a1718 1
/*   fprintf(debugger, "0x%x: receiving SPECMSG_ACK from (0x%x, 0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger);  */
d1732 9
d1742 1
a1742 1
/*     fprintf(debugger, "** it's this ACK !\n"); fflush(debugger);  */
d1745 1
a1745 1
            DBUG_PRINT("MSG", ("it was a granddad speculative process..."));
d1747 1
a1747 1
            DBUG_PRINT("MSG", ("normal dad speculative process, remove..."));
d1759 3
d1769 3
d1776 7
d1800 1
a1800 1
/* fprintf(debugger, "0x%x: receiving BARR from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger); */
d1825 1
a1825 1
/*  fprintf(debugger, "0x%x: receiving GOON from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger); */
d1841 1
a1841 1
/*  fprintf(debugger, "0x%x: receiving WIN from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger); */
d1858 1
a1858 1
/* fprintf(debugger, "0x%x: receiving START from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[4], src, spec_control[1]); fflush(debugger); */
d1874 1
a1874 1
/*     fprintf(debugger, "0x%x: receiving TERM from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger); */
d1888 1
a1888 1
/*  fprintf(debugger, "0x%x: receiving FAIL from (0x%x,0x%d) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger); */
d1903 1
a1903 1
/*  fprintf(debugger, "0x%x: receiving VITAL from (0x%x,0x%x) for 0x%x\n", curr_pid, spec_control[2], src, spec_control[1]); fflush(debugger); */
d1932 1
a1932 1
/*    fprintf(debugger, "0x%x: receiving MT_TERMINATE from 0x%x\n", curr_pid, src); fflush(debugger);  */
d1942 1
a1942 1
/*   fprintf(debugger, "0x%x: receiving MT_NEW_PROCESS from 0x%x\n", curr_pid, src); fflush(debugger);  */
d1980 1
a1980 1
      DBUG_PRINT("MSG", ("slot number is %d", spec_father_slot));
d1986 1
a1986 3
#if ADV_SCHED
      new_letpar_level = DO_RECEIVE();
#endif /* ADV_SCHED */
d1993 4
d2022 3
d2031 5
d2741 10
d2764 1
a2764 1
/*    fprintf(debugger, "0x%x: receiving MT_RESULT from 0x%x\n", curr_pid, src); fflush(debugger);     */
d2798 8
d2837 3
d2841 5
d2847 4
d2854 1
d2860 3
d2864 1
d2878 3
d2882 1
a2906 4
#if(!D_NN_SCHED)
      ticket_pool[src]++;
      ticket_pool_counter++;
#endif
d2908 1
d2914 5
d2932 35
d2981 2
d3017 1
a3017 1
/*   fprintf(debugger, "0x%x: receiving MT_NEW_GRAPH from 0x%x\n", curr_pid, src); fflush(debugger);     */
d3064 1
a3064 1
/*  fprintf(debugger, "0x%x: receiving MT_PARAM from 0x%x\n", curr_pid, src); fflush(debugger);  */
d3111 3
d3146 5
d3155 3
d3159 4
d3165 1
d3384 5
@


1.58
log
@dbug-messages removed, ready for re-compilation
@
text
@d2 3
d207 1
d470 1
d473 1
a473 1
#endif
d510 1
a510 1
/*  fprintf(debugger, "sending MT_NCUBE_READY, MT_ABORT\n"); fflush(debugger);  */
d549 1
a549 1
/*  fprintf(debugger, "sending MT_POST_MORTEM\n"); fflush(debugger);  */
d566 1
a566 1
/*  fprintf(debugger, "sending MT_NCUBE_FAILED\n"); fflush(debugger);  */
d606 1
a606 1
#ifdef D_MESS_ONLY  
a627 2
/* fprintf(debugger, "* ** curr_pid: %x, sending %s message to (%x,%d)\n",curr_pid, m_type, spec_control[1], dest); fflush(debugger); */

d633 3
a635 1
 
d674 1
a674 1
/*  fprintf(debugger, "sending MT_NEW_PROCESS (%x)\n", curr_pid); fflush(debugger);   */
d1238 1
a1238 1
/*  fprintf(debugger, "MT_RESULT from pid %x to pid %x on node %d\n", curr_pid, (int) PC_GET_PPID(curr_pid), dest); fflush(debugger);    */
d1320 1
a1320 1
/*  fprintf(debugger, "sending MT_END_RESULT\n"); fflush(debugger);  */
d1583 1
a1583 1
/*  fprintf(debugger, "receiving HEREAMI from (%x,%d)\n", spec_control[2], src); fflush(debugger);  */
d1604 1
a1604 1
/*   fprintf(debugger, "msg_receive: SPECMSG_ACK from <%d, %x>\n", src, spec_control[2]); fflush(debugger); */
d1664 1
a1664 1
/* fprintf(debugger, "receiving BARR from (%x,%d) for %x\n", spec_control[2], src, spec_control[1]); fflush(debugger); */
d1689 1
a1689 1
/*  fprintf(debugger, "receiving GOON from (%x,%d) for %x\n", spec_control[2], src, spec_control[1]); fflush(debugger); */
d1705 1
a1705 1
/*  fprintf(debugger, "receiving WIN from (%x,%d) for %x\n", spec_control[2], src, spec_control[1]); fflush(debugger); */
d1722 1
a1722 1
/*  fprintf(debugger, "receiving START from (%x,%d) for %x\n", spec_control[4], src, spec_control[1]); fflush(debugger); */
d1738 1
a1738 1
/*     fprintf(debugger, "receiving TERM from (%x,%d) for %x\n", spec_control[2], src, spec_control[1]); fflush(debugger); */
d1752 1
a1752 1
/*  fprintf(debugger, "receiving FAIL from (%x,%d) for %x\n", spec_control[2], src, spec_control[1]); fflush(debugger); */
d1767 1
a1767 1
/*  fprintf(debugger, "receiving VITAL from (%x,%d) for %x\n", spec_control[2], src, spec_control[1]); fflush(debugger); */
d1796 1
a1796 1
/*    fprintf(debugger, "receiving MT_TERMINATE\n"); fflush(debugger);   */
d1806 1
a1806 1
/*   fprintf(debugger, "receiving MT_NEW_PROCESS\n"); fflush(debugger);  */
d2608 1
a2608 1
/*     fprintf(debugger, "receiving MT_RESULT\n"); fflush(debugger);     */
d2793 1
a2793 1
/*   fprintf(debugger, "receiving MT_NEW_GRAPH\n\n\n\n"); fflush(debugger);     */
d2840 1
a2840 1
/*  fprintf(debugger, "receiving MT_PARAM\n"); fflush(debugger);  */
@


1.57
log
@further bugfixes on speculative evaluation (preliminary, beware of debug messages !)
@
text
@d2 3
d1538 1
a1538 1
   fprintf(debugger, "receiving MT_ABORT\n"); fflush(debugger);  
d1578 1
a1578 1
 fprintf(debugger, "receiving HEREAMI from (%x,%d)\n", spec_control[2], src); fflush(debugger); 
d1599 1
a1599 1
  fprintf(debugger, "msg_receive: SPECMSG_ACK from <%d, %x>\n", src, spec_control[2]); fflush(debugger); 
d1614 1
a1614 1
     fprintf(debugger, "** it's this ACK !\n"); fflush(debugger); 
d1659 1
a1659 1
 fprintf(debugger, "receiving BARR from (%x,%d) for %x\n", spec_control[2], src, spec_control[1]); fflush(debugger);
d1684 1
a1684 1
 fprintf(debugger, "receiving GOON from (%x,%d) for %x\n", spec_control[2], src, spec_control[1]); fflush(debugger);
d1700 1
a1700 1
 fprintf(debugger, "receiving WIN from (%x,%d) for %x\n", spec_control[2], src, spec_control[1]); fflush(debugger);
d1717 1
a1717 1
 fprintf(debugger, "receiving START from (%x,%d) for %x\n", spec_control[4], src, spec_control[1]); fflush(debugger);
d1733 1
a1733 1
    fprintf(debugger, "receiving TERM from (%x,%d) for %x\n", spec_control[2], src, spec_control[1]); fflush(debugger);
d1747 1
a1747 1
 fprintf(debugger, "receiving FAIL from (%x,%d) for %x\n", spec_control[2], src, spec_control[1]); fflush(debugger);
d1762 1
a1762 1
 fprintf(debugger, "receiving VITAL from (%x,%d) for %x\n", spec_control[2], src, spec_control[1]); fflush(debugger);
d1791 1
a1791 1
   fprintf(debugger, "receiving MT_TERMINATE\n"); fflush(debugger);  
d1801 1
a1801 1
  fprintf(debugger, "receiving MT_NEW_PROCESS\n"); fflush(debugger); 
d2603 1
a2603 1
    fprintf(debugger, "receiving MT_RESULT\n"); fflush(debugger);    
d2788 1
a2788 1
  fprintf(debugger, "receiving MT_NEW_GRAPH\n\n\n\n"); fflush(debugger);    
@


1.56
log
@modifications for speculative evaluations regarding
meaning preserving transformations
@
text
@d2 4
d463 1
a464 1
 int m_pid = -1;
d473 2
d479 4
d598 1
a598 1
#ifdef D_MESS_ONLY
d620 2
d666 1
a666 1
/*  fprintf(debugger, "sending MT_NEW_PROCESS (%x)\n", curr_pid); fflush(debugger);  */
d688 3
d696 3
a703 2
/* fprintf(stderr, "******** HAAAALLLLOOOOO3 !\n*\n*\n*: %x\n", (int)curr_pid->specmask1); fflush(stderr);  */

d772 1
a772 1
/* fprintf(debugger, "sending NO pointer...\n"); fflush(debugger);*/
d1230 1
a1230 1
/*  fprintf(debugger, "MT_RESULT from pid %x to pid %x on node %d\n", curr_pid, (int) PC_GET_PPID(curr_pid), dest); fflush(debugger);   */
d1237 1
d1301 3
d1329 2
d1376 2
d1422 1
a1422 1
 int spec_tmp2, spec_tmp3;
d1460 1
a1460 1
#ifdef D_MESS_ONLY
d1465 1
a1465 1
#endif
d1473 2
d1535 1
a1535 1
/*   fprintf(debugger, "receiving MT_ABORT\n"); fflush(debugger);  */
d1539 1
a1539 1
#ifdef D_MESS_ONLY
d1541 1
a1541 1
#endif /* D_MESS_ONLY */
d1551 1
a1551 1
/*   fprintf(debugger, "receiving MT_CONTROL\n"); fflush(debugger);   */
d1575 3
a1577 1
#ifdef D_MESS_ONLY
d1590 1
a1590 1
#ifdef D_MESS_ONLY
d1594 1
a1594 1
#endif
d1596 1
a1596 1
fprintf(debugger, "* msg_receive: SPECMSG_ACK from <%d, %x>\n", src, spec_control[2]); fflush(debugger);
a1597 2
        DBUG_PRINT("MSG", ("spec_multi_results: %d", spec_multi_results));
        
a1598 3

/*  fprintf(debugger, "Hey, ignoring ? no more GRANDDAD !\n"); fflush(debugger);*/

d1600 2
a1601 3
          } else

/*        if (!(((PROCESS_CONTEXT *)spec_control[1])->control->result) || ((spec_multi_results>0) && (((PROCESS_CONTEXT *)spec_control[1])->control->result<spec_multi_results))) { */
d1607 7
a1613 1
          if (spec_control[4]) { /* it was a granddad speculative process */
d1617 2
a1618 1
            spec_remove_control_pid(spec_control[1], spec_control[2], src);
a1623 3
          spec_tmp1 = spec_control[1];
          spec_tmp2 = spec_control[3];

d1637 1
a1644 2
/* dump_processes(spec_tmp1);  */
         /*  } else { */
d1646 1
a1646 1
/* fprintf(debugger, "Hey, ignoring ?!\n"); fflush(debugger); */
d1648 1
a1648 2
/*          DBUG_PRINT("MSG", ("there's a result yet, ignore !!"));
         } */
d1656 4
a1659 1
#ifdef D_MESS_ONLY
d1663 1
a1663 1
#endif
d1675 1
a1675 1
#ifdef D_MESS_ONLY
d1679 4
a1682 1
#endif
d1691 1
a1691 1
#ifdef D_MESS_ONLY
d1695 3
a1697 1
#endif
d1708 1
a1708 1
#ifdef D_MESS_ONLY
d1712 3
a1714 1
#endif
d1724 1
a1724 1
#ifdef D_MESS_ONLY
d1728 4
a1731 2
#endif
   
d1743 2
d1746 1
a1746 1
#ifdef D_MESS_ONLY
d1751 1
d1758 2
d1761 1
a1761 1
#ifdef D_MESS_ONLY
d1765 2
a1766 1
#endif
d1788 1
a1788 1
/*   fprintf(debugger, "receiving MT_TERMINATE\n"); fflush(debugger);  */
d1798 1
a1798 1
/*  fprintf(debugger, "receiving MT_NEW_PROCESS\n"); fflush(debugger); */
d1806 1
a1806 1
#ifdef D_MESS_ONLY
d1809 1
a1809 1
#endif
d1813 1
d1819 2
d1827 3
d1859 2
a1871 2
/* fprintf(stderr, "******** HAAAALLLLOOOOO2 !\n*\n*\n: %x*\n", spec_global); fflush(stderr); */

d1887 1
a1887 1
#if D_MESS_ONLY
d1978 1
a1978 1
/* fprintf(debugger, "receiving NO pointer...\n"); fflush(debugger);*/
d2026 1
a2026 1
/* fprintf(debugger, "receiving C_LIST..., dim is %d\n", R_LIST(*new_desc,dim)); fflush(debugger);*/
d2600 1
a2600 1
/*   fprintf(debugger, "receiving MT_RESULT\n"); fflush(debugger);   */
d2606 1
a2606 1
#ifdef D_MESS_ONLY
d2608 1
a2608 1
#endif
d2614 1
a2614 1
#if D_MESS_ONLY
d2656 3
d2724 1
a2724 1
/* fprintf(debugger, "no speculative result... wakeup...\n"); fflush(debugger);*/
d2736 15
a2750 4
          DBUG_PRINT("MSG", ("speculative result !"));
          /* somehow abusing this function, because the process has not failed, */
          /* but instead has transmitted the result */
          spec_process_failed_father(rec_pid, spec_tmp2, src);
d2785 1
a2785 1
/*  fprintf(debugger, "receiving MT_NEW_GRAPH\n"); fflush(debugger);  */
d2789 1
a2789 1
#ifdef D_MESS_ONLY
d2791 1
a2791 1
#endif
d2852 1
a2852 1
#ifdef D_MESS_ONLY
d2854 1
a2854 1
#endif
d3426 2
a3431 3

/*  fprintf(debugger, "having received %s from %d,%x for %x\n", m_type, src, m_pid, f_pid); fflush(debugger);  */

d3483 1
a3483 1
  if (spec_sched_status) {
@


1.55
log
@old version check-in
@
text
@d2 3
d197 2
a684 1
        DBUG_PRINT("MSG", ("speculative process creation... send specmask2 address %x...", &(curr_pid->specmask2)));
d688 3
a690 1
        DO_SEND((int)&(curr_pid->specmask2));
d692 2
a693 1
      else
d696 4
d770 1
a770 1
	      {DBUG_PRINT("DYNHEAP",("sending %08x as dynamic heap",send_data));
d1002 2
a1003 1
			      {heap_elems = *(int *)R_NOMAT(*(T_PTD)send_data,guard_body);
d1006 1
d1219 1
a1219 2
    if (T_SPEC_PROCESS(curr_pid)==1) {
      if (PC_GET_PPID(curr_pid) != curr_pid->father_pid) {
a1221 1
        }
d1241 2
a1252 1
#if (!D_SPEC)
a1253 4
#else /* D_SPEC */
      /* now calculate the total number of used steps... */
      if (!T_SPEC_PROCESS(curr_pid)) {
        DBUG_PRINT("MSG", ("no speculative result..."));
d1255 1
a1255 1
/*  fprintf(debugger, "send: vital process, send %d steps!\n", (PC_GET_SREDCNT(curr_pid)-_redcnt)); fflush(debugger); */
d1257 5
a1261 7
        DO_SEND(PC_GET_SREDCNT(curr_pid)-_redcnt);
        }  
      else {
        DBUG_PRINT("MSG", ("speculative result..."));
        DBUG_PRINT("MSG", ("already vital, so out of sync !"));
        send_spec = curr_pid->start_red_count - _redcnt;
        DBUG_PRINT("MSG", ("counting %d steps...", send_spec));
d1263 17
a1279 3
/*  fprintf(debugger, "send: spec process, send %d steps!\n", send_spec); fflush(debugger);  */

        DO_SEND(send_spec);
d1281 3
a1283 2
      DO_SEND(T_SPEC_PROCESS(curr_pid));
      DO_SEND(curr_pid);
d1308 9
d1399 1
a1399 1
 int spec_flag, spec_counter; /* message for a speculative process */
d1568 2
a1570 1
        DBUG_PRINT("MSG", ("results already stored: %d", ((PROCESS_CONTEXT *)spec_control[1])->control->result));
d1579 1
a1579 1
        if (!(((PROCESS_CONTEXT *)spec_control[1])->control->result) || ((spec_multi_results>0) && (((PROCESS_CONTEXT *)spec_control[1])->control->result<spec_multi_results))) {
d1619 1
a1619 1
          } else {
d1623 2
a1624 2
          DBUG_PRINT("MSG", ("there's a result yet, ignore !!"));
          }
d1704 1
a1704 1
        DBUG_PRINT("MSG", ("a speculative process failed !"));
d1786 4
d1812 1
d2451 2
a2452 1
                                        heap_counter += 5;
a2538 17
  /* if there may be multiple results, copy the pointer to the appropriate destination */

  if (spec_flag && (type==MT_RESULT) && (spec_multi_results>0)) { /* speculative result */
    DBUG_PRINT("MSG", ("specmask2 is now %x", rec_pid->specmask2));
    DBUG_PRINT("MSG", ("storing possible multiple result..."));
    /* copy the result to the destination */

    DBUG_PRINT("MSG", ("SPAWNED %d, already stored %d", PC_GET_SPEC_SPAWNED(rec_pid), spec_counter));
    DBUG_PRINT("MSG", ("storing pointer %x !", rec_pid->specmask2));

    rec_pid->processes[PC_GET_SPEC_SPAWNED(rec_pid)*2+spec_counter*2] = rec_pid->specmask2;
    rec_pid->specmask2 = spec_counter+1;
    DBUG_PRINT("MSG", ("%d results stored.", rec_pid->specmask2));

    /*abdul(rec_pid);*/
    }

d2585 1
d2587 24
a2610 2
      if (spec_flag)  { /* set winner-flag */
        DBUG_PRINT("MSG", ("winning speculative process !"));
d2614 1
a2614 3
        if (T_SPEC_WINNER(rec_pid)==1) { /* process has already received some results */

/* fprintf(debugger, "receive: WINNER was already set...\n"); fflush(debugger); */
d2616 1
a2616 3
          spec_tmp1 = (int) rec_pid->red_count;
          } else {
          PC_SET_SPEC_WINNER(rec_pid);
d2618 1
a2618 1
/* fprintf(debugger, "receive: set WINNER...\n"); fflush(debugger); */
d2620 1
a2620 4
          /* recalculate red-steps */
          if ((T_SPEC_GRANDDAD(rec_pid)==1) || (rec_pid->ppid == 0)) {
            DBUG_PRINT("MSG", ("It was a granddad speculative process !"));
            DBUG_PRINT("MSG", ("or: ppid was 0; ppid = %x", rec_pid->ppid));
d2622 1
a2622 1
/*  fprintf (debugger, "receive: it was a granddad speculative process ! rec_pid->ppid = %x\n", rec_pid->ppid); fflush(debugger);  */
d2624 1
a2624 1
            spec_tmp1 = (int) rec_pid->red_count;
d2626 1
a2626 1
/*  fprintf (debugger, "receive: spec_tmp1 = %d\n", spec_tmp1); fflush(debugger);  */
d2628 1
a2628 2
            } else {
            DBUG_PRINT("MSG", ("It was a normal father speculative process !"));
d2630 1
a2630 1
/*  fprintf (debugger, "receive: it was a normal father speculative process !\n"); fflush(debugger);  */
d2632 3
a2634 2
            /* still in barrier sync... recalculate */
            spec_tmp1 = (int) rec_pid->start_red_count - rec_pid->abs_red_count - (ack_red_count - rec_pid->red_count);
d2636 4
a2639 2
/* fprintf (debugger, "receive: spec_tmp1 = %d\n", spec_tmp1); fflush(debugger);  */
/*  fprintf (debugger, "receive: start_red_count = %d, abs_red_count = %d, ack_red_count = %d, red_count = %d\n", (int) rec_pid->start_red_count, rec_pid->abs_red_count, ack_red_count, rec_pid->red_count); fflush(debugger);  */
d2641 1
a2641 3
            }
          }
        DBUG_PRINT("MSG", ("pid %x has %d steps left, %d were used by the son.", rec_pid, spec_tmp1, spec_tmp3));
a2644 5
        rec_pid->red_count = (int)((int)spec_tmp1 - spec_tmp3);

/*  fprintf (debugger, "receive: pid %x now has %d steps left\n", rec_pid, rec_pid->red_count); fflush(debugger);  */

        DBUG_PRINT("MSG", ("pid %x now has %d steps left", rec_pid, rec_pid->red_count));
a2694 7
#if D_SPEC
      if (spec_flag && (spec_multi_results>0)) {
        spec_counter = rec_pid->specmask2;
        DBUG_PRINT("MSG", ("backup for spec_multi: specmask2 was %d", rec_pid->specmask2));
        }
#endif /* D_SPEC */

d2732 5
d2744 1
a2744 1
         new_pid = (*d_m_process_create)(0,0,new_redcnt);
d2746 1
a2746 1
         new_pid = process_create(0,0,new_redcnt);
@


1.54
log
@some more (complete) modifications concerning speculative evaluation
(don't say you have missed my talk ? ;-)
@
text
@d2 4
d681 3
d1199 1
a1199 1
/*  initialize_fred_fish(); */
d1205 6
a1210 3
    if (PC_GET_PPID(curr_pid) != curr_pid->father_pid) {
      DBUG_PRINT("MSG", ("reinstall father_pid !"));
      curr_pid->ppid = curr_pid->father_pid;
d1212 1
d1741 1
d1785 3
d2417 7
d2534 1
a2534 1
/*      initialize_fred_fish();  */
d2544 2
d2643 2
@


1.53
log
@further work on speculative evaluation
@
text
@d2 3
d187 1
d193 2
d200 1
a200 1
/* #if D_SPEC
d202 1
a202 1
#else  */
d204 1
a204 1
/* #endif */
d483 1
a483 1
/* fprintf(debugger, "MT_NCUBE_READY, MT_ABORT\n"); fflush(debugger); */
d522 1
a522 1
/* fprintf(debugger, "MT_POST_MORTEM\n"); fflush(debugger); */
d539 1
a539 1
/* fprintf(debugger, "MT_NCUBE_FAILED\n"); fflush(debugger); */
d572 1
a572 1
/* fprintf(debugger, "MT_CONTROL\n"); fflush(debugger); */
d612 1
a612 1
/* fprintf(debugger, "sending %s to %d,%x\n", m_type, dest, m_pid); fflush(debugger);  */
d622 2
d645 1
a645 1
/* fprintf(debugger, "MT_NEW_PROCESS\n"); fflush(debugger); */
d650 3
d662 1
d664 10
d736 4
a739 1
           DBUG_PRINT ("MSG", ("no pointer: %x", send_data));
d792 4
a795 1
                       DBUG_PRINT("MSG", ("C_LIST"));
d1192 3
a1194 1
/* fprintf(debugger, "MT_RESULT\n"); fflush(debugger); */
d1198 5
d1212 1
a1212 1
  /*    DBUG_PRINT("MSG",("Result -> Node %d: class %d,type %d",dest,
d1214 1
a1214 1
			R_DESC(*((T_PTD)*(ps_w->TopofStack)),type))); */
d1235 3
d1245 3
d1260 1
a1260 1
/* fprintf(debugger, "MT_END_RESULT\n"); fflush(debugger); */
d1344 1
a1344 1
 INSTR *new_pc;
d1358 1
d1468 1
a1468 1
/* fprintf(debugger, "receiving MT_ABORT\n"); fflush(debugger); */
d1484 1
a1484 1
/* fprintf(debugger, "receiving MT_CONTROL\n"); fflush(debugger); */
d1496 2
d1527 6
a1532 1
        if (!(((PROCESS_CONTEXT *)spec_control[1])->control->result)) {
d1534 2
a1535 1
          DBUG_PRINT("MSG", ("Okey, there's no result yet, register processes"));
d1537 4
d1548 1
a1548 1
/* dump_processes(spec_control[1]); */
d1555 4
d1576 1
a1576 1
/* dump_processes(spec_tmp1); */
d1694 1
d1704 1
a1704 1
/* fprintf(debugger, "receiving MT_TERMINATE\n"); fflush(debugger); */
d1714 1
a1714 1
/* fprintf(debugger, "receiving MT_NEW_PROCESS\n"); fflush(debugger); */
d1727 14
d1742 1
d1765 7
d1877 4
a1880 1
	   {DBUG_PRINT("MSG",("receiving non-pointer value %d (%x)",rec_data,rec_data));
d1926 5
d2471 28
d2510 3
a2512 1
/* fprintf(debugger, "receiving MT_RESULT\n"); fflush(debugger); */
d2540 1
a2540 1
      spec_tmp1 = DO_RECEIVE(); /* this is 1 if it was a speculative result */
d2542 1
a2542 1
      if (spec_tmp1)  { /* set winner-flag */
d2544 7
a2550 4
        PC_SET_SPEC_WINNER(rec_pid);
        /* recalculate red-steps */
        if (T_SPEC_GRANDDAD(rec_pid)==1) {
          DBUG_PRINT("MSG", ("It was a granddad speculative process !"));
d2553 27
a2579 2
          DBUG_PRINT("MSG", ("It was a normal father speculative process !"));
          spec_tmp1 = (int) rec_pid->start_red_count - rec_pid->abs_red_count - (ack_red_count - rec_pid->red_count);
d2582 3
d2586 3
d2592 3
d2614 1
a2614 1
      if (!spec_tmp1) {
d2617 3
d2638 7
d2673 1
a2673 1
/* fprintf(debugger, "receiving MT_NEW_GRAPH\n"); fflush(debugger); */
d2715 1
a2715 1
/* fprintf(debugger, "receiving MT_PARAM\n"); fflush(debugger); */
d2761 1
d2796 9
d2811 2
d3020 1
a3020 1
/* fprintf(debugger, "receiving MT_CLOSE_MEASURE\n"); fflush(debugger); */
d3314 1
a3314 1
/* fprintf(debugger, "having received %s from %d,%x for %x\n", m_type, src, m_pid, f_pid); fflush(debugger);  */
@


1.52
log
@some additions supporting speculative evaluation
@
text
@d2 3
d187 5
d194 3
d198 1
d442 1
d454 6
d470 4
d477 2
d482 1
d516 2
d533 2
d551 3
d566 2
d571 36
a606 1
       DBUG_PRINT ("RNCMESSAGE", ("send CONTROL message"));
d608 2
a610 1
       if (!T_SPECMSG_ACK) {
d615 3
a617 2
       } else
     {
d619 2
a620 5
       DBUG_PRINT("RNCMESSAGE", ("SPECMSG_ACK processing"));
       DO_SEND(spec_control[1]); /* this is the pid for the control process */
       DO_SEND(spec_control[2]); /* this is the pid of the father process and must */
                                 /* be removed */
       DO_SEND(spec_control[3]); /* this is the number of sons */
d625 1
a625 1
         DBUG_PRINT("RNCMESSAGE", ("it's pid %x on node %d !", ((PROCESS_CONTEXT *)spec_control[2])->processes[(spec_control[4]*2)], ((PROCESS_CONTEXT *)spec_control[2])->processes[(spec_control[4]*2)+1]));
d637 2
d652 7
d1164 2
d1191 4
d1196 17
d1219 2
d1246 1
d1269 1
d1376 1
a1376 1
   post_mortem("insufficient memory for received_list");
d1426 2
d1441 3
d1445 1
a1445 1
      DBUG_PRINT ("RNCMESSAGE", ("receiving MT_CONTROL message"));
d1452 2
a1453 2
      if (!T_SPECMSG_ACK) {
      spec_control[4] = DO_RECEIVE(); }
d1457 14
a1470 4
      if (T_SPECMSG_HEREAMI) {
        DBUG_PRINT("RNCMESSAGE", ("HEREAMI-message received, processing"));
        DBUG_PRINT("RNCMESSAGE", ("the message is for pid : %x", spec_control[1]));
        spec_add_son(spec_control[1],spec_control[2],spec_control[3]);
d1472 41
a1512 20
      if (T_SPECMSG_ACK) {
        DBUG_PRINT("RNCMESSAGE", ("ACK-message received, processing"));
        DBUG_PRINT("RNCMESSAGE", ("the message is for pid : %x", spec_control[1]));

        /* remove the father process */

        if (!T_SPEC_GRANDDAD(((PROCESS_CONTEXT *)spec_control[1])))
          spec_remove_control_pid(spec_control[1], spec_control[2], src);

        /* oh, this is some kind of loop, so we can't use the globals any more... */

        spec_tmp1 = spec_control[1];
        spec_tmp2 = spec_control[3];
        for (spec_tmp3=0; spec_tmp3<spec_tmp2; spec_tmp3++) {
          spec_tmp1->control->data[spec_tmp1->control->leaves+2*spec_tmp3]=heap_counter=DO_RECEIVE();
          spec_tmp1->control->data[spec_tmp1->control->leaves+2*spec_tmp3+1]=param_counter=DO_RECEIVE();
          DBUG_PRINT("RNCMESSAGE", ("registering pid %x of node %d as number %d", heap_counter, param_counter, spec_tmp1->control->leaves+spec_tmp3));
          /* these processes are now stored, they may "go for gold" now */
          spec_send_start(param_counter, heap_counter); /* temp variables used */
          }  
d1514 11
d1526 13
a1538 12
      if (T_SPECMSG_BARR) {
        DBUG_PRINT("RNCMESSAGE", ("BARR-message received, processing"));
        DBUG_PRINT("RNCMESSAGE", ("the message is for pid : %x", spec_control[1]));
        ((PROCESS_CONTEXT *)spec_control[1])->control->have_ack++;
        DBUG_PRINT("RNCMESSAGE", ("leaves: %d, ack: %d", ((PROCESS_CONTEXT *)spec_control[1])->control->leaves, ((PROCESS_CONTEXT *)spec_control[1])->control->have_ack));
        if (((PROCESS_CONTEXT *)spec_control[1])->control->have_ack >=
            ((PROCESS_CONTEXT *)spec_control[1])->control->leaves) {
          DBUG_PRINT("RNCMESSAGE", ("all leaves have acknowledged !"));
          ((PROCESS_CONTEXT *)spec_control[1])->control->have_ack = 0;
          spec_broadcast_sons(((PROCESS_CONTEXT *)spec_control[1])->control);
          /* don't forget to reset the counter !!! */
          }
d1540 5
a1544 3
      if (T_SPECMSG_GOON) {
        DBUG_PRINT("RNCMESSAGE", ("GOON-message received, processing"));
        DBUG_PRINT("RNCMESSAGE", ("the message is for pid : %x", spec_control[1]));
d1546 8
a1553 12
        if (spec_control[1] == curr_pid) { /* process is active */
          DBUG_PRINT("RNCMESSAGE", ("process is active"));
          /* reset Flag */
          CLEAR_ACKNOWLEDGE(curr_pid);
          } else {
          DBUG_PRINT("RNCMESSAGE", ("process is not active"));
          ((PROCESS_CONTEXT *)spec_control[1])->red_count += ack_red_count;
          /* so this process must have been waiting, let's wake this process up */
          process_wakeup(spec_control[1]);
          }
          CLEAR_ACKNOWLEDGE((PROCESS_CONTEXT *)spec_control[1]);
          DBUG_PRINT("RNCMESSAGE", ("specmask1 is %x", ((PROCESS_CONTEXT *)spec_control[1])->specmask1));
d1555 3
a1557 1
      if (T_SPECMSG_WIN) { /* there's a result somewhere !!! */
d1559 7
a1565 6
        if (((PROCESS_CONTEXT *)spec_control[1])->control->result) {
          DBUG_PRINT("RNCMESSAGE", ("oh, there's already a result, ignore..."));
          } else {
          DBUG_PRINT("RNCMESSAGE", ("now we've got THE result..."));
          ((PROCESS_CONTEXT *)spec_control[1])->control->result = 1; /* mask it */
          spec_remove_control_pid(((PROCESS_CONTEXT *)spec_control[1])->control,spec_control[2], spec_control[3]);
d1567 1
a1567 1
          /* okey, let's terminate all other leaf processes */
a1568 2
          spec_control_terminate(((PROCESS_CONTEXT *)spec_control[1])->control);
          }
d1570 14
a1583 3
      if (T_SPECMSG_START) { /* finally, a speculative process may start working */
        DBUG_PRINT("RNCMESSAGE", ("SPECMSG_START received..."));
        process_wakeup(spec_control[1]);
d1585 29
a1613 12
      if (T_SPECMSG_TERM) { /* oh, terminate a process, how comes ? */
        DBUG_PRINT("RNCMESSAGE", ("SPECMSG_TERM received..."));
        if (curr_pid == spec_control[1]) { /* oh, this process is running... */
          DBUG_PRINT("RNCMESSAGE", ("process is running..."));
          process_sleep(curr_pid);
          } else { /* process is already sleeping */
          DBUG_PRINT("RNCMESSAGE", ("process is not running..."));
          }
          DBUG_PRINT("RNCMESSAGE", ("sending failure message to the father pid %x on node %d",  ((PROCESS_CONTEXT *)spec_control[1])->father_pid, ((PROCESS_CONTEXT *)spec_control[1])->father_node));
          spec_tmp1 = spec_control[1];
          spec_send_fail(((PROCESS_CONTEXT *)spec_control[1])->father_node, ((PROCESS_CONTEXT *)spec_control[1])->father_pid, spec_control[1]);
          process_terminate(spec_tmp1);
d1615 11
a1625 3
      if (T_SPECMSG_FAIL) { /* oh, whowsers (Inspector Gadget) ! A failed spec process ! */
        DBUG_PRINT("RNCMESSAGE", ("whoops, a speculative process failed !"));
        spec_process_failed(spec_control[1], spec_control[2], src);
d1627 1
d1629 1
a1629 1
          DBUG_PRINT("RNCMESSAGE", ("spec_control[0]: %x", spec_control[0]));
d1633 4
d1645 2
d1649 2
d1655 2
d1696 8
a1703 3
        DBUG_PRINT("RNCMESSAGE", ("spec process created by node %d pid %x", src, ppid));
        DBUG_PRINT("RNCMESSAGE", ("control is at node %d pid %x", new_pid->control_node, new_pid->control_pid));
        spec_send_hereami(src, ppid, new_pid);
d2350 1
d2371 3
d2393 2
d2409 1
a2409 1
      DBUG_PRINT("MSG",("a_stack_addr: %x",a_stack_addr));
d2411 2
d2418 28
d2457 5
a2461 1
      if ((--(*(int *)h_stack_addr) == 0) && (PC_STATUS(rec_pid) == PS_WAITING))
d2463 1
a2463 1
        (*d_m_process_wakeup)(rec_pid);
d2465 1
a2465 1
	process_wakeup(rec_pid);
d2467 9
d2507 2
d2549 1
d2593 2
d2841 3
d3135 3
d3188 5
d3240 3
@


1.51
log
@some scheduling improvements
@
text
@d2 3
d181 5
d353 1
a353 1
#if ADV_SCHED
d421 4
d530 29
a558 1
   {case MT_NEW_PROCESS:
d560 8
d591 8
d1209 4
d1333 117
d1478 5
d1491 12
d2055 10
d2263 4
d2302 3
a2305 1
     sig_interrupt = 0;
d2332 6
d2900 2
@


1.50
log
@some problems concerning PM-instructions fixed
@
text
@d2 3
d334 1
a334 1
extern PROCESS_CONTEXT * ready_queue_first;
d1166 4
d1316 34
d2023 1
d2037 3
a2039 1
    printf (stderr, "insgesamt: %d, sig_suspend: %d\n", jc, sig_suspend);
@


1.49
log
@support for C_PATTERN descriptors added
@
text
@d2 3
d1823 1
a1823 1
                                  if ((rec_instr.instruction >= I_APPEND) && (rec_instr.instruction <= I_MATCHFALSE)) {
d1843 8
@


1.48
log
@support for C_INTACT
@
text
@d2 3
d979 6
d1427 6
@


1.47
log
@C_FUNC TY_CASE ptc's might be used to indicate the number of the when-clause
(bugfix for the distributed version)
@
text
@d2 4
d631 8
d1419 8
@


1.46
log
@another bugfix concerning the SUB-pattern-descriptor...
@
text
@d2 3
d645 1
d647 1
d649 1
a649 1
                       DBUG_PRINT("MSG", ("C_MATRIX C_VECTOR C_TVECTOR"));
d663 1
d665 1
a665 1
                       DBUG_PRINT("MSG", ("C_EXPRESSION C_CONSTANT"));
d668 1
d670 1
d672 1
a672 1
                            DBUG_PRINT ("MSG", ("TY_REC TY_ZF TY_SUB"));
d879 1
d881 1
a881 1
                       DBUG_PRINT("MSG", ("C_FUNC C_CONS"));
d918 1
d920 1
d922 1
d924 1
a924 1
                            DBUG_PRINT("MSG", ("TY_CASE TY_WHEN TY_GUARD TY_BODY"));
d928 5
d934 1
d1425 1
d1427 1
d1429 1
a1429 1
                         DBUG_PRINT("MSG", ("C_MATRIX C_VECTOR C_TVECTOR"));
d1447 1
d1449 1
a1449 1
                         DBUG_PRINT("MSG", ("C_EXPRESSION C_CONSTANT"));
d1452 1
d1454 1
d1456 1
a1456 1
                              DBUG_PRINT("MSG", ("TY_REC TY_ZF TY_SUB"));
d1686 1
d1688 1
a1688 1
                         DBUG_PRINT("MSG", ("C_FUNC C_CONS"));
d1737 1
d1739 1
d1741 1
d1743 1
a1743 1
                              DBUG_PRINT("MSG", ("TY_CASE TY_WHEN TY_GUARD TY_BODY"));
d1746 9
a1754 2
			      if ((type != MT_NEW_GRAPH) || code_received)
				L_CASE(*new_desc,ptc) = GET_CODE_START() + DO_RECEIVE();
@


1.45
log
@sending/receiving CLAUSE and SELECTION descriptors
seems to work now
@
text
@d2 4
d749 11
a759 1
			    heap_elems = *(int *)R_NAME(*(T_PTD)send_data,ptn);
d764 1
d1305 1
a1305 1
            DBUG_PRINT("MSG", ("counter: %d", counter));
d1539 6
d1550 1
@


1.44
log
@still some work left ;-)
@
text
@d2 3
d921 5
d1424 1
@


1.43
log
@still some work on sending MATCHING-descriptors left
@
text
@d2 3
d1282 1
d1303 1
a1303 1
	      {DBUG_PRINT("MSG",("receiving dynamic descriptor pointer %x",*rec_addr));
d1355 8
a1362 2
                            break;
                          default:
@


1.42
log
@problems with TGUARD fixed...
@
text
@d2 3
d842 6
a847 1
			    break;}
d898 4
d904 21
a924 1
		     }                      /* switch(d_class) */
d1340 16
@


1.41
log
@fixed label problems of the pattern matching instructions
@
text
@d2 3
d1685 9
@


1.40
log
@added support for C_FRAME (TY_FRAME/TY_SLOT)
@
text
@d2 3
d1655 37
@


1.39
log
@more DBUG output
@
text
@d2 3
d605 17
d1302 17
@


1.38
log
@some changes for ADV_SCHED (-uling)
@
text
@d2 3
d497 2
d1713 1
@


1.37
log
@set ADV_SCHED for the "advanced ticket scheduling", still under construction !
@
text
@d2 3
d294 3
d943 3
d1731 5
@


1.36
log
@some pvm + ncube + measurement changes
@
text
@d2 3
d288 4
d298 9
d494 5
d991 1
a991 1
 int new_redcnt;
d1019 4
d1150 4
d1165 5
d1688 7
d1707 17
d1743 6
d1772 6
@


1.35
log
@some (final :-) changes for the nCUBE pvm version...
@
text
@d2 3
d1763 1
a1763 1
#if D_PVM
@


1.34
log
@some ncube+pvm changes
@
text
@d2 3
d1739 2
a1740 2
      pvm_upkstr(m_mesfilehea);
      pvm_upkstr(m_mesfilepath);
d1976 1
a1976 1
#if nCUBE
d2059 3
a2061 1
#if D_PVM
@


1.33
log
@minor changes (pvm)
@
text
@d2 3
d538 1
a538 1
#if nCUBE
@


1.32
log
@additional pvm + measure changes
@
text
@d2 3
d1754 3
d1758 1
@


1.31
log
@changes for the pvm + measuer version
@
text
@d2 3
d1739 1
d1741 1
@


1.30
log
@more DBUG output
@
text
@d2 3
d979 3
d2024 1
d2026 8
d2036 1
d2041 8
d2067 1
@


1.29
log
@pvm + measure fixes
@
text
@d2 3
d1526 1
@


1.28
log
@some changes for the pvm measure version
@
text
@d2 3
d1711 1
d1715 5
@


1.27
log
@bugfix for the tilde-versions: send args+nfv in closures...
@
text
@d2 3
d1016 1
d1020 6
d1035 3
d1045 1
a1045 1
   DBUG_PRINT("PVM", ("Receiving message from Host tid t%x", pvm_src)); 
a1046 1
#endif
d1676 1
d1678 1
d1939 1
d1942 1
d1986 1
d1988 6
d2031 1
d2033 5
d2045 1
d2047 1
@


1.26
log
@bug fix in sending doubles
(thanks to mr. held there was no doku on this...)
@
text
@d2 4
d768 3
d772 1
d1455 3
d1459 1
@


1.25
log
@pvm bug fixes
@
text
@d2 3
d343 1
a343 1
#endif D_PVM
d478 3
a480 2
	{if ((!T_POINTER(send_data) || !isdesc(send_data)) && send_data)
	   DO_SEND(send_data);
d483 2
a484 1
	     {DO_SEND(0);
d492 4
a495 2
	      {if (R_DESC(*(T_PTD)send_data,class) == C_SENT)   /* descriptor already sent? */
		 {DO_SEND(0);
d500 2
d511 1
d513 1
d518 1
d523 1
d532 1
d542 1
d557 1
d562 1
d599 1
d609 1
d619 1
d633 1
d638 1
d646 1
d654 1
d673 1
d690 1
d721 1
d738 1
d744 1
d754 1
d757 1
d770 1
d776 1
d782 1
d790 1
d896 1
a896 1
#endif D_PVM
d1146 2
a1147 1
	      {if (T_DESC_INDEX(rec_data))
d1163 1
d1169 1
d1179 1
d1190 1
d1209 1
d1214 1
d1264 1
d1276 1
d1287 1
d1303 1
d1308 1
d1317 1
d1326 1
d1345 1
d1362 1
d1399 1
d1420 1
d1426 1
d1437 1
d1440 1
d1453 1
d1465 1
d1477 1
d1485 1
d1561 1
d1901 1
@


1.24
log
@pvm changes
@
text
@d2 3
d387 3
a389 1
    /* still to be done */
d402 3
a404 1
     /* still to be done */ 
d971 2
d976 2
a991 2
 if (result < 0)
   post_mortem("error on nread");
d2123 2
d2154 1
@


1.23
log
@some minor pvm changes...
@
text
@d2 3
d178 1
a178 1
                           (pvm_recv(src,type), \
d330 2
a331 1
 if (pvm_dest != host) 
d333 4
d356 1
a356 1
    pvm_send(dest,type);
d803 1
a803 1
      DBUG_PRINT("MSG",("Result -> Node %d: class %d,type %d",dest,
d805 1
a805 1
			R_DESC(*((T_PTD)*(ps_w->TopofStack)),type)));
d853 1
a853 1
 pvm_send(dest, type);
d916 1
d969 2
a970 2
 pvm_bufid = pvm_recv(src,type);
 pvm_bufinfo (pvm_bufid, &pvm_length, &type, &src); 
d972 7
a1590 9
#if D_PVM
  pvm_upkint(&pvmspawn_ntask, 1, 1);
  pvm_upkint(pvm_tids, pvmspawn_ntask, 1);
  for (_tmp =0; _tmp<pvmspawn_ntask; _tmp++) /* identify the logical node number */
    if (proc_id==pvm_tids[_tmp]){proc_id=_tmp; break;}
  DBUG_PRINT ("PVM", ("altogether %d nodes, I'm node %d (pvm_id:t%x) !", pvmspawn_ntask, proc_id, pvm_mytid()));
#endif /* D_PVM */


a1605 3
#if D_PVM
  pvmcoding = DO_RECEIVE();
#endif /* D_PVM */
@


1.22
log
@additional pvm changes
@
text
@d2 3
a829 1
DBUG_PRINT("PVM", ("first sending..."));
a830 2

DBUG_PRINT("PVM", ("first sended..."));
d976 2
@


1.21
log
@additional pvm changes
@
text
@d2 3
d83 2
a84 2
extern int pvmspawn_ntask;
extern int pvm_tids[];
d130 1
a130 1
                        (pvm_send(dest, type), \
d174 2
a175 2
                           pvm_upkint (buffer_p, 1, 1), \
                           pvm_counter++,*buffer_p)
d304 1
d323 5
d331 2
d366 3
d379 3
d404 2
d780 2
d813 2
d823 1
a823 1
      DBUG_PRINT("MSG",("End result: class %d,type %d",
d825 1
a825 1
			     R_DESC(*((T_PTD)*(ps_w->TopofStack)),type)));
d827 1
d829 2
d980 2
d994 2
d1000 2
d1494 2
d1530 2
d1561 2
d1573 9
d1615 2
d1823 3
a1825 2
      if (DO_RECEIVE() != END_MARKER)
	/* error !!! */;
@


1.20
log
@pvm changes (to be continued)
@
text
@d2 3
d82 1
a82 1
extern int pvmcoding;
d332 6
d339 1
d354 7
a360 1
   {nwrite(post_mortem_msg,strlen(post_mortem_msg)+1,dest,type,&flags);
d364 7
a370 1
   {nwrite(post_mortem_msg,strlen(post_mortem_msg)+1,dest,type,&flags);
d375 1
d377 7
d812 1
d816 5
d880 2
d930 1
d932 6
d1442 1
d1444 1
d1550 3
d2058 1
d2060 5
a2065 1
     DBUG_PRINT("NN",("msg_check - erg : %d / type : %d " , erg, type)); 
d2067 1
d2101 4
d2112 1
d2114 6
d2125 1
d2127 5
a2131 2
    nrelp(buffer);}}
      
@


1.19
log
@changed nCUBE to D_SLAVE
@
text
@d2 3
d42 1
d45 1
d73 9
d89 1
d120 1
d122 10
d162 9
d296 3
d842 3
d1851 1
a1851 1
        /* now open File again for more reductions !!!!! 
d1877 1
a1877 1
            /* now open File again for more reductions !!!!! 
d1927 1
a1927 1
        /* now open File again for more reductions !!!!! 
d1950 1
a1950 1
            /* now open File again for more reductions !!!!! 
@


1.18
log
@another test check-in (IGNORE)
@
text
@d2 3
d282 1
a282 1
#if (nCUBE && D_MESS && D_MCOMMU)
d294 1
a294 1
#if (nCUBE && D_MESS && D_MCOMMU)
d322 1
a322 1
#if (nCUBE && D_MESS && D_MCOMMU)
d697 1
a697 1
#if (nCUBE && D_MESS && D_MCOMMU)
d726 1
a726 1
#if (nCUBE && D_MESS && D_MCOMMU)
d756 1
a756 1
#if (nCUBE && D_MESS && D_MCOMMU)
d836 1
a836 1
#if (nCUBE && D_MESS && D_MCOMMU)
d900 1
a900 1
#if (nCUBE && D_MESS && D_MSCHED)
d1397 1
a1397 1
#if (nCUBE && D_MESS && D_MSCHED)
d1415 1
a1415 1
#if (nCUBE && D_MESS && D_MSCHED)
d1941 1
a1941 1
#if (nCUBE && D_MESS && D_MCOMMU)
d1979 1
a1979 1
#if (nCUBE && D_MESS && D_MCOMMU)
@


1.17
log
@test check in - ignore
@
text
@d1 2
a2 1
/* $Log */
@


1.16
log
@Version mit eigenst. Komunikation fuer die Steuerung durch
Neuronale Netze
@
text
@d1 2
@


1.15
log
@Neue Message-Typen fuer Verteilung durch Neur. Netze (#if D_NN_SCHED ... )
@
text
@d12 9
a20 4
#if D_NN_SCHED
#include "nc_nn_sched.h"
extern float *Net_Input;
static char DBUG_HELP_STR[256];                           
a22 1

a307 40
#if D_NN_SCHED
/* --------------------------  D_NN_SCHED      ------------------------- */

/* --- MT_STAT_REQ - Message ------------------------------------------ */

 if (type == MT_STAT_REQ) {
#ifdef D_MESS_ONLY
    m_type = "MT_STAT_REQ";
#if (nCUBE && D_MESS && D_MCOMMU)
    if (m_msg_send_begin)
       MPRINT_SEND_BEGIN(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID,
                          m_type, dest, m_pid);
#endif
#endif
   DBUG_PRINT("NN",("MT_STAT_REQ to Node %d", dest));
   nwrite((char *)(&proc_id), sizeof(int), dest, type, &flags); 
   DBUG_VOID_RETURN;
 }


/* --- MT_STAT_SEND - Message ----------------------------------------- */

 if (type == MT_STAT_SEND) {
   DBUG_PRINT("NN",("MT_STAT_SEND"));
#ifdef D_MESS_ONLY
    m_type = "MT_STAT_SEND";
#if (nCUBE && D_MESS && D_MCOMMU)
    if (m_msg_send_begin)
       MPRINT_SEND_BEGIN(D_MESS_FILE, M_TIMER, PROCESS_NR, PROCESS_PID,
                          m_type, dest, m_pid);
#endif
#endif
   nwrite(&proc_id, sizeof(int), dest, type, &flags); 
   nwrite(&(proc_stat[P_RUN]), sizeof(int), dest, type, &flags); 
   nwrite(&(proc_stat[P_READY]), sizeof(int), dest, type, &flags); 
   nwrite(&(proc_stat[P_WAIT]), sizeof(int), dest, type, &flags); 
   DBUG_VOID_RETURN;
 }
#endif

d747 1
a747 1
   T_DEC_REFCNT((T_PTD)result_stelem);
a822 5
#if D_NN_SCHED
  int proc_org = 0;
  int receive=0;
#endif

a871 38
#if D_NN_SCHED
    /* ------------------ D_NN_SCHED -------------------------------- */
    case MT_STAT_REQ :
     DBUG_PRINT("NN",("MT_STAT_REQ "));
     proc_org = (int) DO_RECEIVE();
     DBUG_PRINT("NN",("from Proc %d",proc_org));
#if (nCUBE && D_MESS && D_MCOMMU)
       (*d_m_msg_send)(proc_org,MT_STAT_SEND);
#else
       msg_send(proc_org,MT_STAT_SEND);
#endif
       break;

    case MT_STAT_SEND :
       DBUG_PRINT("NN",("MT_STAT_SEND "));
       proc_org = (int) DO_RECEIVE();
       DBUG_PRINT("NN",("from Proc %d",proc_org));
       if ( (proc_org = Neighbours[proc_org]) == NO_NEIGHB) {
          post_mortem(" Illegal Neighbour to nCube Node ");
       }
       receive= (unsigned int)DO_RECEIVE();
       Net_Input[proc_org+Run_Offset] = ((float)receive / NN_SCALE);
       receive= (unsigned int)DO_RECEIVE();
       Net_Input[proc_org+Ready_Offset] = ((float )receive/NN_SCALE);
       receive= (unsigned int)DO_RECEIVE();
       Net_Input[proc_org+Wait_Offset] = ((float )receive/NN_SCALE);
       sprintf(DBUG_HELP_STR,"Running  %f \t Ready %f \t Waiting %f\n",
                        Net_Input[proc_org+Run_Offset],
                        Net_Input[proc_org+Ready_Offset],
                        Net_Input[proc_org+Wait_Offset]);
       DBUG_PRINT("NN",("%s",DBUG_HELP_STR));

       Message_SENT--;
       break;
    /* ------------------ D_NN_SCHED end ---------------------------- */
#endif 
    

d1386 1
d1389 1
d1956 4
a1959 2
{int source=-1,type=-1;
/*dmk tst*/ int erg=0;
d1963 10
a1972 1
   DBUG_PRINT("NN",("msg_check - erg : %d / type : %d " , erg, type)); 
d1974 1
a1974 1
  (*d_m_msg_receive)();
d1976 1
a1976 1
  msg_receive();
d1978 7
a1984 2
    source=type=-1;}
 sig_msg_flag = 0;}
@


1.14
log
@support for some strange constructions from old preprocessor added
@
text
@d12 6
d303 41
a346 1

d859 5
d913 38
a1015 1
 
d1017 1
a1017 1
	{if ((int)rec_addr & 1)
d1420 1
a1420 1
      if (rec_data*2 != chksum)
d1422 1
d1424 2
d1432 1
a1502 1

d2034 1
d2036 1
a2036 1
 while (ntest(&source,&type)>=0)
d2038 1
@


1.13
log
@PUSHH/POPH changed to R-Stack for tilde version
@
text
@d354 1
a354 1
	{if (!T_POINTER(send_data) || !isdesc(send_data))
d357 8
a364 4
	   {if (IS_STATIC(send_data))                       /* pointer into static heap? */
	      {DBUG_PRINT("STATHEAP",("sending %08x as static heap",send_data));
	       DO_SEND(0);
	       DO_SEND(((int)STATIC_OFFSET(send_data) << 4) | 0x0a);}     /* ...1010 as tag for offset in static heap */
d369 29
a397 29
	       else
	         {DO_SEND(0);
		  DO_SEND(0);                            /* tag for 'pointer to following descriptor' */

                  /* send class and type of descriptor packed into one int */

		  SEND_2_SHORTS((short)(d_class = R_DESC(*(T_PTD)send_data,class)),(short)(d_type = R_DESC(*(T_PTD)send_data,type)));

		  /* refcount doesn`t need to be sent, will be set to 1 on dest processor */
		  /* and now: the main part of sending: the descriptor bodies */
		  switch(d_class)
		    {case C_SCALAR:
		       DO_SEND(R_SCALAR(*(T_PTD)send_data,vali));
		       if (type == MT_END_RESULT)
			 {DO_SEND(*((int *)A_SCALAR(*(T_PTD)send_data,valr) + 1));
			  DO_SEND(*(int *)A_SCALAR(*(T_PTD)send_data,valr));}
		       else
			 {DO_SEND(*(int *)A_SCALAR(*(T_PTD)send_data,valr));
			  DO_SEND(*((int *)A_SCALAR(*(T_PTD)send_data,valr) + 1));}
		       break;
		     case C_DIGIT:
		       SEND_2_SHORTS(R_DIGIT(*(T_PTD)send_data,sign),R_DIGIT(*(T_PTD)send_data,ndigit));
		       heap_elems = (int)R_DIGIT(*(T_PTD)send_data,ndigit);
		       DO_SEND(R_DIGIT(*(T_PTD)send_data,Exp));
		       heap_ptr = R_DIGIT(*(T_PTD)send_data,ptdv);
		       for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			 DO_SEND(*heap_ptr);
		       break;
		     case C_LIST:
d444 14
a457 5
			    heap_elems = *(int *)R_FUNC(*(T_PTD)send_data,pte);
			    heap_ptr = R_FUNC(*(T_PTD)send_data,pte) + 1;
			    DO_SEND(heap_elems);
			    for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
			      D_PUSHSTACK(D_S_hilf,*heap_ptr);
d520 5
a524 1
			    for (heap_counter=0;heap_counter < heap_elems;heap_counter++,heap_ptr++)
d654 5
a658 4
		}                           /* else {descriptor not sent yet}*/
	     }                              /* else {not in static heap} */
	  }                                 /* else {pointer on stack} */
       }                                    /* while */
d957 21
a977 43
	       else                    /* a new descriptor will follow */
		 {RECEIVE_2_SHORTS(new_class,new_type);
		  MAKEDESC(new_desc,1,new_class,new_type);
		  *rec_addr = (int)new_desc;
		  DBUG_PRINT("MSG",("receiving desc for address %x: class %d, type %d",rec_addr,new_class,new_type));
		  switch(new_class)
		    {case C_SCALAR:
		       L_SCALAR(*new_desc,vali) = DO_RECEIVE();
		       *((int *)A_SCALAR(*new_desc,valr)) = DO_RECEIVE();
		       *((int *)A_SCALAR(*new_desc,valr) + 1) = DO_RECEIVE();
		       break;
		     case C_DIGIT:
		       RECEIVE_2_SHORTS(L_DIGIT(*new_desc,sign),L_DIGIT(*new_desc,ndigit));
		       L_DIGIT(*new_desc,Exp) = DO_RECEIVE();
		       heap_elems = R_DIGIT(*new_desc,ndigit);
		       GET_HEAP(heap_elems,A_DIGIT(*new_desc,ptdv));
		       new_heap = R_DIGIT(*new_desc,ptdv);
		       for (heap_counter = 0;heap_counter < heap_elems;heap_counter++,new_heap++)
			 *new_heap = DO_RECEIVE();
		       break;
		     case C_LIST:
		       RECEIVE_2_SHORTS(L_LIST(*new_desc,special),L_LIST(*new_desc,dim));
		       L_LIST(*new_desc,ptdd) = NULL;
		       D_PUSHSTACK(D_S_hilf,heap_elems = R_LIST(*new_desc,dim));
		       GET_HEAP(heap_elems,A_LIST(*new_desc,ptdv));
		       new_heap = R_LIST(*new_desc,ptdv);
		       D_PUSHSTACK(D_S_hilf,((int)(new_heap + (heap_elems - 1)) << 1) | 1);
		       break;
		     case C_MATRIX:
		     case C_VECTOR:
		     case C_TVECTOR:
		       RECEIVE_2_SHORTS(L_MVT(*new_desc,nrows,new_class),L_MVT(*new_desc,ncols,new_class));
		       L_MVT(*new_desc,ptdd,new_class) = NULL;
		       if ((_formated == 1) && (new_type != TY_STRING))
			 {heap_elems = (R_MVT(*new_desc,nrows,new_class)*R_MVT(*new_desc,ncols,new_class));
			  if (new_type == TY_REAL)
			    heap_elems *= 2;}
		       else
			 D_PUSHSTACK(D_S_hilf,heap_elems = (R_MVT(*new_desc,nrows,new_class)*R_MVT(*new_desc,ncols,new_class)));
		       GET_HEAP(heap_elems,A_MVT(*new_desc,ptdv,new_class));
		       new_heap = R_MVT(*new_desc,ptdv,new_class);
		       if ((_formated == 1) && (new_type != TY_STRING))
			 for(;heap_elems >0;heap_elems--,new_heap++)
d979 43
a1021 122
		       else
			 D_PUSHSTACK(D_S_hilf,((int)(new_heap + (heap_elems -1)) << 1) | 1);
		       break;
		     case C_EXPRESSION:
		     case C_CONSTANT:
		       switch(new_type)
			 {case TY_REC:
			  case TY_ZF:
			  case TY_SUB:
			    RECEIVE_2_SHORTS(L_FUNC(*new_desc,special),L_FUNC(*new_desc,nargs));
			    if ((heap_elems = DO_RECEIVE()) >= 0)
			      {
#if WITHTILDE
				counter = DO_RECEIVE();
				if (counter > 0)
				  D_PUSHSTACK(D_S_hilf,counter-2);
				else
				  D_PUSHSTACK(D_S_hilf,heap_elems-1);
#else
				if (heap_elems >0)
				 D_PUSHSTACK(D_S_hilf,heap_elems);
#endif
				GET_HEAP(heap_elems+1,A_FUNC(*new_desc,namelist));
				new_heap = R_FUNC(*new_desc,namelist);
				*new_heap = heap_elems;
#if WITHTILDE
				*(++new_heap)=counter;
				if (counter > 0)
				  {D_PUSHSTACK(D_S_hilf,((int)(new_heap + counter - 2) << 1) | 1);
				   for (;heap_elems>counter-1;heap_elems--)
				     *(new_heap + heap_elems - 1)=DO_RECEIVE();}
				else
				  D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems - 1) << 1) | 1);
#else
				if (heap_elems >0)
				  D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
#endif
			  }
			    else
			      L_FUNC(*new_desc,namelist) = NULL;
			    heap_elems = DO_RECEIVE();
			    D_PUSHSTACK(D_S_hilf,heap_elems);
			    GET_HEAP(heap_elems+1,A_FUNC(*new_desc,pte));
			    new_heap = R_FUNC(*new_desc,pte);
			    *new_heap = heap_elems;
			    D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			    break;
#if WITHTILDE
			  case TY_SNSUB:
			    RECEIVE_2_SHORTS(L_FUNC(*new_desc,special),L_FUNC(*new_desc,nargs));
			    L_FUNC(*new_desc,namelist) = NULL;
			    heap_elems = DO_RECEIVE();
			    D_PUSHSTACK(D_S_hilf,heap_elems);
			    GET_HEAP(heap_elems+1,A_FUNC(*new_desc,pte));
			    new_heap = R_FUNC(*new_desc,pte);
			    *new_heap = heap_elems;
			    D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			    break;
#endif
			  case TY_ZFCODE:
			    RECEIVE_2_SHORTS(L_ZFCODE(*new_desc,zfbound),L_ZFCODE(*new_desc,nargs));
			    D_PUSHSTACK(D_S_hilf,(int)A_ZFCODE(*new_desc,ptd) << 1);
			    heap_elems = DO_RECEIVE();
			    D_PUSHSTACK(D_S_hilf,heap_elems);
			    GET_HEAP(heap_elems+1,A_ZFCODE(*new_desc,varnames));
			    new_heap = R_ZFCODE(*new_desc,varnames);
			    *new_heap = heap_elems;
			    D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			    break;
			  case TY_COND:
			    L_COND(*new_desc,special) = DO_RECEIVE();
			    heap_elems = DO_RECEIVE();
			    D_PUSHSTACK(D_S_hilf,heap_elems);
			    GET_HEAP(heap_elems+1,A_COND(*new_desc,ptte));
			    new_heap = R_COND(*new_desc,ptte);
			    *new_heap = heap_elems;
			    D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			    heap_elems = DO_RECEIVE();
			    D_PUSHSTACK(D_S_hilf,heap_elems);
			    GET_HEAP(heap_elems+1,A_COND(*new_desc,ptee));
			    new_heap = R_COND(*new_desc,ptee);
			    *new_heap = heap_elems;
			    D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			    break;
			  case TY_VAR:
			    L_VAR(*new_desc,nlabar) = DO_RECEIVE();
			    D_PUSHSTACK(D_S_hilf,(int)A_VAR(*new_desc,ptnd) << 1);
			    break;
			  case TY_EXPR:
			    heap_elems = DO_RECEIVE();
			    D_PUSHSTACK(D_S_hilf,heap_elems);
			    GET_HEAP(heap_elems+1,A_EXPR(*new_desc,pte));
			    new_heap = R_EXPR(*new_desc,pte);
			    *new_heap = heap_elems;
			    D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			    break;
			  case TY_NAME:
			    heap_elems = DO_RECEIVE();
			    D_PUSHSTACK(D_S_hilf,heap_elems);
			    GET_HEAP(heap_elems+1,A_NAME(*new_desc,ptn));
			    new_heap = R_NAME(*new_desc,ptn);
			    *new_heap = heap_elems;
			    D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			    break;
			  case TY_SWITCH:
#if WITHTILDE
			    RECEIVE_2_SHORTS(L_SWITCH(*new_desc,nwhen),L_SWITCH(*new_desc,anz_args));
			    L_SWITCH(*new_desc,casetype) = DO_RECEIVE();
#else
			    RECEIVE_2_SHORTS(L_SWITCH(*new_desc,special),L_SWITCH(*new_desc,case_type));
			    L_SWITCH(*new_desc,nwhen) = DO_RECEIVE();
#endif
			    heap_elems = DO_RECEIVE();
			    D_PUSHSTACK(D_S_hilf,heap_elems);
			    GET_HEAP(heap_elems+1,A_SWITCH(*new_desc,ptse));
			    new_heap = R_SWITCH(*new_desc,ptse);
			    *new_heap = heap_elems;
			    D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			    break;
			  case TY_NOMAT:
#if WITHTILDE
			    RECEIVE_2_SHORTS(L_NOMAT(*new_desc,act_nomat),L_NOMAT(*new_desc,reason));
d1023 2
a1024 1
			    L_NOMAT(*new_desc,act_nomat) = DO_RECEIVE();
d1026 9
a1034 41
			    if ((heap_elems = DO_RECEIVE()) >= 0)
			      {D_PUSHSTACK(D_S_hilf,heap_elems);
			       GET_HEAP(heap_elems+1,A_NOMAT(*new_desc,guard_body));
			       new_heap = R_NOMAT(*new_desc,guard_body);
			       *new_heap = heap_elems;
			       D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);}
			    else
			      L_NOMAT(*new_desc,guard_body) = NULL;
			    D_PUSHSTACK(D_S_hilf,(int)A_NOMAT(*new_desc,ptsdes) << 1);
			    break;
			  case TY_MATCH:
			    heap_elems = DO_RECEIVE();
			    if (heap_elems >= 0)
			      {if (heap_elems > 0)
				 D_PUSHSTACK(D_S_hilf,heap_elems);
			       GET_HEAP(heap_elems+1,A_MATCH(*new_desc,guard));
			       new_heap = R_MATCH(*new_desc,guard);
			       *new_heap = heap_elems;
			       if (heap_elems > 0)
				 D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);}
			    else
			      L_MATCH(*new_desc,guard) = NULL;
			    heap_elems = DO_RECEIVE();
			    if (heap_elems >= 0)
			      {if (heap_elems > 0)
				 D_PUSHSTACK(D_S_hilf,heap_elems);
			       GET_HEAP(heap_elems+1,A_MATCH(*new_desc,body));
			       new_heap = R_MATCH(*new_desc,body);
			       *new_heap = heap_elems;
			       if (heap_elems > 0)
				 D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);}
			    else
			      L_MATCH(*new_desc,body) = NULL;
			    if ((heap_elems = DO_RECEIVE()) >= 0)
			      {GET_HEAP(heap_elems+1,A_MATCH(*new_desc,code));
			       new_heap = R_MATCH(*new_desc,code);
			       *new_heap++ = heap_elems;
			       for (heap_counter = 0;heap_counter < heap_elems; heap_counter++)
				 {rec_data = DO_RECEIVE();
				  if (rec_data == PM_DESC_MARKER)
				    D_PUSHSTACK(D_S_hilf,((int)new_heap++) << 1);
d1036 1
a1036 15
				    *new_heap++ = rec_data;}}
			    else
			      L_MATCH(*new_desc,code) = NULL;
			    break;
			  case TY_LREC:
			    L_LREC(*new_desc,nfuncs) = DO_RECEIVE();
			    heap_elems = DO_RECEIVE();
			    D_PUSHSTACK(D_S_hilf,heap_elems);
			    GET_HEAP(heap_elems+1,A_LREC(*new_desc,namelist));
			    new_heap = R_LREC(*new_desc,namelist);
			    *new_heap = heap_elems;
			    D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);
			    D_PUSHSTACK(D_S_hilf,heap_elems = R_LREC(*new_desc,nfuncs));
#if WITHTILDE
			    GET_HEAP(heap_elems+1,A_LREC(*new_desc,ptdv));
d1038 2
a1039 1
			    GET_HEAP(heap_elems,A_LREC(*new_desc,ptdv));
d1041 13
a1053 1
			    new_heap = R_LREC(*new_desc,ptdv);
d1055 3
a1057 1
			    *new_heap++ = R_LREC(*new_desc,nfuncs);
d1059 1
a1059 21
			    D_PUSHSTACK(D_S_hilf,((int)(new_heap + (heap_elems - 1)) << 1) | 1);
			    break;
			  case TY_LREC_IND:
			    L_LREC_IND(*new_desc,index) = DO_RECEIVE();
			    D_PUSHSTACK(D_S_hilf,(int)A_LREC_IND(*new_desc,ptdd) << 1);
			    D_PUSHSTACK(D_S_hilf,(int)A_LREC_IND(*new_desc,ptf) << 1);
			    break;
			  case TY_LREC_ARGS:
			    L_LREC_ARGS(*new_desc,nargs) = DO_RECEIVE();
			    D_PUSHSTACK(D_S_hilf,(int)A_LREC_ARGS(*new_desc,ptdd) << 1);
			    D_PUSHSTACK(D_S_hilf,heap_elems = R_LREC_ARGS(*new_desc,nargs));
			    GET_HEAP(heap_elems,A_LREC_ARGS(*new_desc,ptdv));
			    new_heap = R_LREC_ARGS(*new_desc,ptdv);
			    D_PUSHSTACK(D_S_hilf,((int)(new_heap + (heap_elems - 1)) << 1) | 1);
			    break;}
		       break;
		     case C_FUNC:
		     case C_CONS:
		       switch(new_type)
			 {case TY_CLOS:
			    RECEIVE_2_SHORTS(L_CLOS(*new_desc,args),L_CLOS(*new_desc,nargs));
d1061 266
a1326 99
			    RECEIVE_2_SHORTS(L_CLOS(*new_desc,ftype),L_CLOS(*new_desc,nfv));
#else
			    L_CLOS(*new_desc,ftype) = DO_RECEIVE();
#endif
			    D_PUSHSTACK(D_S_hilf,heap_elems = R_CLOS(*new_desc,args) + 1);
			    GET_HEAP(heap_elems,A_CLOS(*new_desc,pta));
			    new_heap = R_CLOS(*new_desc,pta);
			    D_PUSHSTACK(D_S_hilf,((int)(new_heap + (heap_elems - 1)) << 1) | 1);
			    break;
			  case TY_COMB:
			    RECEIVE_2_SHORTS(L_COMB(*new_desc,args),L_COMB(*new_desc,nargs));
			    D_PUSHSTACK(D_S_hilf,(int)A_COMB(*new_desc,ptd) << 1);
			    if ((type != MT_NEW_GRAPH) || code_received)
			      L_COMB(*new_desc,ptc) = (PTR_HEAPELEM)(GET_CODE_START() + DO_RECEIVE());
			    else
			      {heap_elems = DO_RECEIVE();
			       GET_HEAP(heap_elems+1,A_COMB(*new_desc,ptc));
			       new_heap = R_COMB(*new_desc,ptc);
			       goto receive_code;}
			    break;
			  case TY_CONDI:
			    RECEIVE_2_SHORTS(L_CONDI(*new_desc,args),L_CONDI(*new_desc,nargs));
			    D_PUSHSTACK(D_S_hilf,(int)A_CONDI(*new_desc,ptd) << 1);
			    if ((type != MT_NEW_GRAPH) || code_received)
			      L_CONDI(*new_desc,ptc) = (PTR_HEAPELEM)GET_CODE_START() + DO_RECEIVE();
			    else
			      {heap_elems = DO_RECEIVE();
			       GET_HEAP(heap_elems+1,A_CONDI(*new_desc,ptc));
			       new_heap = R_CONDI(*new_desc,ptc);
			       goto receive_code;}
			    break;
			  case TY_CONS:
			    D_PUSHSTACK(D_S_hilf,(int)A_CONS(*new_desc,hd) << 1);
			    D_PUSHSTACK(D_S_hilf,(int)A_CONS(*new_desc,tl) << 1);
			    break;
			  case TY_CASE:
			  case TY_WHEN:
			  case TY_GUARD:
			  case TY_BODY:
			    RECEIVE_2_SHORTS(L_CASE(*new_desc,args),L_CASE(*new_desc,nargs));
			    D_PUSHSTACK(D_S_hilf,(int)A_CASE(*new_desc,ptd) << 1);
			    if ((type != MT_NEW_GRAPH) || code_received)
			      L_CASE(*new_desc,ptc) = GET_CODE_START() + DO_RECEIVE();
			    else
			      {heap_elems = DO_RECEIVE();
			       GET_HEAP(heap_elems+1,A_CASE(*new_desc,ptc));
			       new_heap = R_CASE(*new_desc,ptc);
receive_code:
			       code_address = new_heap;
			       for (heap_counter = 1;heap_counter < heap_elems; heap_counter ++)
				 {*new_heap = DO_RECEIVE();
				  rec_instr = instr_tab[*new_heap++];
				  switch(rec_instr.paramtype)
				    {case NUM_PAR:
				       /* Here is our special case again, see msg_send */
				       if ((rec_instr.instruction == I_DIST) || (rec_instr.instruction == I_DISTB))
					 {*(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
					  *(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
					  *(new_heap++) = DO_RECEIVE();
					  *(new_heap++) = DO_RECEIVE();
#if WITHTILDE
					  *(new_heap++) = DO_RECEIVE();
					  *(new_heap++) = DO_RECEIVE();
					  heap_counter += 6;
#else
					  heap_counter += 4;
#endif
					  break;}
				     case ATOM_PAR:
				     case FUNC_PAR:
				       for (param_counter = 0;param_counter < rec_instr.nparams;param_counter++)
					 {*(new_heap++) = DO_RECEIVE();
					  heap_counter ++;}
				       break;
				     case DESC_PAR:
				       D_PUSHSTACK(D_S_hilf,(int)(new_heap++) << 1);
				       heap_counter++;
				       break;
				     case ADDR_PAR:
				       *(new_heap++) = (T_HEAPELEM)(code_address + DO_RECEIVE());
				       heap_counter++;
				       break;
				     }                                  /* switch */
				}                                       /* for */
			       *new_heap = I_SYMTAB;
			       code_received = 1;
			       SET_CODE_START(code_address);
			     }                                          /* else {code not received} */
			    break;
			  }                                             /* switch (new_type) */
		       break;
		     }                                                  /* switch (new_class) */
		  received_list[received_index++] = new_desc;
		  if (received_index == rec_list_size)
		    {rec_list_size += 256;
		     received_list = (T_PTD *)realloc(received_list,rec_list_size * sizeof(T_PTD));
		     if (!received_list)
		       post_mortem("insufficient memory for received_list");}
		}                                                       /* else {descriptor not received yet} */
@


1.12
log
@message routined adapted to tilde descriptors
@
text
@d150 1
d316 3
d320 1
d324 1
a324 1
      D_PUSHSTACK(D_S_hilf,ST_END_MARKER);     /* push marker on H-stack */     
d345 2
a346 13
      if (dist_type == DIST_N)              /* send full stack frame? */
	for (;stack_index<stack_elems;stack_index++)
	  D_PUSHSTACK(D_S_hilf,D_MIDSTACK(*ps_t,stack_index));
      else                                  /* send only needed args */
	{while (stack_elems>0)
	   {if (stack_elems & 1)
	      D_PUSHSTACK(D_S_hilf,D_MIDSTACK(*ps_t,stack_index));
	   else
	     D_PUSHSTACK(D_S_hilf,ST_DUMMY);
	    stack_elems >>= 1;
	    stack_index++;}
	 for (;stack_index<dist_tilde_free;stack_index++)
	   D_PUSHSTACK(D_S_hilf,ST_DUMMY);}
@


1.11
log
@small changes due to undocumented tilde features
@
text
@d517 3
d521 1
d596 3
d600 1
d1109 3
d1113 1
d1199 3
d1203 1
@


1.10
log
@more bug fixes
@
text
@d452 10
d566 3
d570 1
d1028 12
d1157 3
d1161 1
d1163 3
d1244 5
d1250 1
@


1.9
log
@even more bugfixes for tilde-picard
@
text
@d660 4
d666 1
d862 5
d870 1
@


1.8
log
@support for DIST, DISTB in tilde version added
@
text
@d337 1
d339 1
a339 1
      D_PUSHSTACK(D_S_hilf,ST_END_MARKER);     /* push marker on H-stack */     
@


1.7
log
@bug in messages removed
@
text
@d135 4
d148 3
d335 20
d870 10
d984 1
a984 1
				   for (;heap_elems<counter-1;heap_elems--)
@


1.6
log
@first beta release of distributed tilde-version
@
text
@d404 5
d410 6
a415 1
				 D_PUSHSTACK(D_S_hilf,*heap_ptr);}
d462 1
a462 1
			      D_PUSHSTACK(D_S_hilf,*heap_ptr);
d929 9
a937 1
			      {if (heap_elems >0)
d939 17
a955 5
			       GET_HEAP(heap_elems+1,A_FUNC(*new_desc,namelist));
			       new_heap = R_FUNC(*new_desc,namelist);
			       *new_heap = heap_elems;
			       if (heap_elems >0)
				 D_PUSHSTACK(D_S_hilf,((int)(new_heap + heap_elems) << 1) | 1);}
@


1.5
log
@ps_i, ps_a changed to ps_a, ps_w
@
text
@d455 4
d461 1
d981 4
d987 1
@


1.4
log
@removed warnings update
@
text
@a141 1
extern DStackDesc *ps_i;             /* rncinter.c */
d143 1
d307 1
a307 1
      DO_SEND((int)D_TOP_ADDRESS(*ps_a));                     /* where to put the result */
d315 1
a315 1
	  D_PUSHSTACK(D_S_hilf,D_MIDSTACK(*ps_i,stack_index));
d319 1
a319 1
	      D_PUSHSTACK(D_S_hilf,D_MIDSTACK(*ps_i,stack_index));
d611 2
a612 2
			R_DESC(*((T_PTD)*(ps_a->TopofStack)),class),
			R_DESC(*((T_PTD)*(ps_a->TopofStack)),type)));
d621 1
a621 1
      result_stelem = D_POPSTACK(*ps_a);
d635 2
a636 2
			     R_DESC(*((T_PTD)*(ps_a->TopofStack)),class),
			     R_DESC(*((T_PTD)*(ps_a->TopofStack)),type)));
d640 1
a640 1
      result_stelem = D_POPSTACK(*ps_a);
@


1.3
log
@MT_TERMINATE implemented
@
text
@d36 1
a36 1
extern int freeheap();
d603 1
a603 1
      m_pid = PC_GET_PPID(curr_pid);
d792 1
a792 1
  m_pid = ppid;
d809 1
a809 1
      f_pid = new_pid;
d1190 1
a1190 1
  f_pid = rec_pid;
d1229 1
a1229 1
         f_pid = new_pid;
d1276 1
a1276 1
      strcpy(m_mesfilehea, buffer_p);
d1278 1
a1278 1
      buffer_p += ((strlen(m_mesfilehea)+strlen(m_mesfilepath)+2)/4)+1;
d1280 1
a1280 1
m_mesfilepath, strlen(m_mesfilepath), ((strlen(m_mesfilehea)+strlen(m_mesfilepath)+2)/4)+1)); 
@


1.2
log
@check C-macro measurement configuration and produce an error
when trying to switch on disabled C-function-measurements
@
text
@d771 1
a771 1
  m_type = "MT_ABORT";
a775 3
/*  
      exit(0);
*/
d780 4
d1803 1
a1803 1
    if (type == MT_PARAM)
@


1.1
log
@Initial revision
@
text
@d54 5
d1294 1
a1294 1
#if D_MHEAP
d1298 3
d1307 3
d1316 3
d1325 3
d1334 3
d1341 1
a1341 1
#endif /* D_MHEAP */
d1343 1
a1343 1
#if D_MSTACK
d1347 3
d1356 3
d1365 3
d1374 3
d1381 1
a1381 1
#endif /* D_MSTACK */
d1383 1
a1383 1
#if D_MSCHED
d1387 3
d1396 3
d1405 3
d1414 3
d1423 3
d1432 3
d1439 1
a1439 1
#endif /* D_MSCHED */
d1441 1
a1441 1
#if D_MCOMMU
d1448 3
d1458 3
d1468 3
d1478 3
d1486 1
a1486 1
#endif /* D_MCOMMU */ 
@
