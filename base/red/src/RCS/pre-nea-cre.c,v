head	1.3;
access;
symbols
	continuation_based_interactions:1.1
	pre_interactions:1.1
	nCUBE~:1.1;
locks; strict;
comment	@ * @;


1.3
date	2001.07.02.15.32.29;	author base;	state Exp;
branches;
next	1.2;

1.2
date	98.02.18.13.34.36;	author rs;	state Exp;
branches;
next	1.1;

1.1
date	94.03.08.15.08.59;	author mah;	state Exp;
branches;
next	;


desc
@tilde version
@


1.3
log
@compiler warning eliminated
@
text
@/* $Log: pre-nea-cre.c,v $
 * Revision 1.2  1998/02/18 13:34:36  rs
 * modifications for speculative evaluations regarding
 * meaning preserving transformations
 *
 * Revision 1.1  1994/03/08  15:08:59  mah
 * Initial revision
 *
 * Revision 1.1  1994/03/08  14:27:28  mah
 * Initial revision
 * */
/**********************************************************************/
/*  ea-create.c  - external:  ea_create;                              */
/*         Aufgerufen durch:  reduct;                                 */
/*                            preproc                                 */
/*  ea-create.c  - internal:                                          */
/**********************************************************************/

#include "rstdinc.h"
#include "rstackty.h"
#include "rheapty.h"
#include "rstelem.h"
#include "rextern.h"
#include <setjmp.h>
#include <malloc.h>
#include "list.h"
#include "dbug.h"


/**********************************************************************/
/* Spezielle externe Routinen:                                        */
/**********************************************************************/


extern PTR_DESCRIPTOR          newdesc();             /* rheap.c      */
extern STACKELEM               st_list();             /* rstpre.c     */   
extern STACKELEM               st_vare();
extern STACKELEM               st_cond();            
extern STACKELEM               st_expr();
extern int                      mvheap();             /* rhinout.c    */     
extern void                    subfunc();             /* subfunc.c    */ 
extern void                   condfunc();             /* cond-func.c  */
extern void                   lrecfunc();             /* lrecfunc.c   */
extern void                   casefunc();             /* casefunc.c   */    
extern BOOLEAN    check_list_for_store();      
extern void                   list_end();
extern void                 fvlist_end();
extern void            free_funct_name();
extern void                   free_arg();
extern void                   test_var();
extern void                        eac();
extern void                stack_error();
extern STACKELEM            *ppopstack();
extern int                   test_cond();

extern int makestrdesc();

/**********************************************************************/
/*    externe Variable                                                */
/**********************************************************************/

extern BOOLEAN    _interrupt;     /* reduct.c */
extern jmp_buf _interruptbuf;     /* reduct.c */

extern list            *VAR;
extern fvlist           *FV;
extern arglist         *ARG;

#if D_SPEC
extern PTR_DESCRIPTOR spec_string1, spec_string2;
#endif



/**********************************************************************/ 
/*  ea_create  --  Preprocessed einen auf dem E-Stack liegenden       */
/*                 Ausdruck, und liefert den Ergebnisausdruck auf     */
/*                 dem A-Stack ab.                                    */
/**********************************************************************/

void ea_create()
{
  register STACKELEM           x,y;
  register unsigned short    arity;
  extern   jmp_buf   _interruptbuf;                       /* reduct.c */

  START_MODUL("ea_create");

  setjmp(_interruptbuf);         /* Interruptbehandlung Preprocessing */
  if (_interrupt)                                /* Interrupt erfolgt */
  {
    _interrupt = FALSE;
    post_mortem("ea_create: Interrupt received");
  }

  eac();                          /* lagere alle konstanten aus       */       

  PUSHSTACK(S_m,DOLLAR);                               /* Ende-Symbol */ 
  
  /* Initialiesieren der Listen, in denen die Bindungsstrukturen nach-*/
  /* gehalten werden                                                  */
                        
      VAR=NULL;
      FV=NULL;
      ARG=NULL;
      list_end(TRUE);
      fvlist_end();

   main_e:

   x = READSTACK(S_e);
                                                
   /*  aeussere Funktionen enthalten keine relativ freien Variablen   */       
   /*  und sind somit nicht zu schliessen => Aufruf von subfunc, etc  */
   /*  mit dem Parameter close gleich FALSE : in FV wird kein neuer   */
   /*  Block angelegt                                                 */

   if (T_SUB(x))
   {
       fvlist_end();
       subfunc(FALSE);
       goto main_e;
   }

   if (T_LREC(x))  
   {
     if (ARITY(x)==3)
     {
        fvlist_end();
        lrecfunc(FALSE,0);
     }
     else
     {
        PPOPSTACK(S_e);
        PUSHSTACK(S_m,x);
        PUSHSTACK(S_m1,x);
     }
     goto main_e;
   }

   if (T_PM_CASE(x)) 
   {
      fvlist_end();
      casefunc(FALSE,FALSE,0);
      goto main_e;
   }                    

   if (T_PM_WHEN(x))
   {
      fvlist_end();
      casefunc(FALSE,TRUE,0);
      goto main_e;
   }                    

   if (T_PROTECT(x) ||
       ((T_POINTER(x)) && (R_DESC((*(PTR_DESCRIPTOR)x),type)) == TY_NAME))
   {
     if (T_KLAA((STACKELEM)VAR->var))
     {
        y=st_vare();
        PUSHSTACK(S_a,y);                                             
                                 /* absolut freie Variable            */
     }
     else
       test_var(x);

     goto main_m;
   } 

   if (T_CON(x)) 
   {
     if (ARITY(x) >0 )
     {
        PPOPSTACK(S_e);
        PUSHSTACK(S_m,x);
        PUSHSTACK(S_m1,x);
        goto main_e;
     }
     else
     {
       PPOPSTACK(S_e);
       PUSHSTACK(S_a,x);
       goto main_m;         
     }
   } 


   if (T_POINTER(x))  
   {
      PPOPSTACK(S_e);
      PUSHSTACK(S_a,x);
      goto main_m;
   }
    
   if (T_ATOM(x)) 
   {
      PPOPSTACK(S_e);
      PUSHSTACK(S_a,x);
      goto main_m;    
   }

   post_mortem("ea_create: No match successful on main_e");

   main_m:

   x = READSTACK(S_m);
   arity = ARITY(x);                                                   

   if (arity > 1)            /* dh die Arity des Konstruktors war >= 2 */
   {
     WRITE_ARITY(S_m,arity-1);
     goto main_e;
   }   

   if (arity > 0)                              /* DOLLAR hat arity = 0 */
   {
      PPOPSTACK(S_m);
      x = POPSTACK(S_m1);
      PUSHSTACK(S_a,x);

      if ( T_LREC(x) )
      { 
        /* lrec(1) auf m , d.h. Startausdruck fertig bearbeitet        */
        /* Fkt-namen aus der Liste der gebundenen Var aushaengen       */

           free_funct_name();
           free_arg();
      }
      
      if (T_COND(x))                          /* conditional auslagern */
      {
         y = st_cond(); 
         PUSHSTACK(S_a,y); 
      }
                          
      if ( (T_LIST(x))||(T_STRING(x)) ) 
#if D_SPEC
      {
      if (ARITY(x)>1) {
        START_MODUL("s_case check");
        trav_a_e(); /* so we can access the list's name */

        y = MIDSTACK(S_e, 1);

        DBUG_PRINT("NEA", ("check for S_CASE-String: %x"));
 
DBUG_PRINT("NEA", ("spec_string1 is %x, spec_string2 is %x", spec_string1, spec_string2));

        if (T_POINTER(y) && (R_DESC(*(PTR_DESCRIPTOR)y,class)==C_LIST)
            && (R_DESC(*(PTR_DESCRIPTOR)y,type)==TY_STRING) &&
            (str_eq(y,spec_string1) || (str_eq(y,spec_string2)))) {
          DBUG_PRINT("NEA", ("It's a SCASE constructor..."));

    /*     if (str_eq(y,spec_string1)) {
            DBUG_PRINT("NEA", ("spec constructor 1 !"));
            POPSTACK(S_e);
            POPSTACK(S_e); 
            PUSHSTACK(S_e, SET_ARITY(P_SPECLIST1, ARITY(x)-1)); */

            POPSTACK(S_e);
            PUSHSTACK(S_e, SET_ARITY(P_SPECLIST1, ARITY(x)));

/*
            } else {
            DBUG_PRINT("NEA", ("spec constructor 2 !"));
            POPSTACK(S_e);
            POPSTACK(S_e);
            PUSHSTACK(S_e, SET_ARITY(P_SPECLIST2, ARITY(x)-1));
            } */

          trav_e_a();

         END_MODUL("s_case check");

         goto main_m;

          }

        trav_e_a();

        END_MODUL("s_case check");
        }

       DBUG_PRINT("NEA", ("no SCASE constructor..."));

#endif /* D_SPEC */

       if (check_list_for_store())   /* darf Liste ausgelagert werden? */
       {
         DBUG_PRINT("NEA", ("ok, this list can be stored..."));

         if ((x = st_list() ) == 0)              /* Wenn ja, auslagern */
            post_mortem("ea_create: heap out of space in st_list");
         else
            PUSHSTACK(S_a,x);
       }

#if D_SPEC
       }
#endif
      goto main_m;
   }   

   /* Ein DOLLAR. Dann ist ea_create zu beenden */
      PPOPSTACK(S_m);                                        /* DOLLAR */

   /* restliche Listenstrukturen freigeben   */
    
      free(VAR);     
      free(FV);    
  
   /* Goal-expression auf den Heap auslagern, damit   */
   /* nur ein Expression-Deskriptor uebrigbleibt fuer */
   /* ear                                             */

      if ((x = st_expr()) == 0)
        post_mortem("ea_create: st_expr failed");
      PUSHSTACK(S_e,x);

   /* nun den V-Stack von Namensdescriptoren befreien: */
   /* weitere Informationen in st_name.                */
   /* Refcountbehandlung ist nicht noetig.             */

      for (arity = SIZEOFSTACK(S_v); arity > 0; arity--)
      PPOPSTACK(S_v);

      END_MODUL("ea_create");
}

@


1.2
log
@modifications for speculative evaluations regarding
meaning preserving transformations
@
text
@d2 4
d56 1
a56 1
extern makestrdesc();
@


1.1
log
@Initial revision
@
text
@d2 3
d23 2
a24 1
 
d52 2
d65 3
d70 1
d232 52
a283 1
      if ( (T_LIST(x))||(T_STRING(x)) )
d286 2
d293 4
@
