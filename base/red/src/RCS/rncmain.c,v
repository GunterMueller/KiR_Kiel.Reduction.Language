head	1.30;
access;
symbols
	continuation_based_interactions:1.15
	pre_interactions:1.9
	nCUBE~:1.4;
locks; strict;
comment	@ * @;


1.30
date	99.11.25.11.58.18;	author rs;	state Exp;
branches;
next	1.29;

1.29
date	98.09.30.08.30.41;	author rs;	state Exp;
branches;
next	1.28;

1.28
date	98.09.24.13.12.10;	author rs;	state Exp;
branches;
next	1.27;

1.27
date	98.09.13.15.30.30;	author rs;	state Exp;
branches;
next	1.26;

1.26
date	98.06.03.16.20.07;	author rs;	state Exp;
branches;
next	1.25;

1.25
date	98.03.31.09.54.42;	author rs;	state Exp;
branches;
next	1.24;

1.24
date	98.02.27.15.00.48;	author rs;	state Exp;
branches;
next	1.23;

1.23
date	98.02.18.13.34.36;	author rs;	state Exp;
branches;
next	1.22;

1.22
date	97.11.24.08.19.48;	author rs;	state Exp;
branches;
next	1.21;

1.21
date	97.06.06.09.13.11;	author rs;	state Exp;
branches;
next	1.20;

1.20
date	97.04.14.09.52.06;	author rs;	state Exp;
branches;
next	1.19;

1.19
date	97.02.17.13.18.12;	author rs;	state Exp;
branches;
next	1.18;

1.18
date	96.06.11.15.27.46;	author rs;	state Exp;
branches;
next	1.17;

1.17
date	96.01.12.15.02.58;	author rs;	state Exp;
branches;
next	1.16;

1.16
date	95.12.06.10.25.44;	author rs;	state Exp;
branches;
next	1.15;

1.15
date	95.11.13.13.21.15;	author rs;	state Exp;
branches;
next	1.14;

1.14
date	95.10.20.13.22.31;	author rs;	state Exp;
branches;
next	1.13;

1.13
date	95.10.02.16.46.25;	author rs;	state Exp;
branches;
next	1.12;

1.12
date	95.09.22.12.46.38;	author rs;	state Exp;
branches;
next	1.11;

1.11
date	95.09.18.13.39.59;	author rs;	state Exp;
branches;
next	1.10;

1.10
date	95.09.11.14.21.28;	author rs;	state Exp;
branches;
next	1.9;

1.9
date	95.07.12.15.23.16;	author rs;	state Exp;
branches;
next	1.8;

1.8
date	95.07.10.09.15.38;	author car;	state Exp;
branches;
next	1.7;

1.7
date	95.07.07.15.15.17;	author rs;	state Exp;
branches;
next	1.6;

1.6
date	95.06.30.12.32.57;	author rs;	state Exp;
branches;
next	1.5;

1.5
date	95.05.22.09.53.25;	author rs;	state Exp;
branches;
next	1.4;

1.4
date	94.10.18.13.21.14;	author rs;	state Exp;
branches;
next	1.3;

1.3
date	94.09.30.16.17.14;	author rs;	state Exp;
branches;
next	1.2;

1.2
date	94.09.13.11.46.44;	author rs;	state Exp;
branches;
next	1.1;

1.1
date	93.09.01.12.37.17;	author base;	state Exp;
branches;
next	;


desc
@ANSI-version mit mess und verteilungs-Routinen
@


1.30
log
@more DEBUG output
@
text
@/* $Log: rncmain.c,v $
 * Revision 1.29  1998/09/30 08:30:41  rs
 * minor bugfixes in the speculative tickets version
 *
 * Revision 1.28  1998/09/24 13:12:10  rs
 * bugfixed version for SPEC_TICKETS + some more features
 *
 * Revision 1.27  1998/09/13 15:30:30  rs
 * first version supporting speculative evaluations with TICKETS
 *
 * Revision 1.26  1998/06/03 16:20:07  rs
 * speculative evaluations version 2 completed
 *
 * Revision 1.25  1998/03/31 09:54:42  rs
 * dbug-messages removed, ready for re-compilation
 *
 * Revision 1.24  1998/02/27 15:00:48  rs
 * further bugfixes on speculative evaluation (preliminary, beware of debug messages !)
 *
 * Revision 1.23  1998/02/18  13:34:36  rs
 * modifications for speculative evaluations regarding
 * meaning preserving transformations
 *
 * Revision 1.22  1997/11/24  08:19:48  rs
 * old version check-in
 *
 * Revision 1.21  1997/06/06  09:13:11  rs
 * some more (complete) modifications concerning speculative evaluation
 * (don't say you have missed my talk ? ;-)
 *
 * Revision 1.20  1997/04/14  09:52:06  rs
 * further work on speculative evaluation
 *
 * Revision 1.19  1997/02/17  13:18:12  rs
 * some additions supporting speculative evaluation
 *
 * Revision 1.18  1996/06/11  15:27:46  rs
 * some scheduling improvements
 *
 * Revision 1.17  1996/01/12  15:02:58  rs
 * set ADV_SCHED for the "advanced ticket scheduling", still under construction !
 *
 * Revision 1.16  1995/12/06  10:25:44  rs
 * some (final :-) changes for the nCUBE pvm version...
 *
 * Revision 1.15  1995/11/13  13:21:15  rs
 * some pvm + measure changes
 *
 * Revision 1.14  1995/10/20  13:22:31  rs
 * some ncube+pvm changes
 *
 * Revision 1.13  1995/10/02  16:46:25  rs
 * some more pvm + measure modifications
 *
 * Revision 1.12  1995/09/22  12:46:38  rs
 * additional pvm + measure changes
 *
 * Revision 1.11  1995/09/18  13:39:59  rs
 * pvm + measure changes
 *
 * Revision 1.10  1995/09/11  14:21:28  rs
 * some changes for the pvm measure version
 *
 * Revision 1.9  1995/07/12  15:23:16  rs
 * several pvm changes
 *
 * Revision 1.8  1995/07/10  09:15:38  car
 * main extracted to build nCUBE linkable modules
 *
 * Revision 1.7  1995/07/07  15:15:17  rs
 * additional pvm changes
 *
 * Revision 1.6  1995/06/30  12:32:57  rs
 * pvm changes (to be continued)
 *
 * */

/**************************************************************/
/*                                                            */
/* rncmain --- main program for the nCube                     */
/*                                                            */
/* ach 22/01/93                                               */
/*                                                            */
/**************************************************************/

#include "rheapty.h"
#include "rncstack.h"
#include "rncsched.h"
#include "rstdinc.h"
#include "rextern.h"
#include "rncmessage.h"
#include <signal.h>
#include <stdlib.h>
#if nCUBE
#include <nself.h>
#include <sysn.h>
#include <ntime.h>
#endif
#if D_PVM
#include "pvm3.h"
#endif /* D_PVM */
#include <stdio.h>
#include <sys/types.h>
#include <time.h>
#include <setjmp.h>
#include "dbug.h"

#if D_MESS
#include "d_mess_io.h"
#include "d_mess_merge.h"
#endif

/* external variables */
extern PROCESS_CONTEXT *curr_pid;

#if D_SPEC
/* extern FILE *debugger;   */
extern int spec_sched_status;
#endif /* D_SPEC */

/* global variables */

void initialize_fred_fish();
int fred_fish_initialized=0;

extern INSTR * code;
extern int proc_id;
extern int host;
extern int cube_dim;
extern int _prec_mult;
extern int _prec;
extern int _prec10;
extern BOOLEAN _formated;
extern BOOLEAN LazyLists;
extern BOOLEAN _digit_recycling;
extern BOOLEAN _beta_count_only;
extern BOOLEAN _trunc;
extern BOOLEAN _count_reductions;
extern int _maxnum;
extern int _base;
extern int hd;
extern int hs;
extern int ss;
extern int sig_msg_flag;
extern char post_mortem_msg[256];
extern jmp_buf post_mortem_buffer;

extern DStackDesc *ps_a;
extern DStackDesc D_S_A,D_S_H,D_S_I,D_S_R;
extern int _redcnt;
extern int _interrupt;
extern _interruptbuf;

#if ADV_SCHED
extern int take_yellow;
#endif

void nc_init();
void restore();

/**************************************************************/
/*                                                            */
/* main:    the main program on the nCube:                    */
/*          -calls initialization                             */
/*          -calls the scheduler functions                    */
/*          -calls the interpreter                            */
/*                                                            */
/**************************************************************/

void main()
{
 char fname[30];
 int dummy,d2,d3,d4;

#if (TIME_SLICE || ADV_SCHED)
 PROCESS_CONTEXT *ts_pid;
#endif

#if nCUBE
 whoami(&proc_id,&dummy,&host,&cube_dim);
#endif /* nCUBE */

#if D_PVM
 host = pvm_parent();
 proc_id = pvm_mytid();
#endif /* D_PVM */

 initialize_fred_fish();  

#if D_MESS
#if nCUBE
  if (nsync(79))
    post_mortem ("NSYNC failed !"); 
  amicclk();
#endif
#ifndef M_OLD_MERGING
#if !D_PVM
  m_init_merge();
#endif
#endif
#endif

#if D_SPEC
/* sprintf(fname, "/tmp/spec_debugger_%d", proc_id);
 debugger = fopen(fname,"w");   */
 spec_sched_status = 0;
#endif /* D_SPEC */

#if D_PVM
 DBUG_PRINT ("PVM", ("Slave-Id: %x", proc_id));
#endif

#if D_PVM_NCUBE
    whoami(&d2,&dummy,&d3,&d4);
    DBUG_PRINT("PVM", ("physical node-id: %d", d2));
#endif

 nc_init();

#if !DEBUG
  signal( SIGSEGV , restore);       /* segmentation violation */
  signal( SIGBUS , restore);       /* bus error */
#endif /* DEBUG */

 setjmp(post_mortem_buffer);

 for(;;)
   {schedule();
    switch(inter())
      {case IR_EXT:
       case IR_DIST_END:
#if (D_SLAVE && D_MESS && D_MSCHED)
         (*d_m_process_terminate)(curr_pid);
#else
	 process_terminate(curr_pid);
#endif
	 break;
       case IR_WAIT:
#if (D_SLAVE && D_MESS && D_MSCHED)
         (*d_m_process_sleep)(curr_pid);
#else
	 process_sleep(curr_pid);
#endif
	 break;
#if TIME_SLICE
       case IR_TIME_OUT:
         ts_pid = curr_pid;
#if (D_SLAVE && D_MESS && D_MSCHED)
         (*d_m_process_sleep)(curr_pid);
#else
         process_sleep(curr_pid);
#endif
#if (D_SLAVE && D_MESS && D_MSCHED)
         (*d_m_process_wakeup)(ts_pid);
#else
         process_wakeup(ts_pid);
#endif 
         break;
#endif /* TIME_SLICE */

       case IR_SCHED:  /* just schedule another process */
         break;

#if ADV_SCHED
       case IR_SUSPEND:
         ts_pid = curr_pid;

         /* put the running process to sleep errrr... to bed ;-) */

         take_yellow = 1; /* flag which is used to force the next (old) yellow */
                          /* process to be selected after the distributing */

#if (D_SLAVE && D_MESS && D_MSCHED)
         (*d_m_process_sleep)(curr_pid);
#else
         process_sleep(curr_pid);
#endif

         /* ok, now enqueue the former running process in the yellow-ready-queue */

#if (D_SLAVE && D_MESS && D_MSCHED)
         (*d_m_process_wakeup)(ts_pid);
#else
         process_wakeup(ts_pid);
#endif

         break; /* now the next white process will be activated by schedule */

#endif /* ADV_SCHED */

     default: post_mortem("unknown inter-return code"); break;

}
  if (sig_msg_flag)
    msg_check();}
}

/**************************************************************************
 *  R E S T O R E
 *
 *  Behandlung von Interrupts durch longjump zur Sprungadresse in
 *  interruptbuf.
 *
 *  Parameter: die Nummer des Signals
 ***************************************************************************
 */
void /*int*/ restore(sig)     /* RS 04/11/92 */
int sig;
{
/*  if (sig == SIGINT) {
    post_mortem("reduction process interrupted");
    } */

  if (sig == SIGSEGV) {
    post_mortem("segmentation fault: please email the example program to base@@informatik.uni-kiel.d400.de");
    }

  if (sig == SIGBUS) {
    post_mortem("bus error: please email the example program to base@@informatik.uni-kiel.d400.de");
    }

  post_mortem ("Interrupt occured...(sorry, no more information available)");

  _interrupt = TRUE;
  longjmp(_interruptbuf,0);

  return/*(0)*/; /* TB & RS, 28.10.92 */    /* RS 04/11/92 */
}

void initialize_fred_fish()
{
time_t now;
struct tm *date;
char fname[80];

/* fprintf(debugger, "Versuche, FRED FISH zu starten...\n"); fflush(debugger); */

if (!fred_fish_initialized) {

/* fprintf(debugger, "Starte FRED FISH !\n"); fflush(debugger); */
 
 fred_fish_initialized = 1;

 now = time(NULL);
 date = localtime(&now);

/* #if D_MESS
 sprintf(fname,"d:t:o,//d02/red/tracefiles/tf.%02d%02d%02d%02d%02d.%02d",date->tm_mday,date->tm_mon, date->tm_year,date->tm_hour,date->tm_min,proc_id);
#endif */
/* "d:t:o,/tmp/tf.%02d%02d%02d%02d */
#if (nCUBE && !D_PVM)
 sprintf(fname,"d:t:o,//d02/red/tracefiles/tf.%02d%02d%02d%02d%02d.%02d",date->tm_mday,date->tm_mon, date->tm_year,date->tm_hour,date->tm_min,proc_id);
/* fname[0]='\0'; */
#endif /* nCUBE */
#if D_PVM
 sprintf(fname,"d:t:o,/tmp/tracefiles/tf.%02d%02d%02d%02d%02d.%02d",date->tm_mday,date->tm_mon, date->tm_year,date->tm_hour,date->tm_min,pvm_mytid());
#endif /* D_PVM */

/* fprintf(debugger, "FRED FISH-String ist %s !\n", fname); fflush(debugger); */

 DBUG_PUSH(fname); /*  initialize Fred-Fish-DBUG in nCUBE */
 }
}
@


1.29
log
@minor bugfixes in the speculative tickets version
@
text
@d2 3
d117 1
a117 1
extern FILE *debugger; 
d204 1
a204 1
/*  sprintf(fname, "/tmp/spec_debugger_%d", proc_id);
@


1.28
log
@bugfixed version for SPEC_TICKETS + some more features
@
text
@d2 3
d201 1
a201 1
 /* sprintf(fname, "/tmp/spec_debugger_%d", proc_id);
@


1.27
log
@first version supporting speculative evaluations with TICKETS
@
text
@d2 3
d198 1
a198 1
/*  sprintf(fname, "/tmp/spec_debugger_%d", proc_id);
@


1.26
log
@speculative evaluations version 2 completed
@
text
@d2 3
d108 1
a108 1
extern FILE *debugger;
d179 1
a179 1
  initialize_fred_fish(); 
d195 2
a196 2
/* sprintf(fname, "/tmp/spec_debugger_%d", proc_id);
 debugger = fopen(fname,"w");    */
@


1.25
log
@dbug-messages removed, ready for re-compilation
@
text
@d2 3
d192 1
a192 1
/*  sprintf(fname, "/tmp/spec_debugger_%d", proc_id);
@


1.24
log
@further bugfixes on speculative evaluation (preliminary, beware of debug messages !)
@
text
@d2 3
d189 2
a190 2
 sprintf(fname, "/tmp/spec_debugger_%d", proc_id);
 debugger = fopen(fname,"w");    
@


1.23
log
@modifications for speculative evaluations regarding
meaning preserving transformations
@
text
@d2 4
d187 1
a187 1
 debugger = fopen(fname,"w");   
@


1.22
log
@old version check-in
@
text
@d2 3
d182 2
a183 2
/*  sprintf(fname, "/tmp/spec_debugger_%d", proc_id);
 debugger = fopen(fname,"w");     */
@


1.21
log
@some more (complete) modifications concerning speculative evaluation
(don't say you have missed my talk ? ;-)
@
text
@d2 4
d163 1
a163 1
 initialize_fred_fish(); 
d179 1
a179 1
/* sprintf(fname, "/tmp/spec_debugger_%d", proc_id);
@


1.20
log
@further work on speculative evaluation
@
text
@d2 3
d93 4
d142 1
a142 2
{time_t now;
 struct tm *date;
d159 2
d176 1
a176 1
 debugger = fopen(fname,"w");    */
a179 16
 now = time(NULL);
 date = localtime(&now);

/* #if D_MESS
 sprintf(fname,"d:t:o,//d02/red/tracefiles/tf.%02d%02d%02d%02d%02d.%02d",date->tm_mday,date->tm_mon, date->tm_year,date->tm_hour,date->tm_min,proc_id);
#endif */
/* "d:t:o,/tmp/tf.%02d%02d%02d%02d */
#if (nCUBE && !D_PVM)
 sprintf(fname,"d:t:o,//d02/red/tracefiles/tf.%02d%02d%02d%02d%02d.%02d",date->tm_mday,date->tm_mon, date->tm_year,date->tm_hour,date->tm_min,proc_id);
/* fname[0]='\0'; */
#endif /* nCUBE */
#if D_PVM
 sprintf(fname,"d:t:o,/tmp/tracefiles/tf.%02d%02d%02d%02d%02d.%02d",date->tm_mday,date->tm_mon, date->tm_year,date->tm_hour,date->tm_min,pvm_mytid());
#endif /* D_PVM */
 DBUG_PUSH(fname); /*  initialize Fred-Fish-DBUG in nCUBE */

d301 34
@


1.19
log
@some additions supporting speculative evaluation
@
text
@d2 3
d84 5
d166 6
d239 3
@


1.18
log
@some scheduling improvements
@
text
@d2 3
d164 1
d166 1
a166 1
 sprintf(fname,"d:t:o,/tmp/tf.%02d%02d%02d%02d%02d.%02d",date->tm_mday,date->tm_mon, date->tm_year,date->tm_hour,date->tm_min,proc_id);
@


1.17
log
@set ADV_SCHED for the "advanced ticket scheduling", still under construction !
@
text
@d2 3
d107 3
d228 3
d248 2
@


1.16
log
@some (final :-) changes for the nCUBE pvm version...
@
text
@d2 3
d123 1
a123 1
#if TIME_SLICE
d214 12
d227 13
@


1.15
log
@some pvm + measure changes
@
text
@d2 3
d118 1
a118 1
 int dummy;
d134 1
a134 1
#if (nCUBE || D_PVM_NCUBE)
d136 1
a136 1
    post_mortem ("NSYNC failed !");
d163 5
@


1.14
log
@some ncube+pvm changes
@
text
@d2 3
d120 1
a120 1
 
d145 1
d154 1
a154 1
 sprintf(fname,"d:t:o,/tmp/tf.%02d%02d%02d%02d%02d.%02d",date->tm_mday,date->tm_mon, date->tm_year,date->tm_hour,date->tm_min,pvm_mytid());
@


1.13
log
@some more pvm + measure modifications
@
text
@d2 3
d128 1
a128 1
#if nCUBE
d145 1
a145 1
#if nCUBE
@


1.12
log
@additional pvm + measure changes
@
text
@d2 3
a152 5
 pvm_hostsync(host, &pvm_time_host, &pvm_time_delta);
 gettimeofday (&pvm_time, NULL);
 DBUG_PRINT("PVM", ("pvm_time %ld %ld", pvm_time.tv_sec, pvm_time.tv_usec));
 DBUG_PRINT("PVM", ("pvm_time_host %ld %ld", pvm_time_host.tv_sec, pvm_time_host.tv_usec));
 DBUG_PRINT("PVM", ("pvm_time_delta %ld %ld", pvm_time_delta.tv_sec, pvm_time_delta.tv_usec));
@


1.11
log
@pvm + measure changes
@
text
@d2 3
d150 5
@


1.10
log
@some changes for the pvm measure version
@
text
@d2 3
d133 1
a133 1
#if D_MESS
d135 1
a135 1
#else
a142 1
#endif
@


1.9
log
@several pvm changes
@
text
@d2 3
d116 1
d120 1
d122 1
d126 1
d134 2
a135 2
/* sprintf(fname,"d:t:o,//d02/red/tracefiles/tf.%02d%02d%02d%02d%02d.%02d",date->tm_mday,date->tm_mon, date->tm_year,date->tm_hour,date->tm_min,proc_id);*/
 fname[0]='\0';
@


1.8
log
@main extracted to build nCUBE linkable modules
@
text
@d2 3
d77 3
d82 1
d142 5
d186 33
@


1.7
log
@additional pvm changes
@
text
@d2 3
d49 21
a69 21
INSTR * code;
int proc_id;
int host;
int cube_dim;
int _prec_mult;
int _prec;
int _prec10;
BOOLEAN _formated;
BOOLEAN LazyLists;
BOOLEAN _digit_recycling;
BOOLEAN _beta_count_only;
BOOLEAN _trunc;
BOOLEAN _count_reductions;
int _maxnum;
int _base;
int hd;
int hs;
int ss;
int sig_msg_flag = 0;
char post_mortem_msg[256];
jmp_buf post_mortem_buffer;
a173 95

/**************************************************************/
/*                                                            */
/* nc_init:  initializes the nCube:                           */
/*           -initializes heap area                           */
/*           -initializes stack area                          */
/*                                                            */
/**************************************************************/

void nc_init(int heapsize,int stacksize)
{void handle_signal();
 void buffer_overflow();

 static struct sigaction act_rcv = {handle_signal,0,0},
                         act_oflw = {buffer_overflow,0,0};

#if D_MESS
#ifdef M_OLD_MERGING
 /* allocating Message-Buffer for merging ! */
  if ((d_mess_buff = malloc(D_MESS_MAXBUF)) == NULL)     /* later use ???? */
    post_mortem ("nc_init: cannot allocate measure-merging-buffer !"); 
#endif
#endif

#if nCUBE
 /* install signal handler for incoming messages */
 sigaction (SIGMSGS,&act_rcv,NULL);

 /* install signal handler for dropped messages */
 sigaction (SIGDROP,&act_oflw,NULL);

 /* set communication mode */
 naddcmode(COMM_MODE_SIGRETRY);
#endif /* nCUBE */

 init_scheduler(); 

#if NCDEBUG
  DBNCinit();
#endif

#if (D_SLAVE && D_MESS && D_MCOMMU)
 (*d_m_msg_send)(host,MT_NCUBE_READY);
#else
 msg_send(host,MT_NCUBE_READY);
#endif
}

/**************************************************************/
/*                                                            */
/* handle_signal     handles the SIGMSGS signal               */
/*                                                            */
/**************************************************************/

void handle_signal()
{sig_msg_flag = 1;}

/**************************************************************/
/*                                                            */
/* buffer_overflow   handles the SIGDROP signal               */
/*                                                            */
/**************************************************************/

void buffer_overflow()
{post_mortem("Message buffer overflow");}

/**************************************************************/
/*                                                            */
/* post_mortem       handles error_messages                   */
/*                                                            */
/**************************************************************/

post_mortem(error)
char *error; 

{sprintf(post_mortem_msg,"Node %d: %s",proc_id,error);
 msg_send(host,MT_POST_MORTEM);
 msg_send(0xffff,MT_ABORT);
 process_terminate_all();
/* exit(0); */
 flush_queue();
 longjmp(post_mortem_buffer,1);}

/**************************************************************/
/*                                                            */
/* abort_init       aborts initialization of nCube            */
/*                                                            */
/**************************************************************/

abort_init(error)
char *error;

{sprintf(post_mortem_msg,"nCube init failed: %s",error);
 msg_send(host,MT_NCUBE_FAILED);
 exit(0);}
@


1.6
log
@pvm changes (to be continued)
@
text
@d2 3
d98 1
d116 1
d119 4
d125 4
@


1.5
log
@changed nCUBE to D_SLAVE
@
text
@d1 3
d20 1
d22 6
a29 2
#include <sysn.h>
#include <ntime.h>
d90 1
d92 5
d182 1
d191 1
@


1.4
log
@TIMESLICE bugfix (another)
@
text
@d112 1
a112 1
#if (nCUBE && D_MESS && D_MSCHED)
d119 1
a119 1
#if (nCUBE && D_MESS && D_MSCHED)
d128 1
a128 1
#if (nCUBE && D_MESS && D_MSCHED)
d133 1
a133 1
#if (nCUBE && D_MESS && D_MSCHED)
d183 1
a183 1
#if (nCUBE && D_MESS && D_MCOMMU)
@


1.3
log
@work in progress
@
text
@d77 4
d127 1
a129 1
         (*d_m_process_wakeup)(curr_pid);
d132 5
a136 1
         process_wakeup(curr_pid)
@


1.2
log
@first time-slicing changes
@
text
@d125 1
d128 1
@


1.1
log
@Initial revision
@
text
@d120 11
a130 1
	 break;}
@
