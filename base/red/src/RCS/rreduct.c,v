head	1.39;
access;
symbols
	continuation_based_interactions:1.20
	pre_interactions:1.18
	nCUBE~:1.16
	red1:1.1;
locks; strict;
comment	@ * @;


1.39
date	2001.07.02.14.53.33;	author base;	state Exp;
branches;
next	1.38;

1.38
date	98.06.17.15.27.06;	author rs;	state Exp;
branches;
next	1.37;

1.37
date	98.02.27.15.00.48;	author rs;	state Exp;
branches;
next	1.36;

1.36
date	98.02.18.13.34.36;	author rs;	state Exp;
branches;
next	1.35;

1.35
date	96.02.23.14.16.28;	author rs;	state Exp;
branches;
next	1.34;

1.34
date	96.02.21.17.19.21;	author rs;	state Exp;
branches;
next	1.33;

1.33
date	96.02.20.15.53.49;	author rs;	state Exp;
branches;
next	1.32;

1.32
date	96.02.19.19.19.11;	author rs;	state Exp;
branches;
next	1.31;

1.31
date	96.02.16.16.16.04;	author rs;	state Exp;
branches;
next	1.30;

1.30
date	96.02.16.09.07.55;	author sf;	state Exp;
branches;
next	1.29;

1.29
date	96.02.15.17.59.31;	author cr;	state Exp;
branches;
next	1.28;

1.28
date	96.02.15.16.24.05;	author rs;	state Exp;
branches;
next	1.27;

1.27
date	96.02.15.12.11.57;	author sf;	state Exp;
branches;
next	1.26;

1.26
date	96.02.14.17.03.57;	author rs;	state Exp;
branches;
next	1.25;

1.25
date	96.02.13.16.34.58;	author rs;	state Exp;
branches;
next	1.24;

1.24
date	96.02.05.13.19.11;	author sf;	state Exp;
branches;
next	1.23;

1.23
date	96.01.23.17.31.04;	author sf;	state Exp;
branches;
next	1.22;

1.22
date	96.01.16.16.00.52;	author rs;	state Exp;
branches;
next	1.21;

1.21
date	95.12.05.13.45.35;	author rs;	state Exp;
branches;
next	1.20;

1.20
date	95.11.06.17.07.42;	author stt;	state Exp;
branches;
next	1.19;

1.19
date	95.09.11.14.21.00;	author rs;	state Exp;
branches;
next	1.18;

1.18
date	95.09.07.15.56.15;	author sf;	state Exp;
branches;
next	1.17;

1.17
date	95.09.01.14.31.41;	author rs;	state Exp;
branches;
next	1.16;

1.16
date	95.05.18.10.03.51;	author sf;	state Exp;
branches;
next	1.15;

1.15
date	95.05.03.11.10.01;	author sf;	state Exp;
branches;
next	1.14;

1.14
date	95.04.05.15.03.14;	author sf;	state Exp;
branches;
next	1.13;

1.13
date	95.03.31.08.23.37;	author sf;	state Exp;
branches;
next	1.12;

1.12
date	95.03.24.09.28.46;	author sf;	state Exp;
branches;
next	1.11;

1.11
date	95.03.24.08.23.46;	author sf;	state Exp;
branches;
next	1.10;

1.10
date	95.03.22.13.04.31;	author sf;	state Exp;
branches;
next	1.9;

1.9
date	95.03.07.14.49.16;	author sf;	state Exp;
branches;
next	1.8;

1.8
date	95.02.09.16.14.55;	author rs;	state Exp;
branches;
next	1.7;

1.7
date	94.11.01.15.54.30;	author car;	state Exp;
branches;
next	1.6;

1.6
date	94.06.20.18.23.06;	author mah;	state Exp;
branches;
next	1.5;

1.5
date	94.06.20.06.03.01;	author car;	state Exp;
branches;
next	1.4;

1.4
date	94.05.18.10.51.34;	author mah;	state Exp;
branches;
next	1.3;

1.3
date	93.09.01.12.37.17;	author base;	state Exp;
branches;
next	1.2;

1.2
date	92.12.16.12.50.46;	author rs;	state Exp;
branches;
next	1.1;

1.1
date	92.11.04.18.12.30;	author base;	state Exp;
branches;
next	;


desc
@original
@


1.39
log
@compiler warnings eliminated
@
text
@/*
 * $Log: rreduct.c,v $
 * Revision 1.38  1998/06/17 15:27:06  rs
 * support for train primitives as interactions
 *
 * Revision 1.37  1998/02/27 15:00:48  rs
 * further bugfixes on speculative evaluation (preliminary, beware of debug messages !)
 *
 * Revision 1.36  1998/02/18  13:34:36  rs
 * modifications for speculative evaluations regarding
 * meaning preserving transformations
 *
 * Revision 1.35  1996/02/23  14:16:28  rs
 * tasm_time inserted...
 *
 * Revision 1.34  1996/02/21  17:19:21  rs
 * more options for tasm + distribute+ D_MESS
 *
 * Revision 1.33  1996/02/20  15:53:49  rs
 * more work on tasm + distribute + measure
 *
 * Revision 1.32  1996/02/19  19:19:11  rs
 * more command line options for distributed tasm (and measurements)
 *
 * Revision 1.31  1996/02/16  16:16:04  rs
 * some changes concerning the integration of measurements
 * in tasm
 *
 * Revision 1.30  1996/02/16  09:07:55  sf
 * Execname will be used for generation of executable (again)
 *
 * Revision 1.29  1996/02/15  17:59:31  cr
 * removed dangerous spaces in in call-string for tasm
 *
 * Revision 1.28  1996/02/15  16:24:05  rs
 * minor changes
 *
 * Revision 1.26  1996/02/14  17:03:57  rs
 * changes in the tasm startup for the distributed version
 *
 * Revision 1.25  1996/02/13  16:34:58  rs
 * changes for nCUBE (D_SLAVE ;-) + TASM
 *
 * Revision 1.24  1996/02/05  13:19:11  sf
 * in call to tasm : Redumalib, nCubelib, Tasmlib
 *
 * Revision 1.22  1996/01/16  16:00:52  rs
 * some output added for ADV_SCHED
 *
 * Revision 1.21  1995/12/05  13:45:35  rs
 * no distributed measurement file-merging in (all) pvm version(s)
 *
 * Revision 1.20  1995/11/06  17:07:42  stt
 * filepointers are set to NULL after closing
 *
 * Revision 1.19  1995/09/11  14:21:00  rs
 * some changes for the pvm measure version
 *
 * Revision 1.18  1995/09/07  15:56:15  sf
 * START_MODUL added
 *
 * Revision 1.16  1995/05/18  10:03:51  sf
 * gcc call removed, tasm makes it now itself
 *
 * Revision 1.15  1995/05/03  11:10:01  sf
 * new red.setup keyword: CodeDup : int
 * if not set -> no code duplication while using tasm
 * if 0 -> unlimited code duplication
 * if > 0 -> max number of duplication
 *
 * Revision 1.14  1995/04/05  15:03:14  sf
 * minor change in gcc call
 *
 * Revision 1.13  1995/03/31  08:23:37  sf
 * minor bug fix
 *
 * Revision 1.11  1995/03/24  08:23:46  sf
 * tasm will be searched in path
 *
 * Revision 1.10  1995/03/22  13:04:31  sf
 * pm bug fixed
 *
 * Revision 1.9  1995/03/07  14:49:16  sf
 * if UseTasm is set, reduct() accepts input from a file generated by tasm
 *
 * Revision 1.8  1995/02/09  16:14:55  rs
 * changed "correct" output of UH's PM statistics
 *
 * Revision 1.7  1994/11/01  15:54:30  car
 * generate codefile in non-DEBUG-version
 *
 * Revision 1.6  1994/06/20  18:23:06  mah
 * reduce to normal form available for WITHTILDE
 *
 * Revision 1.5  1994/06/20  06:03:01  car
 * first extension for optimizer
 *
 * Revision 1.4  1994/05/18  10:51:34  mah
 * no reduce to normal form in WITHTILDE version
 *
 * Revision 1.3  1993/09/01  12:37:17  base
 * ANSI-version mit mess und verteilungs-Routinen
 *
 * Revision 1.2  1992/12/16  12:50:46  rs
 * ANSI-Version
 *
 * Revision 1.1  1992/11/04  18:12:30  base
 * Initial revision
 */



/*----------------------------------------------------------------------------
 * reduct -- steuert die drei Phasen der Reduktionsmaschine, und sorgt
 *           fuer ein evtl. verpointertes Wiederaufsetzen.
 *           Der zu reduzierende Ausdruck wird auf dem E-Stack erwartet.
 *           Der Ergebnisausdruck wird auf den E-Stack zurueckgeliefert.
 *           Es erfolgt fuer die einzelnen Phasen eine Zeitmessung, die an den
 *           Editor uebergeben wird.
 * globals --
 *----------------------------------------------------------------------------
 */

/*-----------------------------------------------------------------------------
 * reduct:c external -- reduct
   reduct:c external -- get_tasm_output
 * reduct:c internal -- none
 *-----------------------------------------------------------------------------
 */

/* last update  by     why

   copied       by     to

*/
 
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include "rstdinc.h"
#include "rstackty.h"
#include "rheapty.h"
#include "rstelem.h"
#include "rextern.h"
#include "rmeasure.h"
#include "rinter.h"
#include "cparm.h"
#include "dbug.h"
/* #if D_DIST
#include "DBHexport.h"
#endif */

#if TRAIN
#include "/home/railway/inc/RailControl.h"
#endif /* TRAIN */

/* #include "rnf.h" */
/* ak *//* rnf.h/rnf.c  :  Modul zur Berechnung einer Normalform */
        /* Importiert die Funktion reduce_to_nf ().              */
        /* Diese Funktion treibt die Reduktion rekursiv in den   */
        /* Rumpf von Abstraktionen.                              */

/* --- externe variablen und funktionen --- */

/* sf 23.02.95   */
extern int UseTasm;
extern int TasmOpt;
extern int CodeDup;
extern int UseTasmRedCount;
extern char CodeFile[80];
extern char Tasm2KiR[80];
extern char Redumalib[80];
extern char nCubelib[80];
extern char Tasmlib[80];
extern char Execname[80];
int get_tasm_output(void);
/*****************/

#if D_DIST
#include <sys/time.h>
#endif

#if D_MESS
#include "d_mess_io.h"
extern getkey();
extern char *_errmes;
#endif

#if DEBUG
extern char TraceFile[];	/* rreduce.c */
extern FILE *TraceFp;		/* rreduce.c */
extern int showdisplay;		/* rruntime.c */
#if UH_ZF_PM
extern FILE *ofp;
extern char pmanal_name[100];
#endif /* UH_ZF_PM */
#endif
extern PTR_DESCRIPTOR _old_expr_p; /* kopie des zuletzt bearbeiteten ausdrucks */
extern void           ptrav_a_e();           /* trav:c */
extern STACKELEM      st_expr();             /* storepro:c */
extern void           ret_expr();            /* retrieve:c */
extern void           ea_create();           /* ea-create:c*/
extern void           ear();                 /* ear:c      */
extern void           ea_retrieve();         /* ea_ret:c   */
extern void           load_expr();
extern void           inter();               /* rinter.c */ /* dg */
extern int            intact_inter();        /* rintact.c */ /* stt */
extern T_CODEDESCR    codedesc;              /* rinter.h */ /* dg */
extern void           reduce_to_nf();        /* rnf.c */ /* ak */
extern int            ia_binds_on_stack;     /* rintact.c */ /* stt */

#if D_DIST
extern void send_params();
extern void send_graph();
extern void receive_result();
extern flush_queue();
extern clearscreen();
extern m_super_merging();
extern char ticket_file[];

extern int cube_dim;
#if (D_MESS && ADV_SCHED)
extern int no_suspended;
#endif /* D_MESS && ADV_SCHED */
#endif

/* ach 05/11/92 */
extern int init_print_heap();                /* dumpheap.c */
extern void loleila();                       /* rdummies.c */
extern void print_heap();                    /* dumpheap.c */
extern void load_heap();                     /* dumpheap.c */
extern void stack_error();                   /* rstack.c */
/* end of ach */

/* RS 5.11.1992 */
extern void setdisplay();  /* rruntime.c */
extern void monitor_call();  /* rruntime.c */ 
extern void DescDump();      /* rdesc.c */
extern STACKELEM *ppopstack();    /* rstack,c */
extern void test_inc_refcnt();    /* rheap.c */
extern void test_dec_refcnt();    /* rheap.c */
extern void res_heap();           /* rheap.c */
extern void rel_heap();           /* rheap.c */
/* END of RS 5.11.1992 */

/* RS 6.11.1992 */ 
extern void disable_scav();                /* rscavenge.c */
extern void enable_scav();                 /* rscavenge.c */
extern void dynamic_gc();                  /* rscavenge.c */
/* END of RS 6.11.1992 */ 

#if SCAV_DEBUG
extern void scav_write_log ();
#endif

/* --- interne variablen und funktionen --- */

       void           evaluate();   /* forward */   /* dg */
       PTR_DESCRIPTOR code_desc;                    /* dg */

double tvorher;                     /* zeitmessung */
double tpre;                        /* zeitmessung */
double tpro;                        /* zeitmessung */
double tpos;                        /* zeitmessung */
double tges;                        /* zeitmessung */
double tasm_time;

#if D_SPEC

PTR_DESCRIPTOR spec_string1 = 0;
PTR_DESCRIPTOR spec_string2 = 0;

#endif

#if  SINTRAN3
extern double tused();
#define TIMER() tused()
#else
extern long clock();
#define TIMER() (clock() / 1000000.0)
#endif

int call_system(char **s)
{
  int pid, status;
  DBUG_ENTER("call_system");
  switch(pid = fork())
  {
    case -1: post_mortem("call_system: unable to generate new process");
             status = 1;
             break;
    case  0: execvp(*s, s); 
             perror("");sleep(5);
             post_mortem("call_system: unable to execute new process");
             status = 1;
             break;
    default: while (wait(&status) != pid);
  }
  DBUG_RETURN(status);
}
    



/* dg */ /*------------------------------------------------------------------*/
/* dg */ /* reduct                                                           */
/* dg */ /*------------------------------------------------------------------*/
/* dg */
/* dg */ void reduct(PTR_UEBERGABE p_parms)
/* dg */ {
/* dg */   /*STACKELEM  x;                       ach 05/11/92 */
/* PTR_UEBERGABE p_parms   [sf 23.02.95]  */
int exec_success = 0;
#if D_DIST
  double zeit1 = 0.0, zeit2 = 0.0;
  struct timeval t0;
#endif

#if D_MESS
  double m_zeit1 = 0.0, m_zeit2 = 0.0;
#endif

/* dg */
/* dg */   START_MODUL("reduct");
/* dg */
#if DEBUG
/* dg */   showdisplay = TRUE;
/* dg */   setdisplay();         /* Stackbildaufbau */
/* dg */   monitor_call();       /* Benutzer kann interagieren */
           if ((TraceFp = fopen(TraceFile,"w")) == NULL)
             post_mortem("cannot open tracefile");
#if UH_ZF_PM
           if ((ofp=fopen(pmanal_name,"a"))==NULL) ofp=fopen("/dev/null","a");
#endif /* UH_ZF_PM */
#endif

#if D_MESS
#ifndef M_OLD_MERGING    /* for ASCII merging only */
#if D_PVM
             if (!m_merge_strat)
               post_mortem("PVM: please change MergingStrategy to 1 in red.setup.");
#endif /* D_PVM */
#endif
#endif /* D_MESS */

/* dg */   /* initialisierungen fuer die zeitmessung */
/* dg */   tvorher = tpre = tpro = tpos = tges = 0.0;
/* dg */   tvorher = TIMER();           /* tvorher eingefuegt: ach 05/11/92 */
/* dg */   tvorher = TIMER();
/* dg */
/* dg */   if (T_KLAA(READSTACK(S_e))) {
/* dg */     /*-------------------------------*/
/* dg */     /* verpointertes Wiederaufsetzen */
/* dg */     /*-------------------------------*/
/* dg */     if (_old_expr_p == NULL)
/* dg */       post_mortem("reduct: there's no preprocessed expression.");
/* dg */     WRITESTACK(S_e,(STACKELEM)_old_expr_p); /* KLAA ueberschreiben */
/* dg */     tpre = TIMER();
/* dg */     evaluate();        /* auswertung anstossen */
/* dg */     tpro = TIMER();
/* dg */   }
/* dg */   else {
/* dg */     /*---------------*/
/* dg */     /* Preprocessing */
/* dg */     /*---------------*/
/* dg */     _old_expr_p = NULL; /* kein alter Ausdruck gespeichert    */

#if D_SPEC
             /* initialize standard descriptors for speculative constructors */
           /*  if (spec_string1 == 0) { */
               spec_string1 = makestrdesc(SPEC_CONSTRUCTOR);
               spec_string2 = makestrdesc(SPEC_GUARD_CONSTRUCTOR); 
/*             } */
#endif

/* dg */     ea_create();        /* Steuermodul der Preprocessingphase */
/* dg */     /* der preprocesste ausdruck liegt als EXPR-descriptor auf e */
/* dg */     ear();                                   /* compilieren (abstr.) */
/* dg */     /* der compilierte ausdruck liegt als COMB-descriptor auf e */
/* dg */     code_desc = (T_PTD)READSTACK(S_e);       /* codedescriptor */
#if SCAVENGE
/* tg */     dynamic_gc ();
#endif
/* dg */     init_print_heap();                       /* dg 04.03.91 HeapDumpFile,HeapBase,HeapAlign */
/* dg */     loleila(R_COMB(*code_desc,ptc),SYMBTAB); /* loleila compiler */
/* dg */     /*------------*/
/* dg */     /* Processing */
/* dg */     /*------------*/
/* dg */     print_heap(NULL);                        /* dg 25.01.91 NULL: name aus red.setup */
/*  sf [03.03.95] anfang */
  if (0 != UseTasm)
  {
    static char p_str[15][80];
    static char *h_ptr[15];
    int i = 0,j;
    
    DBUG_PRINT ("RREDUCT", ("preparing the TASM call..."));

    strcpy(p_str[i], "tasm");
    h_ptr[i] = p_str[i++];
    
    if (-1 < CodeDup) 
    {
      sprintf(p_str[i], "-d%d", CodeDup);
      h_ptr[i] = p_str[i++];
    }
    if (0 < TasmOpt) 
    {
      strcpy(p_str[i], "-trO2");
      h_ptr[i] = p_str[i++];
    }
    else if (-1 == TasmOpt)
    {
      strcpy(p_str[i], "-D#t");
      h_ptr[i] = p_str[i++];
    }
    sprintf(p_str[i], "-L%s", Redumalib);
    h_ptr[i] = p_str[i++];
    sprintf(p_str[i], "-N%s", nCubelib);
    h_ptr[i] = p_str[i++];
    sprintf(p_str[i], "-l%s", Tasmlib);
    h_ptr[i] = p_str[i++];

#if D_DIST
    sprintf(p_str[i], "-n");
    h_ptr[i] = p_str[i++];
#if D_MESS
    sprintf(p_str[i], "-m");
    h_ptr[i] = p_str[i++];

#ifndef DBUG_OFF
    sprintf(p_str[i], "-D");
    h_ptr[i] = p_str[i++];
#endif

#endif
#endif 

    sprintf(p_str[i], "-Co%s", Execname);
    h_ptr[i] = p_str[i++];
    if (1 == UseTasmRedCount)
    {
      strcpy(p_str[i], "-R");
      h_ptr[i] = p_str[i++];
    }
    strcpy(p_str[i], CodeFile);
    h_ptr[i] = p_str[i++];
    h_ptr[i] = NULL;

    DBUG_PRINT("RREDUCT", ("calling:"));
    for (j=0; j<i; j++) DBUG_PRINT("RREDUCT", ("%d: %s", j, h_ptr[j]));

    exec_success = call_system(h_ptr);
    if (0 != exec_success)
      post_mortem("reduct: generation of C-file failed");
  }
/*  sf [03.03.95] ende */

/* dg */     tpre = TIMER();

#if D_DIST
 gettimeofday (&t0, NULL);
 zeit1 =  t0.tv_sec + t0.tv_usec/1000000.0;
#endif


          if (0 == UseTasm)
          {

#if D_DIST

DBUG_PRINT ("rreduct", ("Zeit vorher: %f", zeit1));

#if DEBUG
 DBUG_PRINT ("rreduct", ("Jetzt wuerde ich gern den screen loeschen !"));

#endif
             flush_queue();
             send_params();
             send_graph();

#if NCDEBUG
             DBHinit(1<<cube_dim);
             DBHrun();
#endif
             receive_result();

#else  /* D_DIST */

            int newcode = 0;  /* stt */

#if TRAIN
         if (init_railcontrol() == FAILURE)
           post_mortem("could not initialize railcontrol !");
#endif /* TRAIN */
            
/* dg */    inter(R_COMB(*code_desc,ptc));           /* codeausfuehrung */
            
            ia_binds_on_stack = 0;

            while ((newcode = intact_inter()) != 0)  /* stt  14.09.95 */
              inter(newcode);

#if TRAIN
         if (exit_railcontrol() == FAILURE)
           post_mortem("could not exit railcontrol !");
#endif /* TRAIN */

#endif /* D_DIST */

          }
          else if (0 == exec_success) 
          {
            static char p_str[30][80];
            static char *h_ptr[30];
            int i = 0,j;
            
            DBUG_PRINT ("RREDUCT", ("preparing the call of the compiled program..."));

#if D_DIST
#if D_MESS
            strcpy(p_str[i], "mhost");
#else
            strcpy(p_str[i], "host");
#endif /* D_MESS */
#else /* D_DIST */ 
            sprintf(p_str[i], "%s", Execname);
#endif /* D_DIST */
            h_ptr[i] = p_str[i++];

#if D_DIST
#if D_MESS
#ifndef DBUG_OFF
            sprintf(p_str[i], "-#d:t:o,/tmp/tracefile_");
            h_ptr[i] = p_str[i++];
#endif
#endif /* D_MESS */
            sprintf(p_str[i], "-n%d", cube_dim);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-t%s", ticket_file);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-f%s", Execname);
            h_ptr[i] = p_str[i++];
#if D_MESS
            DBUG_PRINT("RREDUCT", ("writing options for measurements"));
            sprintf(p_str[i], "-m%d", d_bib_mask);
            h_ptr[i] = p_str[i++]; 
            sprintf(p_str[i], "-q%d", m_merge_strat);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-x%d", m_ackno);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-y%s", m_mesfilehea);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-z%s", m_mesfilepath);
            h_ptr[i] = p_str[i++];
            if (_errmes[0]=='\0')
              strcpy(_errmes, "default");
            sprintf(p_str[i], "-E%s", _errmes);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-X%s", m_remote_host);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-M%d", m_del_files);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-Q%s", m_target_dir);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-Y%s", m_remote_dir);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-Z%s", m_remote_bin);
            h_ptr[i] = p_str[i++];
#endif /* D_MESS */
#endif /* D_DIST */

            sprintf(p_str[i], "-k%s", Tasm2KiR);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-h%d", p_parms->heapsize);
            h_ptr[i] = p_str[i++];
/*            sprintf(p_str[i], "-s%d", p_parms->qstacksize);
            h_ptr[i] = p_str[i++];
*/
            sprintf(p_str[i], "-d%d", p_parms->heapdes);
            h_ptr[i] = p_str[i++];
            sprintf(p_str[i], "-R%d", p_parms->redcnt);
            h_ptr[i] = p_str[i++];
            if (-1 == TasmOpt)
            {
              sprintf(p_str[i], "-#t");
              h_ptr[i] = p_str[i++];
            }
            h_ptr[i] = NULL;

            DBUG_PRINT("RREDUCT", ("calling:"));
            DBUG_PRINT("RREDUCT", ("first: %s", h_ptr[1]));
            for (j=0; j<i; j++)
              DBUG_PRINT("RREDUCT", ("%d: %s", j, h_ptr[j])); 

            DBUG_PRINT("RREDUCT", ("really calling now..."));
            if (0 != call_system(h_ptr)) {
              sleep(10);
              post_mortem("reduct: execution of generated file failed"); }
          }

DBUG_PRINT ("rreduct", ("Hi, I'm back !"));

#if D_DIST
 gettimeofday (&t0, NULL);
 zeit2 =  t0.tv_sec + t0.tv_usec/1000000.0;

DBUG_PRINT ("rreduct", ("Zeit nachher: %f", zeit2));
DBUG_PRINT ("rreduct", ("Differenz: %4.2f", zeit2-zeit1));

#endif

#if D_MESS
             if (m_ackno)
               fflush (stdout);
             gettimeofday (&t0, NULL); 
             m_zeit1 = t0.tv_sec + t0.tv_usec/1000000.0; 
             if (m_ackno) {
               clearscreen();
               printf (" merging measurement files ...\n");
               fflush (stdout); 
               }
            
             if (!UseTasm) {

#ifdef M_OLD_MERGING    /* for ASCII merging only */
             get_em_merged();   /*  old merging */
#else
             if (m_merge_strat)
               m_super_merging();
             else
#if !D_PVM
               m_merging();
#endif
#endif
             if (!m_merge_strat)
               m_remote_copy();

             }

             gettimeofday (&t0, NULL); 
             m_zeit2 = t0.tv_sec + t0.tv_usec/1000000.0; 
             if (m_zeit1 == m_zeit2)
               DBUG_PRINT ("REDUCT", ("great time-measurement !"));
             else
               if (m_ackno)
                 printf ("\n merging time: %4.2f s\n", m_zeit2-m_zeit1);
             if (m_ackno) {
#if ADV_SCHED
               printf ("\n Number of suspended processes: %i\n\n", no_suspended);
#endif /* ADV_SCHED */
               printf (" press return ...\n");
               fflush(stdout);
               getkey(); 
               }
#endif

/* dg */     tpro = TIMER();
             if (UseTasm) {
               PUSHSTACK(S_a, get_tasm_output());
               }

#if SCAV_DEBUG
/* tg */     scav_write_log ();
#endif
/* dg */     PPOPSTACK(S_e);                          /* codedescriptor */
/* dg */     load_heap(NULL);                         /* dg 04.02.92 NULL: name aus red.setup */
/* dg */   }
/* dg */   _old_expr_p = (PTR_DESCRIPTOR)POPSTACK(S_a);
/* dg */   if (T_POINTER((int)_old_expr_p))
/* dg */     INC_REFCNT(_old_expr_p);
/* dg */   PUSHSTACK(S_e,_old_expr_p);
#if SCAVENGE
/* tg */   disable_scav();
#endif

#if 0 /* DEBUG */
   showdisplay = TRUE;
   setdisplay();         /* Stackbildaufbau */
   monitor_call();       /* Benutzer kann interagieren */
#endif /* DEBUG */

/* dg */   /*----------------*/
/* dg */   /* Postprocessing */
/* dg */   /*----------------*/
#if RED_TO_NF
/* ak */    reduce_to_nf ();        /* Vorantreiben der Reduktion, Berechnung der Normalform  */
#endif
/* dg */   ea_retrieve();          /* Steuermodul der Postprocessing Phase */
/* dg */   tpos = TIMER();
/* dg */   tpos -= tpro;
/* dg */   tpro -= tpre;
/* dg */   tpre -= tvorher;

           if (UseTasm) {
             tpro = tasm_time;
             }

#if D_DIST
    tpro = zeit2-zeit1;
#endif

/* dg */   tges = tpre + tpro + tpos;
/* dg */ 
#if DEBUG
/* dg */   showdisplay = FALSE;    /* Stackbildmanipulation unterdruecken */
           if (TraceFp)
           {
             fclose(TraceFp);
             TraceFp = NULL;  /* stt */
           }
#if UH_ZF_PM          
           fclose(ofp);
#endif
#endif
/* dg */   END_MODUL("reduct");
/* dg */ }

/* file eval.c */

#include <setjmp.h>

/* --- externe variablen/funktionen --- */

extern BOOLEAN _interrupt;    /* rreduct.c */
extern jmp_buf _interruptbuf; /* rreduct.c */
extern void    freeheap();    /* rheap.c */
extern int     Rout_Eval[];   /* rinter.c */

#define CHECK_EXPR(ptd) \
           (R_DESC(*ptd,class) == C_LIST && R_DESC(*ptd,type) == TY_UNDEF) || \
           (R_DESC(*ptd,type) == TY_CLOS) || \
           (R_DESC(*ptd,type) == TY_COMB && R_COMB(*ptd,nargs) == 0) || \
           (R_DESC(*ptd,type) == TY_EXPR) || \
           (R_DESC(*ptd,type) == TY_NOMAT)

/* -------------------------------------------------- */
/* evaluate: evaluiert den ausdruck auf stack e und   */
/*           bewegt ihn auf stack a                   */
/* -------------------------------------------------- */

void evaluate()
{
  register STACKELEM  x,y;
  register int        dim;
  register VOLATILE T_PTD      ptdesc=(T_PTD)0; /* Initialisierung von TB, 6.11.1992, volatile: ach 10/11/92 */

  START_MODUL("evaluate");

  /* interruptbehandlung neu initialisieren */
  setjmp(_interruptbuf);
  if (_interrupt) {                              /* interrupt aufgetreten? */
    _interrupt = FALSE;                          /* zuruecksetzen */
    post_mortem("evaluate: interrupt received"); /* alles abbrechen */
  }

  PUSHSTACK(S_m,KLAA);             /* bottomsymbol */

main_e:

  x = READSTACK(S_e);
  if (T_POINTER(x)) {
    ptdesc = (T_PTD)x;
    if (R_DESC(*ptdesc,type) == TY_COMB && R_COMB(*ptdesc,nargs) == 0) {
      /* nullstellige funktion (constant applicative form) */
      PUSHSTACK(S_a,x);          /* COMB */
      PPOPSTACK(S_e);            /* COMB */
      INC_REFCNT(ptdesc);        /* um freigabe durch inter zu verhindern */

DBUG_PRINT ("RREDUCT", ("Yups, ich bin hier !"));

      inter(Rout_Eval);          /* evaluieren */

      DEC_REFCNT(ptdesc);        /* freigabe */
      goto main_m;
    } /* end TY_COMB */
    else
    if (R_DESC(*ptdesc,type) == TY_CLOS) {
      /* (un)gesaettigte closure  */
      if (R_CLOS(*ptdesc,args) == 0) {
        /* 0-stellige closure (indirektionsknoten) */
        y = R_CLOS(*ptdesc,pta)[0]; /* dereferenzieren */
        if (T_POINTER(y))
          INC_REFCNT((T_PTD)y);
        PUSHSTACK(S_a,y);          /* und auf a! ablegen */
        PPOPSTACK(S_e);            /* closure */
        DEC_REFCNT(ptdesc);        /* freigeben */
        goto main_m;
      }
      else {
        /* keine 0-stellige closure */
        int count = 0;
        PUSHSTACK(S_a,x);          /* closure */
        WRITESTACK(S_e,DOLLAR);    /* trennsymbol ueber closure */
        /* testen ob die closure nicht ausgewertete ausdruecke enthaelt */
        /* ACHTUNG: hiermit wird die reihenfolge der auswertung geaendert !!! */
        /* for (dim = R_CLOS(*ptdesc,args) ; dim >= 0 ; dim--) { */
        for (dim = 0; dim <= (int) R_CLOS(*ptdesc,args) ; dim++) {
                        /* int gecastet von RS 04/11/92 */ 
          y = R_CLOS(*ptdesc,pta)[dim];
          if (T_POINTER(y)) {
            register T_PTD ptd = (T_PTD)y;
            if (CHECK_EXPR(ptd)) {
              INC_REFCNT(ptd);
              PUSHSTACK(S_e,ptd);
              PUSHSTACK(S_m,SET_ARITY(AP,dim));
              count++;
            }
          }
        } /* end for */
        goto main_e;
      }
    } /* end TY_CLOS */
    else
    if (R_DESC(*ptdesc,class) == C_LIST && R_DESC(*ptdesc,type) == TY_UNDEF) {
      /* liste zu behandeln */
      int count = 0;
      PUSHSTACK(S_a,x);                   /* list */
      WRITESTACK(S_e,HASH);               /* trennsymbol */
      /* testen ob die liste nicht ausgewertete ausdruecke enthaelt */
      for (dim = R_LIST(*ptdesc,dim); --dim >= 0 ;) {
        y = R_LIST(*ptdesc,ptdv)[dim];
        if (T_POINTER(y)) {
          register T_PTD ptd = (T_PTD)y;
          if (CHECK_EXPR(ptd)) {
            INC_REFCNT(ptd);
            PUSHSTACK(S_e,ptd);
            PUSHSTACK(S_m,SET_ARITY(LIST,dim));
            count++;
          }
        }
      } /* end for */
      if (count == 0) {
        PPOPSTACK(S_e);      /* HASH weg */
        goto main_m;
      }
      goto main_e;
    } /* end C_LIST */
    else
    if (R_DESC(*ptdesc,type) == TY_EXPR) {
      /* (nicht ausfuehrbare) applikation */
      int count = 0;
      PUSHSTACK(S_a,x);                   /* expr */
      WRITESTACK(S_e,HASH);               /* trennsymbol */
      /* testen ob die applikation nicht ausgewertete ausdruecke enthaelt */
      for (dim = R_EXPR(*ptdesc,pte)[0]; dim > 0 ; dim--) {
        y = R_EXPR(*ptdesc,pte)[dim];
        if (T_POINTER(y)) {
          register T_PTD ptd = (T_PTD)y;
          if (CHECK_EXPR(ptd)) {
            INC_REFCNT(ptd);
            PUSHSTACK(S_e,ptd);
            PUSHSTACK(S_m,SET_ARITY(SNAP,dim));
            count++;
          }
        }
      } /* end for */
      if (count == 0) {
        PPOPSTACK(S_e);      /* HASH weg */
        goto main_m;
      }
      goto main_e;
    } /* end TY_EXPR */
    else {
      /* sonstige faelle */
      PUSHSTACK(S_a,x);
      PPOPSTACK(S_e);
      goto main_m;
    }
  } /* end T_POINTER(x) */
  else
  if (T_DOLLAR(x)) {
    /* ende der behandlung einer closure */
    register PTR_HEAPELEM pth = R_CLOS(*ptdesc,pta);
    ptdesc = (T_PTD)READSTACK(S_a); /* closure */
    INC_REFCNT(ptdesc);             /* um freigabe durch inter zu verhindern */
    PUSHSTACK(S_a,ptdesc);          /* closure verdoppeln */

DBUG_PRINT ("RREDUCT", ("Ich bin hier unten !"));

    inter(Rout_Eval);               /* evaluieren */

    /* argumente der closure freigeben */
    RES_HEAP;
    for (dim = R_CLOS(*ptdesc,args) ; dim >= 0 ; dim--) {
      if (T_POINTER(pth[dim])) {
        DEC_REFCNT((T_PTD)pth[dim]);
      }
    }
    freeheap(R_CLOS(*ptdesc,pta));
    REL_HEAP;
    /* indirektionsknoten anlegen (CLOS mit args == 0) */
    L_CLOS(*ptdesc,args) = 0;
    y = POPSTACK(S_a);             /* ergebnis von eval */
    if (T_POINTER(y))
      INC_REFCNT((T_PTD)y);
    R_CLOS(*ptdesc,pta)[0] = y;     /* resultat eintragen */
    WRITESTACK(S_a,y);              /* ergebnis von eval ueber closure */
    DEC_REFCNT(ptdesc);             /* closure freigeben */
    PPOPSTACK(S_e);                 /* DOLLAR */
    goto main_m;
  }
  else
  if (T_HASH(x)) {
    /* ende der behandlung einer liste oder applikation */
    PPOPSTACK(S_e);                 /* HASH */
    goto main_m;
  }
  else {
    /* alle sonstigen faelle */
    PUSHSTACK(S_a,x);
    PPOPSTACK(S_e);
    goto main_m;
  }

main_m:

  x = READSTACK(S_m);
  if (T_AP(x)) {
    /* argument einer closure wurde evaluiert */
    y = POPSTACK(S_a);                            /* result of evaluation */
    ptdesc = (T_PTD)READSTACK(S_a);               /* CLOS-descriptor */
    dim = ARITY(x);                               /* arity of AP(n) */
    DEC_REFCNT((T_PTD)R_CLOS(*ptdesc,pta)[dim]);  /* always a pointer !!! */
    R_CLOS(*ptdesc,pta)[dim] = y;                 /* replace by value */
    PPOPSTACK(S_m);
    goto main_e;
  } /* end T_AP */
  else
  if (T_LIST(x)) {
    /* element einer liste wurde evaluiert */
    y = POPSTACK(S_a);                            /* result of evaluation */
    ptdesc = (T_PTD)READSTACK(S_a);               /* LIST-descriptor */
    dim = ARITY(x);                               /*  arity of LIST(n) */
    DEC_REFCNT((T_PTD)R_LIST(*ptdesc,ptdv)[dim]); /* always a pointer !!! */
    R_LIST(*ptdesc,ptdv)[dim] = y;                /* replace by value */
    PPOPSTACK(S_m);
    goto main_e;
  } /* end T_LIST */
  else
  if (T_SNAP(x)) {
    /* element einer applikation wurde evaluiert */
    y = POPSTACK(S_a);                           /* result of evaluation */
    ptdesc = (T_PTD)READSTACK(S_a);              /* EXPR-descriptor */
    dim = ARITY(x);                              /* arity of SNAP(n) */
    DEC_REFCNT((T_PTD)R_EXPR(*ptdesc,pte)[dim]); /* always a pointer !!! */
    R_EXPR(*ptdesc,pte)[dim] = y;                /* replace by value */
    PPOPSTACK(S_m);
    goto main_e;
  } /* end T_SNAP */
  else
  if (T_KLAA(x)) {
    /* terminierung */
    PPOPSTACK(S_m);
    END_MODUL("evaluate");
    return;
  } /* end T_KLAA */
  else {
    post_mortem("evaluate: unexpected symbol on stack m");
  }
} /* end evaluate() */

/* end of       rreduct.c */
@


1.38
log
@support for train primitives as interactions
@
text
@d1 5
a5 1
/* $Log: rreduct.c,v $
a46 3
 * Revision 1.23  1996/01/23  17:31:04  sf
 * *** empty log message ***
 *
a76 3
 * Revision 1.12  1995/03/24  09:28:46  sf
 * *** empty log message ***
 *
d109 1
a109 1
 * */
d344 1
a344 1
#endif D_MESS
d681 1
a681 1
#endif DEBUG
@


1.37
log
@further bugfixes on speculative evaluation (preliminary, beware of debug messages !)
@
text
@d2 3
d155 4
d493 5
d505 5
@


1.36
log
@modifications for speculative evaluations regarding
meaning preserving transformations
@
text
@d2 4
d148 1
a148 1
#if D_DIST
d150 1
a150 1
#endif
@


1.35
log
@tasm_time inserted...
@
text
@d2 3
d259 7
d358 9
d657 7
@


1.34
log
@more options for tasm + distribute+ D_MESS
@
text
@d2 3
d174 1
a174 1
extern char _errmes[];
d254 1
d483 3
d487 1
d518 2
a519 2
            if (strlen(_errmes) == 0)
              strcpy(_errmes, "editor");
d621 1
a621 1
             if (UseTasm)
d623 1
d649 4
@


1.33
log
@more work on tasm + distribute + measure
@
text
@d2 3
d171 1
d472 2
a473 2
            static char p_str[28][80];
            static char *h_ptr[28];
d509 14
@


1.32
log
@more command line options for distributed tasm (and measurements)
@
text
@d2 3
d394 4
d399 2
d482 6
d559 3
d574 2
@


1.31
log
@some changes concerning the integration of measurements
in tasm
@
text
@d2 4
d459 2
a460 2
            static char p_str[8][80];
            static char *h_ptr[8];
d466 2
a467 2
            strcpy(p_str[i], "startup");
#else /* D_DIST */
d473 6
d480 1
d482 2
d485 1
a485 2
#endif /* D_MESS */
            sprintf(p_str[i], "-n%d", cube_dim);
d487 1
a487 1
            sprintf(p_str[i], "-t%s", ticket_file);
d489 1
a489 1
            sprintf(p_str[i], "-f%s", Execname);
d491 1
d513 3
a515 1
            for (j=0; j<i; j++) DBUG_PRINT("RREDUCT", ("%d: %s", j, h_ptr[j]));
d517 1
@


1.30
log
@Execname will be used for generation of executable (again)
@
text
@d2 3
d384 4
d469 4
@


1.29
log
@removed dangerous spaces in in call-string for tasm
@
text
@d2 3
d147 1
d383 1
a383 1
    strcpy(p_str[i], "-Cocode");
d457 1
a457 1
            strcpy(p_str[i], "code");
d466 1
a466 1
            strcpy(p_str[i], "-f./code");
@


1.28
log
@minor changes
@
text
@d2 3
d354 1
a354 1
      sprintf(p_str[i], "-d%d ", CodeDup);
d359 1
a359 1
      strcpy(p_str[i], "-trO2 ");
d364 1
a364 1
      strcpy(p_str[i], "-D#t ");
d367 1
a367 1
    sprintf(p_str[i], "-L%s ", Redumalib);
d369 1
a369 1
    sprintf(p_str[i], "-N%s ", nCubelib);
d371 1
a371 1
    sprintf(p_str[i], "-l%s ", Tasmlib);
@


1.27
log
@Execname will be used for generation of executable
@
text
@a140 1
extern char Execname[80];
d174 1
d376 1
a376 1
    sprintf(p_str[i], "-Co%s ", Execname);
d431 2
d450 1
a450 1
            sprintf(p_str[i], "%s", Execname);
d459 1
a459 1
            strcpy(p_str[i], "-f code");
@


1.26
log
@changes in the tasm startup for the distributed version
@
text
@d2 3
d141 1
d376 1
a376 1
    strcpy(p_str[i], "-Cocode");
d448 1
a448 1
            strcpy(p_str[i], "code");
@


1.25
log
@changes for nCUBE (D_SLAVE ;-) + TASM
@
text
@d2 3
d179 1
d443 1
a443 1
#else
d445 9
a453 1
#endif
d455 2
@


1.24
log
@in call to tasm : Redumalib, nCubelib, Tasmlib
@
text
@d2 3
d334 1
a334 1
    int i = 0;
d336 2
d362 6
d378 4
d395 4
d407 3
a409 3
	     flush_queue();
	     send_params();
	     send_graph();
d412 2
a413 2
	     DBHinit(1<<cube_dim);
	     DBHrun();
d415 4
a418 4
	     receive_result();
#else
          if (0 == UseTasm)
          {
d425 3
d433 1
a433 1
            int i = 0;
d435 5
d441 1
d460 7
a466 2
            if (0 != call_system(h_ptr))
              post_mortem("reduct: execution of generated file failed");
a467 1
#endif
@


1.23
log
@*** empty log message ***
@
text
@d2 3
d129 3
a131 1
extern char TasmRuntime[80];
d351 6
@


1.22
log
@some output added for ADV_SCHED
@
text
@d2 3
d338 1
a338 1
      strcpy(p_str[i], "-tO2 ");
@


1.21
log
@no distributed measurement file-merging in (all) pvm version(s)
@
text
@d2 3
d167 3
d465 3
@


1.20
log
@filepointers are set to NULL after closing
@
text
@d2 3
d268 9
d443 1
a444 1
             else
@


1.19
log
@some changes for the pvm measure version
@
text
@d2 3
d148 1
d366 9
a374 2
        if (0 == UseTasm)
/* dg */     inter(R_COMB(*code_desc,ptc));           /* codeausfuehrung */
d491 1
d493 2
@


1.18
log
@START_MODUL added
@
text
@d2 3
d420 1
d423 1
@


1.17
log
@some more DBUG output
@
text
@a342 2
START_MODUL("reducing");

a393 2

 END_MODUL("reducing");
@


1.16
log
@gcc call removed, tasm makes it now itself
@
text
@d2 3
d343 2
d396 2
@


1.15
log
@new red.setup keyword: CodeDup : int
if not set -> no code duplication while using tasm
if 0 -> unlimited code duplication
if > 0 -> max number of duplication
@
text
@d2 6
d310 6
a315 1
    strcpy(p_str[i], "-cocode.c");
a327 29
    else
    {
      i = 0;
      strcpy(p_str[i], "gcc");
      h_ptr[i] = p_str[i++];
      strcpy(p_str[i], "-O2");
      h_ptr[i] = p_str[i++];
      strcpy(p_str[i], "code.c");
      h_ptr[i] = p_str[i++];
      sprintf(p_str[i], "%s/rmkclos.o", TasmRuntime);
      h_ptr[i] = p_str[i++];
      sprintf(p_str[i], "%s/rapply.o", TasmRuntime);
      h_ptr[i] = p_str[i++];
      sprintf(p_str[i], "%s/initdata.o", TasmRuntime);
      h_ptr[i] = p_str[i++];
      sprintf(p_str[i], "%s/inter.o", TasmRuntime);
      h_ptr[i] = p_str[i++];
      sprintf(p_str[i], "%s/dbug.o", TasmRuntime);
      h_ptr[i] = p_str[i++];
      sprintf(p_str[i], "-I%s", TasmRuntime);
      h_ptr[i] = p_str[i++];
      strcpy(p_str[i], "/home/base/lib/lred.o");
      h_ptr[i] = p_str[i++];
      h_ptr[i] = NULL;

      exec_success = call_system(h_ptr);
      if (0 != exec_success)
        post_mortem("reduct: compilation of C-file failed");
    }
d360 2
a361 2
            static char p_str[5][80];
            static char *h_ptr[5];
d364 1
a364 1
            strcpy(p_str[i], "a.out");
d377 5
@


1.14
log
@minor change in gcc call
@
text
@d2 3
d98 1
d294 5
@


1.13
log
@minor bug fix
@
text
@d2 3
d322 2
@


1.12
log
@*** empty log message ***
@
text
@d2 3
d287 5
a291 1
    if (0 < TasmOpt) strcpy(p_str[i++], "-tO2 ");
@


1.11
log
@tasm will be searched in path
@
text
@d2 3
d323 1
a323 1
        post_mortem("reduct: compililation of C-file failed");
@


1.10
log
@pm bug fixed
@
text
@d2 3
d278 1
a278 1
    strcpy(p_str[i], "../src/tasm");
@


1.9
log
@if UseTasm is set, reduct() accepts input from a file generated by tasm
@
text
@d2 3
d357 1
a357 1
            sprintf(p_str[i], "-a%s", Tasm2KiR);
d361 3
d459 1
d461 1
@


1.8
log
@changed "correct" output of UH's PM statistics
@
text
@d2 3
d42 1
d52 4
a55 1

d63 1
d77 10
d176 22
d202 1
a202 1
/* dg */ void reduct()
d205 2
a206 1

d265 54
d344 1
d346 20
d415 2
@


1.7
log
@generate codefile in non-DEBUG-version
@
text
@d2 3
d82 4
d184 3
d335 1
@


1.6
log
@reduce to normal form available for WITHTILDE
@
text
@d2 3
a53 1
#include "roptasm.h"
a87 1
extern void           optasm();              /* roptasm.c */
a238 2
             if (UseTypes || ReduceRefCnt)
	       optasm(R_COMB(*code_desc,ptc));
@


1.5
log
@first extension for optimizer
@
text
@d2 3
a306 1
#if !WITHTILDE
a309 1
#endif /* !WITHTILDE */
@


1.4
log
@no reduce to normal form in WITHTILDE version
@
text
@d2 3
d48 1
d83 1
d235 2
@


1.3
log
@ANSI-version mit mess und verteilungs-Routinen
@
text
@d2 3
d297 1
d301 1
@


1.2
log
@ANSI-Version
@
text
@d2 3
d41 5
d54 9
d80 11
d146 10
d166 1
d203 24
d228 48
d277 1
d295 1
a295 1
/* ak */   reduce_to_nf ();        /* Vorantreiben der Reduktion, Berechnung der Normalform  */
d302 5
d344 1
a344 1
  register volatile T_PTD      ptdesc=(T_PTD)0; /* Initialisierung von TB, 6.11.1992, volatile: ach 10/11/92 */
d367 3
d371 1
d476 3
d480 1
@


1.1
log
@Initial revision
@
text
@d1 4
a4 1
/* $Log$ */
d63 25
d117 1
a117 1
/* dg */   STACKELEM  x;
d130 1
a130 1
/* dg */   TIMER();
d227 1
a227 1
  register T_PTD      ptdesc;
d275 2
a276 1
        for (dim = 0; dim <= R_CLOS(*ptdesc,args) ; dim++) {
@
